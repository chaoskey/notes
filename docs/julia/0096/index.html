<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="有限元法求解牛顿流体（FEniCS）"><meta property="og:title" content="有限元法求解牛顿流体（FEniCS）" />
<meta property="og:description" content="
在Julia环境中，使用FenicsPy.jl调用FEniCS库，求解偏微分方程。

纳维-斯托克斯方程组
纳维-斯托克斯方程:

  
    

    
    
    
    
    
    
    
    
  





  \[
\color{red}{\frac{\partial \boldsymbol{u}}{\partial t}&#43;(\boldsymbol{u} \cdot \nabla)\boldsymbol{u}=\frac{1}{\rho}\nabla\cdot \boldsymbol{\sigma}&#43;\boldsymbol{f}}
\]


其中，张量



  \(\boldsymbol{\sigma}\)

是应力张量, 取决于具体流体的特性假设，比如：牛顿流体。
连续性方程：




  \[
\frac{\partial \rho}{\partial t}&#43;\nabla \cdot (\rho \boldsymbol{u})=0
\]
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chaoskey.gitee.io/notes/docs/julia/0096/" />
<meta property="article:published_time" content="2020-11-18T22:17:27+08:00" />
<meta property="article:modified_time" content="2020-11-18T22:17:27+08:00" />
<title>有限元法求解牛顿流体（FEniCS） | 学习笔记</title>
<link rel="icon" href="/notes/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/notes/book.min.3a0afab795624b6557eb098eddc1c880180827e07fdb828f747c01148048289e.css" integrity="sha256-Ogr6t5ViS2VX6wmO3cHIgBgIJ&#43;B/24KPdHwBFIBIKJ4=">


<script defer src="/notes/cn.search.min.ae40ea0b51c8339faa91e6c7185b6b7a562a2c37dc01ce6818eaab312cbe1d25.js" integrity="sha256-rkDqC1HIM5&#43;qkebHGFtrelYqLDfcAc5oGOqrMSy&#43;HSU="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/notes"><img src="/notes/logo.png" alt="Logo" /><span>学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  










    
    



<ul>
<li><a href="/notes/posts/"><strong>站点维护记录</strong></a></li>
<li><a href="/notes/docs/fem/"><strong>有限元法自动求解微分方程</strong></a></li>
<li><a href="/notes/docs/julia/"><strong>基于Julia科学计算</strong></a>
<ul>
<li><a href="/notes/docs/julia/0001/">整合Julia和Python的集成环境（Win10）</a></li>
<li><a href="/notes/docs/julia/0095/">科学计算环境搭建（Win10+WSL2+Ubuntu）</a></li>
<li><a href="/notes/docs/julia/0002/">Julia中的数学符号演算</a></li>
<li><a href="/notes/docs/julia/0003/">基于Julia的科学计算功能库整理</a></li>
<li><a href="/notes/docs/diffgeo/0070/">微分几何中的计算</a></li>
<li><a href="/notes/docs/julia/0088/">平面三体问题</a></li>
<li><a href="/notes/docs/julia/0089/">有限差分法求解一维热传导方程</a></li>
<li><a href="/notes/docs/julia/0090/">Galerkin法解常微分方程边值问题</a></li>
<li><a href="/notes/docs/julia/0091/">有限元法解常微分方程边值问题</a></li>
<li><a href="/notes/docs/julia/0092/">有限元之平面三角单元</a></li>
<li><a href="/notes/docs/julia/0093/">有限元之Delaunay三角剖分</a></li>
<li><a href="/notes/docs/julia/0094/">有限元法解偏微分方程（FEniCS）</a></li>
<li><a href="/notes/docs/julia/0096/"class=active>有限元法求解牛顿流体（FEniCS）</a></li>
</ul>
</li>
<li><a href="/notes/docs/theophy/"><strong>理论物理学习笔记</strong></a></li>
<li><a href="/notes/docs/diffgeo/"><strong>微分几何笔记</strong></a></li>
<li><a href="/notes/docs/mlapp/"><strong>机器学习：概率视角</strong></a></li>
<li><a href="/notes/docs/apm/"><strong>主动投资组合管理</strong></a></li>
</ul>












</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/notes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>有限元法求解牛顿流体（FEniCS）</strong>

  <label for="toc-control">
    <img src="/notes/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#纳维-斯托克斯方程组">纳维-斯托克斯方程组</a></li>
    <li><a href="#几个必要公式">几个必要公式</a></li>
    <li><a href="#将运动方程转换成变分等式">将运动方程转换成变分等式</a></li>
    <li><a href="#对时间有限差分-第1步">对时间有限差分 第1步：</a></li>
    <li><a href="#对时间有限差分-第2步">对时间有限差分 第2步：</a></li>
    <li><a href="#对时间有限差分-第3步">对时间有限差分 第3步：</a></li>
    <li><a href="#实现代码">实现代码</a></li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0097/">
    下一页<br>有限元方法（一）【翻译】
  </a>
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/julia/0095/">
      上一页<br>科学计算环境搭建（Win10&#43;WSL2&#43;Ubuntu）
  </a>
  
</nav>

<hr>

<article class="markdown">
  <h1>
    <a href="/notes/docs/julia/0096/">有限元法求解牛顿流体（FEniCS）</a>
  </h1>
  

<div>

  <h5>2020-11-18</h5>


<div>

  
    |
    
      <a href="/notes/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97">科学计算</a>
      
    |
  

  
    |
    
      <a href="/notes/tags/julia">julia</a>
      , 
      <a href="/notes/tags/FEniCS">FEniCS</a>
      , 
      <a href="/notes/tags/%E6%9C%89%E9%99%90%E5%85%83%E6%B3%95">有限元法</a>
      , 
      <a href="/notes/tags/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">偏微分方程</a>
      , 
      <a href="/notes/tags/%E7%89%9B%E9%A1%BF%E6%B5%81%E4%BD%93">牛顿流体</a>
      , 
      <a href="/notes/tags/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6">流体力学</a>
      
    |
  




    <a href="https://gitee.com/chaoskey/notes/blob/master/content/docs/julia/0096.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      评论
    </a>


</div>


</div>

<blockquote>
<p>在Julia环境中，使用<a href="https://gitee.com/chaoskey/FenicsPy.jl">FenicsPy.jl</a>调用<code>FEniCS</code>库，求解偏微分方程。</p>
</blockquote>
<h1 id="纳维-斯托克斯方程组">纳维-斯托克斯方程组</h1>
<p><strong>纳维-斯托克斯方程</strong>:</p>

  
    

    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body,
                {delimiters: [{left: '$$\n', right: '\n$$', display: true}, {left: '$$', right: '$$', display: false}, 
                              {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>
    
  




<span class="katex">
  \[
\color{red}{\frac{\partial \boldsymbol{u}}{\partial t}+(\boldsymbol{u} \cdot \nabla)\boldsymbol{u}=\frac{1}{\rho}\nabla\cdot \boldsymbol{\sigma}+\boldsymbol{f}}
\]
</span>

<p>其中，张量


<span class="katex">
  \(\boldsymbol{\sigma}\)
</span>
是<code>应力张量</code>, 取决于具体流体的特性假设，比如：<code>牛顿流体</code>。</p>
<p><strong>连续性方程</strong>：</p>



<span class="katex">
  \[
\frac{\partial \rho}{\partial t}+\nabla \cdot (\rho \boldsymbol{u})=0
\]
</span>

<p>特别地，对<code>不可压缩流体</code>而言：</p>



<span class="katex">
  \[
\color{red}{ \nabla \cdot \boldsymbol{u}=0}
\]
</span>

<p><strong>牛顿流体的特性假设</strong>：</p>



<span class="katex">
  \[
\color{blue}{\begin{aligned}\sigma(\boldsymbol{u},p) &= -p I + 2\mu \boldsymbol{\epsilon}(\boldsymbol{u}) \\ \boldsymbol{\epsilon}(\boldsymbol{u})&= \frac{1}{2}\left(\nabla \boldsymbol{u} + (\nabla \boldsymbol{u})^T \right)\end{aligned}}
\]
</span>

<p>在


<span class="katex">
  \(\color{blue}{牛顿流体假设}\)
</span>
下，这两个


<span class="katex">
  \(\color{red}{红色方程}\)
</span>
的组成<strong>不可压缩牛顿流体</strong>的运动方程组。</p>
<p>对平面流体而言，这组方程有有三个方程，有三个待求量： 速度场


<span class="katex">
  \(u(x,y,t)\)
</span>
和压强场


<span class="katex">
  \(p(x,y,t)\)
</span>
。  给定边界条件，就可以求解了。</p>
<h1 id="几个必要公式">几个必要公式</h1>



<span class="katex">
  \[
\begin{aligned}\boldsymbol{\epsilon}(\boldsymbol{u}) \cdot \nabla\boldsymbol{v}& =\epsilon_{ij}(\boldsymbol{u}) \frac{\partial v_i}{\partial x_j} \qquad \text{爱因斯坦求和约定} \\  &=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j}+\frac{\partial u_j}{\partial x_i}\right) \frac{\partial v_i}{\partial x_j}  \\  &=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j} \frac{\partial v_i}{\partial x_j}+\frac{\partial u_i}{\partial x_j}\frac{\partial v_j}{\partial x_i}\right) \qquad \text{括号中第二项：由于缩并，指标交换不变}  \\  &=\frac{\partial u_i}{\partial x_j}\frac{1}{2}\left(\frac{\partial v_i}{\partial x_j}+\frac{\partial v_j}{\partial x_i}\right) \\  &=\frac{1}{2}\left(\frac{\partial u_i}{\partial x_j}+\frac{\partial u_j}{\partial x_i}\right) \frac{1}{2}\left(\frac{\partial v_i}{\partial x_j}+\frac{\partial v_j}{\partial x_i}\right) \qquad \text{由于缩并，指标交换不变} \\  &=\boldsymbol{\epsilon}(\boldsymbol{u}) \cdot  \boldsymbol{\epsilon}(\boldsymbol{v}) \qquad \text{这里的点乘，实际是双重指标缩并} \end{aligned}
\]
</span>

<p>即(同时有第二式)：</p>



<span class="katex">
  \[
\color{blue}{\boldsymbol{\epsilon}(\boldsymbol{u}) \cdot \nabla\boldsymbol{v} = \boldsymbol{\epsilon}(\boldsymbol{u}) \cdot  \boldsymbol{\epsilon}(\boldsymbol{v})  =  \nabla\boldsymbol{u} \cdot  \boldsymbol{\epsilon}(\boldsymbol{v}) }
\]
</span>




<span class="katex">
  \[
\color{blue}{\boldsymbol{\sigma}(\boldsymbol{u},p) \cdot \nabla\boldsymbol{v} = \boldsymbol{\sigma}(\boldsymbol{u},p) \cdot  \boldsymbol{\epsilon}(\boldsymbol{v}) }
\]
</span>

<p>不难根据“由于缩并，指标交换不变”类似推导出：</p>



<span class="katex">
  \[
\color{blue}{\boldsymbol{a} \cdot \left[\boldsymbol{\epsilon}(\boldsymbol{u}) \cdot \boldsymbol{v}\right] = \boldsymbol{a} \cdot \left[\nabla \boldsymbol{u} \cdot \boldsymbol{v}\right]}
\]
</span>

<p>在此基础上，容易推导出：</p>



<span class="katex">
  \[
\color{red}{\left[\nabla \cdot \boldsymbol{\sigma}(\boldsymbol{u},p)\right]\cdot \boldsymbol{v} =2\mu\nabla \cdot \left[\nabla \boldsymbol{u} \cdot \boldsymbol{v}\right] -\nabla \cdot (p \boldsymbol{v})  - \boldsymbol{\sigma}(\boldsymbol{u},p) \cdot  \boldsymbol{\epsilon}(\boldsymbol{v})}
\]
</span>

<h1 id="将运动方程转换成变分等式">将运动方程转换成变分等式</h1>
<p>利用前面的公式，将纳维-斯托克斯方程改写成变分等式（同时用了<code>斯托克斯定理</code>）</p>



<span class="katex">
  \[
\left<\frac{\partial \boldsymbol{u}}{\partial t},\boldsymbol{v}\right>+\left<\boldsymbol{u}\cdot \nabla \boldsymbol{u},\boldsymbol{v}\right>+\frac{1}{\rho}\left<\boldsymbol{\sigma}(\boldsymbol{u},p),\boldsymbol{\epsilon}(\boldsymbol{v})\right> \\ \qquad \qquad  \qquad  \qquad  \qquad  + \frac{1}{\rho}\left< p \boldsymbol{n}, \boldsymbol{v} \right>_{\partial \Omega}-\frac{2\mu}{\rho}\left<\frac{\partial \boldsymbol{u}}{\partial n},\boldsymbol{v}\right>_{\partial \Omega} - \left<\boldsymbol{f},\boldsymbol{v}\right>=0
\]
</span>

<p>约定：</p>



<span class="katex">
  \[
\left<\boldsymbol{u},\boldsymbol{v}\right> \overset{\Delta}{=}\int_\Omega{\boldsymbol{u} \cdot \boldsymbol{v}d\omega}\qquad \left<\boldsymbol{u},\boldsymbol{v}\right>_{\partial \Omega} \overset{\Delta}{=}\int_{\partial \Omega}{\boldsymbol{u} \cdot \boldsymbol{v}ds} 
\]
</span>

<h1 id="对时间有限差分-第1步">对时间有限差分 第1步：</h1>
<p>已知


<span class="katex">
  \(\boldsymbol{u}^n,p^n\)
</span>
，求


<span class="katex">
  \(\color{red}{\boldsymbol{u}^*}\)
</span>
</p>



<span class="katex">
  \[
\boxed{\begin{aligned}\rho\left<\frac{\boldsymbol{u}^*-\boldsymbol{u}^n}{\Delta t} , \boldsymbol{v}\right>+\rho\left<\boldsymbol{u}^n\cdot \nabla \boldsymbol{u}^n,\boldsymbol{v}\right>+\left<\boldsymbol{\sigma} ( \boldsymbol{u}^{n+\frac{1}{2}},p^n),\boldsymbol{\epsilon}(\boldsymbol{v})\right> \\ +\left< p^n  \boldsymbol{n}, \boldsymbol{v} \right>_{\partial \Omega}-2\mu\left<\frac{\partial \boldsymbol{u}^{n+\frac{1}{2}}}{\partial n},\boldsymbol{v}\right>_{\partial \Omega}- \rho\left<\boldsymbol{f}^{n+1},\boldsymbol{v}\right>=0 \end{aligned}}
\]
</span>

<p>其中：</p>



<span class="katex">
  \[
\frac{\partial \boldsymbol{u}}{\partial t} \approx \frac{\boldsymbol{u}^*-\boldsymbol{u}^n}{\Delta t}  \qquad \boldsymbol{u}^{n+\frac{1}{2}} \approx \frac{\boldsymbol{u}^*+\boldsymbol{u}^n}{2}
\]
</span>

<h1 id="对时间有限差分-第2步">对时间有限差分 第2步：</h1>
<p>已知


<span class="katex">
  \(\boldsymbol{u}^*,p^n\)
</span>
，求


<span class="katex">
  \(\color{red}{p^{n+1}}\)
</span>
:</p>
<p>第1步对应得运动差分方程实际是：</p>



<span class="katex">
  \[
 \frac{\boldsymbol{u}^*-\boldsymbol{u}^n}{\Delta t}+(\boldsymbol{u}^n \cdot \nabla)\boldsymbol{u}^n=\frac{1}{\rho}\nabla\cdot \boldsymbol{\sigma}(\boldsymbol{u}^{n+\frac{1}{2}}, p^n)+\boldsymbol{f}^n
\]
</span>

<p>第2步需要运动差分方程则是：</p>



<span class="katex">
  \[
 \frac{\boldsymbol{u}^{n+1}-\boldsymbol{u}^n}{\Delta t}+(\boldsymbol{u}^n \cdot \nabla)\boldsymbol{u}^n=\frac{1}{\rho}\nabla\cdot \boldsymbol{\sigma}(\boldsymbol{u}^{n+\frac{1}{2}},p^{n+1})+\boldsymbol{f}^n
\]
</span>

<p>前后两式相减得：</p>



<span class="katex">
  \[
 \frac{\boldsymbol{u}^*-\boldsymbol{u}^{n+1}}{\Delta t}=\frac{1}{\rho}\left(\nabla p^{n+1}-\nabla p^n\right)
\]
</span>

<p>考虑到


<span class="katex">
  \(\nabla \cdot \boldsymbol{u}^{n+1}=0\)
</span>
，对上式两边求散度后得：</p>



<span class="katex">
  \[
\frac{\nabla \cdot \boldsymbol{u}^*}{\Delta t}=\frac{1}{\rho}\left(\nabla^2 p^{n+1}-\nabla^2 p^n\right)
\]
</span>

<p>根据这个等式可构建出变分等式：</p>



<span class="katex">
  \[
\boxed{\left<\nabla p^{n+1},\nabla q\right>=\left<\nabla p^n,\nabla q\right>-\frac{\rho}{\Delta t}\left<\nabla \cdot u^*, q\right>}
\]
</span>

<h1 id="对时间有限差分-第3步">对时间有限差分 第3步：</h1>
<p>已知


<span class="katex">
  \(\boldsymbol{u}^*,p^n,p^{n+1}\)
</span>
，求


<span class="katex">
  \(\color{red}{\boldsymbol{u}^{n+1}}\)
</span>
:</p>
<p>从第2步的公式：</p>



<span class="katex">
  \[
 \frac{\boldsymbol{u}^*-\boldsymbol{u}^{n+1}}{\Delta t}=\frac{1}{\rho}\left(\nabla p^{n+1}-\nabla p^n\right)
\]
</span>

<p>出发, 根据这个等式可构建出变分等式：</p>



<span class="katex">
  \[
\boxed{\left<\boldsymbol{u}^{n+1},\boldsymbol{v}\right>=\left<\boldsymbol{u}^*,\boldsymbol{v}\right>-\frac{\Delta t}{\rho}\left<\nabla\left(p^{n+1}-p^n\right),\boldsymbol{v}\right>}
\]
</span>

<h1 id="实现代码">实现代码</h1>
<p>前面方框中的公式，将在下面的代码中直接用到。</p>
<p>求解区域如图：</p>
<p><img src="/notes/images/0176.png" alt="0176.png"></p>
<p>具体边界条件见有详细注释的代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#75715e"># https://github.com/chaoskey/FenicsPy.jl</span>
<span style="color:#66d9ef">using</span> FenicsPy

<span style="color:#75715e"># 参数：ρ,μ,Δt</span>
T <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>            
num_steps <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>  
Δt <span style="color:#f92672">=</span> T <span style="color:#f92672">/</span> num_steps 
μ <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.001</span> 
ρ <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 解域及网格生成</span>
channel <span style="color:#f92672">=</span> Rectangle(Point(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>), Point(<span style="color:#ae81ff">2.2</span>, <span style="color:#ae81ff">0.41</span>))
cylinder <span style="color:#f92672">=</span> Circle(Point(<span style="color:#ae81ff">0.2</span>, <span style="color:#ae81ff">0.2</span>), <span style="color:#ae81ff">0.05</span>)
Ω <span style="color:#f92672">=</span> channel <span style="color:#f92672">-</span> cylinder
mesh <span style="color:#f92672">=</span> generate_mesh(Ω, <span style="color:#ae81ff">64</span>)

<span style="color:#75715e"># 函数空间：速度场空间 和 压强场空间</span>
V <span style="color:#f92672">=</span> VectorFunctionSpace(mesh, <span style="color:#e6db74">&#34;P&#34;</span>, <span style="color:#ae81ff">2</span>)
Q <span style="color:#f92672">=</span> FunctionSpace(mesh, <span style="color:#e6db74">&#34;P&#34;</span>, <span style="color:#ae81ff">1</span>)

<span style="color:#75715e"># 定义边界： 入口，出口，墙，圆柱障碍</span>
inflow   <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;near(x[0], 0)&#34;</span>
outflow  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;near(x[0], 2.2)&#34;</span>
walls    <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;near(x[1], 0) || near(x[1], 0.41)&#34;</span>
cylinder <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;on_boundary &amp;&amp; x[0]&gt;0.1 &amp;&amp; x[0]&lt;0.3 &amp;&amp; x[1]&gt;0.1 &amp;&amp; x[1]&lt;0.3&#34;</span>

<span style="color:#75715e"># 入口边界的速度</span>
inflow_profile <span style="color:#f92672">=</span> (<span style="color:#e6db74">&#34;4.0*1.5*x[1]*(0.41 - x[1]) / pow(0.41, 2)&#34;</span>, <span style="color:#e6db74">&#34;0&#34;</span>)

<span style="color:#75715e"># 速度场边界条件</span>
bcu_inflow <span style="color:#f92672">=</span> DirichletBC(V, Expression(inflow_profile, degree<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>), inflow)
bcu_walls <span style="color:#f92672">=</span> DirichletBC(V, Constant((<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)), walls)
bcu_cylinder <span style="color:#f92672">=</span> DirichletBC(V, Constant((<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)), cylinder)
bcu <span style="color:#f92672">=</span> [bcu_inflow,bcu_walls,bcu_cylinder]

<span style="color:#75715e"># 压力场边界条件</span>
bcp_outflow <span style="color:#f92672">=</span> DirichletBC(Q, Constant(<span style="color:#ae81ff">0</span>), outflow)
bcp <span style="color:#f92672">=</span> [bcp_outflow]

<span style="color:#75715e"># 下一时刻（待求）速度场u,  求解后保存在u_</span>
u <span style="color:#f92672">=</span> TrialFunction(V)
u_ <span style="color:#f92672">=</span> FeFunction(V)

<span style="color:#75715e"># 下一时刻（待求）压力场p,  求解后保存在p_</span>
p <span style="color:#f92672">=</span> TrialFunction(Q)
p_ <span style="color:#f92672">=</span> FeFunction(Q)

<span style="color:#75715e"># 速度场测试函数 和 压力场测试函数</span>
v <span style="color:#f92672">=</span> TestFunction(V)
q <span style="color:#f92672">=</span> TestFunction(Q)

<span style="color:#75715e"># 当前时刻（已知）速度场u 和 压力场p</span>
u_n <span style="color:#f92672">=</span> FeFunction(V)
p_n <span style="color:#f92672">=</span> FeFunction(Q)


<span style="color:#75715e"># (u^* + u^n)/2</span>
<span style="color:#75715e"># 注意：其中包含待求函数 u (即，u^*)</span>
<span style="color:#75715e"># 所以，包含U的变分方程F的a(u,v)必须用 lhs(F)求出</span>
<span style="color:#75715e"># 对应的L(v)则须用 rhs(F)求出</span>
U  <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>(u_n <span style="color:#f92672">+</span> u)

<span style="color:#75715e"># 法线</span>
n  <span style="color:#f92672">=</span> FacetNormal(mesh)

<span style="color:#75715e"># 力场</span>
f  <span style="color:#f92672">=</span> Constant((<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>))

<span style="color:#75715e"># 在缩并的掩护下，可看作是对称梯度</span>
<span style="color:#66d9ef">function</span> ϵ(u)
    <span style="color:#66d9ef">return</span> sym(nabla_grad(u))
<span style="color:#66d9ef">end</span>
<span style="color:#75715e"># 应力张量</span>
<span style="color:#66d9ef">function</span> σ(u, p)
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>μ<span style="color:#f92672">*</span>ϵ(u) <span style="color:#f92672">-</span> p<span style="color:#f92672">*</span>Identity(len(u))
<span style="color:#66d9ef">end</span>

<span style="color:#75715e"># 第1步的变分方程:  (u^n,p^n) -&gt;  u^*      </span>
<span style="color:#75715e"># 待求的u^*采用u， 结果计划保存在u_</span>
F1 <span style="color:#f92672">=</span> ρ<span style="color:#f92672">*</span>dot((u <span style="color:#f92672">-</span> u_n) <span style="color:#f92672">/</span> Δt, v)<span style="color:#f92672">*</span>dx  <span style="color:#f92672">+</span> ρ<span style="color:#f92672">*</span>dot(dot(u_n, nabla_grad(u_n)), v)<span style="color:#f92672">*</span>dx <span style="color:#f92672">+</span> 
            inner(σ(U, p_n), ϵ(v))<span style="color:#f92672">*</span>dx  <span style="color:#f92672">+</span> dot(p_n<span style="color:#f92672">*</span>n, v)<span style="color:#f92672">*</span>ds <span style="color:#f92672">-</span> 
            dot(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>μ<span style="color:#f92672">*</span>nabla_grad(U)<span style="color:#f92672">*</span>n, v)<span style="color:#f92672">*</span>ds   <span style="color:#f92672">-</span> ρ<span style="color:#f92672">*</span>dot(f, v)<span style="color:#f92672">*</span>dx
a1 <span style="color:#f92672">=</span> lhs(F1)
L1 <span style="color:#f92672">=</span> rhs(F1)

<span style="color:#75715e"># 第2步的变分方程:  (u^*,p^n) -&gt;  p^{n+1}  </span>
<span style="color:#75715e"># u^*  采用第1步的结果 u_</span>
<span style="color:#75715e"># 待求的p^{n+1}采用p， 结果计划保存在p_</span>
a2 <span style="color:#f92672">=</span> dot(nabla_grad(p), nabla_grad(q))<span style="color:#f92672">*</span>dx
L2 <span style="color:#f92672">=</span> dot(nabla_grad(p_n), nabla_grad(q))<span style="color:#f92672">*</span>dx <span style="color:#f92672">-</span> (ρ<span style="color:#f92672">/</span>Δt)<span style="color:#f92672">*</span>div(u_)<span style="color:#f92672">*</span>q<span style="color:#f92672">*</span>dx

<span style="color:#75715e"># 第3步的变分方程:  (u^*,p^n, p^{n+1}) -&gt;  u^{n+1}   </span>
<span style="color:#75715e"># (u^*, p^{n+1})  分别采用第1、2步的结果 (u_,p_)</span>
<span style="color:#75715e"># 待求的u^{n+1}采用u， 结果计划保存在u_</span>
a3 <span style="color:#f92672">=</span> dot(u, v)<span style="color:#f92672">*</span>dx
L3 <span style="color:#f92672">=</span> dot(u_, v)<span style="color:#f92672">*</span>dx <span style="color:#f92672">-</span> (Δt<span style="color:#f92672">/</span>ρ)<span style="color:#f92672">*</span>dot(nabla_grad(p_ <span style="color:#f92672">-</span> p_n), v)<span style="color:#f92672">*</span>dx

<span style="color:#75715e"># 三个变分方程对应的矩阵</span>
A1 <span style="color:#f92672">=</span> assemble(a1)
A2 <span style="color:#f92672">=</span> assemble(a2)
A3 <span style="color:#f92672">=</span> assemble(a3)

<span style="color:#75715e"># 将边界条件附加到矩阵上</span>
[bc<span style="color:#f92672">.</span>apply(A1) <span style="color:#66d9ef">for</span> bc <span style="color:#66d9ef">in</span> bcu]
[bc<span style="color:#f92672">.</span>apply(A2) <span style="color:#66d9ef">for</span> bc <span style="color:#66d9ef">in</span> bcp]

<span style="color:#75715e"># 创建XDMF文件（可视化）</span>
xdmffile_u <span style="color:#f92672">=</span> XDMFFile(<span style="color:#e6db74">&#34;navier_stokes_cylinder/velocity.xdmf&#34;</span>)
xdmffile_p <span style="color:#f92672">=</span> XDMFFile(<span style="color:#e6db74">&#34;navier_stokes_cylinder/pressure.xdmf&#34;</span>)

<span style="color:#75715e"># 创建时间序列</span>
timeseries_u <span style="color:#f92672">=</span> TimeSeries(<span style="color:#e6db74">&#34;navier_stokes_cylinder/velocity_series&#34;</span>)
timeseries_p <span style="color:#f92672">=</span> TimeSeries(<span style="color:#e6db74">&#34;navier_stokes_cylinder/pressure_series&#34;</span>)

<span style="color:#75715e"># 保存网格</span>
File(<span style="color:#e6db74">&#34;navier_stokes_cylinder/cylinder.xml.gz&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> mesh

<span style="color:#66d9ef">global</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">for</span> i <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>num_steps

    <span style="color:#75715e"># 当前时间</span>
    <span style="color:#66d9ef">global</span> t <span style="color:#f92672">+=</span> Δt

    <span style="color:#75715e"># 第一步</span>
    <span style="color:#75715e"># lvsolve(a1,L1,u_,bcu)  # 这个方法求解很慢</span>
    <span style="color:#75715e"># 下面的方法更块的原因是，在循环前已经生成了变分方程对应的矩阵</span>
    b1 <span style="color:#f92672">=</span> assemble(L1)
    [bc<span style="color:#f92672">.</span>apply(b1) <span style="color:#66d9ef">for</span> bc <span style="color:#66d9ef">in</span> bcu]
    solve(A1, u_<span style="color:#f92672">.</span>vector(), b1, <span style="color:#e6db74">&#34;bicgstab&#34;</span>, <span style="color:#e6db74">&#34;hypre_amg&#34;</span>)

    <span style="color:#75715e"># 第二步</span>
    b2 <span style="color:#f92672">=</span> assemble(L2)
    [bc<span style="color:#f92672">.</span>apply(b2) <span style="color:#66d9ef">for</span> bc <span style="color:#66d9ef">in</span> bcp]
    solve(A2, p_<span style="color:#f92672">.</span>vector(), b2, <span style="color:#e6db74">&#34;bicgstab&#34;</span>, <span style="color:#e6db74">&#34;hypre_amg&#34;</span>)

    <span style="color:#75715e"># 第三步</span>
    b3 <span style="color:#f92672">=</span> assemble(L3)
    solve(A3, u_<span style="color:#f92672">.</span>vector(), b3, <span style="color:#e6db74">&#34;cg&#34;</span>, <span style="color:#e6db74">&#34;sor&#34;</span>)
    
    <span style="color:#75715e"># 更新数据</span>
    u_n<span style="color:#f92672">.</span>assign(u_)
    p_n<span style="color:#f92672">.</span>assign(p_)
    
    <span style="color:#66d9ef">if</span> (i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">25</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> i <span style="color:#f92672">==</span> num_steps
        xdmffile_u<span style="color:#f92672">.</span>write(u_, t)
        xdmffile_p<span style="color:#f92672">.</span>write(p_, t)
        
        timeseries_u<span style="color:#f92672">.</span>store(u_<span style="color:#f92672">.</span>vector(), t)
        timeseries_p<span style="color:#f92672">.</span>store(p_<span style="color:#f92672">.</span>vector(), t)
        
        println(<span style="color:#e6db74">&#34;第&#34;</span>,i,<span style="color:#e6db74">&#34;步</span><span style="color:#ae81ff">\t</span><span style="color:#e6db74"> max:&#34;</span>, max(array(u_)<span style="color:#f92672">...</span>))
        
        <span style="color:#75715e"># Plot solution</span>
        plot(u_)
        plot(p_)
    <span style="color:#66d9ef">end</span>
<span style="color:#66d9ef">end</span>

<span style="color:#75715e"># 确保文件不被损坏</span>
xdmffile_u<span style="color:#f92672">.</span>close()
xdmffile_p<span style="color:#f92672">.</span>close()
</code></pre></div><pre><code>第0步	 max:2.739542375402953
第25步	 max:1.9848943489237132
第50步	 max:1.917539036089884
</code></pre>
<p>&hellip; &hellip;</p>
<pre><code>第4950步	 max:2.178513430654289
第4975步	 max:2.1431069545490455
第4999步	 max:2.1574859438440463
</code></pre>
<p><img src="/notes/images/0177.png" alt="0177.png"></p>
<p>用<code>ParaView</code>渲染的结果如下（速度场 和 压力场）：</p>
<p><img src="/notes/images/0174.gif" alt="0174.gif"></p>
<p><img src="/notes/images/0175.gif" alt="0175.gif"></p></article>

<hr>

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0097/">
    下一页<br>有限元方法（一）【翻译】
  </a>
  
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/julia/0095/">
      上一页<br>科学计算环境搭建（Win10&#43;WSL2&#43;Ubuntu）
  </a>
  
</nav>

 

      <footer class="book-footer">
        
  <div class="flex justify-between">





  <div>
    <a class="flex align-center" href="https://gitee.com/chaoskey/notes/blob/master/content/docs/julia/0096.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      <span>评论</span>
    </a>
  </div>
  
  
  <div>
    <a class="flex align-center" href="https://gitee.com/-/ide/project/chaoskey/notes/edit/master/-/content/docs/julia/0096.md" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>

</div>

 
        
  
  <div class="book-comments">

</div>
  
  
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#纳维-斯托克斯方程组">纳维-斯托克斯方程组</a></li>
    <li><a href="#几个必要公式">几个必要公式</a></li>
    <li><a href="#将运动方程转换成变分等式">将运动方程转换成变分等式</a></li>
    <li><a href="#对时间有限差分-第1步">对时间有限差分 第1步：</a></li>
    <li><a href="#对时间有限差分-第2步">对时间有限差分 第2步：</a></li>
    <li><a href="#对时间有限差分-第3步">对时间有限差分 第3步：</a></li>
    <li><a href="#实现代码">实现代码</a></li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












