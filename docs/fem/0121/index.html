<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="UFL：有限元形式语言》形式算符&amp;表达式的表示【翻译】"><meta property="og:title" content="UFL：有限元形式语言》形式算符&amp;表达式的表示【翻译】" />
<meta property="og:description" content="II.实现》17.UFL：有限元形式语言》形式算符&amp;表达式的表示
【章节目录】
17·5 形式算符
一旦定义了一些形式，就有几种方法可以从中计算相关的形式。  上节的算符可用于定义表达式，本节中讨论的算符被用于形式，从而生成新的形式。 形式算符既可以使形式的定义更紧凑，又可以减少错误的可能，因为原始形式中的更改将自动传播到根据它所计算出的形式中。 这些形式算符可以任意组合； 给定一个半线性形式，只需要几条行即可计算出雅可比伴随的作用。  由于这些计算是在形式编译器处理之前完成的，因此在运行时没有任何开销。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chaoskey.gitee.io/notes/docs/fem/0121/" />
<meta property="article:published_time" content="2021-02-02T12:56:05+08:00" />
<meta property="article:modified_time" content="2021-02-02T12:56:05+08:00" />
<title>UFL：有限元形式语言》形式算符&amp;表达式的表示【翻译】 | 学习笔记</title>
<link rel="icon" href="/notes/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/notes/book.min.3a0afab795624b6557eb098eddc1c880180827e07fdb828f747c01148048289e.css" integrity="sha256-Ogr6t5ViS2VX6wmO3cHIgBgIJ&#43;B/24KPdHwBFIBIKJ4=">


<script defer src="/notes/cn.search.min.d1c6aa77add781ac6d33c28dc2572e4eda52fc8fd7f5a629c4ac0c43eaf39ed2.js" integrity="sha256-0caqd63XgaxtM8KNwlcuTtpS/I/X9aYpxKwMQ&#43;rzntI="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/notes"><img src="/notes/logo.png" alt="Logo" /><span>学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  










    
    



<ul>
<li><a href="/notes/posts/"><strong>站点维护记录</strong></a></li>
<li><a href="/notes/docs/fem/"><strong>有限元法自动求解微分方程</strong></a>
<ul>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95">第二章 有限元方法</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%9C%89%E9%99%90%E5%85%83">第三章 常见有限元</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9E%84%E9%80%A0%E9%80%9A%E7%94%A8%E5%8F%82%E8%80%83%E5%8D%95%E5%85%83">第四章 构造通用参考单元</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F">第五章 有限元变分形式</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E7%BB%84%E8%A3%85">第六章 有限元组装</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%AD%A3%E4%BA%A4%E8%A1%A8%E7%A4%BA">第七章 有限元变分形式的正交表示</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%BC%A0%E9%87%8F%E8%A1%A8%E7%A4%BA">第八章 有限元变分形式的张量表示</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%A6%BB%E6%95%A3%E4%BC%98%E5%8C%96">第九章 有限元矩阵计算的离散优化</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E7%AB%A0-dolfincpython%E6%9C%89%E9%99%90%E5%85%83%E5%BA%93">第十章 DOLFIN：C++/Python有限元库</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-ufl%E6%9C%89%E9%99%90%E5%85%83%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80">第十七章 UFL：有限元形式语言</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-unicorn%E7%BB%9F%E4%B8%80%E7%9A%84%E8%BF%9E%E7%BB%AD%E4%BB%8B%E8%B4%A8%E5%8A%9B%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%99%A8">第十八章 Unicorn：统一的连续介质力学求解器</a></li>
</ul>
</li>
<li><a href="/notes/docs/julia/"><strong>基于Julia科学计算</strong></a></li>
<li><a href="/notes/docs/theophy/"><strong>理论物理学习笔记</strong></a></li>
<li><a href="/notes/docs/diffgeo/"><strong>微分几何笔记</strong></a></li>
<li><a href="/notes/docs/mlapp/"><strong>机器学习：概率视角</strong></a></li>
<li><a href="/notes/docs/apm/"><strong>主动投资组合管理</strong></a></li>
</ul>












</nav>




  <script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/notes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>UFL：有限元形式语言》形式算符&amp;表达式的表示【翻译】</strong>

  <label for="toc-control">
    <img src="/notes/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#ii实现17ufl有限元形式语言形式算符表达式的表示">II.实现》17.UFL：有限元形式语言》形式算符&amp;表达式的表示</a>
      <ul>
        <li><a href="#175-形式算符">17·5 形式算符</a>
          <ul>
            <li><a href="#1751-形式的微分">17·5·1 形式的微分</a></li>
            <li><a href="#1752-伴随">17·5·2 伴随</a></li>
            <li><a href="#1753-替换函数">17·5·3 替换函数</a></li>
            <li><a href="#1754-作用">17·5·4 作用</a></li>
            <li><a href="#1755-系统分割">17·5·5 系统分割</a></li>
            <li><a href="#1756-计算函数的敏感性">17·5·6 计算函数的敏感性</a></li>
          </ul>
        </li>
        <li><a href="#176-表达式的表示">17·6 表达式的表示</a>
          <ul>
            <li><a href="#1761-表达式的结构">17·6·1 表达式的结构</a></li>
            <li><a href="#1762-表达式对象">17·6·2 表达式对象</a></li>
            <li><a href="#1763-表达式属性">17·6·3 表达式属性</a></li>
            <li><a href="#1764-树表示">17·6·4 树表示</a></li>
            <li><a href="#1765-图表示">17·6·5 图表示</a></li>
            <li><a href="#1766-划分">17·6·6 划分</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0122/">
    下一页<br>UFL：有限元形式语言》计算导数&amp;算法(一)【翻译】
  </a>
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0120/">
      上一页<br>UFL：有限元形式语言》表达式【翻译】
  </a>
  
</nav>

<hr>

<article class="markdown">
  <h1>
    <a href="/notes/docs/fem/0121/">UFL：有限元形式语言》形式算符&amp;表达式的表示【翻译】</a>
  </h1>
  

<div>

  <h5>2021-02-02</h5>


<div>

  
    |
    
      <a href="/notes/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97">科学计算</a>
      
    |
  

  
    |
    
      <a href="/notes/tags/FEniCS">FEniCS</a>
      , 
      <a href="/notes/tags/%E6%9C%89%E9%99%90%E5%85%83%E6%B3%95">有限元法</a>
      , 
      <a href="/notes/tags/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">偏微分方程</a>
      
    |
  




    <a href="https://gitee.com/chaoskey/notes/blob/master/content/docs/fem/0121.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      评论
    </a>


</div>


</div>

<h1 id="ii实现17ufl有限元形式语言形式算符表达式的表示">II.实现》17.UFL：有限元形式语言》形式算符&amp;表达式的表示</h1>
<p>【<a href="/notes/docs/fem/#%e7%ac%ac%e5%8d%81%e4%b8%83%e7%ab%a0-ufl%e6%9c%89%e9%99%90%e5%85%83%e5%bd%a2%e5%bc%8f%e8%af%ad%e8%a8%80">章节目录</a>】</p>
<h2 id="175-形式算符">17·5 形式算符</h2>
<p>一旦定义了一些形式，就有几种方法可以从中计算相关的形式。  上节的算符可用于定义表达式，本节中讨论的算符被用于形式，从而生成新的形式。 形式算符既可以使形式的定义更紧凑，又可以减少错误的可能，因为原始形式中的更改将自动传播到根据它所计算出的形式中。 这些形式算符可以任意组合； 给定一个半线性形式，只需要几条行即可计算出雅可比伴随的作用。  由于这些计算是在形式编译器处理之前完成的，因此在运行时没有任何开销。</p>
<h3 id="1751-形式的微分">17·5·1 形式的微分</h3>
<p>形式算符<code>derivative</code>声明了一个形式关于离散函数系数（Coefficient）的导数。 例如，可以使用此功能结合Newton-Raphson方法，自动将您的非线性残差方程（线性形式）线性化。 它也可以被多次应用，这对于从凸函数导出线性系统很有用，以便找到使泛函最小化的函数。 对于非平凡方程，手工计算这些表达式可能很繁琐。 此功能可能对其他领域也是有用的，包括最优控制和反演理论，以及灵敏度分析。</p>
<p>就简单的形式，声明形式
  
    

    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body,
                {delimiters: [{left: '$$\n', right: '\n$$', display: true}, {left: '$$', right: '$$', display: false}, 
                              {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>
    
  




<span class="katex">
  \(L\)
</span>
关于系数函数


<span class="katex">
  \(w\)
</span>
的导数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
a <span style="color:#f92672">=</span> derivative(L, w, u)
</code></pre></div><p>形式


<span class="katex">
  \(a\)
</span>
取决于附加的基函数参数


<span class="katex">
  \(u\)
</span>
，该参数必须与函数


<span class="katex">
  \(w\)
</span>
位于相同的有限元空间中。 如果省略最后一个参数，则会创建一个新的基函数参数。</p>
<p>让我们逐步介绍一个示例，如何对泛函求导两次，进而导出一个线性系统。 在下文中，


<span class="katex">
  \(V_h\)
</span>
是具有基底的有限元空间，


<span class="katex">
  \(w\)
</span>
是


<span class="katex">
  \(V_h\)
</span>
中的函数，而


<span class="katex">
  \(f = f (w)\)
</span>
是我们要最小化的泛函。 从


<span class="katex">
  \(f (w)\)
</span>
导出的是线性形式


<span class="katex">
  \(F(w; v)\)
</span>
和双线性形式


<span class="katex">
  \(J(w; u, v)\)
</span>
。</p>



<span class="katex">
  \[
V_h = \mathrm{span} \{\phi_k\}  \tag{17.52}
\]
</span>




<span class="katex">
  \[
w(x) =\sum^{|V_h|}_{k=1}w_k \phi_k(x) \tag{17.53}
\]
</span>




<span class="katex">
  \[
f : V_h \to \mathbb{R} \tag{17.54}
\]
</span>




<span class="katex">
  \[
F(w; \phi_i) =\frac{\partial f (w)}{\partial w_i} \qquad i = 1, \dots , |V_h| \tag{17.55}
\]
</span>




<span class="katex">
  \[
J(w; \phi_j, \phi) =\frac{\partial F(w; \phi)}{\partial w_j} \qquad j = 1, \dots , |V_h|, \phi \in V_h \tag{17.56}
\]
</span>

<p>对于具体的泛函


<span class="katex">
  \(f (w) = \int_\Omega \frac{1}{2} w^2 dx\)
</span>
，我们可以将其实现为</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
v <span style="color:#f92672">=</span> TestFunction(element)
u <span style="color:#f92672">=</span> TrialFunction(element)
w <span style="color:#f92672">=</span> Coefficient(element)
f <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">*</span>w<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>dx
F <span style="color:#f92672">=</span> derivative(f, w, v)
J <span style="color:#f92672">=</span> derivative(F, w, u)
</code></pre></div><p>此代码声明两种形式<code>F</code>​和<code>J</code>。 线性形式<code>F</code>表示标准载荷矢量<code>w*v*dx</code>，双线性形式<code>J</code>表示质量矩阵<code>u*v*dx</code>。</p>
<p>也可以是关于有限元混合空间函数的系数的求导。  考虑从泛函导出的调和映射方程</p>



<span class="katex">
  \[
f (x, \lambda) = \int_\Omega \left(\mathrm{grad} \ x : \mathrm{grad} \ x + \lambda x \cdot x\right) dx \tag{17.57}
\]
</span>

<p>其中，


<span class="katex">
  \(x\)
</span>
是向量有限元空间


<span class="katex">
  \(V_h^d\)
</span>
中的函数，而


<span class="katex">
  \(\lambda\)
</span>
是标量有限元空间


<span class="katex">
  \(V_h\)
</span>
中的函数。 从等式17.57中的泛函导出的线性和双线性形式，有属于混合空间


<span class="katex">
  \(V_h^d\times V_h\)
</span>
中的基函数参数。 可通过自动线性化来得到这些形式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
Vx <span style="color:#f92672">=</span> VectorElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, triangle, <span style="color:#ae81ff">1</span>)
Vy <span style="color:#f92672">=</span> FiniteElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, triangle, <span style="color:#ae81ff">1</span>)
u <span style="color:#f92672">=</span> Coefficient(Vx<span style="color:#f92672">*</span>Vy)
x, y <span style="color:#f92672">=</span> split(u)
f <span style="color:#f92672">=</span> inner(grad(x), grad(x))<span style="color:#f92672">*</span>dx <span style="color:#f92672">+</span> y<span style="color:#f92672">*</span>dot(x,x)<span style="color:#f92672">*</span>dx
F <span style="color:#f92672">=</span> derivative(f, u)
J <span style="color:#f92672">=</span> derivative(F, u)
</code></pre></div><p>注意，该泛函通过两个子函数


<span class="katex">
  \(x\)
</span>
和


<span class="katex">
  \(y\)
</span>
来表示，而<code>derivative</code>的参数必须是单个混合函数


<span class="katex">
  \(u\)
</span>
。 在此示例中，<code>derivative</code>的基函数参数被省略，因此自动由正确的函数空间中提供。</p>
<p>请注意，在计算形式的导数时，我们假设</p>



<span class="katex">
  \[
\frac{\partial }{\partial w_k} \int_\Omega I dx = \int_\Omega \frac{\partial}{\partial w_k} I dx \tag{17.58}
\]
</span>

<p>或更特别地，域


<span class="katex">
  \(\Omega\)
</span>
与


<span class="katex">
  \(w\)
</span>
无关。 同样，除


<span class="katex">
  \(w\)
</span>
以外的任何系数都被认为与


<span class="katex">
  \(w\)
</span>
无关。 此外，请注意，在此框架中对单元的选择没有任何限制，特别是支持任意混合单元。</p>
<h3 id="1752-伴随">17·5·2 伴随</h3>
<p>另一个形式算子是双线性形式


<span class="katex">
  \(a\)
</span>
的伴随


<span class="katex">
  \(a^∗\)
</span>
，定义为


<span class="katex">
  \(a^∗(v, u) = a(u, v)\)
</span>
，等效于组装成稀疏矩阵后再进行转置。 在UFL中，这可以简单地通过交换测试函数和试探函数的顺序来实现，并且可以使用形式算符<code>adjoint</code>。 （请注意，这不是伴随算符的最一般的定义）。 在各向异性扩散项上使用它的一个例子看起来像</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
V <span style="color:#f92672">=</span> VectorElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, cell, <span style="color:#ae81ff">1</span>)
T <span style="color:#f92672">=</span> TensorElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, cell, <span style="color:#ae81ff">1</span>)
u <span style="color:#f92672">=</span> TrialFunction(V)
v <span style="color:#f92672">=</span> TestFunction(V)
M <span style="color:#f92672">=</span> Coefficient(T)
a <span style="color:#f92672">=</span> M[i,j]<span style="color:#f92672">*</span>u[k]<span style="color:#f92672">.</span>dx(j)<span style="color:#f92672">*</span>v[k]<span style="color:#f92672">.</span>dx(i)<span style="color:#f92672">*</span>dx
astar <span style="color:#f92672">=</span> adjoint(a)
</code></pre></div><p>对应于（


<span class="katex">
  \(u\in U\)
</span>
和


<span class="katex">
  \(v\in V\)
</span>
）</p>



<span class="katex">
  \[
a(M; u, v) =\int_\Omega M_{ij} u_{k,j} v_{k,i} dx \tag{17.59}
\]
</span>




<span class="katex">
  \[
a^∗(M; v, u) =\int_\Omega M_{ij} u_{k,j} v_{k,i} dx = a(M; u, v) \tag{17.60}
\]
</span>

<p>如果我们需要使用求导来计算非对称双线性形式的伴随，那么这种自动转换特别有用，因为


<span class="katex">
  \(a\)
</span>
的显式表达式并不在其间。 与<code>derivative</code>结合使用时，以下几种形式算符最有用。</p>
<h3 id="1753-替换函数">17·5·3 替换函数</h3>
<p>通过使用其他值替换终端对象，可以使用新定义的形式参数来对形式求值。 假定您已经定义了依赖于某些函数


<span class="katex">
  \(f\)
</span>
和


<span class="katex">
  \(g\)
</span>
的形式


<span class="katex">
  \(L\)
</span>
。 然后，您可以通过将这些函数替换为其他函数或固定值，来得到特定形式，比如</p>



<span class="katex">
  \[
L(f , g; v) = \int_\Omega \frac{f^2}{2g}v\ dx \tag{17.61}
\]
</span>




<span class="katex">
  \[
L_2(f , g; v) = L(g, 3; v) = \int_\Omega \frac{g^2}{6}v\ dx \tag{17.62}
\]
</span>

<p>此功能通过<code>replace</code>实现了，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
V <span style="color:#f92672">=</span> FiniteElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, cell, <span style="color:#ae81ff">1</span>)
v <span style="color:#f92672">=</span> TestFunction(V)
f <span style="color:#f92672">=</span> Coefficient(V)
g <span style="color:#f92672">=</span> Coefficient(V)
L <span style="color:#f92672">=</span> f<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>g)<span style="color:#f92672">*</span>v<span style="color:#f92672">*</span>dx
L2 <span style="color:#f92672">=</span> replace(L, { f: g, g: <span style="color:#ae81ff">3</span>})
L3 <span style="color:#f92672">=</span> g<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">6</span><span style="color:#f92672">*</span>v<span style="color:#f92672">*</span>dx
</code></pre></div><p>L2和L3代表完全相同的形式。 由于它们仅取决于g，为这些形式生成的代码可以更高效。</p>
<h3 id="1754-作用">17·5·4 作用</h3>
<p>在某些应用中，不明确需要矩阵，而只需要矩阵对矢量的作用。  直接组装结果向量，先比组装稀疏矩阵然后执行矩阵-向量乘法要有效得多。 假设


<span class="katex">
  \(a\)
</span>
是双线性形式，


<span class="katex">
  \(w\)
</span>
是定义在与


<span class="katex">
  \(a\)
</span>
中试探函数相同的有限元上的系数。 令


<span class="katex">
  \(A\)
</span>
表示可以从


<span class="katex">
  \(a\)
</span>
组装的稀疏矩阵。 然后，您可以通过定义代表双线性形式


<span class="katex">
  \(a\)
</span>
作用于一个函数


<span class="katex">
  \(w\)
</span>
的线性形式


<span class="katex">
  \(L\)
</span>
， 进而直接将其组装成


<span class="katex">
  \(A\)
</span>
对向量的作用。 简单地表示成<code>L = action(a, w)</code>，甚至缩写为<code>L = a*w</code>。</p>
<h3 id="1755-系统分割">17·5·5 系统分割</h3>
<p>如果您更喜欢将PDE的所有项都写在一侧，比如</p>



<span class="katex">
  \[
a(u, v) − L(v) = 0 \tag{17.63}
\]
</span>

<p>您可以同时声明线性项和双线性项，然后将方程拆分为


<span class="katex">
  \(a\)
</span>
和


<span class="katex">
  \(L\)
</span>
。 一个简单的例子是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
V <span style="color:#f92672">=</span> FiniteElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, cell, <span style="color:#ae81ff">1</span>)
u <span style="color:#f92672">=</span> TrialFunction(V)
v <span style="color:#f92672">=</span> TestFunction(V)
f <span style="color:#f92672">=</span> Coefficient(V)
pde <span style="color:#f92672">=</span> u<span style="color:#f92672">*</span>v<span style="color:#f92672">*</span>dx <span style="color:#f92672">-</span> f<span style="color:#f92672">*</span>v<span style="color:#f92672">*</span>dx
a, L <span style="color:#f92672">=</span> system(pde)
</code></pre></div><p>这里的<code>system</code>用于将PDE分为双线性和线性部分。 或者，可以使用<code>lhs</code>和<code>rhs</code>分别获得这两个部分。 记住，线性部分的结果符号，对应于在公式（17.63）中将L移动到右侧。</p>
<h3 id="1756-计算函数的敏感性">17·5·6 计算函数的敏感性</h3>
<p>如果您找到了方程（17.63）的解


<span class="katex">
  \(u\)
</span>
，并且


<span class="katex">
  \(u\)
</span>
依赖于某个标量常值


<span class="katex">
  \(c\)
</span>
，则可以计算


<span class="katex">
  \(u\)
</span>
关于


<span class="katex">
  \(c\)
</span>
的变化灵敏度。 如果


<span class="katex">
  \(u\)
</span>
被表示成代数线性系统


<span class="katex">
  \(Ax = b\)
</span>
解的系数向量


<span class="katex">
  \(x\)
</span>
，那么


<span class="katex">
  \(\frac{\partial u}{\partial c}\)
</span>
的系数就是


<span class="katex">
  \(\frac{\partial x}{\partial c}\)
</span>
。 将


<span class="katex">
  \(\frac{\partial}{\partial c}\)
</span>
应用于


<span class="katex">
  \(Ax = b\)
</span>
并使用链式规则，我们可以写成</p>



<span class="katex">
  \[
A \frac{\partial x}{\partial c}=\frac{\partial b}{\partial c}−\frac{\partial A}{\partial c} x \tag{17.64}
\]
</span>

<p>因此，可以通过求解相同的代数线性系统算出的


<span class="katex">
  \(x\)
</span>
来发现


<span class="katex">
  \(\frac{\partial x}{\partial c}\)
</span>
， 仅在右侧不同。 可以写出与等式（17.64）右边相对应的线性形式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
u <span style="color:#f92672">=</span> Coefficient(element)
sL <span style="color:#f92672">=</span> diff(L, c) <span style="color:#f92672">-</span> action(diff(a, c), u) <span style="color:#75715e"># 执行报错，我尚未做到原因</span>
</code></pre></div><p>或者您可以使用等效的形式转换</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
sL <span style="color:#f92672">=</span> sensitivity_rhs(a, u, L, c) <span style="color:#75715e"># 执行报错，我尚未做到原因</span>
</code></pre></div><p>请注意，解


<span class="katex">
  \(u\)
</span>
必须用Coefficient表示，而


<span class="katex">
  \(a(u, v)中\)
</span>
的


<span class="katex">
  \(u\)
</span>
用Argument表示。</p>
<h2 id="176-表达式的表示">17·6 表达式的表示</h2>
<p>从高级的角度来看，UFL就是形式的定义。 每种形式都包含一个或多个标量被积表达式，但是形式表示在很大程度上与被积表达式的表示无关。 实际上，UFL实现的大多数复杂性都与表达式的表示，表现和操纵有关。 本章的其余部分将重点介绍表达式的表示以及在其上操作算法。 这些主题对UFL的普通用户几乎没有兴趣，而更多地针对开发人员和好奇的面向技术的用户。</p>
<p>为了在没有实现细节负担的情况下推理表达式算法，我们需要对表达式结构进行抽象表示。 UFL表达式是程序的表示，并且该表示法应使我们能够看到这种联系。 下面，我们将根据这种抽象符号来讨论表达式的属性，并与特定的实现细节相关。</p>
<h3 id="1761-表达式的结构">17·6·1 表达式的结构</h3>
<p>不依赖于其他表达式的最基本的表达式称为<strong>终端表达式</strong>。 将某些算符应用于一个或多个现有表达式会产生其他表达式。  考虑任意（非终端）表达式


<span class="katex">
  \(z\)
</span>
。 该表达式依赖于一组终端表达式


<span class="katex">
  \(\{t_i\}\)
</span>
，并使用了一组算符


<span class="katex">
  \(\{f_i\}\)
</span>
来计算的。  如果


<span class="katex">
  \(z\)
</span>
的每个子表达式都用一个整数来标记，则可以编写一个抽象程序来计算


<span class="katex">
  \(z\)
</span>
，方法是计算 一个子表达式序列


<span class="katex">
  \(\langle y_i\rangle^n_{i = 1}\)
</span>
，并设置


<span class="katex">
  \(z = y_n\)
</span>
。算法5显示了这样一个程序。</p>
<p><img src="/notes/images/0250.jpg" alt="0250.jpg"></p>
<p>每个终端表达式


<span class="katex">
  \(t_i\)
</span>
是程序的字面常量或输入参数。 这包括了系数，基函数和几何量。  一个非终端子表达式


<span class="katex">
  \(y_i\)
</span>
是将算符


<span class="katex">
  \(f_i\)
</span>
应用于先前计算过的表达式序列


<span class="katex">
  \(\langle y_j\rangle_{j\in \mathcal{J}_i}\)
</span>
的结果，其中


<span class="katex">
  \(\mathcal{J}_i\)
</span>
是表达式有序序列的记号。注意，根据已计算的子表达式，能产生的相同的


<span class="katex">
  \(z\)
</span>
值的顺序并不是唯一的。 为了正确起见，我们只要求


<span class="katex">
  \(j\lt i\ \forall j\in\mathcal{J}_i\)
</span>
，这样子表达式


<span class="katex">
  \(y_i\)
</span>
的所有依赖关系都在


<span class="katex">
  \(y_i\)
</span>
之前计算出来了。 特别是，在此抽象算法中，出于符号上的方便，所有终端表达式都最先编号。</p>
<p>计算z的程序可以表示成图，其中每个表达式


<span class="katex">
  \(y_i\)
</span>
对应于图顶点。  如果


<span class="katex">
  \(j \in \mathcal{J}_i\)
</span>
，而


<span class="katex">
  \(y_i\)
</span>
依赖于


<span class="katex">
  \(y_j\)
</span>
的值，那么这是有向图的一个从


<span class="katex">
  \(y_i\)
</span>
到


<span class="katex">
  \(y_j\)
</span>
的边


<span class="katex">
  \(e = (i, j)\)
</span>
。 更正式地讲，表示计算


<span class="katex">
  \(z\)
</span>
的图


<span class="katex">
  \(G\)
</span>
由一组顶点


<span class="katex">
  \(V\)
</span>
和一组边


<span class="katex">
  \(E\)
</span>
组成，它们由以下各项定义：</p>



<span class="katex">
  \[
G = (V, E) \tag{17.65}
\]
</span>




<span class="katex">
  \[
V = \langle v_i \rangle^n_{i=1} = \langle y_i \rangle^n_{i=1}  \tag{17.66}
\]
</span>




<span class="katex">
  \[
E = \{e_k\} =\bigcup^n_{i=1} \{(i, j)\ \forall j \in \mathcal{J}_i\}  \tag{17.67}
\]
</span>

<p>此图明显是有向的，因为它的依赖关系是有向的。 它是无环的，因为一个表达式只能根据现有的表达式构造。 因此，UFL表达式可以用有向无环图（DAG）表示。 在UFL中，此DAG可用两种方式表示。 在定义表达式时，会建立一个称为<strong>表达式树</strong>的链表示。 从技术上讲，这仍然是DAG，因为可以在多个子表达式中重用顶点，但是这个表示强调了DAG的树状结构。 另一个表示称为<strong>计算图</strong>，它与上面


<span class="katex">
  \(G\)
</span>
的定义非常相似。 此表示对形式编译器最有用。 这两个DAG表示的细节将在下面说明。 它们都将图形中顶点的表示作为表达式对象共享，下面将对其进行说明。</p>
<h3 id="1762-表达式对象">17·6·2 表达式对象</h3>
<p>回顾一下算法5的非终端表达式


<span class="katex">
  \(y_i = f_i(\langle y_j \rangle_{j\in \mathcal{J}_i} )\)
</span>
。 算符


<span class="katex">
  \(f_i\)
</span>
由表达式对象的类来表示，而表达式


<span class="katex">
  \(y_i\)
</span>
由此类的实例表示。 在UFL实现中，每个表达式对象都是Expr的某个子类的实例。 Expr类是层次结构的超类，其中包含UFL所支持的所有终端表达式类型和算符类型。 Expr有两个直接的子类，Terminal和Operator，它们将表达式类型层次分为两部分，如图17.2所示。</p>
<p><img src="/notes/images/0251.jpg" alt="0251.jpg"></p>
<center>图17.2 表达式类的层次结构。</center>
<p>所有表达式对象都被认为是不可变的。 一旦构造了表达式对象，将永远无法对其进行修改。 操作表达式应始终会导致创建新对象。 不可变属性确保表达式对象可以在表达式之间重用和共享，而不会在程序的其他部分产生副作用。 这既减少了内存使用，避免了不必要的对象复制，又简化了对常见子表达式的识别。</p>
<p>在表示


<span class="katex">
  \(y_i\)
</span>
的Expr对象<code>e</code>上调用<code>e.operands()</code>，会返回一个具有表示


<span class="katex">
  \(\langle y_j \rangle_{j\in \mathcal{J}_i}\)
</span>
的表达式对象的元组。 请注意，也可应用到没有传出边的终端表达式，并且<code>t.operands()</code>返回空元组。 除了修改表达式对象的操作数外，还可以调用<code>e.reconstruct(operands)</code>用修改后的操作数构造相同类型的新表达式对象，其中<code>operands</code>是表达式对象元组。 如果操作数相同，则此函数返回原始对象，从而允许许多算法节省内存而不会带来其他复杂性。 不变式<code>e.reconstruct(e.operands()) == e</code>应该始终成立。</p>
<h3 id="1763-表达式属性">17·6·3 表达式属性</h3>
<p>在第17.4.2节中，讨论了UFL的张量代数和索引记号的功能。 表达式可以是标量或具有任意阶和形状的张量值。 因此，每个表达式对象e的值形状为<code>e.shape()</code>，它是在每个张量轴上维数的整数元组。 标量表达式也有<code>shape ()</code>。 另一个重要的属性是表达式中的一组自由索引，可以使用<code>e.free_indices()</code>作为元组获得。 尽管自由索引没有顺序，但为简单起见，它们以Index实例的元组表示。 因此，元组中的排序没有任何意义。</p>
<p>UFL表达式在引用上是透明的，但有一些例外。 <strong>引用透明性</strong>是指子表达式可以用其值的另一种表示代替，而无需更改表达式的含义。 这里的关键是，在这种情况下，表达式的值包括张量形状和一组自由索引。 另一个重要点是，函数


<span class="katex">
  \(f (v)\)
</span>
在某点导数


<span class="katex">
  \(f'(v)|_{v=g}\)
</span>
，依赖于


<span class="katex">
  \(v = g\)
</span>
附近的函数值。 这种依赖性的结果是，算符类型在微分时很重要，而不仅是微分变量的当前值。 特别是，<code>Variable</code>不能用其表示的表达式替换，因为<code>diff</code>依赖于<code>Variable</code>实例，而不是有值的表达式。 同样，用某个值替换<code>Coefficient</code>会更改包含关于函数系数求导表达式的含义。</p>
<p>以下示例说明了<code>Variable</code>和<code>diff</code>的这个问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># UFL code</span>
e <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
v <span style="color:#f92672">=</span> variable(e)
f <span style="color:#f92672">=</span> sin(v)
g <span style="color:#f92672">=</span> diff(f, v)
</code></pre></div><p>这里的


<span class="katex">
  \(v\)
</span>
是一个取值为0的变量，但是


<span class="katex">
  \(\sin(v)\)
</span>
不能简化为0，否则


<span class="katex">
  \(f\)
</span>
的导数将变成0。 此处的正确结果是


<span class="katex">
  \(g = \cos(v)\)
</span>
。 打印f和g得到字符串<code>sin(var1(0))</code>和<code>d/d[var1(0)] (sin(var1(0)))</code>。 尝试仅设置


<span class="katex">
  \(v = e\)
</span>
，看看f和g如何变为零。</p>
<h3 id="1764-树表示">17·6·4 树表示</h3>
<p>表达式树没有单独的数据结构。 它只是查看表达式结构的一种方式。 任何表达式对象e都可以看作是树的根，其中<code>e.operands()</code>返回其子级。 如果某些子项相等，则它们的出现次数将与表达式中出现的次数相同。 因此很容易遍历树节点（也就是DAG中的vi），但是最终无法直接重用子表达式。 DAG中的边不会明确显示，并且只能通过递归遍历树并选择唯一对象来获得顶点列表。</p>
<p>刚度项


<span class="katex">
  \(\mathrm{grad}\ u : \mathrm{grad}\ v\)
</span>
的表达式树如图17.3所示。 终端表达式u和v没有子节点，


<span class="katex">
  \(\mathrm{grad}\ u\)
</span>
项本身由带有两个节点的树表示。 每次将算符应用于某些表达式时，它将返回引用其操作数的新树根。  请注意，用户将在使用该语言时应用的是<code>grad</code>和<code>inner</code>函数，而该图中的名称<code>Grad</code>，<code>Inner</code>和<code>Argument</code>是UFL中用来表示表达式对象的Expr子类名称。 换句话说，由<code>grad(u)</code> 获得的表达式梯度，是一个由<code>Grad(u)</code>表示的表达式，而<code>inner(a, b)</code>则给出一个表达式表示<code>Inner(a, b)</code>。  语言和表示的这种分离仅仅是UFL实现中的一种设计选择。</p>
<p><img src="/notes/images/0252.jpg" alt="0252.jpg"></p>
<center>图17.3 


<span class="katex">
  \(\mathrm{grad}\ u : \mathrm{grad}\ v\)
</span>
的表达式树。</center>
<h3 id="1765-图表示">17·6·5 图表示</h3>
<p>当以树的形式查看表达式时，所有唯一顶点和边的列表都不是直接可用的。 更加直接地表示DAG可以简化或优化许多算法。  UFL包括从任何表达式构建基于DAG表示的数组的工具（<strong>计算图</strong>）。 计算图


<span class="katex">
  \(G = (V, E)\)
</span>
是基于平面数组的数据结构，直接反映了方程（17.65）-（17.67）中图的定义。 此表示可直接访问子表达式之间的依赖关系，并允许在唯一顶点上轻松进行迭代。 该图可通过以下几行轻松构建：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
<span style="color:#75715e"># from ufl.algorithms import Graph</span>
<span style="color:#f92672">from</span> ufl.formatting.graph <span style="color:#f92672">import</span> Graph
G <span style="color:#f92672">=</span> Graph(expression)
V, E <span style="color:#f92672">=</span> G
</code></pre></div><p>一个数组（Python列表）V用于存储DAG中的顶点 


<span class="katex">
  \(\langle v_i\rangle^n_{i=1}\)
</span>
。 对于每个顶点


<span class="katex">
  \(v_i\)
</span>
，存储一个表达式节点


<span class="katex">
  \(y_i\)
</span>
来表示。 因此，每个顶点的表达式树也是直接可用的，因为每个表达式节点都是其表达式树的根。 边则存储在数组


<span class="katex">
  \(E\)
</span>
中，整数元组


<span class="katex">
  \((i,j)\)
</span>
表示从


<span class="katex">
  \(v_i\)
</span>
到


<span class="katex">
  \(v_j\)
</span>
的边； 也就是说，


<span class="katex">
  \(v_j\)
</span>
是


<span class="katex">
  \(v_i\)
</span>
的操作数。 图中的顶点列表是使用深度优先遍历的后序来构建的，这保证了对顶点进行拓扑排序，使得


<span class="katex">
  \(j\lt i\quad \forall j\in \mathcal{J}_i\)
</span>
。</p>
<p>让我们看一个计算图的例子。 以下代码定义一个简单表达式，然后打印图的顶点和边缘。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
<span style="color:#f92672">from</span> ufl <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
cell <span style="color:#f92672">=</span> triangle
V <span style="color:#f92672">=</span> FiniteElement(<span style="color:#e6db74">&#34;Lagrange&#34;</span>, cell, <span style="color:#ae81ff">1</span>)
u <span style="color:#f92672">=</span> TrialFunction(V)
v <span style="color:#f92672">=</span> TestFunction(V)
c <span style="color:#f92672">=</span> Constant(cell)
f <span style="color:#f92672">=</span> Coefficient(V)
e <span style="color:#f92672">=</span> c<span style="color:#f92672">*</span>f<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>u<span style="color:#f92672">*</span>v

<span style="color:#75715e"># from ufl.algorithms import Graph, partition</span>
<span style="color:#f92672">from</span> ufl.formatting.graph <span style="color:#f92672">import</span> Graph, partition
G <span style="color:#f92672">=</span> Graph(e)
V, E, <span style="color:#f92672">=</span> G

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;str(e) = </span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> str(e))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;V[</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">] = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (i, v) <span style="color:#66d9ef">for</span> (i, v) <span style="color:#f92672">in</span> enumerate(V)), <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>join(<span style="color:#e6db74">&#34;E[</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">] = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (i, e) <span style="color:#66d9ef">for</span> (i, e) <span style="color:#f92672">in</span> enumerate(E)), <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</code></pre></div><p>程序输出的摘录如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt"># Generated code
V[0] = v_{-2}
...
V[7] = v_{-1} * c_0 * w_1 ** 2
V[8] = v_{-2} * v_{-1} * c_0 * w_1 ** 2
...
E[6] = (8, 0)
E[7] = (8, 7)
</code></pre></div><p>最后两个边，显示了顶点8与顶点7和0的依存关系，  因为


<span class="katex">
  \(v_8 = v_0 v_7\)
</span>
。 运行代码以查看该代码的完整输出。 尝试更改表达式，然后如上查看图。</p>
<p>从边E可以有效地计算相关的数组。 特别是顶点vi在两个方向上所依赖的顶点索引是有用的：</p>



<span class="katex">
  \[
\begin{aligned}V_{out} &= \langle \mathcal{J}_i\rangle^n_{i=1}  \\ V_{in} &= \langle \{j|i \in \mathcal{J}_j\}\rangle^n_{i=1}\end{aligned} \tag{17.68}
\]
</span>

<p>对任何表达式，这些数组可以很容易构造：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
Vin <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span>Vin()
Vout <span style="color:#f92672">=</span> G<span style="color:#f92672">.</span>Vout()
</code></pre></div><p>存在类似的函数，用于获取所有传入和传出边E的索引。 由UFL构建的计算图有一个不错的特性：没有两个顶点将代表完全相同的表达式。 在图的构建期间，将子表达式插入哈希映射（Python字典）中即可实现此目的。 一些表达式类对参数进行唯一排序，例如<code>a*b</code>和<code>b*a</code>将成为图中的相同顶点。</p>
<p>当实现某些算法时，表达式节点中的自由索引会使线性化图的解释复杂化，因为具有自由索引的表达式对象不代表一个值，而是代表一组值，自由索引的每个值排列都对应一个值。 一种解决方案是在构造图之前应用<code>expand_indices</code>，它将用自由索引所对应的显式固定索引等效表达式，来替换所有表达式。 但是请注意，展开无法重新获得自由索引。 有关此转换的更多信息，请参见第17.8.3节。</p>
<h3 id="1766-划分">17·6·6 划分</h3>
<p>UFL旨在作为形式编译器的前端。 由于最终目标是根据表达式生成代码，因此为代码生成过程提供了一些实用程序。 原则上，只需在顶点上迭代并分别为每个操作生成代码，就可以从其计算图为表达式生成正确的代码，基本上是算法5的镜像。 但是，一个好的形式编译器应该能够产生更好的代码。 UFL提供了实用程序，用于根据子表达式的依赖性将计算图划分为子图（<strong>划分</strong>），这允许基于形式编译器的正交，可以轻松地将子表达式放置在正确的循环集中。  函数<code>partition</code>实现此功能。 每个划分都由一个简单的顶点索引数组表示，并且每个划分都标记有一组依赖项。 默认情况下，这组依赖使用字符串<code>x</code>，<code>c</code>和<code>v%d</code>来分别表示对空间坐标，特定数量的胞元和形式参数（非系数）的依赖关系。</p>
<p>以下示例代码对上面构建的图进行划分，并根据其依存关系将顶点分组打印。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
partitions, keys <span style="color:#f92672">=</span> partition(G)
<span style="color:#66d9ef">for</span> deps <span style="color:#f92672">in</span> sorted(partitions<span style="color:#f92672">.</span>keys()):
    P <span style="color:#f92672">=</span> partitions[deps]
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;The following depends on&#34;</span>, tuple(deps))
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> sorted(P):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;V[</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">] = </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (i, V[i]))
</code></pre></div><p>该程序的输出文本见后。 注意，字面常量2没有依赖。 始终可以在编译时预先计算此划分中的表达式。 常数<code>c_0</code>依赖于每个胞元的变化数据，由依赖集的<code>c</code>代表，而不依赖于空间坐标，因此可以将其置于正交循环之外。 函数<code>w_1</code>及其依赖的表达式还依赖于x表示的空间坐标，因此需要针对每个正交点进行计算。 仅依赖于测试或试探功能的表达式用<code>v%d</code>标记，其中数字是UFL用于区分参数的内部计数器。 请注意，此处的测试和试探函数被标记所依赖的空间坐标，但是不依赖胞元的数量。 这仅适用于在局部参考单元上定义的有限元，在这种情况下，可以在每个正交点中预先计算基函数。 有限元空间中基本函数在运行时的实际依赖关系对于UFL是未知的，这就是为什么函数partition用可选的多功能参数，以便形式编译器可以提供更准确依赖关系的原因。 有关此详细的实现信息，请参考partition的实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-txt" data-lang="txt"># Generated code
The following depends on ()
V[4] = 2
The following depends on (&#34;c&#34;,)
V[2] = c_0
The following depends on (&#34;x&#34;, &#34;c&#34;)
V[3] = w_1
V[5] = w_1 ** 2
V[6] = c_0 * w_1 ** 2
The following depends on (&#34;x&#34;, &#34;v-1&#34;)
V[1] = v_{-1}
The following depends on (&#34;x&#34;, &#34;c&#34;, &#34;v-1&#34;)
V[7] = v_{-1} * c_0 * w_1 ** 2
The following depends on (&#34;x&#34;, &#34;v-2&#34;)
V[0] = v_{-2}
The following depends on (&#34;x&#34;, &#34;c&#34;, &#34;v-2&#34;, &#34;v-1&#34;)
V[8] = v_{-2} * v_{-1} * c_0 * w_1 ** 2
</code></pre></div><p>【<a href="/notes/docs/fem/#%e7%ac%ac%e5%8d%81%e4%b8%83%e7%ab%a0-ufl%e6%9c%89%e9%99%90%e5%85%83%e5%bd%a2%e5%bc%8f%e8%af%ad%e8%a8%80">章节目录</a>】</p></article>

<hr>

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0122/">
    下一页<br>UFL：有限元形式语言》计算导数&amp;算法(一)【翻译】
  </a>
  
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0120/">
      上一页<br>UFL：有限元形式语言》表达式【翻译】
  </a>
  
</nav>

 

      <footer class="book-footer">
        
  <div class="flex justify-between">





  <div>
    <a class="flex align-center" href="https://gitee.com/chaoskey/notes/blob/master/content/docs/fem/0121.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      <span>评论</span>
    </a>
  </div>
  
  
  <div>
    <a class="flex align-center" href="https://gitee.com/-/ide/project/chaoskey/notes/edit/master/-/content/docs/fem/0121.md" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>

</div>

 
        
  
  <div class="book-comments">

</div>
  
  
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li><a href="#ii实现17ufl有限元形式语言形式算符表达式的表示">II.实现》17.UFL：有限元形式语言》形式算符&amp;表达式的表示</a>
      <ul>
        <li><a href="#175-形式算符">17·5 形式算符</a>
          <ul>
            <li><a href="#1751-形式的微分">17·5·1 形式的微分</a></li>
            <li><a href="#1752-伴随">17·5·2 伴随</a></li>
            <li><a href="#1753-替换函数">17·5·3 替换函数</a></li>
            <li><a href="#1754-作用">17·5·4 作用</a></li>
            <li><a href="#1755-系统分割">17·5·5 系统分割</a></li>
            <li><a href="#1756-计算函数的敏感性">17·5·6 计算函数的敏感性</a></li>
          </ul>
        </li>
        <li><a href="#176-表达式的表示">17·6 表达式的表示</a>
          <ul>
            <li><a href="#1761-表达式的结构">17·6·1 表达式的结构</a></li>
            <li><a href="#1762-表达式对象">17·6·2 表达式对象</a></li>
            <li><a href="#1763-表达式属性">17·6·3 表达式属性</a></li>
            <li><a href="#1764-树表示">17·6·4 树表示</a></li>
            <li><a href="#1765-图表示">17·6·5 图表示</a></li>
            <li><a href="#1766-划分">17·6·6 划分</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












