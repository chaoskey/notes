<!DOCTYPE html>
<html lang="cn">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="DOLFIN：C&#43;&#43;/Python有限元库》网格【翻译】"><meta property="og:title" content="DOLFIN：C&#43;&#43;/Python有限元库》网格【翻译】" />
<meta property="og:description" content="【章节目录】
10·3·2 网格
DOLFIN的核心部分是其网格库和Mesh类。  网格库为计算网格提供了数据结构和算法，包括网格连通性（重合关系），网格细化，网格划分和网格相交的计算。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://chaoskey.gitee.io/notes/docs/fem/0113/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2021-01-08T10:12:53&#43;08:00" />
<meta property="article:modified_time" content="2021-01-08T10:12:53&#43;08:00" />

<title>DOLFIN：C&#43;&#43;/Python有限元库》网格【翻译】 | 学习笔记</title>
<link rel="icon" href="/notes/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/notes/book.min.0253b76936e9496c1a48e74d90cdc268fd0e96366c60a1f43994801cc334588a.css" integrity="sha256-AlO3aTbpSWwaSOdNkM3CaP0OljZsYKH0OZSAHMM0WIo=">


<script defer src="/notes/cn.search.min.c9e07669544fa8ea9d43c2a1f23a11bae508039b3f5d99b0b5d1502251caeda8.js" integrity="sha256-yeB2aVRPqOqdQ8Kh8joRuuUIA5s/XZmwtdFQIlHK7ag="></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="container flex">
    <aside class="book-menu">
      
  <nav>
<h2 class="book-brand">
  <a href="/notes"><img src="/notes/logo.png" alt="Logo" /><span>学习笔记</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="搜索" aria-label="搜索" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>









  










    
    



<ul>
<li><a href="/notes/posts/"><strong>杂事记录</strong></a></li>
<li><a href="/notes/docs/fem/"><strong>有限元法自动求解微分方程</strong></a>
<ul>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E6%96%B9%E6%B3%95">第二章 有限元方法</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%B8%B8%E8%A7%81%E6%9C%89%E9%99%90%E5%85%83">第三章 常见有限元</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%9E%84%E9%80%A0%E9%80%9A%E7%94%A8%E5%8F%82%E8%80%83%E5%8D%95%E5%85%83">第四章 构造通用参考单元</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F">第五章 有限元变分形式</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E7%BB%84%E8%A3%85">第六章 有限元组装</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%AD%A3%E4%BA%A4%E8%A1%A8%E7%A4%BA">第七章 有限元变分形式的正交表示</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%BC%A0%E9%87%8F%E8%A1%A8%E7%A4%BA">第八章 有限元变分形式的张量表示</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%9C%89%E9%99%90%E5%85%83%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97%E7%9A%84%E7%A6%BB%E6%95%A3%E4%BC%98%E5%8C%96">第九章 有限元矩阵计算的离散优化</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E7%AB%A0-dolfincpython%E6%9C%89%E9%99%90%E5%85%83%E5%BA%93">第十章 DOLFIN：C++/Python有限元库</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0-ufl%E6%9C%89%E9%99%90%E5%85%83%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80">第十七章 UFL：有限元形式语言</a></li>
<li><a href="/notes/docs/fem/#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0-unicorn%E7%BB%9F%E4%B8%80%E7%9A%84%E8%BF%9E%E7%BB%AD%E4%BB%8B%E8%B4%A8%E5%8A%9B%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%99%A8">第十八章 Unicorn：统一的连续介质力学求解器</a></li>
<li><a href="/notes/docs/fem/#%e7%ac%ac%e4%ba%8c%e5%8d%81%e7%ab%a0-%e4%b8%8d%e5%8f%af%e5%8e%8b%e7%bc%a9%e6%b5%81%e4%bd%93%e7%9a%84%e6%9c%89%e9%99%90%e5%85%83">第二十章 不可压缩流体的有限元</a></li>
</ul>
</li>
<li><a href="/notes/docs/julia/"><strong>基于Julia科学计算</strong></a></li>
<li><a href="/notes/docs/theophy/"><strong>理论物理学习笔记</strong></a></li>
<li><a href="/notes/docs/diffgeo/"><strong>微分几何笔记</strong></a></li>
<li><a href="/notes/docs/mlapp/"><strong>机器学习：概率视角</strong></a></li>
<li><a href="/notes/docs/apm/"><strong>主动投资组合管理</strong></a></li>
</ul>












</nav>




  <script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/notes/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>DOLFIN：C&#43;&#43;/Python有限元库》网格【翻译】</strong>

  <label for="toc-control">
    <img src="/notes/svg/toc.svg" class="book-icon" alt="Table of Contents" />
  </label>
</div>


  
    <input type="checkbox" class="hidden" id="toc-control" />
    <aside class="hidden clearfix">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1032-网格">10·3·2 网格</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


    </aside>
  
 
      </header>

      

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0114/">
    下一页<br>DOLFIN：C&#43;&#43;/Python有限元库》有限元/函数/表达式【翻译】
  </a>
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0112/">
      上一页<br>DOLFIN：C&#43;&#43;/Python有限元库》线性代数【翻译】
  </a>
  
</nav>

<hr>

<article class="markdown">
  <h1>
    <a href="/notes/docs/fem/0113/">DOLFIN：C&#43;&#43;/Python有限元库》网格【翻译】</a>
  </h1>
  

<div>

  <h5>2021-01-08</h5>


<div>

  
    |
    
      <a href="/notes/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97">科学计算</a>
      
    |
  

  
    |
    
      <a href="/notes/tags/FEniCS">FEniCS</a>
      , 
      <a href="/notes/tags/%E6%9C%89%E9%99%90%E5%85%83%E6%B3%95">有限元法</a>
      , 
      <a href="/notes/tags/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">偏微分方程</a>
      
    |
  




    <a href="https://gitee.com/chaoskey/notes/blob/master/content/docs/fem/0113.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      评论
    </a>


</div>


</div>

<p>【<a href="/notes/docs/fem/#%e7%ac%ac%e5%8d%81%e7%ab%a0-dolfincpython%e6%9c%89%e9%99%90%e5%85%83%e5%ba%93">章节目录</a>】</p>
<h3 id="1032-网格">10·3·2 网格</h3>
<p>DOLFIN的核心部分是其网格库和Mesh类。  网格库为计算网格提供了数据结构和算法，包括网格连通性（重合关系），网格细化，网格划分和网格相交的计算。</p>
<p>网格库是用C++实现的，已进行了最小化存储需求的优化，并实现对网格数据的有效访问。  特别是，DOLFIN网格存储在少量连续数组中，在其上是轻量级的面向对象层，可提供对底层数据的查看。  有关网格库设计和实现的详细讨论，请参见Logg（2009）。</p>
<p><strong>创建一个网格</strong>。  DOLFIN提供了用于创建简单网格的功能，例如单位正方形和单位立方体，球体，矩形和盒子的网格。  以下代码演示如何创建单位正方形的16×16三角形网格（由2×16×16 = 512个三角形组成）和单位立方体的16×16×16四面体网格（由6×16×16×16 = 24,576个四面体组成）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>UnitSquareMesh <span style="color:#a6e22e">unit_square</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>);
UnitCubeMesh <span style="color:#a6e22e">unit_cube</span>(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
unit_square <span style="color:#f92672">=</span> UnitSquareMesh(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>)
unit_cube <span style="color:#f92672">=</span> UnitCubeMesh(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>)
</code></pre></div><p>通过指定网格的胞元和顶点，可以显式构造简单网格（由间隔，三角形或四面体组成的网格）。  类<code>MeshEditor</code>提供了用于创建简单网格的接口。  以下代码演示了如何创建两个三角形组成的网格来覆盖单位正方形：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>Mesh mesh;
MeshEditor editor;
editor.open(mesh, <span style="color:#e6db74">&#34;triangle&#34;</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>);
editor.init_vertices(<span style="color:#ae81ff">4</span>);
editor.init_cells(<span style="color:#ae81ff">2</span>);
editor.add_vertex(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>);
editor.add_vertex(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>);
editor.add_vertex(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>);
editor.add_vertex(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>);
editor.add_cell(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>);
editor.add_cell(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
editor.close();
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
mesh <span style="color:#f92672">=</span> Mesh();
editor <span style="color:#f92672">=</span> MeshEditor();
editor<span style="color:#f92672">.</span>open(mesh, <span style="color:#e6db74">&#34;triangle&#34;</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
editor<span style="color:#f92672">.</span>init_vertices(<span style="color:#ae81ff">4</span>)
editor<span style="color:#f92672">.</span>init_cells(<span style="color:#ae81ff">2</span>)
editor<span style="color:#f92672">.</span>add_vertex(<span style="color:#ae81ff">0</span>, [<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>])
editor<span style="color:#f92672">.</span>add_vertex(<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">0.0</span>])
editor<span style="color:#f92672">.</span>add_vertex(<span style="color:#ae81ff">2</span>, [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">1.0</span>])
editor<span style="color:#f92672">.</span>add_vertex(<span style="color:#ae81ff">3</span>, [<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>])
editor<span style="color:#f92672">.</span>add_cell(<span style="color:#ae81ff">0</span>, [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>])
editor<span style="color:#f92672">.</span>add_cell(<span style="color:#ae81ff">1</span>, [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>])
editor<span style="color:#f92672">.</span>close()
</code></pre></div><p><strong>从文件读取网格</strong>。  尽管内置类UnitSquare和UnitCube可用于测试典型应用程序，但仍需要从文件读取由外部网格生成器生成的网格。  要从文件读取网格，只需将文件名提供给Mesh类的构造函数即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>Mesh <span style="color:#a6e22e">mesh</span>(<span style="color:#e6db74">&#34;mesh.xml&#34;</span>);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
mesh <span style="color:#f92672">=</span> Mesh(<span style="color:#e6db74">&#34;mesh.xml&#34;</span>)
</code></pre></div><p>网格必须以DOLFIN XML格式存储。  以下示例说明了单位正方形2×2网格的XML格式：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml"><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>

<span style="color:#f92672">&lt;dolfin</span> <span style="color:#a6e22e">xmlns:dolfin=</span><span style="color:#e6db74">&#34;http://fenicsproject.org&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;mesh</span> <span style="color:#a6e22e">celltype=</span><span style="color:#e6db74">&#34;triangle&#34;</span> <span style="color:#a6e22e">dim=</span><span style="color:#e6db74">&#34;2&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;vertices</span> <span style="color:#a6e22e">size=</span><span style="color:#e6db74">&#34;9&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0.5&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0.5&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0.5&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0.5&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;0.5&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;6&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;0.5&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;vertex</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;8&#34;</span> <span style="color:#a6e22e">x=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">y=</span><span style="color:#e6db74">&#34;1&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/vertices&gt;</span>
<span style="color:#f92672">&lt;cells</span> <span style="color:#a6e22e">size=</span><span style="color:#e6db74">&#34;8&#34;</span><span style="color:#f92672">&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;4&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;0&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;4&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;5&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;5&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;7&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;3&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;6&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;7&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;6&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;5&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;8&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;triangle</span> <span style="color:#a6e22e">index=</span><span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#a6e22e">v0=</span><span style="color:#e6db74">&#34;4&#34;</span> <span style="color:#a6e22e">v1=</span><span style="color:#e6db74">&#34;7&#34;</span> <span style="color:#a6e22e">v2=</span><span style="color:#e6db74">&#34;8&#34;</span><span style="color:#f92672">/&gt;</span>
<span style="color:#f92672">&lt;/cells&gt;</span>
<span style="color:#f92672">&lt;/mesh&gt;</span>
<span style="color:#f92672">&lt;/dolfin&gt;</span>
</code></pre></div><p>可以使用命令<code>dolfin-convert</code>将以其他数据格式存储的网格转换为DOLFIN XML格式，如下文更详细的解释。</p>
<p><strong>网格实体</strong>。 从概念上讲，网格（由类Mesh建模）由一组网格实体组成。  网格实体是一对
  
    

    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    
    
    <script defer src="https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body,
                {delimiters: [{left: '$$\n', right: '\n$$', display: true}, {left: '$$', right: '$$', display: false}, 
                              {left: '\\[', right: '\\]', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>
    
  




<span class="katex">
  \((d, i)\)
</span>
，其中


<span class="katex">
  \(d\)
</span>
是网格实体的拓扑维数，而


<span class="katex">
  \(i\)
</span>
是网格实体的唯一索引。  网格实体在每个拓扑维数中从


<span class="katex">
  \(0\)
</span>
到


<span class="katex">
  \(n_d−1\)
</span>
编号，其中


<span class="katex">
  \(n_d\)
</span>
是拓扑维数


<span class="katex">
  \(d\)
</span>
的网格实体数。</p>
<p><img src="/notes/images/0238.jpg" alt="0238.jpg"></p>
<center>图10.3 网格的每个实体由一对


<span class="katex">
  \((d, i)\)
</span>
标识，对其指定了拓扑维数


<span class="katex">
  \(d\)
</span>
和在


<span class="katex">
  \(d\)
</span>
维实体集中的唯一索引i。</center>
<p><img src="/notes/images/0239.jpg" alt="0239.jpg"></p>
<center>表10.1 网格实体及其维数/余维数。 实体的余维数为


<span class="katex">
  \(D-d\)
</span>
，其中


<span class="katex">
  \(D\)
</span>
为最大维数，


<span class="katex">
  \(d\)
</span>
为维数。</center>
<p>为了方便起见，将拓扑0维网格实体称为<code>顶点</code>，将1维实体称为<code>边</code>，将2维实体称为<code>面</code>。  余1维实体称为<code>维面</code>(facet)，而余0维实体称为<code>胞元</code>(cell)。  这些概念总结在图10.3和表10.1中。  我们注意到，三角形网格由顶点，边和胞元组成，并且这些边也可以称为维面，而胞元则称为面。  我们进一步注意到，四面体网格由顶点，边，面和胞元组成，并且这些面也可以称为维面。  这些概念由类MeshEntity，Vertex，Edge，Face，Facet和Cell来实现。  这些类不存储任何数据。  相反，它们是轻量级对象，提供基础网格数据的视图。  可以从一个Mesh，一个拓扑维数和一个索引创建一个MeshEntity。  以下代码演示了如何在网格上创建各种实体：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>MeshEntity <span style="color:#a6e22e">entity</span>(mesh, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">33</span>); <span style="color:#75715e">// vertex number 33
</span><span style="color:#75715e"></span>Vertex <span style="color:#a6e22e">vertex</span>(mesh, <span style="color:#ae81ff">33</span>); <span style="color:#75715e">// vertex number 33
</span><span style="color:#75715e"></span>Cell <span style="color:#a6e22e">cell</span>(mesh, <span style="color:#ae81ff">25</span>); <span style="color:#75715e">// cell number 25
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
entity <span style="color:#f92672">=</span> MeshEntity(mesh, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">33</span>) <span style="color:#75715e"># vertex number 33</span>
vertex <span style="color:#f92672">=</span> Vertex(mesh, <span style="color:#ae81ff">33</span>) <span style="color:#75715e"># vertex number 33</span>
cell <span style="color:#f92672">=</span> Cell(mesh, <span style="color:#ae81ff">25</span>) <span style="color:#75715e"># cell number 25</span>
</code></pre></div><p><strong>网格拓扑和几何</strong>。  网格的拓扑与其几何分开存储。  网格的拓扑是对网格各个实体间关系的描述，而几何则描述了这些实体如何嵌入


<span class="katex">
  \(\mathbb{R}^d\)
</span>
中。</p>
<p>用户很少直接面对MeshTopology和MeshGeometry类，因为大多数关于网格的算法都可以用网格迭代器来表示。  但是，用户有时可能需要访问网格的维数，这涉及访问作为网格的一部分存储的MeshTopology或MeshGeometry，如以下代码示例所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>uint gdim <span style="color:#f92672">=</span> mesh.topology().dim();
uint tdim <span style="color:#f92672">=</span> mesh.geometry().dim();
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
gdim <span style="color:#f92672">=</span> mesh<span style="color:#f92672">.</span>topology()<span style="color:#f92672">.</span>dim()
tdim <span style="color:#f92672">=</span> mesh<span style="color:#f92672">.</span>geometry()<span style="color:#f92672">.</span>dim()
</code></pre></div><p>应当注意，拓扑和几何维数可能不同。  特别是对于网格边界这种情况，通常是嵌入在


<span class="katex">
  \(\mathbb{R}^{D+1}\)
</span>
中的拓扑


<span class="katex">
  \(D\)
</span>
维网格。  也就是说，几何维数为


<span class="katex">
  \(D+1\)
</span>
。</p>
<p><strong>网格连通性</strong>。  网格的拓扑由网格的连通性（重合关系）表示，这是对网格实体间相互连接的完整描述。  这种连通性通过MeshConnectivity类存储在DOLFIN中。  对于每对拓扑维


<span class="katex">
  \(d \to d'\quad d, d'= 0, 1, \dots, D\)
</span>
，将一个这样的数据集存储为类MeshTopology的一部分，其中


<span class="katex">
  \(D\)
</span>
是拓扑维。</p>
<p><img src="/notes/images/0240.jpg" alt="0240.jpg"></p>
<center>表10.2 DOLFIN计算网格的连通性


<span class="katex">
  \(d \to d'\)
</span>
，对每对


<span class="katex">
  \(d,d' = 0, 1, \dots, D\)
</span>
。 该表指示哪些连通性对（用×表示）已计算了，以便计算四面体网格的连通性


<span class="katex">
  \(1 \to 1\)
</span>
（边-边连通性）。</center>
<p>创建Mesh时，将创建最小的MeshTopology。 仅存储从胞元（


<span class="katex">
  \(D\)
</span>
维）到顶点（


<span class="katex">
  \(0\)
</span>
维度）的连通性（MeshConnectivity 


<span class="katex">
  \(D \to 0\)
</span>
）。  当要求某种连通性时，例如连通性


<span class="katex">
  \(1 \to 1\)
</span>
（边-边连通性），DOLFIN自动计算所要求连通性所需的任何其他连通性。  表10.2对此进行了说明，其中我们指出了计算


<span class="katex">
  \(1 \to 1\)
</span>
连通性需要哪些连通性。  以下代码演示了如何初始化四面体网格（


<span class="katex">
  \(D=3\)
</span>
）的各种网格连通：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>mesh.init(<span style="color:#ae81ff">2</span>); <span style="color:#75715e">// Compute faces
</span><span style="color:#75715e"></span>mesh.init(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Compute vertex neighbors for each vertex
</span><span style="color:#75715e"></span>mesh.init(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// Compute edge neighbors for each edge
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
mesh<span style="color:#f92672">.</span>init(<span style="color:#ae81ff">2</span>) <span style="color:#75715e"># Compute faces</span>
mesh<span style="color:#f92672">.</span>init(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#75715e"># Compute vertex neighbors for each vertex</span>
mesh<span style="color:#f92672">.</span>init(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># Compute edge neighbors for each edge</span>
</code></pre></div><p><strong>网格迭代器</strong>。  在网格上运行的算法通常可以用迭代器表示。  网格库提供了用于在网格实体上进行迭代的常规迭代器MeshEntityIterator，以及专用的网格迭代器VertexIterator，EdgeIterator，FaceIterator，FacetIterator和CellIterator。</p>
<p>以下代码说明了如何遍历给定网格的所有胞元的所有顶点的所有重合（连接）顶点。  如果两个顶点都属于同一个胞元，则将它们视为邻居。  对于单纯形网格，这等效于连接两个顶点的边。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (CellIterator c(mesh); <span style="color:#f92672">!</span>c.end(); <span style="color:#f92672">++</span>c)
    <span style="color:#66d9ef">for</span> (VertexIterator v0(<span style="color:#f92672">*</span>c); <span style="color:#f92672">!</span>v0.end(); <span style="color:#f92672">++</span>v0)
        <span style="color:#66d9ef">for</span> (VertexIterator v1(<span style="color:#f92672">*</span>v0); <span style="color:#f92672">!</span>v1.end(); <span style="color:#f92672">++</span>v1)
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>v1 <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
<span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> cells(mesh):
    <span style="color:#66d9ef">for</span> v0 <span style="color:#f92672">in</span> vertices(c):
        <span style="color:#66d9ef">for</span> v1 <span style="color:#f92672">in</span> vertices(v0):
            <span style="color:#66d9ef">print</span> v1
</code></pre></div><p>也可以使用通用迭代器MeshEntityIterator实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>uint D <span style="color:#f92672">=</span> mesh.topology().dim();
<span style="color:#66d9ef">for</span> (MeshEntityIterator c(mesh, D); <span style="color:#f92672">!</span>c.end(); <span style="color:#f92672">++</span>c)
    <span style="color:#66d9ef">for</span> (MeshEntityIterator v0(<span style="color:#f92672">*</span>c, <span style="color:#ae81ff">0</span>); <span style="color:#f92672">!</span>v0.end(); <span style="color:#f92672">++</span>v0)
        <span style="color:#66d9ef">for</span> (MeshEntityIterator v1(<span style="color:#f92672">*</span>v0, <span style="color:#ae81ff">0</span>); <span style="color:#f92672">!</span>v1.end(); <span style="color:#f92672">++</span>v1)
            cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>v1 <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
D <span style="color:#f92672">=</span> mesh<span style="color:#f92672">.</span>topology()<span style="color:#f92672">.</span>dim()
<span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> entities(mesh, D):
    <span style="color:#66d9ef">for</span> v0 <span style="color:#f92672">in</span> entities(c, <span style="color:#ae81ff">0</span>):
        <span style="color:#66d9ef">for</span> v1 <span style="color:#f92672">in</span> entities(v0, <span style="color:#ae81ff">0</span>):
            <span style="color:#66d9ef">print</span> v1
</code></pre></div><p><strong>网格函数</strong>。  MeshFunction类是用于存储与Mesh相关数据的有用类。  这使得存储，例如决定性参数，子域指示符，网格胞元上的细化标记或网格维面上的边界标记，变得很容易。  MeshFunction是一个离散函数，在给定拓扑维数


<span class="katex">
  \(d\)
</span>
的每个网格实体上取一个值。  存储在MeshFunction中的值的数量等于


<span class="katex">
  \(d\)
</span>
维实体


<span class="katex">
  \(n_d\)
</span>
的数量。  MeshFunction是关于值类型的模板，因此可以用于存储任何类型的值。  为了方便起见，由VertexFunction，EdgeFunction，FaceFunction，FacetFunction和CellFunction类来具体命名MeshFunction。  以下代码说明了如何创建一对MeshFunction，一个用于在胞元上存储子域指示器，另一个用于在维面上存储边界标记：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>CellFunction<span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;</span> sub_domains(mesh);
sub_domains.set_all(<span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">for</span> (CellIterator cell(mesh); <span style="color:#f92672">!</span>cell.end(); <span style="color:#f92672">++</span>cell)
{
    Point p <span style="color:#f92672">=</span> cell.midpoint();
    <span style="color:#66d9ef">if</span> (p.x() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>)
        sub_domains[cell] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
}

FacetFunction<span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;</span> boundary_markers(mesh);
boundary_markers.set_all(<span style="color:#ae81ff">0</span>);
<span style="color:#66d9ef">for</span> (FacetIterator facet(mesh); <span style="color:#f92672">!</span>facet.end(); <span style="color:#f92672">++</span>facet)
{
    Point p <span style="color:#f92672">=</span> facet.midpoint();
    <span style="color:#66d9ef">if</span> (near(p.y(), <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">||</span> near(p.y(), <span style="color:#ae81ff">1.0</span>))
        boundary_markers[facet] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
sub_domains <span style="color:#f92672">=</span> CellFunction(<span style="color:#e6db74">&#34;uint&#34;</span>, mesh)
sub_domains<span style="color:#f92672">.</span>set_all(<span style="color:#ae81ff">0</span>)
<span style="color:#66d9ef">for</span> cell <span style="color:#f92672">in</span> cells(mesh):
p <span style="color:#f92672">=</span> cell<span style="color:#f92672">.</span>midpoint()
<span style="color:#66d9ef">if</span> p<span style="color:#f92672">.</span>x() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.5</span>:
sub_domains[cell] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>

boundary_markers <span style="color:#f92672">=</span> FacetFunction(<span style="color:#e6db74">&#34;uint&#34;</span>, mesh)
boundary_markers<span style="color:#f92672">.</span>set_all(<span style="color:#ae81ff">0</span>)
<span style="color:#66d9ef">for</span> facet <span style="color:#f92672">in</span> facets(mesh):
    p <span style="color:#f92672">=</span> facet<span style="color:#f92672">.</span>midpoint()
    <span style="color:#66d9ef">if</span> near(p<span style="color:#f92672">.</span>y(), <span style="color:#ae81ff">0.0</span>) <span style="color:#f92672">or</span> near(p<span style="color:#f92672">.</span>y(), <span style="color:#ae81ff">1.0</span>):
        boundary_markers[facet] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p><strong>网格数据</strong>。  MeshData类提供了一种将数据与Mesh关联的简单方法。  它允许将任意MeshFunction（以及其他量）与Mesh关联。  以下代码说明了如何在网格上附加和检索名为“sub_domains”的MeshFunction：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>MeshFunction<span style="color:#f92672">&lt;</span>uint<span style="color:#f92672">&gt;*</span> sub_domains <span style="color:#f92672">=</span> mesh.data().create_mesh_function(<span style="color:#e6db74">&#34;sub_domains&#34;</span>);
sub_domains <span style="color:#f92672">=</span> mesh.data().mesh_function(<span style="color:#e6db74">&#34;sub_domains&#34;</span>);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>
sub_domains <span style="color:#f92672">=</span> mesh<span style="color:#f92672">.</span>data()<span style="color:#f92672">.</span>create_mesh_function(<span style="color:#e6db74">&#34;sub_domains&#34;</span>)
sub_domains <span style="color:#f92672">=</span> mesh<span style="color:#f92672">.</span>data()<span style="color:#f92672">.</span>mesh_function(<span style="color:#e6db74">&#34;sub_domains&#34;</span>)
</code></pre></div><p>要列出与给定网格相关的数据，请在C++中发出命令<code>info(mesh.data(), true)</code>或在Python中发出<code>info(mesh.data(), True)</code>。</p>
<p><strong>网格细化</strong>。  如下面的代码示例所示，可以调用<code>refine</code>函数，通过统一或局部细化来细化网格。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// C++ code
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// Uniform refinement
</span><span style="color:#75715e"></span>mesh <span style="color:#f92672">=</span> refine(mesh);

<span style="color:#75715e">// Local refinement
</span><span style="color:#75715e"></span>CellFunction<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> cell_markers(mesh);
cell_markers.set_all(false);
Point <span style="color:#a6e22e">origin</span>(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>);
<span style="color:#66d9ef">for</span> (CellIterator cell(mesh); <span style="color:#f92672">!</span>cell.end(); <span style="color:#f92672">++</span>cell)
{
    Point p <span style="color:#f92672">=</span> cell.midpoint();
    <span style="color:#66d9ef">if</span> (p.distance(origin) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.1</span>)
        cell_markers[cell] <span style="color:#f92672">=</span> true;
}
mesh <span style="color:#f92672">=</span> refine(mesh, cell_markers);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Python code</span>

<span style="color:#75715e"># Uniform refinement</span>
mesh <span style="color:#f92672">=</span> refine(mesh)

<span style="color:#75715e"># Local refinement</span>
cell_markers <span style="color:#f92672">=</span> CellFunction(<span style="color:#e6db74">&#34;bool&#34;</span>, mesh)
cell_markers<span style="color:#f92672">.</span>set_all(False)
origin <span style="color:#f92672">=</span> Point(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>)
<span style="color:#66d9ef">for</span> cell <span style="color:#f92672">in</span> cells(mesh):
    p <span style="color:#f92672">=</span> cell<span style="color:#f92672">.</span>midpoint()
    <span style="color:#66d9ef">if</span> p<span style="color:#f92672">.</span>distance(origin) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0.1</span>:
        cell_markers[cell] <span style="color:#f92672">=</span> True
mesh <span style="color:#f92672">=</span> refine(mesh, cell_markers)
</code></pre></div><p>目前，局部细化默认为按边平分进行递归细化（Rivara，1984，1992）。 图10.4中显示了通过重复标记靠近立方体一角的胞元获得的局部细化网格的示例。</p>
<p><img src="/notes/images/0241.jpg" alt="0241.jpg"></p>
<center>图10.4 通过重复标记靠近立方体一角的胞元来获得的局部细化网格。</center>
<p><strong>并行网格</strong>。 在分布式内存体系结构上并行运行程序时（通过使用mpirun包装器调用程序来使用MPI），DOLFIN会自动划分和分布网格。  然后，每个进程将全局网格一部分存储为标准网格对象。  此外，它存储辅助数据，以正确计算每个进程上的本地到全局映射以及将数据传送到相邻区域。  在10.4节中讨论了使用DOLFIN进行并行计算。</p>
<p>【<a href="/notes/docs/fem/#%e7%ac%ac%e5%8d%81%e7%ab%a0-dolfincpython%e6%9c%89%e9%99%90%e5%85%83%e5%ba%93">章节目录</a>】</p></article>

<hr>

<nav class="post-pagination">
  
  <a class="newer-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0114/">
    下一页<br>DOLFIN：C&#43;&#43;/Python有限元库》有限元/函数/表达式【翻译】
  </a>
  
  
  
  <a class="older-posts" href="https://chaoskey.gitee.io/notes/docs/fem/0112/">
      上一页<br>DOLFIN：C&#43;&#43;/Python有限元库》线性代数【翻译】
  </a>
  
</nav>

 

      <footer class="book-footer">
        
  <div class="flex justify-between">





  <div>
    <a class="flex align-center" href="https://gitee.com/chaoskey/notes/blob/master/content/docs/fem/0113.md#blob-comment" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Comment" />
      <span>评论</span>
    </a>
  </div>
  
  
  <div>
    <a class="flex align-center" href="https://gitee.com/-/ide/project/chaoskey/notes/edit/master/-/content/docs/fem/0113.md" target="_blank" rel="noopener">
      <img src="/notes/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>编辑本页</span>
    </a>
  </div>

</div>

 
        
  
  <div class="book-comments">

</div>
  
  
      </footer>
      
    </div>

    
    <aside class="book-toc">
      
  <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#1032-网格">10·3·2 网格</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>

 
    </aside>
    
  </main>

  
</body>

</html>












