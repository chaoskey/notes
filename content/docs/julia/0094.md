---
title: "有限元法解偏微分方程（FEniCS）"
date: 2020-11-13T16:27:30+08:00
draft: true
categories: ["科学计算"]
tags: ["julia","FEniCS","有限元法","偏微分方程"]
---


# 以泊松方程（第一边界条件）为例

$$
-\Delta u = f \qquad \boldsymbol{x} \in \Omega \\ u|_{\partial \Omega} =g
$$

范例而已， 本例提供的套路是通用的，大不了多看看文档。

关键的地方，我特意列出相关链接。

本文采用软件包： FEniCS。

<!--more-->

# 第1步：将问题转化成变分形式

$$
\begin{aligned}a(u,v)&=L(v) \qquad \forall v \ \text{是任意0边值的测试函数} \\ a(u,v) &\overset{\Delta}{=} \int_\Omega{\nabla u \nabla v dx} \\ L(v) &\overset{\Delta}{=} \int_\Omega{f v dx} \end{aligned}
$$

问题具体化为

$$
\begin{aligned} f(x,y)&=-6 \\  g(x,y)&=1+x^2+2y^2 \\ & \\ \Omega&=\left\{(x,y)|x^2+y^2 \le 1\right\} \end{aligned}
$$

**特别说明**：后续Julia代码涉及的变量名，完全和上面的公式一致。

# 第2步：对求解域进行刨分

这里用到了`Circle`, 更多请查阅文档：

https://bitbucket.org/fenics-project/mshr/wiki/API

也可以通过一组顶点组成的多边形来逼近更复杂的求解域，然后再对这个多边形区域进行刨分，更详细查阅文档：

https://fenicsproject.org/docs/dolfin/1.4.0/python/demo/documented/mesh-generation/python/documentation.html

这里的求解域很简单，代码如下：


```julia
using Plots
pyplot()

using FEniCS

# 求解域Ω设定
Ω = Circle(Point([0.0,0.0]),1)
mesh = generate_mesh(Ω,16)

FEniCS.Plot(mesh)
```
    
![](../images/0167.png)
    
    2-element Array{PyCall.PyObject,1}:
     PyObject <matplotlib.lines.Line2D object at 0x7f8ddf8bd7d0>
     PyObject <matplotlib.lines.Line2D object at 0x7f8ddf07d210>



# 第3步：构造基于网格的试探函数空间

这里的`试探函数空间`(`FunctionSpace`)，选择最简单的线性插值。

所谓`试探函数`(`TrialFunction`), 特指符合边界条件的函数。

所谓`测试函数`(`testFunction`), 特指0值边界条件的函数。

关于`FunctionSpace`的参数设定，具体可参见：

https://fenicsproject.org/docs/dolfin/1.3.0/python/programmers-reference/functions/functionspace/FunctionSpace.html


```julia
# 试探函数空间
# 1阶多项式插值（线性插值）
V = FunctionSpace(mesh, "P", 1)

# 函数空间V上的试探函数u
u = TrialFunction(V)

# 函数空间V上的测试函数v
v = TestFunction(V);
```

# 第4步：边界条件及参数设定

关于边界条件的设定参数，可参见：

https://fenicsproject.org/docs/dolfin/1.4.0/python/programmers-reference/cpp/fem/DirichletBC.html


```julia
# 源f(x,y)
# f = Expression('-6', degree=0)
f = Constant(-6.0)

# 边界值g(x,y)
g = Expression("1 + x[0]*x[0] + 2*x[1]*x[1]", degree=2)

#function boundary(x, on_boundary)
#    return on_boundary
#end
bc = DirichletBC(V, g, "on_boundary");
```

# 第5步：变分方程的“直译”

几乎是前面数学公式的"直译", 需要注意的是： `dx` 是预定义量，代表`体元`。


```julia
# 定义变分问题(dx是预定的)
a = dot(grad(u), grad(v))*dx
L = f*v*dx;
```

# 第6步：求解并绘图

关于求解器`solve`，参见：

https://fenicsproject.org/docs/dolfin/1.3.0/python/programmers-reference/fem/solving/solve.html

但是在 `FEniCS.jl`中，分成了3个求解器（都是对fenics.solve的封装）：

https://github.com/SciML/FEniCS.jl/blob/master/src/jsolve.jl

1. 线性求解器: `solve`

2. 线性变分求解器： `lvsolve`   (本例所采用)

3. 非线性变分求解器： `nlvsolve`

至于`FeFunction`, 其实就是`fenics.Function`的封装：

- `FeFunction(V) = fenics.Function(V.pyobject)`


```julia
# 求解
u = FeFunction(V)  
lvsolve(a,L,u,bc)  

FEniCS.Plot(u)
FEniCS.Plot(mesh)
```
    
![](../images/0168.png)


    Solving linear variational problem.

    2-element Array{PyCall.PyObject,1}:
     PyObject <matplotlib.lines.Line2D object at 0x7f8dde997910>
     PyObject <matplotlib.lines.Line2D object at 0x7f8dde997d10>

# 第7步：误差估计及其它


```julia
errornorm(g, u, norm="L2")
```

    *** Warning: Degree of exact solution may be inadequate for accurate result in errornorm.

    0.00444692071683997

将结果导出到vtk文件


```julia
vtkfile = File("poisson/solution.pvd")
vtkfile << u.pyobject;  #exports the solution to a vtkfile
```

查看结果数据


```julia
get_array(u)
```

    549-element Array{Float64,1}:
     2.647985350348445
     2.593690657292863
     2.4339075463156465
     2.712889645782536
     2.3863642443300686
     2.1981490620535595
     2.1831070985479455
     2.4655691189520748
     2.7609431348948275
     2.5253575052502386
     2.302218396526692
     2.4686047402353437
     2.02311867450322
     ⋮
     2.261621580085735
     2.123167515460912
     2.1160030006867037
     2.2820357294253473
     2.2320866025105017
     2.176630600748635
     2.0517861914831785
     2.5936906572928624
     2.5253575052502386
     2.4686047402353433
     2.4007647581013947
     2.3454915028125263


```julia
get_array(L)
```

    549-element Array{Float64,1}:
     -0.008392858025463551
     -0.012741198169921803
     -0.03848341879718738
     -0.017021315622294253
     -0.021713729039878175
     -0.029478923777970935
     -0.034026820619627716
     -0.05088852534524327
     -0.010367182346204592
     -0.012795005024268308
     -0.03279137223347792
     -0.01886029858177263
     -0.03511674100815843
      ⋮
     -0.03518098596470059
     -0.05109509635843975
     -0.03749738775294356
     -0.017169860628274095
     -0.011672524611234077
     -0.02066343674380304
     -0.025837631199883776
     -0.009153818009571206
     -0.015390575536917694
     -0.01947350394238706
     -0.020102668008156164
     -0.010131473054162399


