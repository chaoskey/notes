'use strict';(function(){const b={encode:!1,tokenize:function(a){return a.replace(/[\x00-\x7F]/g,'').split('')}};b.doc={id:'id',field:['title','content'],store:['title','href']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/notes/posts/',title:"Posts\\",content:""}),a.add({id:1,href:'/notes/categories/',title:"分类",content:""}),a.add({id:2,href:'/notes/tags/git/',title:"git",content:""}),a.add({id:3,href:'/notes/tags/',title:"标签",content:""}),a.add({id:4,href:'/notes/tags/termux/',title:"termux",content:""}),a.add({id:5,href:'/notes/posts/%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E4%B8%8A%E7%9A%84Git%E6%9C%8D%E5%8A%A1%E5%99%A8/',title:"安卓手机上的Git服务器",content:"缘由 今天，收到阿里云的密钥泄露通知短信：密钥被公开到Github代码库中。　可我明明是私有库呀！！　吓得我立刻将Github和Gitee的私有库删除，　私有库不安全呀。\n通过一番网上搜索，我选择了用手机充当Git服务器的方案，对私有库而言，好处就不用我多说了。\n此外，此方案具有一般性，本文仅仅以Ｇｉｔ为例，其实完全可以充当其他特定功能的服务器。\n第一步：安装安卓终端模拟器Termux 官网下载：https://termux.com/　，然后安装到手机。\n 可以选择：F-Droid下载，但无需下载F-Droid，后面有termux的直接下载链接。\n 第二步：Termux 镜像设置 清华源：https://mirrors.tuna.tsinghua.edu.cn/help/termux/\n# 手机上termux中执行 sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main@\u0026#39; $PREFIX/etc/apt/sources.list sed -i \u0026#39;s@^\\(deb.*games stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/game-packages-24 games stable@\u0026#39; $PREFIX/etc/apt/sources.list.d/game.list sed -i \u0026#39;s@^\\(deb.*science stable\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/science-packages-24 science stable@\u0026#39; $PREFIX/etc/apt/sources.list.d/science.list apt update \u0026amp;\u0026amp; apt upgrade 第三步：安装Git及必要软件 # 手机上termux中执行 pkg install git openssh vim termux-auth 第四步：访问外置SD卡或内部存储授权 # 手机上termux中执行 termux-setup-storage 说明：　这个命令会在home目录下，生成一个storage目录（如图），此目录中的子目录external-1对应外置SD卡中的一个特定目录。就我的手机而言， 这个特定目录是：　外置SD卡/Android/data/com.termux/files/。　然后，在home目录，创建软链接指向你外置SD卡中的Git库。【避免路径过长】\n第五步：手机Git的服务仓库 # 创建Git服务仓库（建议外置存储卡上，具体位置参考第四步的图） git init --bare private.git # 在home目录中，创建目录软链接 ln -s \u0026lt;全路径\u0026gt;/private.git private.git 第六步：配置sshd服务 PC 端生成公私钥，\n# PC中执行 ssh-keygen 把生成的公钥~\\.ssh\\id_rsa.pub 拷贝到手机的~\\.ssh 文件夹中。然后，\n# 手机上termux中执行 cat id_rsa.pub \u0026gt; authorized_keys # 修改为：PasswordAuthentication no vim $PREFIX/etc/ssh/sshd_config 获取必要的信息\n# 查看用户名（记住） whoami # 查看ip地址（记住） ifconfig 第七步：sshd服务启动、停止 # 指定端口启动 sshd -p 9876 # 停止 ssh 服务，只需要 kill 杀掉进程即可 pkill sshd # 查看sshd的日志 logcat -s \u0026#39;syslog:*\u0026#39; 第八步：在ＰＣ端克隆 # u0_a133 前面查询到的用户名 # 192.168.1.102 前面查询到的ip # 9876 前面指定的端口 # ~ 代表手机termux中的home目录 git clone ssh://u0_a133@192.168.1.102:9876/~/private.git 写在后面  为安全起见，建议临时用临时启动sshd。 IP可能会变，clone \u0026amp; pull \u0026amp; push 前可能要修改Git客户端配置。 可以从ＰＣ登陆手机终端  # 如下图 ssh u0_a133@192.168.1.102 -p 9876 "}),a.add({id:6,href:'/notes/categories/%E6%9D%82%E4%BA%8B/',title:"杂事",content:""}),a.add({id:7,href:'/notes/',title:"索引",content:" 杂事记录 \n 用Hugo+码云搭建支持Markdown+LaTeX的云笔记 通过实例掌握流编辑器sed 小技巧备忘    基于Obsidian＋Hugo＋Gitee的笔记系统 给家中长辈的电脑打字方案 我用一个下午掌握小鹤双拼 安卓手机上的Git服务器     《有限元法自动求解微分方程》【翻译】 \n 第二章 有限元方法 第三章 常见有限元 第四章 构造通用参考单元 第五章 有限元变分形式 第六章 有限元组装 第七章 有限元变分形式的正交表示 第八章 有限元变分形式的张量表示    第九章 有限元矩阵计算的离散优化 第十章 DOLFIN：C＋＋／Python有限元库 第十七章 UFL：有限元形式语言 第十八章 Unicorn：统一的连续介质力学求解器 第二十章 不可压缩流体的有限元     基于Julia科学计算 \n 1. 整合Julia和Python的集成环境（Win10） 2. 科学计算环境搭建（Win10+WSL2+Ubuntu） 3. Julia中的数学符号演算 4. 基于Julia的科学计算功能库整理 5. 微分几何中的计算 6. 平面三体问题    7. 有限差分法求解一维热传导方程 8. Galerkin法解常微分方程边值问题 9. 有限元法解常微分方程边值问题 10. 有限元之平面三角单元 11. 有限元之Delaunay三角剖分 12. 有限元法解偏微分方程（FEniCS） 13. 有限元法求解牛顿流体（FEniCS）     理论物理学习笔记 \n 1. 流形上的拉格朗日力学 2. 流形视角下的牛顿力学 3. 对称性与守恒律（Noether定理） 4. 辛流形上的哈密顿力学    5. 闵氏时空对称性的三种观点 6. 场及其对称性 7. 庞加莱群的单粒子态的表示     微分几何笔记 \n 1. 基于抽象指标的张量分析 2. 流形上的导数算符 3. 流形上的平移 4. 黎曼曲率张量 5. 流形间的映射 6. 流形上的李导数 7. Killing矢量场 8. 子流形和超曲面 9. 流形上的微分形式及其对偶 10. 流形上的微积分 11. 李群李代数 12. 常用李群及其李代数 13. 李变换群 14. 微分几何中的计算（Julia版）    15. 辛群及其李代数 16. 辛流形 17. 流形上的旋量和旋量场（初步） 18. 流形上的旋量和旋量场（几何解释） 19. 流形上的旋量和旋量场（导数算符和曲率) 20. 流形上的旋量和旋量场（自旋系数和克氏符） 21. 李群李代数伴随表示和Killing型、Casimir算符 22. 半单李代数的标准形式 23. 半单李代数的根系、权系和Dynkin图 24. 半单李代数的Casimir不变算符     机器学习：概率视角 \n 第一章 导论 第二章 概率 第三章 基于离散数据的生成式模型 第四章 高斯模型    第五章 贝叶斯统计 第六章 频率派统计 第七章 线性回归     主动投资组合管理 \n 第一章 绪论 第二章 一致预期收益率：资本资产定价模型 第三章 风险 第四章 超常收益率、业绩基准和附加值    第五章 残差风险和残差收益率：信息率 第六章 主动管理基本定律 第七章 预期收益率和套利定价理论 第八章 估值理论     "}),a.add({id:8,href:'/notes/docs/',title:"Docs",content:""}),a.add({id:9,href:'/notes/tags/FEniCS/',title:"FEniCS",content:""}),a.add({id:10,href:'/notes/docs/fem/0127/',title:"不可压缩流体的有限元【翻译】",content:"【章节目录】\n有限元方法的结构为用户提供了一个选择范围。 对于解决不可压缩的流体问题尤其如此，因为理论上指出了许多稳定的有限元公式。 我们使用自动化工具来实现和检查稳态Stokes方程的各种稳定公式。 事实证明，FEniCS项目组件的表达能力使Stokes问题的求解器可以轻松创建使用各种单元公式。\n20·1 Stokes方程 Stokes方程描述了稳定的不可压缩的低雷诺数流体。 对于域   \\(\\Omega\\subset\\mathbb{R}^d\\quad 1\\le d \\le 3\\)  ，Stokes方程读着：\n\\[ -\\Delta u + \\nabla p = f \\qquad in\\ \\Omega \\tag{20.1} \\]  \\[ \\nabla \\cdot u = 0 \\qquad in\\ \\Omega \\tag{20.2} \\]  \\[ u = 0 \\qquad on\\ \\partial \\Omega \\tag{20.3} \\]  其中， \\(u:\\Omega \\to \\mathbb{R}^d\\)  是速度场， \\(p:\\Omega \\to \\mathbb{R}\\)  是压力场， \\(f:\\Omega \\to \\mathbb{R}^d\\)  是源项。\n在开发用于求解Stokes方程的变分公式时，可能是在无散度的函数空间中搜索（20.1）的变分公式的解，从而通过构造满足（20.2）。 但是，这并不能很好地转换为有限元公式。或者，可以考虑一个混合变分公式如下。令 \\(V = [H_0^1(\\Omega)]^d\\)  和 \\(\\Pi = \\{q\\in L^2(\\Omega) : \\int_{\\Omega}q dx = 0\\}\\)  。 给定 \\(f\\in [L^2(\\Omega)]^d\\)  ，寻求函数 \\(u\\in V\\)  和 \\(p\\in\\Pi\\)  ，满足：\n\\[ a(u, v) − b(v, p) = ( f , v) \\qquad \\forall v \\in V \\tag{20.4} \\]  \\[ b(u, q) = 0 \\qquad \\forall q \\in \\Pi \\tag{20.5} \\]  其中\n\\[ a(u, v) := \\int_{\\Omega} \\nabla u \\cdot \\nabla v dx \\tag{20.6} \\]  \\[ b(v, q) := \\int_{\\Omega}(\\nabla \\cdot v) q dx \\tag{20.7} \\]  \\[ ( f , v) := \\int_{\\Omega} f \\cdot v dx \\tag{20.8} \\]  20·2 混合Stokes问题的有限元公式 在本节中，我们将考虑寻求（20.4）-（20.5）混合公式的近似解所对应的有限元公式。 在有限元方法的背景下，Stokes问题得到了广泛的研究，Brezzi和Fortin（1991）以及Brenner和Scott（2008）提出了一些关键结果。 这在许多方面都是一个具有挑战性的问题。 首先，必须仔细选择V和Π的有限元子空间，以确保所得有限元问题的稳定性。其次，混合变分形式是一个鞍点问题，这导致了不定矩阵方程。 这样的系统在迭代线性求解器上特别费力。 此外，质量守恒要求速度场无散度。 很少有方案可以逐点满足此条件。 施加此条件的程度取决于特定的方案。\n用于Stokes方程的稳定的混合有限元方法必须满足Ladyzhenskaya–Babuška–Brezzi（LBB）（或inf–sup）的相容性条件（有关更多详细信息，请参阅Brezzi和Fortin（1991））。 最直接的方案-压力和速度分量均等的连续拉格朗日有限元空间-导致不稳定的问题。 此外，混合单元公式可以表现出“锁定”类型，在实践中有时可以通过对 \\(b(v, q)\\)  型项使用不精确的正交来弥补（Engelman等，1982）。 这已经被认为等同于改变压力空间。 在这里，我们采用现代的观点，并使用已知满足LBB条件的速度和压力空间。\n避免Stokes问题鞍点性质相关难题的方法是，通过用涉及压力的项来扩充连续性方程，以修正离散变分问题。 通过适当解决离散问题，可以证明等阶公式的稳定性（Hughes等，1986）。 仔细的修改会导致不会破坏一致性的离散问题。\n很少有涉及多个有限元公式的关于Stokes问题的数值研究。 这可以归因于许多难以实施的已知稳定方法。 借助自动代码生成，可以轻松生成用于多种方法的求解器； 它就像重新定义有限元素空间或修改变分公式一样简单。 在本节的其余部分，我们将说明Stokes方程混合形式的各种稳定有限元求解器的构造。\n20·2·1 基于兼容函数空间的公式 我们考虑了许多LBB稳定的公式，这些公式都是基于速度和压力场的兼容函数空间的选择。 图20.1给出了大多数这些公式的通用UFL输入。 按照UFL约定，双线性和线性形式分别命名为a和L。 通过速度的单元类型（U_element），速度的基函数阶次（U_order），压力的单元类型（P_element）和压力的基函数阶次（P_order），定义出不同的有限元空间。 从图20.1的输入中，FFC生成用于数值模拟的特定问题代码。\n图20.1 混合Stokes问题的通用UFL输入。 Stokes方程式中使用最广泛的有限元族之一是Taylor–Hood族（Taylor and Hood，1973; Boffi，1997）。 它由用于速度分量的连续 \\(P_q (q \\ge 2)\\)  拉格朗日单元和用于压力场的连续 \\(P_{q−1}\\)  拉格朗日单元组成（对于q = 3，请参见图20.2）。 压力收敛的阶次低于速度的阶次。 对于图20.1中的UFL提取，Taylor-Hood单元对应于P_element = Lagrange，U_order = q，P_element = Lagrange和P_order = q-1。\n图20.2 Taylor–Hood单元具有（a）三次速度基底和（b）二次压力基底。 Crouzeix–Raviart单元（Crouzeix和Raviart，1973年）是一种不符合的单元，它使用胞元边上的积分矩作为速度的基底，并且不连续的压力空间要比速度空间低一个级次。 对于最低阶情况，速度边矩等效于每个边中点的拉格朗日基函数的求值，压力使用 \\(P_0\\)  （见图20.3）。 对于图20.1中的提取，Crouzeix–Raviart单元对应于U_element = CR，U_order = 1，P_element = DiscontinuousLagrange和P_order = 0。\n图20.3 Crouzeix–Raviart单元用于速度场。 MINI单元（Arnold等，1984b）通过气泡函数 \\(P_q + B_{q + 3}\\)  增强速度空间。 MINI单元如图20.4所示。 压力空间使用连续的 \\(P_q\\)  拉格朗日单元。 有人建议将MINI单元替换为更廉价的Taylor-Hood单元。 MINI单元是使用来自UFL的“单元增强”概念来实现的。 MINI函数空间的UFL定义如图20.5所示。 在写此内容时，仅适用于 \\(q = 1, 2\\)  。\n图20.4 用于速度场的MINI单元。 它使用 \\(q + 3\\)  阶气泡函数增强了 \\(P_q\\)  单元。 图20.5 定义MINI元素速度空间的UFL输入。 另一种可能性是对速度分量使用高阶连续拉格朗日有限元基底，而对压力场使用的不连续单元则要低两阶。 对于连续速度/不连续压力，我们将这个单元简称为“CD”。 Brezzi和Fortin（1991）讨论了P2-P0的情况，Maday等人（1992）则中分析了高阶版本。 对于图20.1中的提取，CD单元对应于U_element = Lagrange，U_order = q，P_element = DiscontinuousLagrange和P_order = q-2。\n表20.1总结了图20.1所示UFL代码中针对所介绍的不同方法的特定变量。\n表20.1 定义不同混合方法的单元变量。 20·2·2 压力稳定法 为了减轻查找LBB兼容函数空间的困难，可以使用稳定化技术。 压力稳定将有限维公式从鞍点问题转换为强制问题。 通常希望修改有限维问题，以免破坏一致性。 有关更完整的讨论，请参见Donea和Huerta（2003）。 我们考虑的压力稳定方法涉及：\n\\[ a(u, v) − b(v, p) = ( f , v)\\qquad \\forall v \\in V_h \\tag{20.9} \\]  \\[ b(u, q) + (\\delta \\nabla q, \\nabla p) = ( f , \\delta \\nabla q)\\qquad \\forall q \\in \\Pi_h \\tag{20.10} \\]  其中， \\(\\delta\\)  是一个稳定参数，而 \\(V_h\\subset V\\)  和 \\(\\Pi_h \\subset\\Pi\\)  是合适的有限元空间。 对于我们的测试， \\(\\delta= 0.2 h^2_T\\)  ，其中 \\(h_T\\)  是胞元 \\(T\\)  周长的两倍。 对于稳定化测试，对压力和速度空间使用相同阶次的连续拉格朗日单元。 该方法称为“ STAB”。 我们采用的稳定方法很简单，但确实违反了阶次 \\(q1\\)  的一致性。 图20.6说明了将稳定项添加到图20.1中的标准弱形式中。 表20.1包含了STAB单元的定义。\n图20.6 UFL代码为图20.1中的混合方法代码增加了稳定性。 20·3 惩罚方法：Scott–Vogelius方法 处理LBB条件的其他解决方案包括Uzawa迭代方法和惩罚方法。 这两种方法的结合导致了Scott和Vogelius（1985）中提出的迭代惩罚方法。 令 \\(r\\in\\mathbb{R}\\)  和 \\(\\rho\\in\\mathbb{R}^{+}\\)  为规定参数。 我们希望寻求 \\(u_n\\in V_h\\)  以满足\n\\[ a(u^n, v) + r(\\nabla \\cdot u^n, \\nabla \\cdot v) = ( f , v) − (\\nabla \\cdot v, \\nabla \\cdot w^n)\\qquad \\forall v \\in V_h \\tag{20.11} \\]  其中\n\\[ w^{n+1} = w^n + \\rho u^n \\tag{20.12} \\]  可以通过 \\(p =\\nabla\\cdot w-C\\)  用辅助场 \\(w\\)  来表示压力，其中 \\(C\\)  是任意常数（因为压力场只能确定相差任意一个常数）。 在计算 \\(p\\)  中的误差时，我们减去 \\(\\nabla\\cdot w\\)  的平均值，以计入 \\(C\\)  。 该算法最初假定 \\(w_0 = 0\\)  ，然后求解（20.11）并通过（20.12）更新 \\(w\\)  。 重复该过程，直到 \\(\\|u^{n + 1} -u^n\\| ，其中 \\(\\epsilon\\)  是规定的公差。 该方法仅涉及一个函数空间，但是它需要一个高阶连续单元（ \\(q\\ge 4\\)  ），并且可以精确地解决无散度准则。 迭代次数和精度取决于惩罚参数 \\(\\rho\\)  和 \\(r\\)  。 对于我们的实验，我们使用 \\(\\rho= −r = 1\\times 10^3\\)  。 此公式的实现如图20.7所示。\n图20.7 DOLFIN代码，用于定义Scott-Vogelius方法。 20·4 数值测试 为了评估提出的方法，我们将计算结果与针对不同网格细化和单元阶次所制造的解进行比较。 所有模拟都使用FEniCS工具通过UMFPACK LU求解器（来自SuiteSparse软件包v3.4）来生成离散问题（FFC v0.7.0，DOLFIN v0.9.4，UFL v0.4.0，UFC v1.2.0）。 对于应用于Stokes问题的迭代方法，请参阅第35章和Elman等（2005）。 表20.2给出了所考虑情况下自由度数与网格尺寸和单元类型的函数。\n表20.2 比较由速度阶数（q）和每个维度（n）的网格划分数组成的自由度数。 “-”表示该特定单元阶次不稳定； “ x”表示当前尚未实现。 20·4·1 模拟设置 对于我们的测试，我们使用具有交叉三角形图案的n×n单位正方形网格，如图20.8a所示。 应该注意的是，网格的选择可能会以令人惊讶的方式影响收敛结果，例如避免锁定现象（Nagtegaal等，1974）或杂散压力模式（Malkus，2000）。 交叉的三角形网格用作我们的测试案例，以避免与网格构造有关的细微问题（请参阅Brezzi和Fortin（1991年，建议6.1，第VI.6节））。 此外，由于我们从一开始就使用稳定单元，因此我们不关心锁定现象。 为了进行比较，请在非交叉网格上使用带有杂散压力模式校正的网格，请参见Terrel等（2008）。\n图20.8 测试网格和解绘制。 作为第一个测试用例，我们使用以下Stokes方程的解析解：\n\\[ f = \\begin{bmatrix}−28\\pi^2\\sin(4\\pi x) \\cos(4\\pi y) \\\\ -36\\pi^2 \\cos(4\\pi x) \\sin(4\\pi y)\\end{bmatrix} \\tag{20.13} \\]  \\[ u = \\begin{bmatrix}−\\sin(4\\pi x) \\cos(4\\pi y) \\\\ \\cos(4\\pi x) \\sin(4\\pi y)\\end{bmatrix} \\tag{20.14} \\]  \\[ p = \\pi \\cos(4\\pi x) \\cos(4\\pi y) \\tag{20.15} \\]  我们还考虑了在顶部具有二次驱动功能的盖驱动腔问题（见图20.8b和20.8c）。\n图20.9和20.10显示了所考虑的问题的DOLFIN Python代码。 为了从分析测试问题变为盖驱动腔，只需要改变边界条件函数和右侧 \\(f\\)  。 只能由一个任意常数决定的压力场在一个压力自由度为零的情况下被“钉住”。 给定网格和定义的变分问题之一，DOLFIN将使用FFC和FIAT自动生成必要的计算机代码，从而允许使用一个脚本来测试所有方法。在根据功能规范计算分析测试用例的误差时，使用10阶的拉格朗日单元来插值精确解。 计算误差的代码如图20.11所示。\n图20.9 用于定义测试域的DOLFIN代码。 图20.10 DOLFIN代码，用于定义盖驱动腔域。 图20.11 DOLFIN代码，用于计算 \\(L^2\\)  范数中的误差。 精确解使用胞元上的10阶拉格朗日多项式进行插值。 20·4·2 结果 表20.3给出了在每种情况下，分析方法在速度场的L2范数中观测到的收敛速度，这是根据n在{8、16、32、64}中的一系列网格细化计算得出的。除CD单元外，所有公式均可观察到的最佳速率为q+1。 由于差的压力近似和不能满足LBB条件，CD单元失去了一个收敛阶。\n表20.3 计算速度收敛速度的指数； 就是， \\(q\\)  在 \\(O(h^q)\\)  中，其中h是网格单元的宽度。 对于不同的单元，此误差使用 \\(L^2\\)  ，其中 \\(q = p + 1\\)  是最优误差率，其中p是速度场的阶次。 请注意，如理论上所预期的，CD方法失去收敛阶数，而MINI单元在二阶情况下效果不佳。 要进一步比较的方法中，一些用于与适当选择的压力空间的四阶速度空间的情况下，给出了误差和性能度量。 使用分析测试用例。 Crouzeix–Raviart和MINI单元仅适用于低阶基底。 为了进行比较，它们是在一个细网格上计算的，该细网格的自由度与四阶Taylor–Hood单元具有相似的自由度。 图20.12比较了不同方法的速度 \\(L^2\\)  误差。 对所有的单元，速度近似似乎都是收敛的。 压力的 \\(L^2\\)  误差如图20.13所示。 对于CD单元，观察到压力的不可预测行为，而对于其他方法，观察到压力场的收敛。图20.14给出了速度场散度的 \\(L^2\\)  范数。 正如理论所预测的，对于所有网格，在机器精度以内，Crouzeix–Raviart和Scott–Vogelius方法的散度误差为零。 MINI单元的散度误差比其他方法大得多。 图20.15给出了各种四阶情况的运行时间。 使用2.6 GHz Intel Xeon，在所有运行时，都可以使用Python代码测量组装和线性系统求解时间。 假定代码生成所需的时间可以忽略不计，因为生成的代码已缓存，并且仅影响第一次仿真的时间； 我们的时间总是来自第二次仿真。 混合单元的运行时间随自由度的数量而定。 Scott-Vogelius方法对于迭代求解器具有更好的性质，因此，尽管相对于测试小问题的其他方法而言，运行时间更长，但它对于大规模问题可能具有吸引力。\n图20.12 分析测试用例的速度误差。 图20.13 分析测试用例的压力误差。 图20.14 分析测试用例的散度误差。 图20.15 分析测试用例的运行时。 除Crouzeix-Raviart和MINI以外，所有速度空间均为四阶，压力空间由该方法确定。Crouzeix–Raviart和MINI是在细网格上计算的，其自由度与四阶Taylor–Hood方法相似。 CR，TH和SV分别指Crouzeix–Raviart，Taylor–Hood和Scott–Vogelius。 图20.16显示了盖驱动腔问题的速度散度的 \\(L^2\\)  范数。 与已经考虑过的平滑测试用例不同，CD，MINI，STAB和Taylor-Hood单元的散度误差不会随着网格细化而减小。 在盖角上的压力奇异点周围仍然存在散度误差，如图20.17中的Taylor-Hood情况所示。 为了用Scott-Vogelius方法解决盖驱动腔问题，必须将惩罚参数增加到1×108，以使固定点迭代收敛。\n图20.16 盖驱动腔测试问题的散度误差。 图20.17 使用P2-P1 Taylor-Hood单元的盖驱动腔中的局部散度误差。尤其要注意在盖子角落处的较大误差。 20·5 结论 提出了Stokes问题的不同有限元之间的比较。 通过自动生成各种方法的求解器，已经证明了自动代码生成提供的灵活性。 在所有情况下观察到的收敛速度与先验估计一致。 在所检查过的单元中，Crouzeix-Raviart单元和Scott-Vogelius导致的散度误差最小，而Taylor-Hood的速度误差最小。 如果质量守恒特性不是至关重要的，那么Taylor–Hood或STAB等单元的简单性就很有吸引力。\n【章节目录】\n"}),a.add({id:11,href:'/notes/tags/%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/',title:"偏微分方程",content:""}),a.add({id:12,href:'/notes/tags/%E6%9C%89%E9%99%90%E5%85%83%E6%B3%95/',title:"有限元法",content:""}),a.add({id:13,href:'/notes/categories/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/',title:"科学计算",content:""}),a.add({id:14,href:'/notes/tags/%E5%8F%8C%E6%8B%BC/',title:"双拼",content:""}),a.add({id:15,href:'/notes/tags/%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/',title:"小鹤双拼",content:""}),a.add({id:16,href:'/notes/posts/%E6%88%91%E7%94%A8%E4%B8%80%E4%B8%AA%E4%B8%8B%E5%8D%88%E6%8E%8C%E6%8F%A1%E5%B0%8F%E9%B9%A4%E5%8F%8C%E6%8B%BC/',title:"我用一个下午掌握小鹤双拼",content:"昨天，我决定全拼转向双拼，选择了“小鹤双拼”方案。\n今天，我简要描述了要点总结和个人体验！\n要点总结 1） 双拼 = 声母 + 韵母。 每个部分敲一个字母即可，故为“双拼”。\n2）如果有声母：声母同字母键位，例外sh、ch、zh见图红框部分。\n3）如果没声母：双字母音节保持全拼方式，一三字母音节为首字母加韵母所在键。\n4）韵母口诀：见图。\n个人体验 口诀的作用仅仅辅助作用，关键是反复练习。\n练习两三个小时后，你会发现口诀会慢慢从你脑海中消失，取而代之的是：想到韵母就想到字母键位。\n万一有时，看到韵母还是想不到字母键位的话，你就再看一眼“韵母口诀图”。\n如此反复，不需要很长时间就可以掌握。\n我所谓的“掌握”： 不需要再看“韵母口诀图”，甚至“口诀从你脑海中消失了”， 想到韵母就想到字母键位。\n当然，“掌握” 不代表“熟练”。 我目前自认为“掌握” 了，但打字速度还没全拼快，这只能交给时间和练习了。\n"}),a.add({id:17,href:'/notes/tags/%E8%BE%93%E5%85%A5%E6%B3%95/',title:"输入法",content:""}),a.add({id:18,href:'/notes/posts/%E7%BB%99%E5%AE%B6%E4%B8%AD%E9%95%BF%E8%BE%88%E7%9A%84%E7%94%B5%E8%84%91%E6%89%93%E5%AD%97%E6%96%B9%E6%A1%88/',title:"给家中长辈的电脑打字方案",content:"前提条件：1）老人会用智能手机。 2）老会基本的电脑操作，就是不会打字。 3） 当然也不会拼音。\n老人普通话标准：语音跨屏输入 只需要有一款支持跨屏输入的输入法。 【吐槽：为何目前的跨屏输入只支持语音跨屏输入？不支持手写跨屏输入？ 如果支持，就没有此文了。】\n支持跨屏输入的输入法，目前不少了！ 我试用过两款： \u0026ldquo;讯飞输入法\u0026rdquo;，\u0026ldquo;搜狗输入法\u0026rdquo;。 当然PC端和手机端都要安装同款输入法啊。\n我个人推荐: \u0026ldquo;讯飞输入法\u0026rdquo;。\n安装配置好后的使用门槛： 老人会扫码，会普通话即可。\n老人普通话不标准：手写跨屏输入 只能使用“手写输入”， 于是找一款可以手机远程控制电脑的软件是唯一的选择了。\n我试用过很多“手机远程控制电脑的软件”， 使用都不方便。【注意：最终使用者是老人。】\n最后，我找到一款配置好后，非常适合老人使用的软件: Unified Remote\n安装配置好后的使用门槛： 老人会手机手写输入即可。\n"}),a.add({id:19,href:'/notes/tags/%E9%95%BF%E8%BE%88/',title:"长辈",content:""}),a.add({id:20,href:'/notes/docs/fem/0126/',title:"Unicorn：统一的连续介质力学求解器（下）【翻译】",content:"【章节目录】\n18·5 解决连续介质力学问题 在本节中，我们介绍一些使用Unicorn计算的示例。 第一个例子是没有自适应性的流固耦合问题，我们讨论了几何和子域的建模，系数（形式中使用的函数），主程序的参数和规范（运行求解器的接口）。 接下来，我们给出一个用自适应性解决湍流纯流体问题的示例，其中我们涵盖了对偶问题的数据建模，自适应回路，并指定了用于建模湍流边界层的滑移/摩擦边界条件。\n我们在这里介绍了问题实现的示例性片段。 有关完整的详细信息，请参见Unicorn源代码分发。\n18·5·1 流固耦合 我们在这里给出解决流固连续介质力学问题的用例，其中用户指定了用于建模问题的数据，并描述了接口和预期结果。 问题在于（Hron和Turek，2005年）给出的FLUSTRUK-A变体3基准，并在（Hoffman等人，2011年）以及第28章中用作Unicorn的验证。 在时间   \\(t = 1\\)  和 \\(t = 5.5\\)  时，速度场和相函数 \\(\\theta\\)  绘制在图18.16中。 完整示例可以在Unicorn发行版unicorn-0.1.3-hpc/ucsolver/fsi/cylinder2D/下找到。\n图18.16 对于FSI基准和用例，时间 \\(t = 1\\)  和 \\(t = 5.5\\)  的速度和相函数（带有网格）。 在具有12个核（5415个网格点）的分布式网格上并行计算的解决方案。 我们将用例分为四个部分：\n几何和子域\n用户指定可能的几何参数并定义子域。 我们注意到，对于复杂的几何，用户可以省略几何信息，并将子域标记指定为数据文件。\n系数\n声明了已知的系数（在形式中出现的函数），例如力函数和边界条件。\n参数\n在参数文件中给出了指定材料属性和数值公差的简单参数。\n主程序\n用户实现主程序，并声明数据并将其传递给求解器。\n这四个部分通过图18.18–18.21中显示的代码示例展示。\n18·5·2 自适应性 我们继续用一个纯流体湍流问题自适应解的用例：环绕3维立方体的流动，该立方体对应于第28章中给出的立方体问题描述。 该解的快照可以在图18.17中看到。 完整示例可在Unicorn发行版的unicorn-0.1.3-hpc/ucsolver/icns/cube/下找到。\n图18.17 环绕立方体流动：最细的网格的速度（上部）和压力（下部）的快照。 图18.18 Unicorn求解器FSI用例的第1部分：几何和子域。 图18.19 Unicorn求解器FSI用例的第2部分：系数。 图18.20 FSI用例的第3部分：参数文件 图18.21 FSI用例的第4部分：主程序的结构，将数据传递到求解器。 问题的实现与流固的情况非常相似（仅使用纯流体数据），但有3个重要的补充：\n对偶问题\n为了计算自适应算法所需的误差估计，我们必须求解由原始问题产生的对偶问题和输出量 \\(\\psi\\)  。 由于对偶问题在形式上与原始问题相似，因此我们将两者都实现为同一求解器的变体。 在这种情况下，我们对计算阻力感兴趣，将 \\(\\psi\\)  作为对偶问题的边界条件：\n自适应回路\n我们指定一个solve()函数，该函数计算自适应循环的一次迭代：求解原始问题，求解对偶问题，计算误差估计并检查是否满足公差并计算自适应网格。 此函数在unicorn_solve()函数中的自适应循环中被调用。\nclass Dual_BC_Momentum : public Function { public: Dual_BC_Momentum(Mesh\u0026amp; mesh) : Function(mesh) {} void eval(real* values, const real* x) const { values[0] = -1.0; values[1] = 0.0; values[2] = 0.0; } }; solve() { // Boundary condition for dual problem  CubeBoundary cb; Dual_BC_Momentum dual_bcf_mom(mesh); DirichletBC dual_bc0(dual_bcf_mom, mesh, cb); Array \u0026lt;BoundaryCondition*\u0026gt; dual_bc_mom; dual_bc_mom.push_back(\u0026amp;dual_bc0); ... // Solve primal problem  NSESolver primal_solver(mesh, node_normal, f, beta, aero_f, primal_bc_mom, primal_bc_con, chkp, w_limit, td, \u0026#34;primal\u0026#34;); primal_solver.solve(); // Solve dual problem (gives weight for error estimate)  NSESolver dual_solver(mesh, node_normal, f, beta, aero_f, dual_bc_mom, dual_bc_con, chkp, w_limit, td, \u0026#34;dual\u0026#34;); dual_solver.solve(); } 滑移边界条件\n对于湍流，我们将边界层建模为摩擦边界条件。 我们将法向分量指定为与常规Dirichlet边界条件相同的强滑动边界条件。\nNodeNormal node_normal(mesh); SlipBoundary sb; SlipBC slip_bc(mesh, sb, node_normal); Array \u0026lt;BoundaryCondition*\u0026gt; primal_bc_mom; primal_bc_mom.push_back(\u0026amp;slip_bc); 18·5·3 Unicorn-HPC安装和基本测试 Unicorn-HPC是Unicorn的高性能计算分支，并且是积极开发的分支。 与本书各章相对应的版本是“ Unicorn 0.1.3-hpc”。 对于以前发表的文章中引用的模拟和绘图，我们参考该特定文章以获取软件详细信息。 当前，Unicorn的MAdLib网格自适应接口仅在不再维护的Unicorn串行分支中可用，我们在Live DVD unicorn_fenics-book.iso中提供了该分支，可通过以下任一方式获得 http://www.csc.kth.se/ctl or http://fenicsproject.org.\n要验证Unicorn-HPC的正确安装和功能，请遵循Unicorn-HPC发行版中“测试”下自述文件中的步骤。 该测试代表了第28章及更高版本中描述的环绕立方体模拟的湍流。\n18·6 致谢 我们感谢以下公司对Unicorn的贡献，软件开发以及思想和科学支持：Mattias Aechtner，Peter Brune，Zilan Ciftci，GéetanCompere，Claes Johnson，Ashraful Kadir，KasparMüller，JeannetteSpühler，MichaelStöckli和Rodrigo Vilela de Abreu。\n作者要感谢欧洲研究委员会，瑞典战略研究基金会，瑞典研究委员会和瑞典能源署的财政支持。 这些模拟是由瑞典国家基础设施计算中心（SNIC），高性能计算中心北部（HPC2N），瑞典国家超级计算机中心（NSC）和PDC –高性能计算中心提供的资源执行的。\n【章节目录】\n"}),a.add({id:21,href:'/notes/docs/fem/0125/',title:"Unicorn：统一的连续介质力学求解器（中）【翻译】",content:"【章节目录】\n18·4 实现 在这里，我们概述了Unicorn的设计。 Unicorn求解器类UCSolver将Unicorn库中的技术与FEniCS的其他部分结合，合在一起公开一个接口（请参见清单18.6），以模拟连续介质力学中的应用。 求解器实现的主要部分是UC模型的G2离散化的弱形式（请参见图18.4），以及用于误差估计的应力和残差的形式。 来自应用程序的系数被连接到形式，然后由TimeDependentPDE类执行时间步进。 某些系数，例如   \\(\\delta\\)  稳定化系数，也作为求解器的一部分（而不是作为形式）来进行计算。 求解器计算自适应算法的一次迭代（主求解，对偶求解和网格划分），其中，自适应循环是通过迭代运行一系列网格的求解器来实现的。\n对于使用MPI的分布式内存体系结构，UCSolver已经实现并行化，我们可以在多个平台上展示数百个内核的强大扩展能力（见图18.5）。 整个自适应算法是并行的，包括Rivara网格修正和先验预测负载平衡。 Unicorn可以有效地模拟不可压缩的湍流的大规模并行应用（Jansson等，2010； Jansson，2011）。 图18.3给出了并行自适应圆柱体仿真的示例。\nUCSolver的一个可压缩变体CNSSolver，用于适应G2的可压缩Euler流。 除了不可压缩性之外，更一般方法和算法与UCSolver的方法和算法非常接近。 长期目标是统一不可压缩/可压缩的表述。 关于可压缩CNSSolver的实现细节，请参阅Nazarov（2009）。 有关球体周围可压缩流的示例图，请参见图18.2。\n图18.2 围绕球体的3维可压缩流的自适应计算的示例应用。 图18.3 具有并行自适应计算的圆柱体周围3维不可压缩湍流的示例应用。 图18.4 用于求解不可压缩的UC模型的牛顿迭代（近似雅可比）的双线性和线性形式的源代码。 图18.5 在几种不同的体系结构上，网格细化和整个求解器具有强大的伸缩结果：Lindgren（Cray XT6m），Hebb（BlueGene / L）和Neolith（带有InfiniBand的常规Linux群集）。 虚线表示理想的加速。 图18.6 Unicorn的类UCSolver的C++类接口。 18·4·1 Unicorn类／接口 以下类/接口中提供了关键概念的抽象：\nTimeDependentPDE: 时间步进\n在每个时间步中，非线性代数系统都通过不动点迭代来求解。\nErrorEstimate: 自适应误差控制\n适应性是基于计算形式 \\(\\eta_K = \\|hR(U)\\|_T\\|DZ\\|_T\\)  的局部误差指标，其中 \\(Z\\)  是所谓的对偶解。\nSpaceTimeFunction: 时空系数\n时空函数/系数的存储和求值。\nSlipBC: 摩擦边界条件\nUnicorn中湍流的有效计算是基于通过摩擦模型对湍流边界层进行建模的，其中滑移边界条件 \\(u \\cdot n = 0\\)  作为代数系统的一部分而得到了强有力的实现。\nElasticSmoother: 弹性网格平滑/优化\n根据弹性类比的胞元质量优化。\nMeshAdaptInterface: 网格自适应接口\n使用本地网格操作对MAdLib软件包的接口进行抽象以进行网格自适应。\n18·4·2 TimeDependentPDE 我们考虑比如 \\(\\frac{\\partial}{\\partial t} u + A(u) = 0\\)  的一般时间依赖方程，其中 \\(A\\)  表示空间中可能的非线性微分算符。 我们想定义一个类（数据结构和算法）来抽象G2方法的时间步进。 该方程作为输入给出，时间步进应自动生成。 我们对于cG(1)cG(1)方法通过应用简化的牛顿法做到这一点。 它封装在图18.7的C++类接口中，称为TimeDependentPDE。\n图18.8实现了带不动点迭代的时间步进骨架。\n图18.7 TimeDependentPDE的C++类接口。 图18.8 在Unicorn中使用不动点迭代实现时间步进的骨架。 我们使用块对角准牛顿法，从公式完整的牛顿法开始，然后将各项从对角块中删除。 我们还使用本构定律作为恒等式来表示 \\(U\\)  各项中的 \\(\\Sigma\\)  ，与通过在 \\(\\Sigma\\)  和 \\(U\\)  之间进行迭代相比，可以允许更大的时间步长。 参见Jansson（2009）；Hoffman等（2011年）了解更多详细信息，并讨论了不动点迭代及其实现的效率。\n18·4·3 ErrorEstimate 基于对偶的自适应误差控制算法需要以下组件：\n残差计算 我们通过分段常数空间中的 \\(L^2\\)  -投影，计算残差 \\(R(U)\\)  在每个胞元中的平均值。\n对偶解 我们使用与原始问题相同的技术来计算对偶问题的解。 对偶问题虽然在时间上是向后求解的，但通过时间坐标变换 \\(s = T − t\\)  ，我们可以使用标准的TimeDependentPDE接口。\n时空函数存储/求值 我们在计算对偶问题的同时计算误差指标，作为对胞元的时空积分： \\(\\eta_T=\\left\\langle R(U)\\ ,\\ \\frac{\\partial}{\\partial x}Z\\right\\rangle\\)  ，在这里我们需要对原始解 \\(U\\)  和对偶解 \\(Z\\)  进行求值。 \\(U\\)  是对偶方程的系数。 这需要存储并对时空函数求值，该函数封装在SpaceTimeFunction类中。\n自适应网格 计算误差指标后，我们选择指标最大的 \\(p\\%\\)  进行细化。 然后通过递归Rivara胞元二等分法进行优化。或者，可以使用MAdLib（Compère等人，2009）进行基于边缘拆分，折叠和交换的更通用的网格自适应操作。\n使用这些组件，我们可以构建自适应算法。 自适应算法封装在图18.9中的C++类接口ErrorEstimate。\n图18.9 C++类接口ErrorEstimate。 18·4·4 SpaceTimeFunction 作为解决对偶问题的一部分，误差估计算法需要对在对偶问题定义中出现的时空系数进行求值。 特别是，我们必须对原始解 \\(U\\)  在时间 \\(s=T-t\\)  处求值。 这需要存储和求值一个时空函数，封装在SpaceTimeFunction类中（请参见图18.10）。\n图18.10 C++类接口SpaceTimeFunction。 时空泛函被实现为在常规采样时间的空间函数列表，对其求值是时间自由度的分段线性插值。\n18·4·5 SlipBC 对于雷诺数较高的问题，例如汽车的空气动力学或飞机的飞行能力，无法解决湍流边界层。 然后，一种可能性是通过摩擦模型来建模湍流边界层：\n\\[ u \\cdot n = 0 \\tag{18.18} \\]  \\[ \\beta u \\cdot \\tau_k + (\\sigma n) \\cdot \\tau_k = 0\\qquad k = 1, 2 \\tag{18.19} \\]  我们实现了法向分量条件（滑移）的强边界条件。 这里的“强”是指在代数系统中将左侧矩阵和右侧向量组合后的边界条件实现，而切向分量（摩擦）是通过在变分公式中添加边界积分的“弱”实现。 找到与自由度相对应的矩阵行和荷载向量，并根据边界条件用新行替换。\n想法如下：最初，测试函数 \\(v\\)  以笛卡尔标准基底 \\((e_1, e_2, e_3)\\)  表示。 现在，将测试函数以 \\((n, \\tau_1, \\tau_2)\\)  为基底局部映射到法向-切向坐标，其中 \\(n = (n_1, n_2, n_3)\\)  为法向，而 \\(\\tau_1 = (\\tau_{11}, \\tau_{12}, \\tau_{13})\\)  ， \\(\\tau_2 = (\\tau_{21}, \\tau_{22}, \\tau_{23})\\)  是边界上每个节点的切向。 这使我们可以限制法向，而切向自由：\n\\[ v = (v \\cdot n)n + (v \\cdot \\tau_1)\\tau_1 + (v \\cdot \\tau_2)\\tau_2 \\tag{18.20} \\]  对于矩阵和向量，这意味着对应于边界行需要分别乘以 \\(n, \\tau_1, \\tau_2\\)  ，然后将速度的法向分量设置为零。\n此概念封装在SlipBC类中，该类是dolfin::BoundaryCondition的子类，用于表示强边界条件。 有关滑移边界条件实现的更多详细信息，请参见Nazarov（2011）。\n18·4·6 ElasticSmoother 为了在UC模型中保持不连续相界面，我们将网格速度 \\(\\beta_h\\)  定义为固相中的离散速度 \\(U\\)  （特别是在界面上）。 流体中的网格速度可以任意选择，但必须满足网格质量和尺寸标准。 我们构造基于UC的纯弹性变体的胞元质量优化/平滑方法（请参见图18.11中的形式）。 对于网格速度 \\(\\beta_h\\)  ，我们定义了以下要求：\n 在网格的固相部分中， \\(\\beta_h=U\\)  。 有界网格质量 \\(Q\\)  定义为 \\[ Q =\\frac{d\\|F\\|^2_F}{\\det(F)^{\\frac{d}{2}}} \\]  其中， \\(d\\)  是空间维度，在网格的流体部分。 最好是，如果可能的话，网格平滑应该能改善 \\(Q\\)  。 在自适应算法中，保持网格尺寸 \\(h(x)\\)  接近所需的后验误差估计所给定的 \\(\\hat{h}(x)\\)  。  图18.11 表示UC模型的弹性平滑变体中变形梯度（ \\(F\\)  ）演化的一个时间步的形式的源码。 在Unicorn中，通过使用本构定律 \\(\\sigma = \\tau(I − (FF^T)^{−1})\\)  的弹性模型处理网格平滑，我们将 \\(F\\)  称为变形梯度。 我们使用更新定律： \\(\\frac{\\partial}{\\partial t} F^{−1} = −F^{−1}\\nabla u\\)  ，因此我们需要F的初始条件。 我们设置初始条件 \\(F_0 = \\bar{F}\\)  ，其中 \\(\\bar{F}\\)  是关于等边参考胞元的变形梯度，代表质量 \\(Q = 1\\)  的最佳形状。\n因此，求解弹性模型可以看作是针对网格中最高的全局质量 \\(Q\\)  进行优化。 对于低质量的胞元，我们还在杨氏模量 \\(\\mu\\)  上引入权重，这会损害较高的平均水平，但会导致局部质量低于中等水平的全局质量。 我们参考源代码以获取更多详细信息。\nUnicorn提供了ElasticSmoother类（请参见图18.13，该类可用于平滑/优化整个或部分网格的质量）。\n我们对弹性平滑度和网格自适应性进行了鲁棒性测试，如图18.12所示，其中我们使用与湍流3D标记问题相同的几何形状，但是定义了零流速，并且向标记添加了重体积力，以创建标记指向下方时发生大变形。 弹性平滑和网格自适应都可以计算解，但是正如预期的那样，弹性网格平滑最终无法控制胞元质量； 在限定胞元质量的同时，还不存在可以处理较大的刚体旋转的网格运动。\n图18.12 （a）弹性平滑和（b）网格自适应的鲁棒性测试。 请注意，变形不好的胞元被挤压在立方体和标记之间。 图18.13 C++类接口ElasticSmoother. 18·4·7 MeshAdaptInterface 如上所述，自适应算法中的关键要素是网格自适应性，我们将其定义为构造满足给定网格尺寸函数 \\(h(x)\\)  的网格。\n我们从介绍Rivara递归二等分算法（Rivara，1992）开始，这是网格自适应性的基本选择（当前是并行网格自适应性的唯一可用选择），但是只能细化而不是粗化。 然后，提出了更通用的MAdLib，它可以通过局部网格操作（边分割，边折叠和边交换）来对指定的 \\(h(x)\\)  进行全网格自适应。\nRivara递归二等分 Rivara算法将胞元的最长边一分为二（拆分），从而用两个新胞元替换该胞元，并使用递归对分法消除带有悬挂节点的不合格胞元。 相同的算法在2D/3D（三角形/四面体）中均适用。 在2D模式下，可以证明（Rivara，1992），该算法以有限的步长终止，并且已细化的网格最小角度至少是起始网格最小角度的一半。 在实践中，该算法可以在2D和3D中生成质量优良的细化网格。\n局部网格操作: MAdLib MAdLib结合了网格自适应算法和实现，其中定义了一小组局部网格修改操作，例如边分割，边折叠和边交换（有关边交换操作的说明，请参见图18.14）。 定义了一种网格自适应算法，在控制回路中使用这组局部操作来满足规定的尺寸场 \\(h(x)\\)  和质量公差。 边交换是提高胞元质量的关键操作，例如在具有大量连接边的顶点周围。\n在有限元方法的表述中，通常假设可以自由修改计算网格的胞元大小，以满足所需的尺寸场 \\(h(x)\\)  或允许网格运动。 在最先进的有限元软件实现中，很少出现这种情况（Bangerth等，2007； COMSOL，2009）。\nMAdLib中的网格自适应算法提供了使用局部网格操作来适应指定尺寸场的自由。 该实现以免费/开源软件的形式发布.\nUnicorn提供了MeshAdaptInterface类（请参见图18.15），在该类中可以使用MAdLib子类化并实现虚拟函数来控制网格自适应。\n图18.14 边交换操作：（顶部）初始腔体，突出显示交换边，（底部）交换之后可能的配置。 图18.15 C++类接口MeshAdaptInterface. 【章节目录】\n"}),a.add({id:22,href:'/notes/tags/hugo/',title:"hugo",content:""}),a.add({id:23,href:'/notes/tags/latex/',title:"latex",content:""}),a.add({id:24,href:'/notes/tags/markdown/',title:"markdown",content:""}),a.add({id:25,href:'/notes/tags/obsidian/',title:"obsidian",content:""}),a.add({id:26,href:'/notes/posts/%E5%9F%BA%E4%BA%8EObsidianHugoGitee%E7%9A%84%E7%AC%94%E8%AE%B0%E7%B3%BB%E7%BB%9F/',title:"基于Obsidian＋Hugo＋Gitee的笔记系统",content:" 本文基于Typora＋Hugo＋Gitee的笔记系统，仅把Typora改成Obsidian而已。\nObsidian是一个强大的知识库，可在纯文本Markdown文件的本地文件夹上运行。 支持双向链接（Roam Link）。\n通过gitee可实现云同步；通过gitee pages可以发布成网页。\n但是，Hugo无法解析Obsidian的双向链接，解决这个问题是本文的目标。\n【解决方案】 我通过shell脚本和Hugo短代码的配合解决这个问题。 通过shell脚本将Obsidian的双向链接转换成Hugo可以识别的自定义格式；Hugo短代码则负责解析这种自定义格式。\n本笔记系统是我自用，仅供参考。\n 回顾基于Typora＋Hugo＋Gitee的笔记系统 改进后的笔记系统，支持形如[[...]]以及![[...]]的双向链接（后者支持图片），自然就支持Obsidian； 如果你不使用双向链接，也可以使用Typora（甚至任意文本编辑器）。 所以Typora＋Hugo＋Gitee的笔记系统是基础，具体使用方法参见我的笔记主页：https://gitee.com/chaoskey/notes。此处不再多说！\n用Hugo短代码获得目标页面路径 使用方式 在md文件中需要的地方插入：{{\u0026lt; roamlink \u0026quot;docs/fem/_index#第五章 有限元变分形式\u0026quot; \u0026gt;}} 。 能在插入的地方显示对应的页面相对路径，就我的笔记而言，结果是：/notes/docs/fem/#第五章-有限元变分形式。\n又比如：{{\u0026lt; roamlink \u0026quot;0097\u0026quot; \u0026gt;}} ， 就我的笔记而言，结果是：/notes/docs/fem/0097/。\n如果没有重复的文件名，无须指定路径，通过hugo自定义短代吗，可以获得实际的页面路径（如第2例）；如果有重复文件名，则需要指定更详细的相对路径（如第1例）。\n这种功能，就是为双向链接量身定制的，因为[[...]]或![[...]]可能只给出一个文件名，而非完整的路径。\n实现方式 具体代码（Hugo短代码）见项目文件： roamlink.html 。\n为了避免获取的页面路径含空格和换行符，代码被压缩成一行。为清晰起见，我见代码展开如下：\n{{ if gt (len .Params) 0 }} \u0026lt;!-- 输入解析 --\u0026gt; {{ $keys := (split (index .Params 0) \u0026#34;#\u0026#34;) }} {{ $tag := \u0026#34;\u0026#34; }} {{ if (gt (len $keys) 1) }} \u0026lt;!-- 定位锚点 --\u0026gt; {{ $tag = (index $keys 1 | urlize | lower) }} {{ end }} {{ $key := (index $keys 0) }} \u0026lt;!-- 扩展名解析 --\u0026gt; {{ if not (findRE \u0026#34;\\\\.[^.]*$\u0026#34; $key) }} {{ $key = add $key \u0026#34;.md\u0026#34; }} {{ end }} \u0026lt;!-- 没有扩展名，则默认md文件 ，否则搜索资源文件 --\u0026gt; {{ if (strings.HasSuffix $key \u0026#34;md\u0026#34;) }} {{ relref . $key }}{{ if $tag }}#{{ $tag }}{{ end }} {{ else }} \u0026lt;!-- 解析资源路径 --\u0026gt; {{ $dir := (path.Split $key) }} {{ $key = $dir.File }} {{ if gt (len $dir.Dir) 0 }} \u0026lt;!-- 含资源路径的情况 --\u0026gt; {{ relref . $dir.Dir }}{{ $key }} {{ else }} \u0026lt;!-- 不含资源路径，则进一步搜索 --\u0026gt; {{ $rel := 0 }} {{ range where .Site.Pages \u0026#34;Kind\u0026#34; \u0026#34;section\u0026#34; }} {{ if not $rel }} {{ $rel = (.Resources.GetMatch $key) }} {{ end }} {{ end }} {{ if $rel }} {{ ($rel).RelPermalink }} {{ end }} {{ end }} {{ end }} {{ end }} 双向链接和Hugo自定义格式相互转换 正向变换 这个功能用shell命令sed来实现的，作为shell脚本forgitee的一部分。\n其中的正则替换代码是：\n## 将[[abc|efg]] 置换成 [efg]({{\u0026lt; roamlink \u0026#34;abc\u0026#34; \u0026gt;}}) s/\\[\\[\\([^[]*\\)|\\([^[]*\\)\\]\\]/[\\2]({{\u0026lt; roamlink \u0026#34;\\1\u0026#34; \u0026gt;}})/g; ## 将[[abc]] 置换成 [abc]({{\u0026lt; roamlink \u0026#34;abc\u0026#34; \u0026gt;}}) s/\\[\\[\\([^[|]*\\)\\]\\]/[\\1]({{\u0026lt; roamlink \u0026#34;\\1\u0026#34; \u0026gt;}})/g; 逆向变换 作为shell脚本fortypora的一部分。\n## 将[abc]({{\u0026lt; roamlink \u0026#34;abc\u0026#34; \u0026gt;}}) 置换成 [[abc]] s/\\[\\([^[]*\\)\\]({{\u0026lt;\\s*roamlink\\s*\u0026#34;\\1\u0026#34;\\s*\u0026gt;}})/[[\\1]]/g; ## 将[efg]({{\u0026lt; roamlink \u0026#34;abc\u0026#34; \u0026gt;}}) 置换成 [[abc|efg]] s/\\[\\([^[]*\\)\\]({{\u0026lt;\\s*roamlink\\s*\u0026#34;\\([^\u0026#34;]*\\)\u0026#34;\\s*\u0026gt;}})/[[\\2|\\1]]/g; 日常使用情景 用Obsidian记笔记、写作，支持双向链接。\n范例：\n  [[docs/fem/_index#第十八章 Unicorn：统一的连续介质力学求解器]|章节目录]]\n  [[0115]]\n  [[0115|DOLFIN：C++/Python有限元库》变分形式/组装/边界条件]]\n  [[0115.md]]\n  ![[0257.jpg|图18.2]]\n  ![[0258.jpg]]\n  ![[docs/images/0258.jpg]]\n  【注意】![[...]]中的资源文件所在的目录中，必须存在_index.md（空文件文件也行），否则Hugo无法搜索到对应的资源文件。\n如果想发布成网页，先执行命令./forgitee server 可在本地打开页面查看勘误。\n 这一步，会自动进行格式变换（包括双向链接、LaTex等等的格式变换）使得Hugo能够正常解析。\n如果退出服务，也会自动进行格式恢复，使得Obsidian能够正常解析。\n 如果确认无误，执行./publish发布到gitee pages。\n 这一步也会自动进行格式变换/逆变换，并将生成的静态页面发布到gitee pages。\n【注意】如果修改的内容没有提交\u0026amp;Push到Gitee，也会自动提交。 如果希望添加提交说明，建议在执行./publish前，先手工提交。\n 最后说明 由于此笔记系统的用户仅仅是我自己，很多细节我都配置好了，所以我自己能顺利使用。 其它人使用可能不会那么顺利，需要各自进行调整配置。 所以，本文仅供参考。\n"}),a.add({id:27,href:'/notes/tags/%E7%A0%81%E4%BA%91/',title:"码云",content:""}),a.add({id:28,href:'/notes/docs/fem/0124/',title:"Unicorn：统一的连续介质力学求解器（上）【翻译】",content:"【章节目录】\n本章介绍了Unicorn技术，重点介绍了用于统一连续介质（UC）概念和自适应通用Galerkin（G2）离散化的简单，高效和通用算法和软件，将其作为统一的连续介质力学方法。 我们将介绍Unicorn如何适应FEniCS框架，如何为其他FEniCS组件提供接口，Unicorn提供了哪些接口和功能以及如何设计实现的。 我们还将介绍一些使用Unicorn计算的流固耦合（ﬂuid–structure interaction）和适应性的例子。\n18·1 背景 Unicorn是一种求解器技术（模型，方法，算法和软件），其目标是自动模拟现实的连续介质力学应用，例如在湍流不可压缩或可压缩流中的固定或柔性物体（流固耦合）的阻力或升力计算。 参见图18.1。 Unicorn的基础是： 在Euler坐标（实验室坐标）中表述的统一连续介质（UC）建模（Hoffman等人，2011），以及带有用于跟踪相界面的移动网格的G2（一般Galerkin）自适应稳定有限元离散化技术。 UC模型由全域中作为连续介质的质量，动量，能量和相位的典型守恒方程组成，以及以柯西应力和相位变量作为定义材料特性和本构方程的数据。 Unicorn制定并实现了适用于UC模型的自适应G2方法，并为FEniCS工具链中的其他组件（FIAT，FFC，DOLFIN）提供接口，从而提供了有限元函数空间，弱形式和网格以及自动并行组装和线性代数的算法的表示 。\n图18.1 流固耦合问题，包括在湍流中安置在立方体后面的标志。 该图显示了流固界面，压力的等值面和网格的切面。 Unicorn软件分为三个部分：\n库 Unicorn库提供了通用的求解器技术，例如自动时间步长，误差估计，适应性，网格平滑和滑动/摩擦边界条件。\n求解器 Unicorn求解器通过制定相关弱形式来实现UC模型的G2自适应离散化方法。 当前有两种主要的求解器：不可压缩的流体和固体（包括流固耦合）和可压缩的欧拉流体。 长期目标是统一不可压缩和可压缩的陈述。\n应用 与求解器关联的是诸如具有特定几何形状，系数和参数的计算实验和基准之类的应用。 这些表示为构建在Unicorn求解器/库之上的独立程序，可以串行或并行运行（当前仅限于不可压缩的流）。\n18·2 统一的连续介质建模 根据经典的连续介质力学（Gurtin，1981），我们在固定的欧拉坐标系中定义了一个统一的连续介质模型，该模型包括：\n 质量守恒， 动量守恒, 能量守恒, 相对流方程（phase convection equation）, 作为数据的应力本构方程，  其中应力是柯西应力（实验室应力），相位是指示函数，用于确定要使用的本构方程和材料参数。 请注意，在此连续介质描述中，将坐标系固定（欧拉），相位函数（指示器）根据相位对流方程来对流的。 在固相的情况下，网格以连续速度移动，以消除相界面的扩散。 我们将在以下第18.3.2节中对此进行详细阐述。\n我们定义了该模型的两个变体，即不可压缩和可压缩，未来的目标是构造统一的不可压缩/可压缩模型和求解器。 在这里，我们将介绍重点放在不可压缩模型上。\n我们从一个用于质量和动量守恒的模型开始，在时空域   \\(Q = \\Omega \\times [0, T]\\)  上具有相函数 \\(\\theta\\)  的对流方程，其中 \\(\\Omega\\)  是 \\(\\mathbb{R}^3\\)  中有边界 \\(\\Gamma\\)  的开域：\n\\[ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial}{\\partial x_j}(u_j ρ) = 0,\\qquad \\text{(质量守恒)} \\tag{18.1} \\]  \\[ \\frac{\\partial m_i}{\\partial t} + \\frac{\\partial}{\\partial x_j}(u_j m_i) =\\frac{\\partial}{\\partial x_j} \\sigma_{ij} + f_i, \\qquad \\text{(动量守恒)} \\tag{18.2} \\]  \\[ \\frac{\\partial \\theta}{\\partial t}+\\frac{\\partial}{\\partial x_j}(u_j \\theta) = 0,\\qquad\\text{(相对流方程)} \\tag{18.3} \\]  连同初始条件和边界条件，其中 \\(\\rho\\)  是密度， \\(m_i =\\rho u_i\\)  是动量， \\(u_i\\)  是速度。 如果我们假设连续介质是不可压缩的； 也就是 \\(0 = D_t\\rho = \\frac{\\partial}{\\partial t} \\rho + u_j \\frac{\\partial}{\\partial x_j} \\rho\\)  ，因此我们可以将不可压缩的UC方程表示为\n\\[ \\rho \\left(\\frac{\\partial u_i}{\\partial t}+ u_j \\frac{\\partial u_i}{\\partial x_j} \\right) = \\frac{\\partial}{\\partial x_j} \\sigma_{ij} + f_i \\tag{18.4)} \\]  \\[ \\frac{\\partial u_j}{\\partial x_j}= 0 \\tag{18.5} \\]  \\[ \\frac{\\partial \\theta}{\\partial t}+ u_j \\frac{\\partial \\theta}{\\partial x_j}= 0 \\tag{18.6} \\]  我们注意到，要对流固耦合问题建模，我们可以简单地将总应力 \\(\\sigma\\)  编写为使用 \\(\\theta\\)  相函数的流体和固体应力的线性组合： \\(\\sigma = \\theta\\sigma^f + (1 − \\theta)\\sigma^s\\)  。 我们还可以将应力分解为压力 \\(p\\delta_{ij}\\)  及其偏离部分： \\(\\sigma_{ij} = \\sigma_{ij}^D − p\\delta{ij}\\)  。\nUC建模框架简单而紧凑，接近原始守恒方程的公式，并且不需要在不同坐标系之间进行映射。 这允许简单的操作并处理误差估计和实现。\nUC建模的一个关键设计选择是将柯西应力σ定义为数据，这意味着无论本构方程如何选择，守恒方程都将是固定的。 这提供了方法和软件设计的一般性，其中对本构方程的修改会影响本构方程的表述和实现，但不会影响守恒方程的表述和实现。\n在Unicorn中，我们目前已实施了两个本构定律，有关详细信息请参见Hoffman等（2011）：\n\\[ \\sigma^f_{ij} = 2\\mu_f \\epsilon(u)_{ij} \\qquad \\text{(牛顿流体)} \\tag{18.7} \\]  \\[ \\frac{\\partial \\sigma^s_{ij}}{\\partial t}= 2\\mu_s\\epsilon(u)_{ij} +\\frac{\\partial u_i}{\\partial x_k} \\sigma^s_{kj} + \\sigma^s_{ik}\\frac{\\partial u_k}{\\partial x_j}\\ \\text{\\scriptsize (不可压缩新胡克型固体)} \\tag{18.8} \\]  18·3 时空的一般Galerkin离散化 自适应G2方法（也称为自适应DNS / LES）已用于许多湍流计算中，但计算成本却非常低（Hoffman，2005； Hoffman和Johnson，2006； Hoffman，2006； Hoffman和Johnson，2007； Hoffman和Johnson，2007； Hoffman和Johnson，2007； Hoffman，2009年； Hoffman和Jansson，2009年； de Abreu等人，2010年），其中在输出量（例如阻力，升力和压力系数和Strouhal数）上获得了收敛，并且使用的网格点数比基于临时细化计算网格的标准LES方法少了几个数量级。\n18·3·1 标准Galerkin 我们首先用标准的 cG(1)cG(1) FEM（Eriksson等人，1996）公式表示（18.9）在时间和空间上连续分段线性解。 我们让 \\(w = (u, p, \\theta)\\)  表示精确解， \\(W = (U, P, \\Theta)\\)  是离散解， \\(v = (v^u, v^p, v^\\theta)\\)  是测试函数， \\(R(W) = (R_u(W), R_p(W), R_\\theta(W))\\)  是残差。 这个残差定义为\n\\[ \\begin{aligned}R_u(W) \u0026= \\rho \\left(\\frac{\\partial U_i}{\\partial t}+ U_j \\frac{\\partial U_i}{\\partial x_j} \\right)−\\frac{\\partial}{\\partial x_j}\\left(\\Sigma^D_{ij} − P\\delta_{ij}\\right) − f_i \\\\ R_p(W) \u0026=\\frac{\\partial U_j}{\\partial x_j} \\\\ R_\\theta (W) \u0026=\\frac{\\partial \\Theta}{\\partial t} + U_j \\frac{\\partial \\Theta}{\\partial x_j}\\end{aligned}\\tag{18.9} \\]  其中 \\(\\Sigma\\)  表示离散的分段常应力。\n为了计算解，我们强制执行Galerkin正交性\n\\[ \\langle R(W), v\\rangle = 0 \\tag{18.10} \\]  对于测试空间 \\(\\hat{V}_{hk}\\)  中的所有函数 \\(v\\)  ，包括空间中的分段线性连续函数和时间上的分段常值不连续函数组成。 这里， \\(\\langle\\cdot, \\cdot\\rangle\\)  表示时空中的 \\(L^2\\)  -内积。\n对于对流占优问题，这种标准有限元表述是不稳定的，并且也源于压力和速度的等阶单元的不稳定结果。 因此，如下所述，我们增加了流线扩散（streamline–diffusion）稳定性。\n在时间上具有梯形求积的cG(1)cG(1)的表述等效于空间中具有分段线性单元的Crank–Nicolson时间步长。 这具有成为非常简单，标准且熟悉的离散表述的优点。\n18·3·2 局域ALE 如果相函数 \\(\\Theta\\)  在同一胞元上具有不同的值，则将导致相界面的不良扩散。 通过引入移动的时空有限元空间和网格，它们沿着相界面对流的特性方向（Eriksson等，1996，有关“特征Galerkin方法”的部分），我们可以定义胞元维面的相界面，使界面保持不连续。\n因此，我们在每个时空块上定义局部ALE坐标映射作为离散化的一部分，用于引入网格速度。 请注意，我们仍然使用全局Euler坐标进行计算，但是使用了移动的网格。\n为了能够定义和补偿任意网格速度 \\(\\beta_h\\)  ，我们在每个时空块上定义一个局部坐标映射 \\(\\phi\\)  ：\n\\[ \\begin{aligned}\\frac{\\partial}{\\partial t} \\phi(\\bar{x}, t) \u0026= \\beta_h(\\bar{x}, t) \\\\ (x, t) \u0026= \\phi(\\bar{x}, t) \\end{aligned}\\tag{18.11} \\]  应用链式法则给出了关系\n\\[ \\scriptsize \\frac{\\partial}{\\partial t} U(x, t) + U(x, t) \\cdot \\nabla U(x, t) =\\frac{\\partial}{\\partial t} \\bar{U}(\\bar{x}, t) + (\\bar{U}(\\bar{x}, t) − \\beta_h)) \\cdot \\nabla \\bar{U}(\\bar{x}, t)\\tag{18.12} \\]  在网格的固体部分中选择 \\(\\beta_h= U\\)  可得出相对流方程的平凡解，我们可以将其从系统中删除。 然后，最后的离散UC方程是通过残差定义的\n\\[ \\begin{aligned}R_u(W) \u0026= \\rho \\left(\\frac{\\partial U_i}{\\partial t}+ (U_j − β^h_j)\\frac{\\partial U_i}{\\partial x_j} \\right)−\\frac{\\partial}{\\partial x_j}(\\Sigma^D_{ij} − P\\delta_{ij}) − f_i \\\\ R_p(W) \u0026=\\frac{\\partial U_j}{\\partial x_j}\\end{aligned}\\tag{18.13} \\]  因此，我们选择网格速度 \\(\\beta_h\\)  作为网格的结构部分（接触结构胞元的顶点）中的离散材料速度 \\(U\\)  ，在网格的其余部分中，我们使用网格平滑来确定βh最大化网格质量。 或者，可以在网格上使用局部网格修改操作（细化，粗化，交换）以保持质量（Compère等，2009）。\n18·3·3 加权最小二乘稳定化 标准FEM表述是不稳定的。 因此，我们考虑形式 \\(\\langle R(W), v + \\delta R(v)\\rangle = 0,\\ \\forall v\\in\\hat{V}_{hk}\\)  的加权标准最小二乘法（请参阅Eriksson等人（1996）； Hoffman和Johnson（2007）），其中 \\(\\delta \\gt 0\\)  是稳定化参数。 我们通过降低稳定化项，包括时间导数和 \\(\\Sigma^D\\)  ，来使之简化。 虽然不完全一致，但这样避免了剪切层不必要的拖尾效应。 因此，对于UC模型，稳定化方法采用以下形式：\n\\[ \\begin{aligned}\\left\\langle R^u(W), v^u\\right\\rangle \u0026= \\left\\langle \\rho\\left(\\frac{\\partial U_i}{\\partial t}+ U_j\\frac{\\partial U_i}{\\partial x_j}\\right) − f_i\\ ,\\ v_i^u\\right\\rangle + \\\\ \u0026 \\qquad \\qquad \\left\\langle \\Sigma^D_{ij} − P\\delta_{ij}\\ ,\\ \\frac{\\partial}{\\partial x_j} v^u_i\\right\\rangle + S D^u(W, v^u) = 0\\end{aligned} \\tag{18.14} \\]  \\[ \\left\\langle R^p(W)\\ ,\\ v^p\\right\\rangle = \\left\\langle\\frac{\\partial U_j}{\\partial x_j}\\ ,\\ v^p\\right\\rangle + S D^p(W, v^p) = 0 \\tag{18.15} \\]  对所有 \\(v \\in \\hat{V}_{hk}\\)  ，其中\n\\[ \\begin{aligned}S D^u(W, v^u) \u0026= \\delta_1\\left\\langle U_j\\frac{\\partial U_i}{\\partial x_j}+\\frac{\\partial P\\delta_{ij}}{\\partial x_i}\\ ,\\ U_j\\frac{\\partial v_i^u}{\\partial x_j}\\right\\rangle \\\\ \u0026\\qquad\\qquad + \\delta_2\\left\\langle\\frac{\\partial U_j}{\\partial x_j}\\ ,\\ \\frac{\\partial v^u_j}{\\partial x_j}\\right\\rangle\\end{aligned} \\tag{18.16} \\]  \\[ S D^p(W, v^p) = \\delta_1\\left\\langle\\frac{\\partial P\\delta_{ij}}{\\partial x_i}+ U_j \\frac{\\partial U_i}{\\partial x_j}\\ ,\\ \\frac{\\partial v^p}{\\partial x_i}\\right\\rangle \\tag{18.17} \\]  【章节目录】\n"}),a.add({id:29,href:'/notes/docs/fem/0123/',title:"UFL：有限元形式语言》算法(二)\u0026实现的问题【翻译】",content:"【章节目录】\n17·8 算法（续前） 17·8·4 重要的变换 有很多方法可以操纵表达式的表示。 在这里，我们描述了三个特别重要的变换。 注意，这里每一个算法都删除了一些抽象，因此可能删除了一些分析或优化的机会。 为了展示其效果，下面将每种变换应用到下面的表达式\n  \\[ a = \\mathrm{grad}(f u) \\cdot \\mathrm{grad}\\ v \\tag{17.77} \\]  在本节的最后，给出了一些示例代码来演示更多的表示细节。\nUFL中的某些算符称为“复合”算符，这意味着它们可以由其他更基本的算符表示。 尝试定义一个表达式a = dot(grad(f*u), grad(v))，然后打印repr(a)。 如您所见，a的表示是Dot(Grad(Product(f, u)), Grad(v))，其中一些详细信息代替了f，u和v。 通过直接使用高级别类型Grad（而不是更多低级别类型）来表示梯度，输入表达式在表示中更容易识别，并且将表达式呈现为比如LATEX格式可以显示终端用户所写的原始复合算符。 但是，由于许多算法必须为每种算符类型实现操作，因此函数expand_compounds可以将所有“ 复合”类型的表达式节点替换为使用基本类型的等效表达式。 当将此操作应用于来自用户的输入形式时，UFL和形式编译器中的算法仍可以纯粹用更基本的算符来编写。 展开方程式（17.77）的复合表达式可得到表达式\n\\[ a_c = \\sum_i\\frac{\\partial v}{\\partial x_i}\\frac{\\partial (uf)}{\\partial x_i} \\tag{17.78} \\]  另一个重要的变换是expand_derivatives，递归地且对所有类型的导数，应用对表达式的自动微分。 最终结果是大多数导数都能被计算，并且表达式树中剩余的仅有导数算符类型是应用到终端表达式的。 该算法的前提是已应用过expand_compounds。 根据公式（17.78）对ac展开求导可得出\n\\[ a_d = \\sum_i\\frac{\\partial v}{\\partial x_i}\\left(u \\frac{\\partial f}{\\partial x_i}+ f \\frac{\\partial u}{\\partial x_i}\\right) \\tag{17.79} \\]  索引记号和IndexSum表达式节点类型在某种程度上使表达式树的解释复杂化，尤其是在具有嵌套索引求和的表达式中。 由于具有自由索引的表达式将具有多个值，因此每个表达式对象不仅代表一个值，而且代表一组值。 变换expand_indices便派上用场了。 该算法的前提是已应用过expand_compounds和expand_derivatives。 该算法的后置条件是表达式中没有剩余的自由索引。 最终将公式（17.79）展开索引，得到\n\\[ a_i = \\frac{\\partial v}{\\partial x_0}\\left(u\\frac{\\partial f}{\\partial x_0}+ f \\frac{\\partial u}{\\partial x_0}\\right) +\\frac{\\partial v}{\\partial x_1}\\left(u\\frac{\\partial f}{\\partial x_1}+ f \\frac{\\partial u}{\\partial x_1}\\right) \\tag{17.80} \\]  我们从等式（17.77）中的更高层次的概念梯度和点积开始，最后仅以形式参数的标量加法，乘法和偏导数结束。 形式编译器通常以ad或ai开头，插入参数导数值，并在最终生成代码之前应用一些其他变换。\n一些示例代码可以帮助您理解这些算法在表达式的表示级别上的作用。 由于此代码的打印输出有点长，因此下面仅输出要重复的关键方面。 将此代码复制到python文件或在python解释器中运行以查看完整的输出。\n# Python code from ufl import * V = FiniteElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) u = TestFunction(V) v = TrialFunction(V) f = Coefficient(V) # Note no *dx! This is an expression, not a form. a = dot(grad(f*u), grad(v)) from ufl.algorithms import * ac = expand_compounds(a) ad = expand_derivatives(ac) ai = expand_indices(ad) print(\u0026#34;\\na: \u0026#34;, str(a), \u0026#34;\\n\u0026#34;, tree_format(a)) print(\u0026#34;\\nac:\u0026#34;, str(ac), \u0026#34;\\n\u0026#34;, tree_format(ac)) print(\u0026#34;\\nad:\u0026#34;, str(ad), \u0026#34;\\n\u0026#34;, tree_format(ad)) print(\u0026#34;\\nai:\u0026#34;, str(ai), \u0026#34;\\n\u0026#34;, tree_format(ai)) 显示为 \\(a\\)  的打印输出是（有限元对象的详细信息，已切除部分信息，以缩短行数）：\n# Output a: (grad(v_{-2} * w_0)) . (grad(v_{-1})) Dot ( Grad Product ( Argument(FiniteElement(...), -2) Coefficient(FiniteElement(...), 0) ) Grad Argument(FiniteElement(...), -1) ) 标为-1和-2的参数分别引用v和u。\n在 \\(a_c\\)  中，Dot乘法已展开为具有两个Indexed操作数的Product的IndexSum：\n# Output IndexSum ( Product ( Indexed ( ... MultiIndex((Index(10),), {Index(10): 2}) ) Indexed ( ... MultiIndex((Index(10),), {Index(10): 2}) ) ) MultiIndex((Index(10),), {Index(10): 2}) ) 看起来有点复杂的表达式MultiIndex((Index(10),), {Index(10): 2})可以简单地理解为“绑定到第2维轴的名为 \\(i_{10}\\)  的索引”。\n放大到上面的\u0026hellip;行之一，将grad(f u)的表示变换为更多基本表达式后，仍必须保持矢量形状，这就是为什么SpatialDerivative对象包装在ComponentTensor对象中的原因： 【译者注：较新版本显示的信息和这里不一样，具体以实际打印信息为准，后面不再作此说明】\n# Output ComponentTensor ( SpatialDerivative ( Product ( u f ) MultiIndex((Index(8),), {Index(8): 2}) ) MultiIndex((Index(8),), {Index(8): 2}) ) 在展开表达式的算法中，出现的常见模式：\n# Output Indexed ( ComponentTensor ( ... MultiIndex((Index(8),), {Index(8): 2}) ) MultiIndex((Index(10),), {Index(10): 2}) ) 此模式用作索引对象的重新标记，将. . .所再内部的 \\(i_8\\)  重命名为外部的 \\(i_{10}\\)  。 当查看 \\(a_d\\)  的打印结果时，链式规则 \\(((f u)′ = u f ′ + f u′)\\)  的结果可以看作是两个Product对象的Sum。\n# Output Sum ( Product ( u SpatialDerivative ( f MultiIndex((Index(8),), {Index(8): 2}) ) ) Product ( f SpatialDerivative ( u MultiIndex((Index(8),), {Index(8): 2}) ) ) ) 最终，在 \\(a_i\\)  （此处未显示）中进行索引展开之后，没有剩余自由的Index对象，反而在 \\(a_i\\)  的打印中看到很多FixedIndex对象。 如果您想很好地了解此处显示的三个变换，强烈建议您仔细阅读上面示例代码的全部输出。\n17·8·5 表达式求值 即使UFL表达式打算由形式编译器进行编译，将其直接求值得浮点值也很有用的。 特别是，这使得UFL的测试和调试更加容易，并且在单元测试中得到了广泛的使用。 要对UFL表达式求值，必须指定形式参数和几何量的值。 通过将带有坐标的元组传递给调用算符，可对只依赖于空间坐标的表达式求值。 可以直接复制到交互式Python会话的如下代码展示了这种语法：\n# Python code from ufl import * cell = triangle # 在较新的版本中，cell没有x这个成员，改用随后的代码 # x = cell.x x = SpatialCoordinate(cell) e = x[0] + x[1] print(e((0.5, 0.7))) # prints 1.2 可以使用从终端表达式实例到值的映射字典来指定其他终端表达式。 此代码通过映射扩展了上面的代码：\n# Python code c = Constant(cell) e = c*(x[0] + x[1]) print(e((0.5, 0.7), { c: 10 })) # prints 12.0 如果函数和基函数依赖于空间坐标，那么这个映射可以指定一个Python可调用函数，而不是字面常量。 这个可调用函数必须是将空间坐标作为输入并返回一个浮点值。 如果要映射的函数是向量函数，则可调用函数必须返回值的元组。 这些扩展可以在以下代码中看到：\n# Python code element = VectorElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) c = Constant(triangle) f = Coefficient(element) e = c*(f[0] + f[1]) def fh(x): return (x[0], x[1]) print(e((0.5, 0.7), { c: 10, f: fh })) # prints 12.0 为了使用表达式求值来验证导数计算是否正确，还可以指定形式参数的空间导数。 然后，可调用函数必须携带第二个参数，该参数是指定要微分的空间方向的整数元组。 最终的示例代码，对 \\(g = x_0 x_1\\)  ，计算出 \\(g^2 + g^2_{，0} + g^2_{，1}\\)  。\n# Python code element = FiniteElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) g = Coefficient(element) e = g**2 + g.dx(0)**2 + g.dx(1)**2 def gh(x, der=()): if der == (): return x[0]*x[1] if der == (0,): return x[1] if der == (1,): return x[0] print(e((2, 3), { g: gh })) # prints 49 17·8·6 表达式查看 可以用各种方式格式化表达式以进行检查，这在调试时特别有用。 内置的Python字符串转换算符str(e)提供了紧凑的人类可读字符串。 如果在交互式Python会话中键入print(e)，则显示str(e)。 另一个Python内置字符串算符是repr(e)。 UFL所正确实现的repr，满足对任何表达式e，e == eval(repr(e))都成立。 字符串repr(e)反映表达式中使用的所有确切表示类型，因此对于调试很有用。 另一个格式化函数是tree_format(e)，它产生一个缩进的多行字符串，该字符串清楚地显示了表达式的树结构，而repr则相反，后者可能返回很长且难以阅读的字符串。 可以在手册中找到有关将表达式格式化为LATEX和点图可视化格式的信息。\n17·9 实现的问题 17·9·1 Python作为领域专用语言的基础 将UFL作为一个嵌入在Python的语言， 最初的这种选择会影响本节中详细介绍的许多实现细节。 因此，这里有一些关于为什么Python适用于此，为什么不适用的说法。\nPython提供了一种简单的语法，通常被认为类似于伪代码。这是一个领域专用语言的很好起点。 很好地支持面向对象和操作符重载，这是UFL设计的基础。 Python的函数式编程功能（例如生成器表达式）在算法和形式编译器的实现中很有用。 内置的数据结构列表，字典和集合在可伸缩算法的快速实现中起着核心作用。\nPython中的运算符重载有一个问题，那就是比较运算符。 问题源于以下事实：__eq__或__cmp__被用于内置数据结构字典，并将其设置为比较键，这意味着a == b必须返回布尔值，即使Expr也是如此。 结果是__eq__不能被重载，用来返回某些Expr类型的表示（比如Equals(a, b)）供形式编译器稍后处理。 另一个问题是and和or也不能被重载，因此不能在条件表达式中使用。 在Python中，这些设计选择是有充分的理由。 而这又是UFL中比较运算符设计有些不直观的原因。\n17·9·2 确保形式签名的唯一性 形式编译器需要计算每个形式的唯一签名，以便在缓存系统中使用，避免重新编译。 定义签名的便捷方法是使用repr(form)，因为在Python中的此定义是eval(repr(form)) == form。 因此，对所有Expr子类都实现了__repr__。\n有些形式在数学上是等效的，即使它们的表示不完全相同。 UFL的表达式没有使用真正的规范形式，而是采取了一些措施来确保识别这些平凡的等价形式。\nExpr类层次结构中的某些类型（Counted的子类）具有全局计数器，用于标识创建它们的顺序。 形式参数（Argument和Coefficient）都使用了此计数器来标识它们在形式参数列表中的相对顺序。 其他要计数类型有Index和Label，它们仅将计数器用作唯一标识符。 实现了对所有Counted类型进行重新编号的算法，以使所有计数均从0开始。\n另外，某些算符类型（例如Sum和Product）要维护操作数的排序列表，使得a + b和b + a都表示为Sum(a, b)。 此操作数排序有意与索引编号无关，因为那样会不稳定。 这种不稳定的原因是索引重编号算法的结果取决于操作数的顺序。 操作数排序和重编号相结合，可确保相等的形式的签名保持不变。 请注意，形式的表示以及签名可能会随UFL版本的变化而变化。 下面的行打印了应用了expand_derivatives并重新编号的形式签名。\n# Python code print(repr(preprocess(myform).preprocessed_form)) 17·9·3 效率考量 在Python中编写UFL，我们显然没有将最高性能作为第一要务。 如果形式编译过程可以融合到应用程序构建过程中，那么性能就足够了。 但是，我们确实关心可扩展性能以有效地处理复杂的方程，因此，我们关心的是所使用算法的渐近复杂性。\n要用Python编写清晰有效的算法，正确使用内置数据结构非常重要。 这些数据结构特别包括列表，字典和集合。 CPython（van Rossum等人），Python的参考实现，将数据结构列表实现为数组，这意味着append和pop以及随机读写访问都是O(1)操作。 但是，随机插入为O(n)。 字典和集合都实现为哈希映射，后者仅不具有与键关联的值而已。 在哈希映射中，只要键类型有效地实现了__hash__和__eq__，随机读写，插入和删除都是O(1)操作。 字典数据结构被Python语言广泛使用，因此要特别注意使其高效（Kuchling，2007年）。 因此，要享受高效地利用这些容器，所有Expr子类都必须有效地实现这两个特殊函数。 如此考虑对于使UFL的有效实现非常重要。\n17·10 结论和未来方向 更多的其它功能可以引入到UFL。 添加哪些功能将取决于FEniCS用户和开发人员的需求。 某些功能可以单独在UFL中实现，但是大多数功能将需要更新FEniCS项目的其他部分。 因此，UFL的未来方向与整个FEniCS项目的发展紧密相关。\n在UFL中，很容易对有限元的声明进行改进。 附加的复杂性主要是在形式编译器中。 当前的建议包括时空单元和时间导数。 具有不均匀胞元类型的其他几何映射和有限元空间也是有可能扩展。\n可以添加其他算符以使语言更具表现力。 一些算符很容易添加，因为它们的实现只影响一小部分代码。 很容易添加更多的使用基本算符表示的复合算符。 只要知道其导数，其他特殊函数也很容易添加。 其他功能可能需要更全面的设计考量，例如对复数的支持，这会影响大部分代码。\n用户友好的记号和对快速开发的支持是UFL设计的核心价值。 使用接近数学抽象符号可以更轻松地表达特定的想法，从而可以减少用户代码中错误的可能性。 但是，元编程和代码生成的概念增加了另一层抽象，这可能使终端用户对框架的理解更加困难。 因此，每处都进行良好的错误检查非常重要，尽可能地检测用户输入错误。 错误消息，文档和单元测试套件的改进将始终对您有所帮助，以避免新用户频繁重复出现错误和误解。\n为了支持形式编译器项目，可以在UFL中包含用于更有效地生成更好代码的算法和实用程序。 这样的算法可能应该局限于诸如表达图的一般变换之类的算法，独立于形式编译器特定方法。 在这一领域，更多的关于自动微分算法替代方案的工作（Forth等，2004； Tadjouddine，2008）可能有用。\n总而言之，UFL是FEniCS框架的核心组件，在此框架中，它提供了丰富的形式语言，自动微分功能以及高效形式编译器的构建块。 这些对于快速求解偏微分方程的应用程序很有用。 UFL提供了离散自动化的用户接口，这是FEniCS的核心功能，并将线性自动化添加到了框架中。 凭借这些功能，UFL使FEniCS距其总体目标“自动化数学建模”又近了一步。\n17·11 致谢 这项工作得到了挪威研究委员会（grant 162730）和Simula研究实验室的支持。 我要感谢通过建议和测试帮助改善UFL的所有人，特别是Anders Logg，KristianØlgaard，Garth Wells，Harish Narayanan和Marie Rognes。 除了两位匿名评论， Kent-André Mardal和Marie Rognes都进行了严格的评论，极大地改善了本章。\n【章节目录】\n"}),a.add({id:30,href:'/notes/docs/fem/0122/',title:"UFL：有限元形式语言》计算导数\u0026算法(一)【翻译】",content:"【章节目录】\n17·7 计算导数 当由形式语言的终端用户声明任何种类的导数表达式时，都会构造一个表达式对象来表示它，但不会计算任何内容。 这种表达式对象的类型是Derivative的子类。在从导数表达式生成低级代码之前，必须应用某种求导数的算法，因为差分算符本身在C++等低级语言中不可用。 计算精确的导数很重要，它消除了差分除法的近似。 存在几种用于计算精确导数的替代算法。 所有相关算法都基于链规则，并结合每种表达式对象类型的规则差异。 算法之间的主要区别在于子表达式的重用程度以及子表达式的累积方式。\n将导数的计算混入每个形式编译器的代码生成策略中，这将导致实现工作的显著重复。 为了分离问题并保持代码的可管理性，微分作为UFL的一部分实现，以使形式编译器独立于UFL中所选择的微分策略。 因此，对已求值的导数表达式，使用与任何其他表达式相同的表示是有利的。 在形式编译器解释表达式之前，应先对差分算符进行求值，以使剩下的算符只能是非差分算符。 由于UFL不知道终端的空间导数，这是一个例外，因为它们是由形式编译器提供的。\n下面，讨论一些最简单的算法之间的异同。 在解释了当前在UFL中实现的算法之后，讨论了张量和索引记号以及高阶导数的扩展。 最后，本节以关于终端表达式的微分规则的一些注释收尾。\n17·7·1 计算导数的方法 设计用于计算导数的算法时，要考虑到不同的最终目标。 符号微分（SD）将单个符号表达式作为输入，并为其求导生成新的符号表达式。 自动微分（AD）将用来计算一个函数的程序作为输入，并生成一个新程序以计算此函数的导数。 存在几种AD算法变体，最常见的两种是正向模式AD和反向模式AD（Griewank，1989）。 存在更高级的算法，并且是活跃的研究主题。 UFL表达式是一个符号表达式，由表达式树表示。 但是表达式树是有向无环图，表示用来对表达式求值的程序。 因此，在这种情况下，SD和AD之间的界限似乎变得不太明显。\n单纯地应用，SD会产生巨大的表达式，这不但需要在计算过程中占用大量内存，而且如果直接编写代码则效率很低。 但是，一些符号微分效率低下的例证，如在Griewank（1989）中，是基于在一些独立的计算机代数系统（CAS）中计算导数的闭式表达式。 直接将大表达式的结果复制到计算机代码中可能会导致代码效率低下。 编译器可能无法检测到常见的子表达式，尤其是如果CAS中的化简和重写规则已更改了子表达式的结构并具有重用潜力时。\n通常，AD是能够处理SD无法处理的算法。 将AD应用于通用源代码的工具必须处理许多复杂问题，例如子例程，全局变量，任意循环和分支（Bischof等，1992，2002； Giering和Kaminski，1998）。 由于UFL中对程序流结构的支持非常有限，因此UFL中的AD实施不会遇到这种麻烦。 在第17.7.2节中，将更详细地解释在UFL中SD和前向模式AD之间的相似性。\n17·7·2 前向模式自动微分 回顾算法5，表示用于根据一组终端值   \\(\\{t_i\\}\\)  和一组基本算符 \\(\\{f_i\\}\\)  来计算表达式 \\(z\\)  的程序。 暂时假设 \\(\\{f_i\\}\\)  中没有微分算符。 然后可以扩展该算法以计算导数 \\(\\frac{dz}{dv}\\)  ，其中 \\(v\\)  表示任何类型的微分变量。 此扩展给出了算法6。\n这种扩展程序以同时计算表达式 \\(z\\)  及其导数 \\(\\frac{dz}{dv}\\)  的方式称为前向模式自动微分（AD）。 通过将 \\(y_i\\)  和 \\(\\frac{d y_i}{dv}\\)  重命名得到新序列 \\(\\langle \\hat{y}_j\\rangle^{\\hat{n}}_{j = 1}\\)  的，如重写自算法6的算法7所示，该算法与算法5同构（它们具有完全相同的结构）。\n由于算法5中的程序可以表示为DAG，而算法7与算法5同构，因此算法7中的程序也可以表示为DAG。 因此，计算 \\(\\frac{dz}{dv}\\)  的程序可表示成由根据终端值和非微分算符构建的表达式树。\n当前实现的用于计算UFL中的导数的算法紧密遵循正向模式AD。 由于结果是一个新的表达式树，因此该算法也可以称为符号微分。 在这方面，两者之间的区别在于实现细节。 为了确保我们可以正确地重用表达式，UFL中的化简规则避免了修改算符的操作数。 因此，形式编译器可以轻松检测表达式中自然重复的模式。 然后可以通过将子表达式放在哈希映射中来实现有效的通用子表达式消除。 但是，存在诸如0∗f → 0和1∗f → f之类的化简，称为常数折叠，这在构造差分算法时会自动简化其结果。 这些化简对于导数计算期间的存储器使用以及结果程序的性能至关重要。\n17·7·3 张量和索引表达式的扩展 到目前为止，我们还没有考虑非标量表达式和带有自由索引表达式的导数。 此问题不会影响整体算法，但是会影响每种表达式类型的局部求导规则。\n考虑带有A和B矩阵表达式的diff(A, B)表达式。 张量关于张量的导数的意思很容易通过索引记号来定义，此记号在微分规则中大量使用：\n\\[ \\frac{dA}{dB}=\\frac{d A_{ij}}{d B_{kl}} e_i \\otimes e_j \\otimes e_k \\otimes e_l \\tag{17.69} \\]  子表达式的导数经常是以被求值成字面常量。 对于索引表达式，重要的是，自由索引必须与导数一起正确传播。 因此，微分表达式有时会包含带有自由索引标记的字面常量。\n当索引求和绑定索引 \\(i\\)  时，这是一个罕见而棘手的极端情况，比如 \\((v_i v_i)\\)  并且对其作关于 \\(x_i\\)  的求导尝试。 最简单的例子是表达式 \\((v_i v_i)_{,j}\\)  ，它具有一个自由索引 \\(j\\)  。 如果将 \\(j\\)  替换为 \\(i\\)  ，则仍然可以很好地定义表达式，但是您永远不会手动编写 \\((v_i v_i)_{,i}\\)  。 如果括号中的表达式定义为变量e = v[i]*v[i]，则表达式e.dx(i)看起来毫无问题。 但是，随着导数（包括索引 \\(i\\)  ）传播到终端，这将引起问题。 如果在当前的UFL实现中遇到这种情况，将检测到该情况并触发错误消息。 要变通解决此问题，只需使用不同的索引实例。 在UFL的未来版本中，可以通过重新标记索引来将任何表达式 \\((\\sum_i e_i)_{,i}\\)  更改为 \\((\\sum_j e_j)_{,i}\\)  来处理这种情况。\n17·7·4 高阶导数 简单的前向模式AD实现（例如算法6）仅考虑一个微分变量。 还必须支持使用微分变量的任何组合的高阶或嵌套微分算符。 一个简单的例子说明这样的表达式可以是\n\\[ a = \\frac{d}{dx} \\left(\\frac{d}{dx} f (x) + 2\\frac{d}{dy} g(x, y)\\right) \\tag{17.70} \\]  考虑泛函框架中嵌套导数的实现的探讨，可以浏览几篇论文（Karczmarczuk，2001； Pearlmutter和Siskind，2007； Siskind和Pearlmutter，2008）。\n在当前的UFL实现中，已经用不同的方式解决了。 考虑方程（17.70），该方法只是首先计算最里面的导数 \\(\\frac{d}{dx} f (x)\\)  和 \\(\\frac{d}{dy} g(x, y)\\)  ，然后计算外面的导数。 这种方法之所以可行，是因为与其他任何表达式一样，将求导计算的结果表示为表达式树。 之所以选择这种方法，是因为它易于实现且易于验证。 其他方法是否更快尚未进行调查。 此外，将来可以尝试使用可选的AD算法，例如反向模式，而无需担心在第一个实现中的嵌套导数。\n外部控制器函数apply_ad可处理可能有嵌套导数的表达式的单变量AD例程。 这个AD例程是一个接受导数表达式节点并返回已计算的单变量导数表达式的函数。 该例程可以是算法7的实现。 apply_ad的结果在数学上与输入相等，但是没有剩余的导数表达式节点。\n函数apply_ad的工作方式是：以后序遍历递归树，发现以导数根表示的子树，并将提供的AD例程应用于导数的子树。 由于apply_ad已访问导数节点的子节点，因此可以确保它们不含导数表达式节点，并且AD例程仅需要使用算法6和7处理上面讨论的情况。\nad_routine的复杂度应为 \\(O(n)\\)  ，其中 \\(n\\)  为表达式树的大小。 导数表达式的大小与原始表达式成比例。 如果表达式树中有 \\(d\\)  个导数表达式节点，则此算法的复杂度为 \\(O(dn)\\)  ，因为ad_routine要应用于子表达式 \\(d\\)  次。 最坏情况，apply_ad的复杂度为 \\(O(n^2)\\)  ，但实际上 \\(d \\ll n\\)  。 该算法的递归实现如图17.4所示。\n图17.4 apply_ad过程的简单递归实现。 17·7·5 基本微分规则 要实现上述算法描述，我们必须为所有表达式节点类型实现微分规则。 算符的导数可以实现为与微分变量无关的通用规则，此乃众所周知，不再赘述。 终端表达式的导数取决于微分变量类型。 字面常量的导数当然总是为零，并且只有几何量的空间导数为非零。 由于UFL不知道形式参数（它们由形式编译器从外部提供），因此它们的空间导数( \\(\\frac{\\partial \\phi^k}{\\partial x_i}\\)  和 \\(\\frac{\\partial w^k}{\\partial x_i}\\)  ) 也被视为输入参数。 在所有导数计算中，均假设形式系数不依赖于微分变量。 还有另外两种情况需要解释，用户定义变量和关于Coefficient的系数的导数。\n如果 \\(v\\)  是一个Variable，那么我们可为任意终端表达式t定义 \\(\\frac{dv}{dt} \\equiv 0\\)  。 如果 \\(v\\)  为标量值，则 \\(\\frac{dv}{dv}\\equiv 1\\)  。 此外，如果 \\(V\\)  是张量值Variable，那么它关于自身的导数就是\n\\[ \\frac{dV}{dV}=\\frac{d V_{ij}}{d V_{kl}} e_i \\otimes e_j \\otimes e_k \\otimes e_l = \\delta_{ik}\\delta_{jl}e_i \\otimes e_j \\otimes e_k \\otimes e_l \\tag{17.71} \\]  另外，变量关于除了自身的其它量的导数，等于其表示的表达式的导数：\n\\[ v = g \\tag{17.72} \\]  \\[ \\frac{dv}{dz}= \\frac{dg}{dz} \\tag{17.73} \\]  最后，我们考虑算符导数，它表示关于函数 \\(w\\)  的所有系数 \\(\\{w_k\\}\\)  的微分。 考虑一个对象单元，它表示一个以 \\(\\{\\phi_k\\}\\)  为基底的有限元空间 \\(V_h\\)  。 接下来考虑在此空间中定义的形式参数：\n# UFL code # v = Argument(element) # 在较新版本中报错 v = Argument(element, 1) w = Coefficient(element) Argument实例 \\(v\\)  表示任何 \\(v\\in \\{\\phi_k\\}\\)  ，而Coefficient实例 \\(w\\)  代表求和\n\\[ w = \\sum_k w_k \\phi_k(x) \\tag{17.74} \\]   \\(w\\)  关于任意 \\(w_k\\)  的导数是 \\(V_h\\)  中对应的基函数，\n\\[ \\frac{\\partial w}{\\partial w_k}= \\phi_k, \\qquad k = 1, \\dots , |V_h| \\tag{17.75} \\]  可以用v表示，因为\n\\[ v \\in \\langle \\phi_k\\rangle^{|V_h|}_{k=1} = \\left\\langle \\frac{\\partial w}{w_k}\\right\\rangle^{|V_h|}_{k=1} \\tag{17.76} \\]  请注意， \\(v\\)  应该是尚未在形式中使用的基函数实例。\n17·8 算法 在本节中，将讨论一些核心算法和关键实现问题，其中大部分与Python编程语言有关。 因此，本节主要面向开发人员以及需要在技术层面上与UFL相关的其他人员。 Python用户可能还会在这里发现一些有趣的技术。\n17·8·1 Python中的有效树遍历 使用递归很自然地表示对树中所有节点执行一些操作：\n# Python code def walk(expression, pre_action, post_action): pre_action(expression) for o in expression.operands(): walk(o) post_action(expression) 此实现同时涵盖顺序遍历和后顺序遍历，在顺序遍历中每个节点在其子节点之前被访问，在后顺序遍历中每个节点在其子节点之后被访问。\n在节点集合上实现迭代的一种更“pythonic”的方法是使用生成器。 最小的实现可能是\n# Python code def post_traversal(root): for o in root.operands(): yield post_traversal(o) yield root 然后启用自然的Python语法在表达式节点上进行迭代：\n# Python code for e in post_traversal(expression): post_action(e) 为了提高效率，UFL中post_traversal的实际实现并未使用递归。 函数调用在Python中非常昂贵，这使得非递归实现比上面的实现快一个数量级。\n17·8·2 Python中基于类型的函数分派 符号计算和编译器实现中的常见任务是基于表达式节点类型来选择某些操作。 对于选定的少数几个操作，这是通过使用Expr子类中的函数重载来完成的，但这并不适合所有操作。 在许多情况下，特定类型的操作可以在算法中更好地实现，而不是分布在类定义中。 这种实现模式称为“访问者”模式（Gamma等，1995）。 UFL中的实现与静态类型语言（例如C++）中使用的模式有所不同。\n实现基于类型操作选择的一种方法是使用类型开关，它是一系列if-tests，如下所示：\n# Python code def operation(expression): if isinstance(expression, IntValue): return int_operation(expression) elif isinstance(expression, Sum): return sum_operation(expression) # etc. 这种方法存在几个问题，其中一个是要检查的类型很多时的效率问题。 通过MultiFunction类可以实现一种效率与类型数无关的基于类型的函数分派机制。 底层机制是根据输入参数的类型进行字典查找（为O(1)），然后调用字典中的查找函数。 查找表仅在MultiFunction构造函数中构建一次。 使用Python的运行时类型检查功能会自动发现要插入表中的函数。\n多重函数声明为MultiFunction的子类。 对于应该特别处理的每种类型，在子类中声明一个成员函数。 Expr类使用CamelCaps命名约定，该约定会自动将对应函数名称转换成underscore_notation（例如IndexSum和index_sum）。 如果没有为类型声明处理函数，则使用最接近的超类处理函数。 注意，MultiFunction实现专用于Expr类层次结构中的类型。 以下示例代码说明了多重函数的声明和使用：\n# Python code from ufl.corealg.multifunction import MultiFunction # 译者添加 class ExampleFunction(MultiFunction): def __init__(self): MultiFunction.__init__(self) def terminal(self, expression): return \u0026#34;Got a Terminal subtype %s.\u0026#34; % type(expression) def operator(self, expression): return \u0026#34;Got an Operator subtype %s.\u0026#34; % type(expression) def argument(self, expression): return \u0026#34;Got an Argument.\u0026#34; def sum(self, expression): return \u0026#34;Got a Sum.\u0026#34; m = ExampleFunction() cell = triangle # x = cell.x x = SpatialCoordinate(cell) element = FiniteElement(\u0026#34;Lagrange\u0026#34;, cell, 1) # print(m(Argument(element))) print(m(Argument(element,1))) print(m(x)) print(m(x[0] + x[1])) print(m(x[0] * x[1])) 注意，argument和sum将处理得到确切类型Argument和Sum的实例，而终端表达式和算符将处理类型SpatialCoordinate和Product，因为它们没有特定的处理程序。\n17·8·3 表达式变换的实现 表达式的许多变换可以通过递归实现将某种特定类型的操作应用到每个表达式节点。 操作示例包括将表达式节点转换为字符串表示，使用符号外部库表达式的表示或具有某些不同属性的UFL表示。 此模式的一个简单变体可以使用多重函数来实现，来表示特定类型的操作：\n# Python code def apply(e, multifunction): ops = [apply(o, multifunction) for o in e.operands()] return multifunction(e, *ops) 基本思想如下。 给定一个表达式节点e，首先将变换应用于每个子节点。 然后使用已变换过的子节点作为输入，根据e的类型返回一些特定的运算结果。\nTransformer类实现了此模式。 使用这种模式定义一个新算法涉及到声明一个Transformer子类，并将特定类型的操作实现为此类的成员函数，就像使用MultiFunction一样。 区别在于成员函数对表达式节点的每个操作数都接受一个附加参数。 提供变换后的子节点作为这些附加参数。 以下代码将终端对象替换为在词典映射中找到的对象，并使用变换后的表达式树的reconstructs算符。 通过调用以类Visitor模式命名的visit函数将算法应用于表达式。\n# Python code from ufl.algorithms import Transformer # 译者添加 class Replacer(Transformer): def __init__(self, mapping): Transformer.__init__(self) self.mapping = mapping def operator(self, e, *ops): return e.reconstruct(*ops) def terminal(self, e): return self.mapping.get(e, e) f = Constant(triangle) r = Replacer({f: f**2}) g = r.visit(2*f) # 报错，我尚未找到原因 运行此代码后，结果为 \\(g = 2f^2\\)  。 replace函数的实际实现与此代码相似。\n在某些情况下，不应在子节点的父节点之前访问子节点。 使用Transformer可以轻松表达这种区别，只需为变换后的操作数省略成员函数参数即可。 有关使用此模式的算法的许多示例，请参见源代码。\n【章节目录】\n"}),a.add({id:31,href:'/notes/docs/fem/0121/',title:"UFL：有限元形式语言》形式算符\u0026表达式的表示【翻译】",content:"【章节目录】\n17·5 形式算符 一旦定义了一些形式，就有几种方法可以从中计算相关的形式。 上节的算符可用于定义表达式，本节中讨论的算符被用于形式，从而生成新的形式。 形式算符既可以使形式的定义更紧凑，又可以减少错误的可能，因为原始形式中的更改将自动传播到根据它所计算出的形式中。 这些形式算符可以任意组合； 给定一个半线性形式，只需要几条行即可计算出雅可比伴随的作用。 由于这些计算是在形式编译器处理之前完成的，因此在运行时没有任何开销。\n17·5·1 形式的微分 形式算符derivative声明了一个形式关于离散函数系数（Coefficient）的导数。 例如，可以使用此功能结合Newton-Raphson方法，自动将您的非线性残差方程（线性形式）线性化。 它也可以被多次应用，这对于从凸函数导出线性系统很有用，以便找到使泛函最小化的函数。 对于非平凡方程，手工计算这些表达式可能很繁琐。 此功能可能对其他领域也是有用的，包括最优控制和反演理论，以及灵敏度分析。\n就简单的形式，声明形式   \\(L\\)  关于系数函数 \\(w\\)  的导数：\n# UFL code a = derivative(L, w, u) 形式 \\(a\\)  取决于附加的基函数参数 \\(u\\)  ，该参数必须与函数 \\(w\\)  位于相同的有限元空间中。 如果省略最后一个参数，则会创建一个新的基函数参数。\n让我们逐步介绍一个示例，如何对泛函求导两次，进而导出一个线性系统。 在下文中， \\(V_h\\)  是具有基底的有限元空间， \\(w\\)  是 \\(V_h\\)  中的函数，而 \\(f = f (w)\\)  是我们要最小化的泛函。 从 \\(f (w)\\)  导出的是线性形式 \\(F(w; v)\\)  和双线性形式 \\(J(w; u, v)\\)  。\n\\[ V_h = \\mathrm{span} \\{\\phi_k\\} \\tag{17.52} \\]  \\[ w(x) =\\sum^{|V_h|}_{k=1}w_k \\phi_k(x) \\tag{17.53} \\]  \\[ f : V_h \\to \\mathbb{R} \\tag{17.54} \\]  \\[ F(w; \\phi_i) =\\frac{\\partial f (w)}{\\partial w_i} \\qquad i = 1, \\dots , |V_h| \\tag{17.55} \\]  \\[ J(w; \\phi_j, \\phi) =\\frac{\\partial F(w; \\phi)}{\\partial w_j} \\qquad j = 1, \\dots , |V_h|, \\phi \\in V_h \\tag{17.56} \\]  对于具体的泛函 \\(f (w) = \\int_\\Omega \\frac{1}{2} w^2 dx\\)  ，我们可以将其实现为\n# UFL code v = TestFunction(element) u = TrialFunction(element) w = Coefficient(element) f = 0.5*w**2*dx F = derivative(f, w, v) J = derivative(F, w, u) 此代码声明两种形式F​和J。 线性形式F表示标准载荷矢量w*v*dx，双线性形式J表示质量矩阵u*v*dx。\n也可以是关于有限元混合空间函数的系数的求导。 考虑从泛函导出的调和映射方程\n\\[ f (x, \\lambda) = \\int_\\Omega \\left(\\mathrm{grad} \\ x : \\mathrm{grad} \\ x + \\lambda x \\cdot x\\right) dx \\tag{17.57} \\]  其中， \\(x\\)  是向量有限元空间 \\(V_h^d\\)  中的函数，而 \\(\\lambda\\)  是标量有限元空间 \\(V_h\\)  中的函数。 从等式17.57中的泛函导出的线性和双线性形式，有属于混合空间 \\(V_h^d\\times V_h\\)  中的基函数参数。 可通过自动线性化来得到这些形式\n# UFL code Vx = VectorElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) Vy = FiniteElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) u = Coefficient(Vx*Vy) x, y = split(u) f = inner(grad(x), grad(x))*dx + y*dot(x,x)*dx F = derivative(f, u) J = derivative(F, u) 注意，该泛函通过两个子函数 \\(x\\)  和 \\(y\\)  来表示，而derivative的参数必须是单个混合函数 \\(u\\)  。 在此示例中，derivative的基函数参数被省略，因此自动由正确的函数空间中提供。\n请注意，在计算形式的导数时，我们假设\n\\[ \\frac{\\partial }{\\partial w_k} \\int_\\Omega I dx = \\int_\\Omega \\frac{\\partial}{\\partial w_k} I dx \\tag{17.58} \\]  或更特别地，域 \\(\\Omega\\)  与 \\(w\\)  无关。 同样，除 \\(w\\)  以外的任何系数都被认为与 \\(w\\)  无关。 此外，请注意，在此框架中对单元的选择没有任何限制，特别是支持任意混合单元。\n17·5·2 伴随 另一个形式算子是双线性形式 \\(a\\)  的伴随 \\(a^∗\\)  ，定义为 \\(a^∗(v, u) = a(u, v)\\)  ，等效于组装成稀疏矩阵后再进行转置。 在UFL中，这可以简单地通过交换测试函数和试探函数的顺序来实现，并且可以使用形式算符adjoint。 （请注意，这不是伴随算符的最一般的定义）。 在各向异性扩散项上使用它的一个例子看起来像\n# UFL code V = VectorElement(\u0026#34;Lagrange\u0026#34;, cell, 1) T = TensorElement(\u0026#34;Lagrange\u0026#34;, cell, 1) u = TrialFunction(V) v = TestFunction(V) M = Coefficient(T) a = M[i,j]*u[k].dx(j)*v[k].dx(i)*dx astar = adjoint(a) 对应于（ \\(u\\in U\\)  和 \\(v\\in V\\)  ）\n\\[ a(M; u, v) =\\int_\\Omega M_{ij} u_{k,j} v_{k,i} dx \\tag{17.59} \\]  \\[ a^∗(M; v, u) =\\int_\\Omega M_{ij} u_{k,j} v_{k,i} dx = a(M; u, v) \\tag{17.60} \\]  如果我们需要使用求导来计算非对称双线性形式的伴随，那么这种自动转换特别有用，因为 \\(a\\)  的显式表达式并不在其间。 与derivative结合使用时，以下几种形式算符最有用。\n17·5·3 替换函数 通过使用其他值替换终端对象，可以使用新定义的形式参数来对形式求值。 假定您已经定义了依赖于某些函数 \\(f\\)  和 \\(g\\)  的形式 \\(L\\)  。 然后，您可以通过将这些函数替换为其他函数或固定值，来得到特定形式，比如\n\\[ L(f , g; v) = \\int_\\Omega \\frac{f^2}{2g}v\\ dx \\tag{17.61} \\]  \\[ L_2(f , g; v) = L(g, 3; v) = \\int_\\Omega \\frac{g^2}{6}v\\ dx \\tag{17.62} \\]  此功能通过replace实现了，如下所示：\n# UFL code V = FiniteElement(\u0026#34;Lagrange\u0026#34;, cell, 1) v = TestFunction(V) f = Coefficient(V) g = Coefficient(V) L = f**2 / (2*g)*v*dx L2 = replace(L, { f: g, g: 3}) L3 = g**2 / 6*v*dx L2和L3代表完全相同的形式。 由于它们仅取决于g，为这些形式生成的代码可以更高效。\n17·5·4 作用 在某些应用中，不明确需要矩阵，而只需要矩阵对矢量的作用。 直接组装结果向量，先比组装稀疏矩阵然后执行矩阵-向量乘法要有效得多。 假设 \\(a\\)  是双线性形式， \\(w\\)  是定义在与 \\(a\\)  中试探函数相同的有限元上的系数。 令 \\(A\\)  表示可以从 \\(a\\)  组装的稀疏矩阵。 然后，您可以通过定义代表双线性形式 \\(a\\)  作用于一个函数 \\(w\\)  的线性形式 \\(L\\)  ， 进而直接将其组装成 \\(A\\)  对向量的作用。 简单地表示成L = action(a, w)，甚至缩写为L = a*w。\n17·5·5 系统分割 如果您更喜欢将PDE的所有项都写在一侧，比如\n\\[ a(u, v) − L(v) = 0 \\tag{17.63} \\]  您可以同时声明线性项和双线性项，然后将方程拆分为 \\(a\\)  和 \\(L\\)  。 一个简单的例子是\n# UFL code V = FiniteElement(\u0026#34;Lagrange\u0026#34;, cell, 1) u = TrialFunction(V) v = TestFunction(V) f = Coefficient(V) pde = u*v*dx - f*v*dx a, L = system(pde) 这里的system用于将PDE分为双线性和线性部分。 或者，可以使用lhs和rhs分别获得这两个部分。 记住，线性部分的结果符号，对应于在公式（17.63）中将L移动到右侧。\n17·5·6 计算函数的敏感性 如果您找到了方程（17.63）的解 \\(u\\)  ，并且 \\(u\\)  依赖于某个标量常值 \\(c\\)  ，则可以计算 \\(u\\)  关于 \\(c\\)  的变化灵敏度。 如果 \\(u\\)  被表示成代数线性系统 \\(Ax = b\\)  解的系数向量 \\(x\\)  ，那么 \\(\\frac{\\partial u}{\\partial c}\\)  的系数就是 \\(\\frac{\\partial x}{\\partial c}\\)  。 将 \\(\\frac{\\partial}{\\partial c}\\)  应用于 \\(Ax = b\\)  并使用链式规则，我们可以写成\n\\[ A \\frac{\\partial x}{\\partial c}=\\frac{\\partial b}{\\partial c}−\\frac{\\partial A}{\\partial c} x \\tag{17.64} \\]  因此，可以通过求解相同的代数线性系统算出的 \\(x\\)  来发现 \\(\\frac{\\partial x}{\\partial c}\\)  ， 仅在右侧不同。 可以写出与等式（17.64）右边相对应的线性形式\n# UFL code u = Coefficient(element) sL = diff(L, c) - action(diff(a, c), u) # 执行报错，我尚未做到原因 或者您可以使用等效的形式转换\n# UFL code sL = sensitivity_rhs(a, u, L, c) # 执行报错，我尚未做到原因 请注意，解 \\(u\\)  必须用Coefficient表示，而 \\(a(u, v)中\\)  的 \\(u\\)  用Argument表示。\n17·6 表达式的表示 从高级的角度来看，UFL就是形式的定义。 每种形式都包含一个或多个标量被积表达式，但是形式表示在很大程度上与被积表达式的表示无关。 实际上，UFL实现的大多数复杂性都与表达式的表示，表现和操纵有关。 本章的其余部分将重点介绍表达式的表示以及在其上操作算法。 这些主题对UFL的普通用户几乎没有兴趣，而更多地针对开发人员和好奇的面向技术的用户。\n为了在没有实现细节负担的情况下推理表达式算法，我们需要对表达式结构进行抽象表示。 UFL表达式是程序的表示，并且该表示法应使我们能够看到这种联系。 下面，我们将根据这种抽象符号来讨论表达式的属性，并与特定的实现细节相关。\n17·6·1 表达式的结构 不依赖于其他表达式的最基本的表达式称为终端表达式。 将某些算符应用于一个或多个现有表达式会产生其他表达式。 考虑任意（非终端）表达式 \\(z\\)  。 该表达式依赖于一组终端表达式 \\(\\{t_i\\}\\)  ，并使用了一组算符 \\(\\{f_i\\}\\)  来计算的。 如果 \\(z\\)  的每个子表达式都用一个整数来标记，则可以编写一个抽象程序来计算 \\(z\\)  ，方法是计算 一个子表达式序列 \\(\\langle y_i\\rangle^n_{i = 1}\\)  ，并设置 \\(z = y_n\\)  。算法5显示了这样一个程序。\n每个终端表达式 \\(t_i\\)  是程序的字面常量或输入参数。 这包括了系数，基函数和几何量。 一个非终端子表达式 \\(y_i\\)  是将算符 \\(f_i\\)  应用于先前计算过的表达式序列 \\(\\langle y_j\\rangle_{j\\in \\mathcal{J}_i}\\)  的结果，其中 \\(\\mathcal{J}_i\\)  是表达式有序序列的记号。注意，根据已计算的子表达式，能产生的相同的 \\(z\\)  值的顺序并不是唯一的。 为了正确起见，我们只要求 \\(j\\lt i\\ \\forall j\\in\\mathcal{J}_i\\)  ，这样子表达式 \\(y_i\\)  的所有依赖关系都在 \\(y_i\\)  之前计算出来了。 特别是，在此抽象算法中，出于符号上的方便，所有终端表达式都最先编号。\n计算z的程序可以表示成图，其中每个表达式 \\(y_i\\)  对应于图顶点。 如果 \\(j \\in \\mathcal{J}_i\\)  ，而 \\(y_i\\)  依赖于 \\(y_j\\)  的值，那么这是有向图的一个从 \\(y_i\\)  到 \\(y_j\\)  的边 \\(e = (i, j)\\)  。 更正式地讲，表示计算 \\(z\\)  的图 \\(G\\)  由一组顶点 \\(V\\)  和一组边 \\(E\\)  组成，它们由以下各项定义：\n\\[ G = (V, E) \\tag{17.65} \\]  \\[ V = \\langle v_i \\rangle^n_{i=1} = \\langle y_i \\rangle^n_{i=1} \\tag{17.66} \\]  \\[ E = \\{e_k\\} =\\bigcup^n_{i=1} \\{(i, j)\\ \\forall j \\in \\mathcal{J}_i\\} \\tag{17.67} \\]  此图明显是有向的，因为它的依赖关系是有向的。 它是无环的，因为一个表达式只能根据现有的表达式构造。 因此，UFL表达式可以用有向无环图（DAG）表示。 在UFL中，此DAG可用两种方式表示。 在定义表达式时，会建立一个称为表达式树的链表示。 从技术上讲，这仍然是DAG，因为可以在多个子表达式中重用顶点，但是这个表示强调了DAG的树状结构。 另一个表示称为计算图，它与上面 \\(G\\)  的定义非常相似。 此表示对形式编译器最有用。 这两个DAG表示的细节将在下面说明。 它们都将图形中顶点的表示作为表达式对象共享，下面将对其进行说明。\n17·6·2 表达式对象 回顾一下算法5的非终端表达式 \\(y_i = f_i(\\langle y_j \\rangle_{j\\in \\mathcal{J}_i} )\\)  。 算符 \\(f_i\\)  由表达式对象的类来表示，而表达式 \\(y_i\\)  由此类的实例表示。 在UFL实现中，每个表达式对象都是Expr的某个子类的实例。 Expr类是层次结构的超类，其中包含UFL所支持的所有终端表达式类型和算符类型。 Expr有两个直接的子类，Terminal和Operator，它们将表达式类型层次分为两部分，如图17.2所示。\n图17.2 表达式类的层次结构。 所有表达式对象都被认为是不可变的。 一旦构造了表达式对象，将永远无法对其进行修改。 操作表达式应始终会导致创建新对象。 不可变属性确保表达式对象可以在表达式之间重用和共享，而不会在程序的其他部分产生副作用。 这既减少了内存使用，避免了不必要的对象复制，又简化了对常见子表达式的识别。\n在表示 \\(y_i\\)  的Expr对象e上调用e.operands()，会返回一个具有表示 \\(\\langle y_j \\rangle_{j\\in \\mathcal{J}_i}\\)  的表达式对象的元组。 请注意，也可应用到没有传出边的终端表达式，并且t.operands()返回空元组。 除了修改表达式对象的操作数外，还可以调用e.reconstruct(operands)用修改后的操作数构造相同类型的新表达式对象，其中operands是表达式对象元组。 如果操作数相同，则此函数返回原始对象，从而允许许多算法节省内存而不会带来其他复杂性。 不变式e.reconstruct(e.operands()) == e应该始终成立。\n17·6·3 表达式属性 在第17.4.2节中，讨论了UFL的张量代数和索引记号的功能。 表达式可以是标量或具有任意阶和形状的张量值。 因此，每个表达式对象e的值形状为e.shape()，它是在每个张量轴上维数的整数元组。 标量表达式也有shape ()。 另一个重要的属性是表达式中的一组自由索引，可以使用e.free_indices()作为元组获得。 尽管自由索引没有顺序，但为简单起见，它们以Index实例的元组表示。 因此，元组中的排序没有任何意义。\nUFL表达式在引用上是透明的，但有一些例外。 引用透明性是指子表达式可以用其值的另一种表示代替，而无需更改表达式的含义。 这里的关键是，在这种情况下，表达式的值包括张量形状和一组自由索引。 另一个重要点是，函数 \\(f (v)\\)  在某点导数 \\(f'(v)|_{v=g}\\)  ，依赖于 \\(v = g\\)  附近的函数值。 这种依赖性的结果是，算符类型在微分时很重要，而不仅是微分变量的当前值。 特别是，Variable不能用其表示的表达式替换，因为diff依赖于Variable实例，而不是有值的表达式。 同样，用某个值替换Coefficient会更改包含关于函数系数求导表达式的含义。\n以下示例说明了Variable和diff的这个问题。\n# UFL code e = 0 v = variable(e) f = sin(v) g = diff(f, v) 这里的 \\(v\\)  是一个取值为0的变量，但是 \\(\\sin(v)\\)  不能简化为0，否则 \\(f\\)  的导数将变成0。 此处的正确结果是 \\(g = \\cos(v)\\)  。 打印f和g得到字符串sin(var1(0))和d/d[var1(0)] (sin(var1(0)))。 尝试仅设置 \\(v = e\\)  ，看看f和g如何变为零。\n17·6·4 树表示 表达式树没有单独的数据结构。 它只是查看表达式结构的一种方式。 任何表达式对象e都可以看作是树的根，其中e.operands()返回其子级。 如果某些子项相等，则它们的出现次数将与表达式中出现的次数相同。 因此很容易遍历树节点（也就是DAG中的vi），但是最终无法直接重用子表达式。 DAG中的边不会明确显示，并且只能通过递归遍历树并选择唯一对象来获得顶点列表。\n刚度项 \\(\\mathrm{grad}\\ u : \\mathrm{grad}\\ v\\)  的表达式树如图17.3所示。 终端表达式u和v没有子节点， \\(\\mathrm{grad}\\ u\\)  项本身由带有两个节点的树表示。 每次将算符应用于某些表达式时，它将返回引用其操作数的新树根。 请注意，用户将在使用该语言时应用的是grad和inner函数，而该图中的名称Grad，Inner和Argument是UFL中用来表示表达式对象的Expr子类名称。 换句话说，由grad(u) 获得的表达式梯度，是一个由Grad(u)表示的表达式，而inner(a, b)则给出一个表达式表示Inner(a, b)。 语言和表示的这种分离仅仅是UFL实现中的一种设计选择。\n图17.3 \\(\\mathrm{grad}\\ u : \\mathrm{grad}\\ v\\)  的表达式树。 17·6·5 图表示 当以树的形式查看表达式时，所有唯一顶点和边的列表都不是直接可用的。 更加直接地表示DAG可以简化或优化许多算法。 UFL包括从任何表达式构建基于DAG表示的数组的工具（计算图）。 计算图 \\(G = (V, E)\\)  是基于平面数组的数据结构，直接反映了方程（17.65）-（17.67）中图的定义。 此表示可直接访问子表达式之间的依赖关系，并允许在唯一顶点上轻松进行迭代。 该图可通过以下几行轻松构建：\n# Python code # from ufl.algorithms import Graph from ufl.formatting.graph import Graph G = Graph(expression) V, E = G 一个数组（Python列表）V用于存储DAG中的顶点 \\(\\langle v_i\\rangle^n_{i=1}\\)  。 对于每个顶点 \\(v_i\\)  ，存储一个表达式节点 \\(y_i\\)  来表示。 因此，每个顶点的表达式树也是直接可用的，因为每个表达式节点都是其表达式树的根。 边则存储在数组 \\(E\\)  中，整数元组 \\((i,j)\\)  表示从 \\(v_i\\)  到 \\(v_j\\)  的边； 也就是说， \\(v_j\\)  是 \\(v_i\\)  的操作数。 图中的顶点列表是使用深度优先遍历的后序来构建的，这保证了对顶点进行拓扑排序，使得 \\(j\\lt i\\quad \\forall j\\in \\mathcal{J}_i\\)  。\n让我们看一个计算图的例子。 以下代码定义一个简单表达式，然后打印图的顶点和边缘。\n# Python code from ufl import * cell = triangle V = FiniteElement(\u0026#34;Lagrange\u0026#34;, cell, 1) u = TrialFunction(V) v = TestFunction(V) c = Constant(cell) f = Coefficient(V) e = c*f**2*u*v # from ufl.algorithms import Graph, partition from ufl.formatting.graph import Graph, partition G = Graph(e) V, E, = G print(\u0026#34;str(e) = %s\\n\u0026#34; % str(e)) print(\u0026#34;\\n\u0026#34;.join(\u0026#34;V[%d] = %s\u0026#34; % (i, v) for (i, v) in enumerate(V)), \u0026#34;\\n\u0026#34;) print(\u0026#34;\\n\u0026#34;.join(\u0026#34;E[%d] = %s\u0026#34; % (i, e) for (i, e) in enumerate(E)), \u0026#34;\\n\u0026#34;) 程序输出的摘录如下所示：\n# Generated code V[0] = v_{-2} ... V[7] = v_{-1} * c_0 * w_1 ** 2 V[8] = v_{-2} * v_{-1} * c_0 * w_1 ** 2 ... E[6] = (8, 0) E[7] = (8, 7) 最后两个边，显示了顶点8与顶点7和0的依存关系， 因为 \\(v_8 = v_0 v_7\\)  。 运行代码以查看该代码的完整输出。 尝试更改表达式，然后如上查看图。\n从边E可以有效地计算相关的数组。 特别是顶点vi在两个方向上所依赖的顶点索引是有用的：\n\\[ \\begin{aligned}V_{out} \u0026= \\langle \\mathcal{J}_i\\rangle^n_{i=1} \\\\ V_{in} \u0026= \\langle \\{j|i \\in \\mathcal{J}_j\\}\\rangle^n_{i=1}\\end{aligned} \\tag{17.68} \\]  对任何表达式，这些数组可以很容易构造：\n# Python code Vin = G.Vin() Vout = G.Vout() 存在类似的函数，用于获取所有传入和传出边E的索引。 由UFL构建的计算图有一个不错的特性：没有两个顶点将代表完全相同的表达式。 在图的构建期间，将子表达式插入哈希映射（Python字典）中即可实现此目的。 一些表达式类对参数进行唯一排序，例如a*b和b*a将成为图中的相同顶点。\n当实现某些算法时，表达式节点中的自由索引会使线性化图的解释复杂化，因为具有自由索引的表达式对象不代表一个值，而是代表一组值，自由索引的每个值排列都对应一个值。 一种解决方案是在构造图之前应用expand_indices，它将用自由索引所对应的显式固定索引等效表达式，来替换所有表达式。 但是请注意，展开无法重新获得自由索引。 有关此转换的更多信息，请参见第17.8.3节。\n17·6·6 划分 UFL旨在作为形式编译器的前端。 由于最终目标是根据表达式生成代码，因此为代码生成过程提供了一些实用程序。 原则上，只需在顶点上迭代并分别为每个操作生成代码，就可以从其计算图为表达式生成正确的代码，基本上是算法5的镜像。 但是，一个好的形式编译器应该能够产生更好的代码。 UFL提供了实用程序，用于根据子表达式的依赖性将计算图划分为子图（划分），这允许基于形式编译器的正交，可以轻松地将子表达式放置在正确的循环集中。 函数partition实现此功能。 每个划分都由一个简单的顶点索引数组表示，并且每个划分都标记有一组依赖项。 默认情况下，这组依赖使用字符串x，c和v%d来分别表示对空间坐标，特定数量的胞元和形式参数（非系数）的依赖关系。\n以下示例代码对上面构建的图进行划分，并根据其依存关系将顶点分组打印。\n# Python code partitions, keys = partition(G) for deps in sorted(partitions.keys()): P = partitions[deps] print(\u0026#34;The following depends on\u0026#34;, tuple(deps)) for i in sorted(P): print(\u0026#34;V[%d] = %s\u0026#34; % (i, V[i])) 该程序的输出文本见后。 注意，字面常量2没有依赖。 始终可以在编译时预先计算此划分中的表达式。 常数c_0依赖于每个胞元的变化数据，由依赖集的c代表，而不依赖于空间坐标，因此可以将其置于正交循环之外。 函数w_1及其依赖的表达式还依赖于x表示的空间坐标，因此需要针对每个正交点进行计算。 仅依赖于测试或试探功能的表达式用v%d标记，其中数字是UFL用于区分参数的内部计数器。 请注意，此处的测试和试探函数被标记所依赖的空间坐标，但是不依赖胞元的数量。 这仅适用于在局部参考单元上定义的有限元，在这种情况下，可以在每个正交点中预先计算基函数。 有限元空间中基本函数在运行时的实际依赖关系对于UFL是未知的，这就是为什么函数partition用可选的多功能参数，以便形式编译器可以提供更准确依赖关系的原因。 有关此详细的实现信息，请参考partition的实现。\n# Generated code The following depends on () V[4] = 2 The following depends on (\u0026#34;c\u0026#34;,) V[2] = c_0 The following depends on (\u0026#34;x\u0026#34;, \u0026#34;c\u0026#34;) V[3] = w_1 V[5] = w_1 ** 2 V[6] = c_0 * w_1 ** 2 The following depends on (\u0026#34;x\u0026#34;, \u0026#34;v-1\u0026#34;) V[1] = v_{-1} The following depends on (\u0026#34;x\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;v-1\u0026#34;) V[7] = v_{-1} * c_0 * w_1 ** 2 The following depends on (\u0026#34;x\u0026#34;, \u0026#34;v-2\u0026#34;) V[0] = v_{-2} The following depends on (\u0026#34;x\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;v-2\u0026#34;, \u0026#34;v-1\u0026#34;) V[8] = v_{-2} * v_{-1} * c_0 * w_1 ** 2 【章节目录】\n"}),a.add({id:32,href:'/notes/docs/fem/0120/',title:"UFL：有限元形式语言》表达式【翻译】",content:"【章节目录】\n17·4 定义表达式 UFL的大多数内容涉及如何声明表达式，例如公式17.13中的积分表达式。 最基本的表达式是终值，它们不依赖于其他表达式。 其他表达式称为算符，将在17.4.2-17.4.5节中讨论。\nUFL中的终值类型包括形式参数（这是第17.4.1节的主题），几何量和字面常量。 字面常量中有标量整数和浮点值，以及dxd单位矩阵I = Identity(d)。 要获得单位向量，只需使用单位矩阵的行或列，例如e0 = I[0,:]。 同样，I[i,j]表示Kronecker   \\(\\delta\\)  函数 \\(\\delta_{ij}\\)  （有关索引记号的详细信息，请参见第17.4.2节）。 可用的几何值是空间坐标x ↔ cell.x和维面法线n ↔ cell.n。 几何维数可由cell.d获得。\n17·4·1 形式的参数 基函数和系数函数分别由参数和系数表示。 形式的参数顺序由UFL代码中声明的形式参数的顺序决定。 每个基函数参数代表其有限元空间的基底中的任何函数\n\\[ \\phi^j \\in \\{\\phi_k^j\\}, \\qquad V_h^j = \\mathrm{span} \\left\\{φ_k^j\\right\\} \\tag{17.14} \\]  目的是稍后针对所有 \\(\\phi_k\\)  计算如公式（17.12）所示的形式。 每个系数函数 \\(w\\)  代表有限元空间 \\(V_h\\)  中的离散函数；通常是带系数 \\(w_k\\)  的基函数 \\(\\phi_k\\in V_h\\)  加权和\n\\[ w =\\sum^{|V_h|}_{k=1}w_k\\phi_k \\tag{17.15} \\]  例外情况是系数函数只能逐点求值，这些函数使用带有“正交”族的有限元声明。 基函数被声明为任意单元，如下所示：\n# UFL code # phi = Argument(element)  phi = Argument(element, 0) # 较新的版本中至少要有两个输入； 0表示关联首个子单元 v = TestFunction(element) u = TrialFunction(element) 通过使用TestFunction和TrialFunction声明代替Argument，您可以忽略它们的相对顺序。对于元数为r \u0026gt; 2的形式，只能使用Argument。\n对任意单元，可类似地声明系数函数，并且存在用于声明常系数的简写记号：\n# UFL code w = Coefficient(element) c = Constant(cell) v = VectorConstant(cell) M = TensorConstant(cell) 如果需要混合有限元空间 \\(V_h = V_h^0 \\times V_h^1\\)  中的形式参数 \\(u\\)  ，但是使用子函数 \\(u_0\\in V_h^0\\)  和 \\(u_1\\in V_h^1\\)  更容易表示此形式，则可以使用split的通用方式，将混合函数或基函数分解到其子函数中：\n# UFL code V = V0*V1 # V = element * element # 由于V0和V1前面没给赋值，不妨用这个V代替测试 u = Coefficient(V) u0, u1 = split(u) split函数可以处理任意混合单元。 另外，一个方便的速记符号表示法是在参数声明后加上分隔符\n# UFL code v0, v1 = TestFunctions(V) u0, u1 = TrialFunctions(V) f0, f1 = Coefficients(V) 17·4·2 索引记号 UFL允许同时使用张量代数和索引记号来处理任意秩的张量表达式。 假设大家基本熟悉张量代数和索引记号。 这里的重点是如何在UFL中表示索引记号。\n假设标准正交欧几里德基底 \\(\\{e_k \\in \\mathbb{R}^d\\}^d_{k=1}\\)  ，那么向量可表示成此基底下的标量分量。 二阶张量可以用标量分量来表示，对应的基底是 \\(\\left\\{e_i \\otimes e_j\\right\\}^d_{i, j=1}\\)  。 任意阶张量可以用相同的方式表示，如此所示。\n\\[ v =\\sum^d_{k=1}v_k e_k \\tag{17.16} \\]  \\[ A =\\sum^d_{i=1}\\sum^d_{j=1}A_{ij}e_i \\otimes e_j \\tag{17.17} \\]  \\[ C =\\sum^d_{i=1}\\sum^d_{j=1}\\sum^d_{k=1} C_{ijk}e_i \\otimes e_j \\otimes e_k \\tag{17.18} \\]  在这里， \\(v\\)  ， \\(A\\)  和 \\(C\\)  分别是1、2和3阶张量。 如果索引没有赋值（例如 \\(v_i\\)  中的 \\(i\\)  ），则称其为自由的；如果索引具有固定值（例如 \\(v_1\\)  中的 \\(1\\)  ），则称其为固定的。 带有自由索引的表达式表示您可以通过将固定值分配给索引来获得任意表达式。 表达式 \\(A_{ij}\\)  是标量值，表示欧几里德基底下的张量 \\(A\\)  的任意分量 \\( (i, j)\\)  。 在纸上工作时，很容易在张量记号（ \\(A\\)  ）和索引记号（ \\(A_{ij}\\)  ）之间切换，因为知道张量及其组成部分是相同物理量的不同表示。 在编程语言中，我们必须表示成一个操作，从张量到标量分量的映射，并显式返回。从张量到其分量的映射，对于2阶张量可定义为\n\\[ A_{ij} = A : (e_i \\otimes e_j) \\tag{17.19} \\]  这使用索引记号A[i,j]来做到。 从分量值 \\(A_{ij}\\)  定义张量 \\(A\\)  为\n\\[ A = A_{ij}e_i \\otimes e_j \\tag{17.20} \\]  并使用函数as_tensor(Aij, (i,j))来做到。 为了说明这点，考虑两个向量的外积 \\(A = u \\otimes v = u_i v_j e_i \\otimes e_j\\)  ，以及相应的标量分量 \\(A_{ij}\\)  。 一种实现方法是\n# UFL code A = outer(u, v) Aij = A[i, j] 或者，可以使用索引记号直接表示A的分量，例如 \\(A_{ij} = u_i v_j\\)  。 然后可以通过以下方式将 \\(A_{ij}\\)  映射到 \\(A\\)  ：\n# UFL code Aij = v[j]*u[i] A = as_tensor(Aij, (i, j)) 这两对代码在数学上是等效的，每对代码的结果都是变量A代表张量 \\(A\\)  ，变量Aij代表张量 \\(A_{ij}\\)  。 请注意，自由索引没有顺序，因此它们在表达式v[j]*u[i]中的出现顺序微不足道。 可以使用专用函数as_vector和as_matrix代替as_tensor。 尽管上面的示例使用了2阶张量，但是映射可推广到任意阶张量。\n在为表达式建立索引时，还可以使用固定索引，例如在表示单个标量分量的A[0,1]中。 固定索引也可以与自由索引混合，例如A[0,i]。 另外，可以使用切片代替索引。 使用切片的示例是A[0,:]，它是表示A的第0行的向量表达式。 要创建新索引，您可以创建一个索引或一次创建多个索引：\n# UFL code i = Index() j, k, l = indices(3) 有一组预定义的索引i, j, k, l和p, q, r, s，这些索引对于大多数应用来说应该是足够的。\n如果您的分量不是表示为具有自由索引的表达式，而是表示为独立的不相关的标量表达式，那么可以使用as_tensor及其对等的函数来构建张量。 例如，让我们定义一个2D旋转矩阵，可将向量表达式旋转 \\(\\frac{\\pi}{2}\\)  ：\n# UFL code th = pi/2 A = as_matrix([[ cos(th), -sin(th)], [ sin(th), cos(th)]]) u = A*v 当在一项中出现重复索引时，根据爱因斯坦约定，隐含对这些索引的求和。 特别是，索引化二阶或更高阶张量（A[i,i]），微分一个带自由索引的表达式 (v[i].dx(i))，或者将两个具有共享自由索引的表达式相乘(u[i]*v[i])， 这三种情况都可出现重复指标。\n\\[ A_{ii} \\equiv \\sum_i A_{ii}, \\qquad v_i u_i \\equiv \\sum_i v_i u_i, \\qquad v_{i, i} \\equiv \\sum_i v_{i, i} \\tag{17.21} \\]  表达式Aij = A[i,j]在内部使用Indexed类表示。 Aij是A的引用，并保持原始张量表达式A的表示不变。 隐式求和被显式表示成使用IndexSum类的表达式。 由于这种显式表示，许多算法变得更容易实现， 因为Product实例永远不能隐式表示成求和。 有关表示类的更多详细信息，请参见第17.6节。\n17·4·3 代数算符和函数 UFL定义了可用于组成表达式的一组全面的算符。 基本的代数算符+, -, *, /可以在大多数UFL表达式之间使用，但有一些限制。 除法要求分母是没有自由索引的标量表达式。 求和操作各项必须具有相同的形状和一组自由索引。\n乘法算符*只能在两个标量，一个标量和任何张量，一个矩阵和一个向量以及两个矩阵之间才有效。 对于一些极少数情况，我们可以明确地使用张量代数算符和索引记号来定义其他乘积。 两个具有共享自由索引表达式的乘积意味着对这些索引求和，有关索引记号的更多信息，请参见第17.4.2节。\n三个常用算符是dot(a, b)，inner(a, b)和outer(a, b)。 两个任意阶张量的点积是第1个张量的最后一个索引与第2个张量的第一个索引的求和。 有一些例子：\n\\[ v \\cdot u = v_i u_i \\tag{17.22} \\]  \\[ A \\cdot u = A_{ij} u_j e_i \\tag{17.23} \\]  \\[ A \\cdot B = A_{ik} B_{kj} e_i e_j \\tag{17.24} \\]  \\[ C \\cdot A = C_{ijk} A_{kl}e_i e_j e_l \\tag{17.25} \\]  内积是对所有索引求和，例如 \\[ v : u = v_i u_i \\tag{17.26} \\]  \\[ A : B = A_{ij} B_{ij}, \\tag{17.27} \\]  \\[ C : D = C_{ijkl}D_{ijkl} \\tag{17.28} \\]  外积的一些示例 \\[ v \\otimes u = v_i u_j e_i e_j \\tag{17.29} \\]  \\[ A \\otimes u = A_{ij} u_k e_i e_j e_k \\tag{17.30} \\]  \\[ A \\otimes B = A_{ij} B_{kl} e_i e_j e_k e_l \\tag{17.31} \\]  其他常见的张量代数算符有cross(u,v)，transpose(A)（或A.T），tr(A)，det(A)，inv(A)，ofac(A)，dev（A），skew(A)和sym(A)。这些张量代数算符中的大多数，都要求作用到没有自由索引的张量。 这些算符的详细定义可以在手册中找到。\n作用于无自由索引标量表达式的一组通用基本函数算符， 比如：abs(f)，pow(f, g)，sqrt(f)，exp(f)，ln(f)，cos(f)， sin(f)，tan(f)，acos(f)，asin(f)，atan(f)和sign(f)。 任何携带标量参数的算符，都可逐元地应用到张量上，比如 elem_op(sin, A)。\n17·4·4 微分算符 UFL实现了关于三种不同的变量的导数 。 最常用的一种是空间导数。 表达式也可以求关于任意用户定义变量的微分 。 并且最后一种导数是形式或函数关于离散函数系数的导数； 即关于系数或常数。 形式导数在第17.5.1节中说明。\n请注意，导数在声明时是不会立即计算的。 有关如何计算导数的讨论，请参见第17.7节。\n空间导数 基本空间导数 \\(\\frac{\\partial f}{\\partial x_i}\\)  可以用两种等效的方式表示：\n# UFL code df = Dx(f, i) df = f.dx(i) 在此，df表示 \\(f\\)  在空间方向 \\(x_i\\)  上的导数。 索引 \\(i\\)  可以是代表一个固定空间方向 \\(x_i\\)  上以示区别的整数，也可以是代表以示方向差异的自由索引。 符号f.dx(i)旨在反映索引记号 \\(f_{,i}\\)  ，它是 \\(\\frac{\\partial f}{\\partial x_i}\\)  的简写。 重复索引意味着求和，这样向量值表达式v的散度可以写成 \\(v_{i, i}\\)  或v[i].dx(i)。\n定义了几种常见的复合空间导数算符，即梯度(gradient)，散度(divergence)和旋度算符(curl)。 这些算符分别命名为grad，div，nabla_grad，nabla_div，curl和rot（rot是curl的同义词）。 请注意，定义梯度和散度有两种常用方法，并且UFL同时支持之。\n令 \\(s\\)  为标量表达式， \\(v\\)  为向量表达式， \\(M\\)  为r阶张量表达式。 在UFL中，算符的grad被明确定义为\n\\[ (\\mathrm{grad}(s))_i = s_{,i} \\tag{17.32} \\]  \\[ (\\mathrm{grad}(v))_{ij} = v_{i,j} \\tag{17.33} \\]  \\[ (\\mathrm{grad}(M))_{i_1\\dots i_r k} = M_{i_1\\dots i_r, k} \\tag{17.34} \\]  并且算符div相应地定义为\n\\[ \\mathrm{div}(v) = v_{i, i} \\tag{17.35} \\]  \\[ (\\mathrm{div}(M))_{i_1 \\dots i_{r−1}} = M_{i_1\\dots i_r, i_r} \\tag{17.36} \\]  相反，nabla_*算符的定义依赖 \\(\\nabla\\)  算符\n\\[ ∇ \\equiv e_k \\frac{\\partial}{\\partial x_k} \\tag{17.37} \\]  算符nabla_grad是 \\(\\nabla\\)  与其操作对象的外积：\n\\[ (\\nabla s)_i = s_{,i} \\tag{17.38} \\]  \\[ (\\nabla v)_{ij} = v_{j,i} \\tag{17.39} \\]  \\[ (\\nabla M)_{k,i_1 \\dots i_r} = M_{i_1 \\dots i_r, k} \\tag{17.40} \\]  同样，算符nabla_div是 \\(\\nabla\\)  与其操作对象的点积：\n\\[ \\nabla \\cdot v = v_{i, i} \\tag{17.41} \\]  \\[ (\\nabla \\cdot M)_{i_2 \\dots i_r} = M_{i_1 \\dots i_r, i_1} \\tag{17.42} \\]  从值形状的角度考虑，grad算符将一个轴附加到其操作对象的形状的末尾，而nabla_grad算符则是预先就选定了轴。 对于标量梯度，结果是相同的。 相应地，div算符是与其操作对象关于最后一个索引求和，而nabla_div算符是与其操作对象关于第一个索引求和。 对于向量的散度，也是相同的结果。\n算符curl和rot按惯例是没有区别的。 对3维向量表达式，可以由 \\(\\nabla\\)  算符和叉积来定义旋度：\n\\[ \\begin{aligned}\\mathrm{curl}(v) \u0026 \\equiv \\nabla \\times v \\\\ \u0026=e_0(v_{2,1} − v_{1,2}) − e_1(v_{2,0} − v_{0,2}) + e_2(v_{1,0} − v_{0,1})\\end{aligned} \\tag{17.43} \\]  对于2维向量和标量表达式，定义为：\n\\[ \\mathrm{curl}(v) \\equiv v_{1,0} − v_{0,1} \\tag{17.44} \\]  \\[ \\mathrm{curl}(f) \\equiv f_{,1}e_0 − f_{,0}e_1 \\tag{17.45} \\]  用户定义变量 第二类微分变量是用户定义的变量，可以表示任意表达式。 关于任意量的自动求导，对很多任务都是有用的，比如：从物性定律微分到计算灵敏度。 可以将任意表达式 \\(g\\)  指定为一个变量 \\(v\\)  。 被定义为 \\(v\\)  的函数的表达式 \\(f\\)  ，可对 \\(f\\)  作关于 \\(v\\)  的微分:\n\\[ v = g \\tag{17.46} \\]  \\[ f = f (v) \\tag{17.47} \\]  \\[ h(v) = \\frac{\\partial f (v)}{\\partial v} \\tag{17.48} \\]  设 \\(g = \\sin(x_0)\\)  和 \\(f = e^{v^2}\\)  ，得到 \\(h = 2v e^{v^2} = 2 \\sin(x_0)e^{\\sin^2(x_0)}\\)  ，可以实现如下：\n# UFL code # 在较新的版本中，cell没有x这个成员，改用随后的两行代码 # g = sin(cell.x[0])  x = SpatialCoordinate(cell) g = sin(x[0]) v = variable(g) f = exp(v**2) h = diff(f, v) 尝试在Python会话中运行此代码并打印表达式。 结果是\n# Python code »\u0026gt;print(v) var0(sin((x)[0])) »\u0026gt;print(h) d/d[var0(sin((x)[0]))] (exp((var0(sin((x)[0]))) ** 2)) 注意，该变量有标签“var0”，并且h仍表示抽象导数。第17.7节解释了如何计算导数。\n17·4·5 其他算符 还提供了一些算符来实现不连续Galerkin方法。 基本概念是将表达式限制在内部维面的正侧或负侧，分别简单地表示为v(\u0026quot;+\u0026quot;)或v(\u0026quot;-\u0026quot;)。 最重要的是，实现了算符avg和jump，被定义为\n\\[ \\mathrm{avg}(v) =\\frac{1}{2}(v^+ + v^−) \\tag{17.49} \\]  \\[ \\mathrm{jump}(v) = v^+ − v^− \\tag{17.50} \\]  这些算符只能被用于内部维面上的积分（*dS）。\nUFL中包含的唯一控制流结构是条件表达式。 条件表达式取两个值之一，具体取决于布尔逻辑表达式的结果。 语法是\n# UFL code f = conditional(condition, true_value, false_value) 解释为\n\\[ f = \\left\\{\\begin{aligned}\\mathrm{true\\_value}, \u0026\\qquad 如果 \\mathrm{condition}为真 \\\\ \\mathrm{false\\_value} , \u0026\\qquad 否则 \\end{aligned} \\right. \\tag{17.51} \\]  条件可以是以下之一\n         lt(a, b) \\(\\leftrightarrow (a  gt(a, b \\(\\leftrightarrow (a  b)\\)     le(a, b) \\(\\leftrightarrow (a \\le b)\\)   ge(a, b) \\(\\leftrightarrow (a \\ge b)\\)     eq(a, b) \\(\\leftrightarrow(a = b)\\)   ne(a, b) \\(\\leftrightarrow (a \\ne b)\\)     And(P, Q) \\(\\leftrightarrow (P \\wedge Q)\\)   Or(P, Q) \\(\\leftrightarrow (P \\vee Q)\\)     Not(P) \\(\\leftrightarrow (\\neg P)\\)       【章节目录】\n"}),a.add({id:33,href:'/notes/docs/fem/0119/',title:"UFL：有限元形式语言》概述\u0026有限元空间\u0026形式【翻译】",content:"【章节目录】\n统一形式语言（UFL，Alnæs和Logg，2009年）是一种领域专用语言，用于描述变分形式和函数的有限元离散化。 更准确地说，该语言定义了一个灵活的用户接口，用于定义近似于数学符号弱形式的有限元空间和表达式。\nFEniCS项目提供了一个框架，用于构建求解偏微分方程（PDE）的应用程序。 UFL是此框架的核心组件之一。 它定义了你表示PDE的语言。 它是形式编译器FFC和SFC的输入语言和前端，这在第11章和第15章中介绍过。 UFL实现还提供了可以用形式编译器简化编译过程的算法。 这些形式编译器的输出是符合UFC规范的C++代码（Stroustrup，1997），这在第16章中说明过。 该代码可与第10章介绍的C++/Python库DOLFIN一起使用，以有效地组装线性系统并计算PDE的解。 请注意，本章并未涵盖如何实际求解UFL中定义的方程。 有关如何使用完整的FEniCS框架求解方程式的教程，请参见第1章。\n本章既适合希望学习如何表示方程式的FEniCS用户，也适合希望了解UFL在内部是如何工作的其他FEniCS开发人员和技术用户。 因此，本章的各节将组织更多的技术细节。 第17.1-17.5节概述了终端用户所看到的语言，并面向所有受众。 第17.6-17.9节解释了实现的设计，并深入一些实现细节。 在这样的行文中，必须省略该语言的许多细节，有关更详尽的描述，请参阅UFL手册（Alnæs和Logg，2009）。 请注意，本章涉及UFL版本1.0.0，并且用户接口和实现都可能在将来的版本中更改。\n从简要概述开始，我们提及UFL的主要设计目标，并在第17.1节中展示非平凡PDE的实现例子。 接下来，我们将在第17.2节中介绍如何定义有限元空间，然后在第17.3节中介绍形式的整体结构及其描述。 该语言的主要部分涉及从一组数据类型和运算符定义表达式，这将在17.4节中讨论。 应用于形式整体的算符是第17.5节的主题。\n本章的技术部分从第17.6节开始，讨论表达式的表示。 在这里定义的符号和数据结构基础上，第17.7节讨论了如何计算导数。 第17.8节讨论了一些核心内部算法及其实现中的关键问题。 第17.9节中的主题是一些特定编程语言Python（van Rossum等）中的实现细节。 最后，第17.10节讨论了UFL项目的未来前景。\n17·0·1 相关工作 在其他几个项目中，也从其他角度追求：结合领域专用语言和符号计算的有限元方法。 Sundance（Long，2003，2004b，a）直接在C++中实现了一个符号引擎来定义变分形式，并支持自动微分。 Life项目（Prud’homme，2006b，a）使用基于表达模板技术的嵌入在C++的领域专用语言来指定变分形式。 SfePy（Cimrman等人，2008）使用SymPy作为符号引擎，并通过有限元方法对其进行了扩展。 GetDP（Dular和Geuzaine，2005年）是另一个使用领域专用语言表示变分形式的项目。 Mathematica软件包AceGen（Korelc，1997，2002）使用Mathematica的符号功能为有限元方法生成有效的代码。 所有这些软件包的共同点都集中在偏微分方程的高级描述上，以在仿真软件的开发中实现更高的人工效率。\nUFL几乎类似于符号计算库，但其范围，目标和优先级与通用符号计算项目不同，例如GiNaC（Bauer等人，2002），Swiginac（Skavhaug和ˇCertík，2009）和SymPy（ˇCertík等人，2009）。 作为领域专用语言和形式编译器前端，UFL不适合大规模符号计算。\n17·1 概述 17·1·1 设计目标 UFL是对FFC和SFC早期版本所使用形式语言的统一，完善和重新实现。 这种语言的发展受到诸多因素的推动，其中最重要的是：\n 一种更丰富的形式语言，尤其是其可用于表示非线性PDE。 表达式和形式的自动微分。 提高形式编译器技术的性能，来有效处理更复杂的方程。  UFL满足了所有这些要求，因此，它代表了FEniCS项目功能的重大进步。\nFFC形式语言之后，支持张量代数和索引符号建模，并进一步推广。 该语言包括了一些以前仅SFC支持的非线性算符和函数。 表达式和形式的微分已成为该语言的一个组成部分，比以前在SFC中实现这些功能的方式要容易得多。 总之，UFL作为一种统一的形式语言，结合了FFC和SFC的优点，并增加了其他功能。\n配合以前形式编译器基准，基于UFL的新一代形式编译器所生成的代码效率已被验证匹配。（Alnæs和Mardal，2010；Ølgaard和Wells，2010） 现在，形式编译过程足够快，可以融合到常规应用程序构建过程中。 以前需要太多内存来编译，或者花费数十分钟甚至几小时来编译的复杂形式，现在都可以在几秒钟内用SFC和FFC进行编译。\n17·1·2 动机的例子 在UFL的最初开发过程中，一个主要的动机例子是具有大形变的弹性方程。 特别是，生物组织模型使用具有各向异性和强非线性的复杂超弹性本构定律。 为了用FEniCS实现这些方程，必须解决上面列出的所有三个设计目标。 下面显示了超弹性方程的一种形式及其对应的UFL实现。 请记住，这仅是为了说明形式语言和方程式自然表达之间的紧密对应关系。 这些方程的含义对于读者来说不是必需的。 第27章更详细地介绍了非线性弹性。 注意，许多其他示例与UFL一起分发。\n在这里介绍的超弹性方程的公式中，未知函数是位移向量场   \\(u\\)  。 物性系数 \\(c_1\\)  和 \\(c_2\\)  是标量常数。 根据应变能量函数 \\(W(C)\\)  ，计算第二类Piola-Kirchhoff应力张量 \\(S\\)  。 \\(W\\)  定义了本构定律，这里是简单的Mooney-Rivlin定律。 与位移和应力有关的方程式：\n\\[ \\begin{aligned}F \u0026= I + \\mathrm{grad} \\ u \\\\ C \u0026= F^⊤ F \\\\ I_C \u0026= \\mathrm{tr}(C) \\\\ II_C \u0026=\\frac{1}{2}\\left(\\mathrm{tr}(C)^2 − \\mathrm{tr}(CC)\\right)\\\\ W \u0026= c_1(I_C − 3) + c_2(II_C − 3)\\\\ S \u0026= 2 \\frac{\\partial W} {\\partial C} \\end{aligned} \\tag{17.1} \\]  为了简单起见，在此示例中，我们忽略了外部力和边界力，并假设为准稳态，从而导致以下力学问题。 寻求 \\(u\\)  ，以满足：\n\\[ \\mathrm{div}(FS) = 0, \\qquad \\mathrm{in} \\ dx \\tag{17.2} \\]  \\[ u = u_0, \\qquad \\mathrm{on} \\ ds \\tag{17.3} \\]  有限元方法在第2章中介绍过，因此我们仅将简要地介绍此处采取的步骤。 首先，我们将等式（17.2）与测试函数 \\(\\phi\\in V\\)  相乘，然后在域 \\(\\Omega\\)  上积分，然后分部积分。 于是，非线性变分问题读为：需求 \\(u\\in V\\)  ，满足\n\\[ L(u; \\phi) = \\int_\\Omega FS : \\mathrm{grad} \\ \\phi \\ dx = 0 \\qquad \\forall \\phi \\in V \\tag{17.4} \\]  为了简洁起见，这里我们省略了系数 \\(c_1\\)  和 \\(c_2\\)  。 将位移场近似为 \\(u \\approx u_h = \\sum_k u_k \\psi_k\\)  ，其中 \\(\\psi_k \\in V_h \\approx V\\)  是试探函数，并使用牛顿法求解非线性方程，最终得到一个待求解的方程组\n\\[ \\sum^{|V_h|}_{k=1}\\frac{\\partial L(u_h; \\phi)}{\\partial u_k} \\Delta u_k = −L(u_h; \\phi)\\qquad \\forall \\phi \\in V_h \\tag{17.5} \\]  UFL可以自动计算与等式（17.5）左侧相对应的双线性形式 \\(a(u; \\psi, \\phi)\\)  ，从而\n\\[ a(u_h; \\psi_k, \\phi) =\\frac{\\partial L(u_h; \\phi)}{\\partial u_k}\\qquad k = 1,\\dots, |V_h| \\tag{17.6} \\]  图17.1 使用Mooney-Rivlin物性定律的超弹性方程的UFL实现。 图17.1显示了UFL中公式（17.1），（17.4）和（17.6）的实现。 注意数学符号和UFL源代码之间的紧密关系。 特别要注意，本构定律和残差方程的自动微分。 算符diff可应用于表达式的微分（关于指定变量，例如C）， 而算符derivative可以应用于整个形式的导数（关于比如 \\(u\\)  的离散函数的每个系数）。 这些特征的组合允许通过简单地改变 \\(W\\)  来实现新的物性定律，其余的则是自动的。 在以下各节中，将说明此实现中使用的符号，定义和算符。\n17·2 定义有限元空间 多边形胞元在UFL中由基本形状定义，并被描述为\n# UFL code cell = Cell(shapestring) UFL定义了一组有效的多边形胞元形状：“interval”，“triangle”，“tetrahedron”，“quadrilateral”和“hexahedron”。 所有形状的胞元对象都是预先定义的，可以用下面的写法代替\n# UFL code cell = tetrahedron 在本章的其余部分，变量名cell将被用于任何有合法参数胞元，以使示例的维数尽可能独立。\nUFL定义了用于声明有限元空间的语法，但对实际的多项式基底或自由度一无所知的。 多项式基底是通过在预定的基本单元族中极其提供多项式次数来隐式选择的，但是UFL假定每个有限元空间 \\(V_h\\)  只存在一个具有固定顺序的基础； 那就是\n\\[ V_h = \\mathrm{span} \\left\\{\\phi_j\\right\\}^n_{j=1} \\tag{17.7} \\]  基本的标量单元可以组合形成矢量单元或张量单元，并且单元可以轻松地组合为任意混合单元的层次结构。\nUFL中的一组预定义单元族名称包括“ Lagrange”（简称“ CG”），代表标量Lagrange有限元（连续的分段多项式函数），“ Discontinuous Lagrange”（简称“ DG”），代表标量不连续的Lagrange有限元（不连续的分段多项式函数），以及可以在手册中找到的其他族的范围。 为了方便起见，每个族都有一个关联的简称。要从Python将所有有效族打印到屏幕，请调用show_elements()。\n声明单元的语法最好通过一些示例进行解释。\n# UFL code cell = tetrahedron P = FiniteElement(\u0026#34;Lagrange\u0026#34;, cell, 1) V = VectorElement(\u0026#34;Lagrange\u0026#34;, cell, 2) T = TensorElement(\u0026#34;DG\u0026#34;, cell, 0, symmetry=True) TH = V*P ME = MixedElement(T, V, P) 在第一行中，从一组预定义的胞元中选择一个多边形胞元。 然后声明了标量线性拉格朗日单元P，以及二次矢量拉格朗日单元V。 接下来定义一个对称的2秩张量单元T，它在每个胞元上也是分段恒定的。 代码继续声明了混合单元TH，该单元将二次矢量单元V和线性标量单元P组合在一起。 该单元被称为Taylor-Hood单元。 最后，声明另一个具有三个子单元的混合单元。 请注意，T*V*P的写法不会导致具有三个直接子单元的混合单元，而只会产生MixedElement(MixedElement(T, V), P)。\n17·3 定义形式 考虑在 \\(\\partial\\Omega_0\\)  和 \\(\\partial\\Omega_1\\)  上两个不同边界条件的泊松方程，\n\\[ a(w; u, v) = \\int_\\Omega w \\ \\mathrm{grad} \\ u \\cdot \\mathrm{grad} \\ v \\ dx \\tag{17.8} \\]  \\[ L(f , g, h; v) = \\int_\\Omega f v \\ dx + \\int_{\\partial \\Omega_0}g^2 v \\ ds + \\int_{\\partial \\Omega_1}h v \\ ds \\tag{17.9} \\]  这些形式可以在UFL中表示为：\n# UFL code a = w*dot(grad(u), grad(v))*dx L = f*v*dx + g**2*v*ds(0) + h*v*ds(1) 其中，乘以测度dx，ds(0)和ds(1)分别表示积分 \\(\\int_{\\Omega}(\\cdot)dx\\)  ，积分 \\(\\int_{\\Omega_0}(\\cdot)ds\\)  和 \\(\\int_{\\Omega_1}(\\cdot)ds\\)  。\nUFL所表示的形式用于有限元离散化，然后编译为用于计算单元张量的有效代码。 考虑上面的示例，在一系列基函数并且系数函数固定后，具有一个系数函数 \\(w\\)  的双线性形式 \\(a\\)  在各点已被算出，即\n\\[ V_h^1 = \\mathrm{span} \\left\\{\\phi_k^1\\right\\}, V_h^2 = \\mathrm{span} \\left\\{\\phi_k^2\\right\\}, V_h^3 = \\mathrm{span} \\left\\{\\phi_k^3\\right\\} \\tag{17.10} \\]  \\[ w =\\sum^{|V_h^3|}_{k=1}w_k\\phi_k^3, \\qquad \\{w_k\\} 给定 \\tag{17.11} \\]  \\[ A_{ij} = a(w; \\phi_i^1, \\phi_j^2), \\qquad i = 1, \\cdots, |V_h^1|, j = 1,\\cdots , |V_h^2| \\tag{17.12} \\]  通常，UFL旨在表示以下一般化的形式：\n\\[ \\begin{aligned}\u0026a(w^1, . . . , w^n; \\phi^1, \\dots, \\phi^r) \\\\ = \u0026\\sum^{n_c}_{k=1} \\int_{\\Omega_k}I_k^c dx + \\sum^{n_e}_{k=1} \\int_{\\partial\\Omega_k}I_k^e ds + \\sum^{n_i}_{k=1} \\int_{\\Gamma_k}I_k^i dS \\end{aligned}\\tag{17.13} \\]  本章的大部分内容讨论定义积分表达式 \\(I_k^c\\)  ， \\(I_k^e\\)  和 \\(I_k^i\\)  的方法。 其余的符号将在下面说明。\n形式的参数分为两组，即基函数 \\(\\phi^1, \\dots , \\phi^r\\)  和系数函数 \\(w^1, \\dots , w^n\\)  。 所有 \\(\\{\\phi^k\\}\\)  和 \\(\\{w^k\\}\\)  都是具有一个基底的某些离散函数空间中的函数。 注意，UFL从来不知道具体的基函数 \\(\\{\\phi_j^k\\}\\)  和系数 \\(\\{w_k\\}\\)  ，但是我们假设每个有限元空间的基底都是固定的。 固定顺序仅在要区别不同形式时才重要，如第17.7节所述。\n有效形式表达式的每个项都必须是一个精确积分的标量值表达式，并且在 \\(\\{\\phi^k\\}\\)  中必须是线性的。 任何项都可能对系数函数具有非线性依赖。 带有一个或两个基函数参数（r = 1, 2）的形式分别称为线性形式或双线性形式，而忽略了它对系数函数的依赖。 在应用程序中使用时，它们将被组装成向量和矩阵。 仅依赖系数函数（r = 0）的形式称为泛函，因为它将被组装为实数。 r\u0026gt;2的多重线性形式也被支持，但不常用的。\n整个域表示为 \\(\\Omega\\)  ，外部边界表示为 \\(\\partial \\Omega\\)  ，而三角剖分的一组内部维面表示为 \\(\\Gamma\\)  。 子域用一个后缀标记，例如 \\(\\Omega_k\\subset\\Omega\\)  。 如上所述，积分是通过与测度相乘来表示的，并且UFL定义了测度 \\(dx\\)  ， \\(ds\\)  和 \\(dS\\)  。 总之，存在三种具有相应UFL表示形式的积分\n  \\(\\int_{\\Omega_k}(\\cdot)dx \\leftrightarrow (\\cdot)*dx(k)\\)  ，称之为胞元积分，  \\(\\int_{\\partial\\Omega_k}(\\cdot)ds \\leftrightarrow (\\cdot)*ds(k)\\)  ，称之为外维面积分，  \\(\\int_{\\Gamma_k}(\\cdot)dS \\leftrightarrow (\\cdot)*dS(k)\\)  ，称之为内维面积分。  可以通过将元数据附加到测度对象上来实现为形式的每项定义不同的正交顺序，例如\n# UFL code dx02 = dx(0, { \u0026#34;integration_order\u0026#34;: 2 }) dx14 = dx(1, { \u0026#34;integration_order\u0026#34;: 4 }) dx12 = dx(1, { \u0026#34;integration_order\u0026#34;: 2 }) L = f*v*dx02 + g*v*dx14 + h*v*dx12 元数据还可用于为每项分别覆盖其他形式编译器特定选项。 有关此特性的更多详细信息，请参见UFL和形式编译器的手册。\n【章节目录】\n"}),a.add({id:34,href:'/notes/docs/fem/0118/',title:"DOLFIN：C++/Python有限元库》注记【翻译】",content:"【章节目录】\n10·4 实现注记 在本节中，我们讨论DOLFIN实现的特定方面，包括并行计算，Python接口的生成，以及即时编译。\n10·4·1 并行计算 DOLFIN支持从多核工作站到大规模的并行超级计算机的并行计算。 它的设计，使用户可以用与串行计算相同的代码来执行并行仿真。\n支持两种并行仿真范式。 第一个范式是共享机器内存的多线程。 第二个范式是针对分布式存储器的完全分布式并行化。 对于这两种范式，都需要对网格进行特殊的预处理。 对于多线程并行化，使用了所谓的着色方法（请参见图10.8a），对于分布式并行化，使用了网格划分方法（请参见图10.8b）。 下面讨论这两种方法的各个方面。 也可以将这些方法组合在一起，从而产生混合方法，以利用现代多核处理器集群的功能。\n共享内存并行计算。 使用OpenMP支持在共享内存机器上对有限元矩阵和向量进行多线程组装。 通过参数系统，设置要使用的线程数来激活它。 例如，代码\n// C++ code parameters[\u0026#34;num_threads\u0026#34;] = 6; 指示DOLFIN在组装过程中使用六个线程。 在组装期间，DOLFIN在网格中的胞元或胞元维面上循环，并计算对全局矩阵或向量的局部贡献，然后将其添加到全局矩阵或向量中。 使用多线程组装时，将为每个线程分配所负责的胞元或维面集。 这对用户是透明的。\n多线程的使用，要求设计时注意避免出现竞争状况（多个线程试图同时写入同一内存位置）。 竞争状况通常会导致程序的行为无法预测。 为了避免在组装过程中出现竞争状况（如果两个线程几乎同时将值添加到全局矩阵或向量中），DOLFIN使用图形着色方法。 在组装之前，对给定进程中的网格“着色”，以便为每个胞元分配一种颜色（实际上是整数），以满足，没有两个相邻的胞元具有相同的颜色。 对于给定问题，胞元是相邻的意义取决于所用有限元的类型。 在大多数情况下，共享顶点的胞元被认为是邻居，但是在其他情况下，共享边或维面的胞元也可能被认为是邻居。 在组装过程中，按颜色组装胞元。 所有第一种颜色的胞元在线程之间共享并组装，然后是下一种颜色。 由于相同颜色的胞元是不相邻的，因此不共享全局矩阵或向量中的实体，因此在组装过程中不会发生竞争状况。 LFIN中的网格着色，使用了Boost Graph Library接口或Zoltan接口（属于Trilinos项目的一部分）。 图10.8a显示了已着色的网格，使得没有两个相邻的胞元（在共享维面的意义上）具有相同的颜色。\n图10.8 网格（a）：基于维面连接的着色，以便共享一个共同维面的胞元具有不同的颜色；网格（b）划分为12个部分，每个分区都用一种颜色表示。 第三方线性代数库中多线程的支持，目前受限的，但这是一个活跃的领域。 可以通过PETSc线性代数后端，来访问支持多线程并发的LU求解器PaStiX。\n分布式内存并行计算。 使用消息传递接口（MPI）支持完全分布式并行计算。 为了能执行并行仿真，应该在MPI和启用了并行线性代数后端（例如PETSc或Trilinos）的情况下编译DOLFIN。 要运行并行仿真，应使用mpirun启动DOLFIN程序（要启动的MPI的程序名，在某些计算机上可能有所不同）。 使用16个进程的C++程序，可使用以下命令执行：\n# Bash code mpirun -n 16 ./myprogram and for Python:\n# Bash code mpirun -n 16 python myprogram.py DOLFIN支持完全分布式的并行网格，这意味着每个处理器仅拥有其所负责的网格部分副本。 这种方法是可扩展的，因为不需要处理器来保存完整网格的副本。 并行仿真中的一个重要步骤是网格划分。 DOLFIN可以使用ParMETIS和SCOTCH（Pellegrini）库并行执行网格划分。 可以通过参数系统指定用于网格划分的库，例如，使用SCOTCH：\n// C++ code parameters[\u0026#34;mesh_partitioner\u0026#34;] = \u0026#34;SCOTCH\u0026#34;; 或使用ParMETIS：\n# Python code parameters[\u0026#34;mesh_partitioner\u0026#34;] = \u0026#34;ParMETIS\u0026#34; 图10.8b显示了已被并行划分为12个域的网格。 每个域都由一个进程负责。\n如果使用MPI启动并行程序，并启用了并行线性代数后端，那么线性代数运算将被并行执行。 在大多数应用程序中，这对用户是透明的。 PVD输出格式支持用于后处理的并行输出，并且其使用方式与串行输出相同。 每个进程都写入一个输出文件，并且单个主输出文件指向由不同进程产生的文件。\n10·4·2 实现和Python接口生成 DOLFIN C++库，通过简单的包装程序和接口生成器SWIG（Beazley，1996； SWIG），为Python提供了封装； 有关更多详细信息，请参见第19章。 封装后的C++库，可通过DOLFIN主dolfin模块内名为cpp的Python模块来访问。【译者注：大部分情况下，可直接访问对应的类/函数名，而无须戴上包含cpp.的类路径】 这意味着可以通过以下方式直接访问其已编译模块的所有功能和类的：\n# Python code from dolfin import cpp Function = cpp.function.Function # 原文是： cpp.Function assemble = cpp.fem.assemble # 原文是：cpp.assemble cpp模块中的类和函数与C++接口中的相应类和函数具有相同的功能。 除了由SWIG自动生成的包装层之外，DOLFIN Python接口还依赖于直接在Python中实现的许多组件。 两者都被导入到名为dolfin的Python模块中。 在以下各节中，介绍了有助于这种集成的DOLFIN接口关键自定义项。 Python接口还与NumPy和SciPy工具包很好地集成在一起，这也在下面讨论。\n10·4·3 UFL集成和即时编译器 在Python接口中，UFL形式语言已与Python封装的DOLFIN C++模块集成在一起。 在解释集成时，我们在本节中使用符号dolfin::Foo或dolfin::bar来表示DOLFIN中的C++类或函数。 对应的SWIG包装类或函数将记作cpp.Foo和cpp.bar。 UFL中的类将记为ufl.Foo，而UFC中的类将记为ufc::foo（注意小写）。 C++封装库顶部附加的Python层中，Python类和函数将记为dolfin.Foo或dolfin.bar。 为方便起见，有时会跳过类和函数的前缀。 本节中介绍的大多数代码段都是伪代码。 其目的是说明特定方法或功能的逻辑。 可能会故意排除部分实际代码。 有兴趣的读者可以检查代码中的特定类或函数，以全面了解实现。\n函数空间的构造。 在Python接口中，集成了ufl.FiniteElement和dolfin::FunctionSpace。 FunctionSpace的声明与ufl.FiniteElement的声明类似，但是FunctionSpace构造函数使用cpp.Mesh（dolfin.Mesh）代替胞元类型（例如，三角形）：\n# Python code mesh = UnitSquare(8, 8) V = FunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 1) 在FunctionSpace的Python构造函数中，ufl.FiniteElement的实例化。 FiniteElement被传递给即时（JIT）编译器，该编译器返回已编译且Python封装的ufc对象：ufc::finite_element和ufc::dofmap。 这两个对象，与网格一起，用于实例化cpp.FunctionSpace。 以下伪代码说明了从Python接口实例化FunctionSpace的方法：\n# Python code class FunctionSpace(cpp.FunctionSpace): def __init__(self, mesh, family, degree): # Figure out the domain from the mesh topology if mesh.topology().dim() == 2: domain = ufl.triangle else: domain = ufl.tetrahedron # Create the UFL FiniteElement self.ufl_element = ufl.FiniteElement(family, domain, degree) # JIT compile and instantiate the UFC classes ufc_element, ufc_dofmap = jit(self.ufl_element) # Instantiate DOLFIN classes and finally the FunctionSpace dolfin_element = cpp.FiniteElement(ufc_element) dolfin_dofmap = cpp.DofMap(ufc_dofmap, mesh) cpp.FunctionSpace.__init__(self, mesh, dolfin_element, dolfin_dofmap) 构造参数（试探和测试函数）。 ufl.Argument类（ufl.TrialFunction和ufl.TestFunction的基类）是Python接口的子类。 作为使用ufl.FiniteElement类实例化的替代，可使用DOLFIN FunctionSpace：\n# Python code u = TrialFunction(V) v = TestFunction(V) 通过从所传递的FunctionSpace中提取ufl.FiniteElement，来在子类构造函数中实例化ufl.Argument基类，以下伪代码对此进行了说明：\n# Python code class Argument(ufl.Argument): def __init__(self, V, index=None): ufl.Argument.__init__(self, V.ufl_element, index) self.V = V 然后使用子类Argument来定义TrialFunction和TestFunction：\n# Python code def TrialFunction(V): return Argument(V, -1) def TestFunction(V): return Argument(V, -2) 系数，函数和表达式。 使用Coefficient定义UFL形式时，用户在组装形式之前必须将其与离散有限元Function或用户定义的Expression相关联。 在DOLFIN C++接口中，用户需要显式地执行此关联（L.f = f）。 在DOLFIN Python接口中，ufl.Coefficient类与DOLFIN Function和Expression类组合，并且形式表达式（Coefficient）中的符号系数及其值（Function或Expression）之间的关联是自动的。 因此，用户可以直接组装，由这些组合类实例来定义的形式：\n# Python code class Source(Expression): def eval(self, values, x): values[0] = sin(x[0]) v = TestFunction(V) f = Source() L = f*v*dx b = assemble(L) Python接口中的Function类是从ufl.Coefficient和cpp.Function继承的，如以下伪代码所示：\n# Python code class Function(ufl.Coefficient, cpp.Function): def __init__(self, V): ufl.Coefficient.__init__(self, V.ufl_element) cpp.Function().__init__(self, V) 实际的构造函数还包括从其他对象实例化Function的逻辑。实际的构造函数还包括从其他对象实例化Function的逻辑。 关于对子函数的访问处理，还包括更复杂的逻辑。\n可以通过两种不同的方式来创建用户定义表达式：（i）作为纯Python表达式； 或（ii）作为JIT编译表达式。 纯Python表达式是从Python中Expression子类实例化的对象。【译者注：在较新的版本中，用户定义表达式继承自UserExpression】 上面的Source类就是一个例子。 Expression类的构造函数的伪代码类似于Function类的伪代码：\n# Python code class Expression(ufl.Coefficient, cpp.Expression): def __init__(self, element=None): if element is None: element = auto_select_element(self.value_shape()) ufl.Coefficient.__init__(self, element) cpp.Expression(element.value_shape()) 如果用户未定义ufl.FiniteElement，DOLFIN将使用auto_select_element函数自动选择一个单元。 此函数将携带Expression的一个“值形状”，作为参数。 用户必须通过重载value_shape方法为向量值或张量值的表达式提供此属性。 基类cpp.Expression使用ufl.FiniteElement的\u0026quot;值形状\u0026quot;来进行初始化。\n实际的代码比上面展示的要复杂得多，作为同一个类，Expression同时被用于处理JIT编译的和纯Python表达式。 还要注意，实际的子类最终是由Python中的元类生成的，这使得可以为已声明的子类作诸如完整性检查。\n在SWIG生成的C++层中，cpp.Expression类由所谓的导子（director）类来封装。 这意味着整个Python类都由dolfin::Expression的C++子类封装的。 C++基类的每个虚拟方法都由SWIG在C++中生成的子类实现。C++基类的每个虚拟方法都由SWIG在C++中生成的子类实现。 这些方法调用该方法的Python版本，用户最终通过在Python中cpp.Expression的子类来实现该方法。\n即时编译表达式。 每次表达式求值时都会从C++回调到Python，因此纯Python表达式的性能可能不太理想。 为了避免这种情况，用户可以使用JIT编译的Expression来替代C++版本的Expression的子类。 因为子类是用C++实现的，所以它不会涉及到Python的任何回调，因此比纯Python表达式要快得多。 通过将C++代码字符串传递给Expression构造函数来生成JIT编译的Expression：\n# Python code e = Expression(\u0026#34;sin(x[0])\u0026#34;) 所传递的字符串用于在C++中生成dolfin::Expression的子类，在该子类中内联到重载的eval方法中。 最终代码是由JIT编译，并使用Instant打包到Python的（请参见第14章）。 然后将生成的Python类导入Python。 该类尚未实例化，因为最终的JIT编译的Expression还需要从ufl.Coefficient继承。 为此，我们动态创建一个类，该类同时从生成的类和ufl.Coefficient继承。\n可以使用类型函数在运行时创建Python中的类。 创建类并返回该类的实例的逻辑在dolfin.Expression的__new__方法中处理，如以下伪代码所示：\n# Python code class Expression(object): def __new__(cls, cppcode=None): if cls.__name__ != \u0026#34;Expression\u0026#34;: return object.__new__(cls) cpp_base = compile_expressions(cppcode) def __init__(self, cppcode): ... generated_class = type(\u0026#34;CompiledExpression\u0026#34;, (Expression, ufl.Coefficient, cpp_base), {\u0026#34;__init__\u0026#34;: __init__}) return generated_class() 实例化JIT编译的Expression时，将调用__new__方法。 但是，当在基类的初始化过程中实例化Expression纯Python子类时，也会调用它。 我们通过检查实例化类名来处理两种情况。 如果该类的名称不是“Expression”，则该调用源自Expression的子类的实例化。 当实例化一个纯Python表达式时，如上面的代码示例中的Source实例，将调用object的__new__方法并返回实例化的对象。 在另一种情况下，当实例化JIT编译表达式时，如上所述，我们需要根据所传递的Python字符串来生成JIT编译基类。 这可以通过调用compile_expressions函数来完成。 在调用type生成最终类之前，先为该类定义__init__方法。 此方法通过自动选择单元类型，并为所创建的Expression设置尺寸来启动新对象。 此过程类似于对Python的Expression类派生。 最后，我们构造一个新类，该类通过调用type来继承JIT编译类和ufl.Coefficient。\ntype函数有三个参数：类名（\u0026ldquo;CompiledExpression\u0026rdquo;），基类（Expression，ufl.Coefficient，cpp_base）以及用于定义类的接口（方法和属性）的字典。 我们提供给生成类的唯一新方法或属性是__init__方法。 生成类后，我们将其实例化并将对象返回给用户。\nUFL形式的组装。 DOLFIN Python接口中的assemble函数，运行用户可以直接组装已声明的UFL形式：\n# Python code mesh = UnitSquare(8, 8) V = FunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 1) u = TrialFunction(V) v = TestFunction(V) c = Expression(\u0026#34;sin(x[0])\u0026#34;) a = c*dot(grad(u), grad(v))*dx A = assemble(a) assemble函数是包装自cpp.assemble函数浅层封装包。 以下伪代码说明了在此层所发生的情况：\n# Python code def assemble(form, tensor=None, mesh=None): dolfin_form = Form(form) if tensor is None: tensor = create_tensor(dolfin_form.rank()) if mesh is not None: dolfin_form.set_mesh(mesh) cpp.assemble(dolfin_form, tensor) return tensor 此处，form是一个ufl.Form，用于生成dolfin.Form，如下所述。 除了form参数，用户可以选择提供张量和（或）网格。 如果未提供张量，则create_tensor函数将自动生成一个张量。 如果form不包含任何参数或函数，那么mesh是可选的。 例如，当组装汇仅包含表达式的函数时。 请注意，以上签名的长度已缩短。 assemble函数还有其他参数，但为清楚起见，此处将其忽略。\n以下伪代码演示了dolfin.Form的构造函数中发生的情况，该构造函数从ufl.Form初始化了基类cpp.Form：\n# Python code class Form(cpp.Form): def __init__(self, form): compiled_form, form_data = jit(form) function_spaces = extract_function_spaces(form_data) coefficients = extract_coefficients(form_data) cpp.Form.__init__(self, compiled_form, function_spaces, coefficients) form首先被传给dolfin.jit函数，用来调用已注册的形式编译器，生成代码，然后JIT对其进行编译。 当前可以选择两种形式的编译器：\u0026ldquo;ffc\u0026quot;和\u0026quot;sfc\u0026rdquo;（参见第11章和第15章）。 每种形式编译器中都定义自己的jit函数，该函数最终将接收该调用。 可以通过设置来选择形式编译器：\n# Python code parameters[\u0026#34;form_compiler\u0026#34;][\u0026#34;name\u0026#34;] = \u0026#34;sfc\u0026#34; 默认的形式编译器是\u0026quot;ffc\u0026quot;。 形式编译器的jit函数返回JIT已编译的ufc::form以及ufl.FormData对象。 后者是一个包含ufl.form元数据的数据结构，用于提取实例化cpp.Form所需的函数空间和系数。 这些数据的提取由extract_function_spaces和extract_coefficients函数处理。\n10·4·4 NumPy和SciPy整合 DOLFIN Python接口中的Matrix和Vector类的值可视为NumPy数组。 这是通过调用向量或矩阵的数组方法来完成的：\n# Python code A = assemble(a) AA = A.array() 在此，A是从形式a组装而来的矩阵。 NumPy数组AA是稠密结构，并且所有值都是从原始数据中复制的。 array函数可以在分布式矩阵或向量上调用，在这种情况下，它将返回存储于本地值。\n直接访问线性代数数据。 uBLAS和MTL4线性代数后端可以直接访问底层数据。uBLAS和MTL4线性代数后端可以直接访问底层数据。 通过data方法，返回作为数据视图的NumPy数组：\n# Python code parameters[\u0026#34;linear_algebra_backend\u0026#34;] = \u0026#34;uBLAS\u0026#34; b = assemble(L) bb = b.data() 此处，b是uBLAS向量，bb是数据b的NumPy视图。 对bb的任何更改将直接影响b。 矩阵也存在类似的方法：\n# Python code parameters[\u0026#34;linear_algebra_backend\u0026#34;] = \u0026#34;MTL4\u0026#34; A = assemble(a) rows, columns, values = A.data() 从压缩行存储格式返回的数据，三个NumPy数组：rows，columns和values。 这些也是代表A的数据视图。 values的任何变化都将直接导致A的相应变化。\n稀疏矩阵和SciPy集成。 rows，columns和values的数据结构可用于从scipy.sparse模块实例化一个csr_matrix（Jones et al。，2009）：\n# Python code from scipy.sparse import csr_matrix rows, columns, values = A.data() csr = csr_matrix((values, columns, rows)) 然后，可以将csr_matrix与其他支持稀疏矩阵的Python模块一起使用，例如scipy.sparse模块和pyamg，后者是代数多网格求解器（Bell等，2011）。\n向量切片。 NumPy为NumPy数组提供了方便的切片接口。 DOLFIN Python接口也提供了向量接口（有关实现的详细信息，请参见第19章）。 切片可用于访问和设置向量中的数据：\n# Python code # Create copy of vector b_copy = b[:] # Slice assignment (c can be a scalar, a DOLFIN vector or a NumPy array) b[:] = c # Set negative values to zero b[b \u0026lt; 0] = 0 # Extract every second value b2 = b[::2] NumPy切片与DOLFIN向量切片之间的区别在于NumPy数组的切片可提供对原始数组的视图，而DOLFIN中提供的是副本。 整数列表/元组，或NumPy数组也可以用于访问和设置向量中的数据。\n# Python code b1 = b[[0, 4, 7, 10]] b2 = b[array((0, 4, 7, 10))] 10·5 历史注记 DOLFIN的第一个公开版本是0.2.0版，于2002年发布。 那时，DOLFIN是一个独立的C++库，具有最小的外部依赖性。 然后，所有功能都作为DOLFIN本身的一部分实现，包括线性代数和有限元形式求值。 尽管仅支持分段线性单元，但DOLFIN提供了变分形式的基本自动化有限元组件。 形式语言是由C++操作符重载实现的。 有关FEniCS形式语言开发概述，以及DOLFIN中实现的早期形式语言的示例，请参见第11章。\n后来，DOLFIN的部分功能已移至外部库或其他FEniCS组件。 FEniCS项目于2003年诞生，此后不久，即2004年发布了0.5.0版本，DOLFIN中的形式求值系统被基于FFC和FIAT的自动代码生成系统所取代。 在第二年，线性代数被PETSc数据结构和求解器的包装器所取代。 这时，引入了DOLFIN Python接口（PyDOLFIN）。 从那时起，Python接口已经从用于DOLFIN C++功能的简单的自动生成的包装层发展到成熟的问题解决环境，该环境支持即时编译变分形式并与外部Python模块（例如NumPy）集成。\n在2006年，简化并重新实现了DOLFIN网格数据结构，以提高效率并扩展功能。 新的数据结构是基于一个轻量级面向对象层，其位于普通连续C/C++数组的底层数据存储之上的，并且与基于完全对象的旧实现相比，效率提高了几个数量级。 本地存储所有网格实体（如胞元和顶点）的面向对象的实现。 带有新网格库的DOLFIN第一个版本是0.6.2版。\n在2007年，引入了UFC接口，并将FFC形式语言与DOLFIN Python接口集成在一起。 还引入了即时编译。 第二年，对DOLFIN的线性代数接口进行了重新设计，从而可以灵活地处理多个线性代数后端。 2009年，在DOLFIN中引入并行计算时，达到了一个重要的里程碑。\n多年来，DOLFIN对设计，接口和实现进行了许多更改。 但是，自从DOLFIN 0.9.0发布以来，它基于新的函数空间抽象引入了DOLFIN函数类的重新设计，仅对接口进行了较小的更改。 自0.9.0版发布以来，在预期第一个稳定版本DOLFIN 1.0版中，完善接口，实现缺少的功能，修复错误和改进文档的大多数工作都已完成。\n【章节目录】\n"}),a.add({id:35,href:'/notes/docs/fem/0117/',title:"DOLFIN：C++/Python有限元库》日志/诊断/参数【翻译】",content:"【章节目录】\n10·3·12 日志／诊断 DOLFIN提供了一个简单的接口来统一处理日志消息，包括警告和错误。 所有消息都收集到单个流中，这使整个程序（包括DOLFIN库）的输出的目的地和格式可由用户控制。\n打印消息。 通常使用info命令打印来自DOLFIN的消息报文。 该命令采用字符串参数和要格式化的变量的可选列表，与标准C printf命令非常相似。 请注意，info命令自动将换行符附加到给定的字符串。 另外，C++用户可以将dolfin::cout和dolfin::endl对象用于消息的C++样式格式，如下所示。\n// C++ code info(\u0026#34;Assembling system of size %d x %d.\u0026#34;, M, N); cout \u0026lt;\u0026lt; \u0026#34;Assembling system of size \u0026#34; \u0026lt;\u0026lt; M \u0026lt;\u0026lt; \u0026#34; x \u0026#34; \u0026lt;\u0026lt; N \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; endl; # Python code info(\u0026#34;Assembling system of size %dx %d.\u0026#34; % (M, N)) info命令和dolfin::cout/endl对象与标准C printf命令和std::cout/endl对象的不同之处在于，输出定向到特殊的流中，其输出可以重定向到标准输以及其他目标。 特别是，可能会完全禁用DOLFIN的输出，或选择打印消息的详细程度，如下所述。\n警告和错误。 除了info命令之外，DOLFIN还提供了warning和error命令，可分别用于发出警告和错误。 这两个命令的工作方式与info命令大致相同。 但是，warning命令将在给定的消息前加上*** Warning: ，而error命令在C++和Python将引发可以捕获的异常。 这两个命令还将以比使用info打印的消息更高的日志级别打印消息。\n设置日志级别。 DOLFIN日志级别确定通过日志系统打印的消息路由。 仅打印高于或等于当前日志级别的消息。 可以使用set_log_level函数设置DOLFIN的日志级别。 该函数需要一个指定日志级别的整数值。 为了简化日志级别的规范，可以使用表10.5中列出的许多预定日志级别之一。 默认日志级别为INFO。 通过从C++调用命令set_log_active(false)和从Python调用set_log_active(False)，可以完全关闭日志消息。 出于技术原因，用于调试消息的日志级别在C++中称为DBG，在Python中称为DEBUG。 表10.5中对此进行了总结。\n表10.5 DOLFIN中的日志级别。 要以任意日志级别打印消息，可以指定log命令的日志级别，如下面的代码示例所示。 【译者注：目前较近Python版DOLFIN已经不支持log命令了，只支持前面info, warning，error这三个日志命令和日志级别设置命令set_log_level,get_log_level和set_log_active。】\n// C++ code  info(\u0026#34;Test message\u0026#34;); // will be printed cout \u0026lt;\u0026lt; \u0026#34;Test message\u0026#34; \u0026lt;\u0026lt; endl; // will be printed log(DBG, \u0026#34;Test message\u0026#34;); // will not be printed log(15, \u0026#34;Test message\u0026#34;); // will not be printed  set_log_level(DBG); info(\u0026#34;Test message\u0026#34;); // will be printed cout \u0026lt;\u0026lt; \u0026#34;Test message\u0026#34; \u0026lt;\u0026lt; endl; // will be printed log(DBG, \u0026#34;Test message\u0026#34;); // will be printed log(15, \u0026#34;Test message\u0026#34;); // will be printed  set_log_level(WARNING); info(\u0026#34;Test message\u0026#34;); // will not be printed cout \u0026lt;\u0026lt; \u0026#34;Test message\u0026#34; \u0026lt;\u0026lt; endl; // will not be printed warning(\u0026#34;Test message\u0026#34;); // will be printed std::cout \u0026lt;\u0026lt; \u0026#34;Test message\u0026#34; \u0026lt;\u0026lt; std::endl; // will be printed! # Python code info(\u0026#34;Test message\u0026#34;) # will be printed log(DEBUG, \u0026#34;Test message\u0026#34;) # will not be printed log(15, \u0026#34;Test message\u0026#34;) # will not be printed set_log_level(DEBUG) info(\u0026#34;Test message\u0026#34;) # will be printed log(DEBUG, \u0026#34;Test message\u0026#34;) # will be printed log(15, \u0026#34;Test message\u0026#34;) # will be printed set_log_level(WARNING) info(\u0026#34;Test message\u0026#34;) # will not be printed warning(\u0026#34;Test message\u0026#34;) # will be printed print \u0026#34;Test message\u0026#34; # will be printed! 对象打印。 可以使用info命令来打印许多标准的DOLFIN对象，如下面的代码示例所示。\n// C++ code info(vector); info(matrix); info(solver); info(mesh); info(mesh_function); info(function); info(function_space); info(parameters); # Python code info(vector) info(matrix) info(solver) info(mesh) info(mesh_function) info(function) info(function_space) info(parameters) 上面的命令将打印简短的非正式消息。 例如，命令info(mesh)可能会导致以下输出：\n\u0026lt;Mesh of topological dimension 2 (triangles) with 25 vertices and 32 cells, ordered\u0026gt; 在Python接口中，也可以通过调用print mesh来打印相同的非正式消息。 要打印更详细的数据，可以将info函数的详细参数设置为true（默认为false），这将打印对象的详细摘要。\n// C++ code info(mesh, true); # Python code info(mesh, True) 一些对象的详细输出可能很长。\n任务和进度条。 除了用于打印消息的基本命令外，DOLFIN还提供了许多命令来组织模拟程序的诊断输出。 两个这样的命令是begin和end。 这些命令可用于程序的嵌套输出。 每次调用begin将缩进级别增加一个单位（两个空格），而每次调用end将缩进级别减小一个单位。\n提供反馈的另一种方法是通过进度条。 DOLFIN为此提供了Progress类。 尽管已经尽力减少了更新进度条的开销，但还是要谨慎使用。 如果在循环的每次迭代中仅执行少量工作，则使用进度条的相对开销可能会很大。 下面的代码示例说明了begin/end命令和进度条的用法。\n// C++ code begin(\u0026#34;Starting nonlinear iteration.\u0026#34;); info(\u0026#34;Updating velocity.\u0026#34;); info(\u0026#34;Updating pressure.\u0026#34;); info(\u0026#34;Computing residual.\u0026#34;); end(); Progress p(\u0026#34;Iterating over all cells.\u0026#34;, mesh.num_cells()); for (CellIterator cell(mesh); !cell.end(); ++cell) { ... p++; } Progress q(\u0026#34;Time-stepping\u0026#34;); while (t \u0026lt; T) { ... t += dt; q = t / T; } # Python code begin(\u0026#34;Starting nonlinear iteration.\u0026#34;) info(\u0026#34;Updating velocity.\u0026#34;) info(\u0026#34;Updating pressure.\u0026#34;) info(\u0026#34;Computing residual.\u0026#34;) end() p = Progress(\u0026#34;Iterating over all cells.\u0026#34;, mesh.num_cells()) for cell in cells(mesh): ... p += 1 q = Progress(\u0026#34;Time-stepping\u0026#34;) while t \u0026lt; T: ... t += dt q.update(t / T) 设定计时器。 可以使用Timer类完成计时。 Timer在创建时会自动启动，并在超出范围时自动停止。 Timer在创建时会自动启动，并在超出范围时自动停止。\n// C++ code void solve(const Matrix\u0026amp; A, Vector\u0026amp; x, const Vector\u0026amp; b) { Timer timer(\u0026#34;Linear solve\u0026#34;); ... } # Python code def solve(A, b): timer = Timer(\u0026#34;Linear solve\u0026#34;) ... return x 可以显式调用Timer的start和stop成员函数。 要直接访问计时器的值，可以调用成员函数value。【译者注：成员函数value已经没有了，改用elapsed。】 可以通过调用list_timings函数来打印在程序执行期间创建的所有计时器的值摘要。\n10·3·13 参数 DOLFIN保留了控制其各个组件行为的参数全局数据库。 通过统一的类型无关的接口（允许检索参数值）来控制参数，修改参数值以及向数据库添加新参数。 DOLFIN的不同组件（类）也依赖于该类每个本地实例的参数。 这允许为类的不同对象设置不同的参数值。\n参数值可以是整数值，实值（标准双精度），字符串值或布尔值。 参数名称不得包含空格。\n访问参数。 可以通过全局变量parameters访问全局参数。 以下代码说明了如何打印全局参数数据库中所有参数的值，以及如何访问和更改参数值。\n// C++ code info(parameters, True); uint num_threads = parameters[\u0026#34;num_threads\u0026#34;]; bool allow_extrapolation = parameters[\u0026#34;allow_extrapolation\u0026#34;]; parameters[\u0026#34;num_threads\u0026#34;] = 8; parameters[\u0026#34;allow_extrapolation\u0026#34;] = true; # Python code info(parameters, True) num_threads = parameters[\u0026#34;num_threads\u0026#34;] allow_extrapolation = parameters[\u0026#34;allow_extrapolation\u0026#34;] parameters[\u0026#34;num_threads\u0026#34;] = 8 parameters[\u0026#34;allow_extrapolation\u0026#34;] = True 可以通过访问名为parameter的成员变量来控制DOLFIN特定组件本地的参数。 以下代码说明了如何为Krylov求解器设置一些参数：\n// C++ code KrylovSolver solver; solver.parameters[\u0026#34;absolute_tolerance\u0026#34;] = 1e-6; solver.parameters[\u0026#34;report\u0026#34;] = true; solver.parameters(\u0026#34;gmres\u0026#34;)[\u0026#34;restart\u0026#34;] = 50; solver.parameters(\u0026#34;preconditioner\u0026#34;)[\u0026#34;reuse\u0026#34;] = true; # Python code solver = KrylovSolver() solver.parameters[\u0026#34;absolute_tolerance\u0026#34;] = 1e-6 solver.parameters[\u0026#34;report\u0026#34;] = True solver.parameters[\u0026#34;gmres\u0026#34;][\u0026#34;restart\u0026#34;] = 50 solver.parameters[\u0026#34;preconditioner\u0026#34;][\u0026#34;reuse\u0026#34;] = True 上面的示例访问嵌套参数数据库\u0026quot;gmres\u0026quot;和\u0026quot;preconditioner\u0026quot;。 DOLFIN参数可以嵌套到任意深度，这有助于将参数组织到不同的类别中。 注意在两个接口中访问嵌套参数的细微差别。 在C++接口中，嵌套参数用方括号(\u0026quot;\u0026hellip;\u0026quot;)访问，而在Python接口中，嵌套参数用方括号[\u0026quot;\u0026hellip;\u0026quot;]访问。 可以使用info函数查看某个组件可用的参数。\n添加参数。 可以用add成员函数将参数（新参数的名称及其默认值）添加到现有参数数据库中。 通过创建Parameters类新实例来创建新参数数据库也很简单。 以下代码演示了如何创建一个新的参数数据库，并向其中添加一对整数值和浮点值参数：\n// C++ code Parameters parameters(\u0026#34;my_parameters\u0026#34;); my_parameters.add(\u0026#34;foo\u0026#34;, 3); my_parameters.add(\u0026#34;bar\u0026#34;, 0.1); # Python code my_parameters = Parameters(\u0026#34;my_parameters\u0026#34;) my_parameters.add(\u0026#34;foo\u0026#34;, 3) my_parameters.add(\u0026#34;bar\u0026#34;, 0.1) 参数数据库类似于Python接口中的字典类。 用户可以遍历键，值和项：\n# Python code for key, value in parameters.items(): print key, value Python字典也可以用于更新参数数据库：\n// Python code d = dict(num_threads=4, krylov_solver=dict(absolute_tolerance=1e-6)) parameters.update(d) 也可以在Python接口中以更紧凑的方式创建参数数据库：\n// Python code my_parameters = Parameters(\u0026#34;my_parameters\u0026#34;, foo=3, bar=0.1, nested=Parameters(\u0026#34;nested\u0026#34;, baz=True)) 解析命令行参数。 命令行参数可以解析到全局参数数据库或任何其他参数数据库。 以下代码说明了如何在C++和Python中解析命令行参数，以及如何将命令行参数传递给程序：\n// C++ code int main(int argc, char* argv[]) { ... parameters.parse(argc, argv); ... } # Python code parameters.parse() # Bash code python myprogram.py --num_threads 8 --allow_extrapolation true 存储参数至文件。 将参数值存储到文件中可能很有用，例如，记录哪些参数值用于运行模拟或重用上一次运行中的一组参数值。 以下代码说明了如何向DOLFIN XML文件中写入参数值，然后从中读取参数值：\n// C++ code File file(\u0026#34;parameters.xml\u0026#34;); file \u0026lt;\u0026lt; parameters; file \u0026gt;\u0026gt; parameters; # Python code file = File(\u0026#34;parameters.xml\u0026#34;) file \u0026lt;\u0026lt; parameters file \u0026gt;\u0026gt; parameters 在启动时，DOLFIN自动扫描当前目录和用户主目录（按此顺序）中的目录.config/fenics以查找名为dolfin_parameters.xml的文件。 如果找到，这些参数将被读入DOLFIN的全局参数数据库。\n【章节目录】\n"}),a.add({id:36,href:'/notes/docs/fem/0116/',title:"DOLFIN：C++/Python有限元库》变分问题/文件/可视化【翻译】",content:"【章节目录】\n10·3·10 变分问题 变分问题（偏微分方程的有限元离散化）可以在DOLFIN中使用solve函数轻松解决。 线性和非线性问题都可以解决。 线性问题必须表示为以下规范形式：寻求   \\(u \\in V\\)  使得\n\\[ a(u, v) = L(v) \\qquad \\forall v \\in \\hat{V} \\tag{10.8} \\]  非线性问题必须表示为以下规范形式：寻求 \\(u \\in V\\)  使得\n\\[ F(u; v) = 0 \\qquad \\forall v \\in \\hat{V} \\tag{10.9} \\]  在以双线性形式 \\(a\\)  和线性形式 \\(L\\)  表示的线性变分问题的情况下，通过组装相应线性系统的矩阵 \\(A\\)  和向量 \\(b\\)  ，然后将边界条件应用于该系统，最终求解这个线性系统。 对于以线性形式 \\(F\\)  和双线性形式 \\(J\\)  （F的导数或雅可比行列）表示的非线性变分问题，其解是通过牛顿法计算的。\n下面的代码示例演示如何求解根据双线性形式 \\(a\\)  ，线性形式 \\(L\\)  和以DirichletBC对象给出的Dirichlet边界条件列表指定的线性变分问题：\n// C++ code std::vector\u0026lt;const BoundaryCondition*\u0026gt; bcs; bcs.push_back(\u0026amp;bc0); bcs.push_back(\u0026amp;bc1); bcs.push_back(\u0026amp;bc2); Function u(V); solve(a == L, u, bcs); # Python code bcs = [bc0, bc1, bc2] u = Function(V) solve(a == L, u, bcs=bcs) 为了解决非线性变分问题，必须提供线性形式F，对于C++，还必须提供其（双线性形式的）导数J。 在Python中，这个导数是自动计算的，但也可以指定为手动的。 在许多情况下，所使用的函数导数，以.ufl格式文件或Python脚本的一部分，来轻松计算导数。 我们在这里展示了如何使用Python接口解决非线性问题。 非线性变分问题可以类似地用C++解决。\n# Python code u = Function(V) v = TestFunction(V) F = inner((1 + u**2)*grad(u), grad(v))*dx - f*v*dx # Let DOLFIN compute Jacobian solve(F == 0, u, bcs=bcs) # Differentiate to get Jacobian J = derivative(F, u) # Supply Jacobian manually solve(F == 0, u, bcs=bcs, J=J) 通过使用LinearVariational{Problem,Solver}和NonlinearVariational{Problem,Solver}类，可以对求解过程进行更高级的控制。 以下代码示例说明了这些类的用法：\n# Python code u = Function(V) problem = LinearVariationalProblem(a, L, u, bcs=bcs) solver = LinearVariationalSolver(problem) solver.parameters[\u0026#34;linear_solver\u0026#34;] = \u0026#34;gmres\u0026#34; solver.parameters[\u0026#34;preconditioner\u0026#34;] = \u0026#34;ilu\u0026#34; solver.solve() # Python code u = Function(V) problem = NonlinearVariationalProblem(F, u, bcs=bcs, J=J) solver = NonlinearVariationalSolver(problem) solver.parameters[\u0026#34;linear_solver\u0026#34;] = \u0026#34;gmres\u0026#34; solver.parameters[\u0026#34;preconditioner\u0026#34;] = \u0026#34;ilu\u0026#34; solver.solve() 这些类可以类似地用于C++。\n求解器类提供了可以调整以控制求解过程的一系列参数。 例如，要查看LinearVariationalSolver或 NonlinearVariationalSolver的可用参数列表，请发出以下命令：\n// C++ code info(solver.parameters, true) # Python code info(solver.parameters, True) 10·3·11 文件I／O和可视化 预处理。 DOLFIN仅在内置网格，形如UnitSquare，UnitCube等，有网格生成功能。 必须使用外部软件来生成更复杂的网格。 为了简化此过程，DOLFIN提供了一个简单的脚本dolfin-convert来将网格从其他格式转换为DOLFIN XML格式。 表10.4列出了当前支持的文件格式。 以下代码说明了如何将网格从Gmsh格式（suffix .msh或.gmsh）转换为DOLFIN XML格式：\n# Bash code dolfin-convert mesh.msh mesh.xml 表10.4 `dolfin-convert`脚本支持的文件格式列表。 将网格转换为DOLFIN XML文件格式后，可以将其读取到程序中，如以下代码示例所示：\n// C++ code Mesh mesh(\u0026#34;mesh.xml\u0026#34;); # Python code mesh = Mesh(\u0026#34;mesh.xml\u0026#34;) 后期处理。 从C++或Python发出plot命令，可以对解（Function），Mesh或MeshFunction 进行可视化：\n// C++ code plot(u); plot(mesh); plot(mesh_function); # Python code plot(u) plot(mesh) plot(mesh_function) 使用plot命令生成示例图10.6和10.7。 在Python中，还可以绘制表达式和有限元：\n# Python code plot(grad(u)) plot(u*u) element = FiniteElement(\u0026#34;BDM\u0026#34;, tetrahedron, 3) plot(element) 图10.6 使用DOLFIN `plot`命令绘制网格，此处是DOLFIN分发的网格dolfin-1.xml.gz。 图10.7 使用DOLFIN `plot`命令绘制标量值和矢量值函数，来自图10.6网格上Stokes方程解的压力（左）和速度（右）。 要通过Python与绘图窗口进行交互（旋转，缩放），请调用函数interactive，或在plot命令中添加可选参数interactive = True。 【译者注：interactive目前已经弃用了】 plot命令提供了基本的绘图功能，高级的后期处理可以通过外部软件（例如ParaView和MayaVi2）更好地处理。 通过将解（Function对象）存储为PVD格式（ParaView Data，一种基于XML的格式）来轻松实现此目的。 可以在C++和Python中通过写入扩展名为.pvd的文件来完成，如以下代码示例所示：\n// C++ code File file(\u0026#34;solution.pvd\u0026#34;); file \u0026lt;\u0026lt; u; # Python code file = File(\u0026#34;solution.pvd\u0026#34;) file \u0026lt;\u0026lt; u 标准PVD格式基于ASCII的，因此，对于大型数据集，文件可能会变得非常大。 要使用压缩的二进制格式，在创建基于PVD的File对象时可以使用字符串\u0026quot;compressed\u0026quot;：\n// C++ code File file(\u0026#34;solution.pvd\u0026#34;, \u0026#34;compressed\u0026#34;); 如果将多个函数写入同一文件（通过重复使用\u0026laquo;），则数据将解释为时间序列，然后可以在ParaView或MayaVi2中对其进行动画处理。 时间序列的每个帧都存储为.vtu（VTK非结构化数据）文件，并参考存储在.pvd文件中的文件。 写入时间相关数据时，存储每个快照的时间t可能很有用。 如下所示：\n// C++ code File file(\u0026#34;solution.pvd\u0026#34;, \u0026#34;compressed\u0026#34;); file \u0026lt;\u0026lt; std::make_pair\u0026lt;const Function*, double\u0026gt;(\u0026amp;u, t); # Python code file = File(\u0026#34;solution.pvd\u0026#34;, \u0026#34;compressed\u0026#34;); file \u0026lt;\u0026lt; (u, t) 在对使用可变时间步长的仿真进行动画处理时，存储的时间就特别有用。\nPVD格式支持并行后期处理。 并行运行时，将为每个分区上的数据创建一个.pvd文件和一个.vtu文件。 可以使用ParaView无缝查看并行计算的结果。\nDOLFIN XML格式。\nDOLFIN XML是DOLFIN的本机格式。 XML的优点是它是一种健壮且易于阅读的格式。 如果文件被压缩，则与二进制格式相比，文件大小的开销也很小。\n可以使用标准流运算符\u0026laquo;和\u0026raquo;向DOLFIN XML文件中写入DOLFIN中的许多类，如以下代码示例所示：\n// C++ code File vector_file(\u0026#34;vector.xml\u0026#34;); vector_file \u0026lt;\u0026lt; vector; vector_file \u0026gt;\u0026gt; vector; File mesh_file(\u0026#34;mesh.xml\u0026#34;); mesh_file \u0026lt;\u0026lt; mesh; mesh_file \u0026gt;\u0026gt; mesh; File parameters_file(\u0026#34;parameters.xml\u0026#34;); parameters_file \u0026lt;\u0026lt; parameters; parameters_file \u0026gt;\u0026gt; parameters; # Python code vector_file = File(\u0026#34;vector.xml\u0026#34;) vector_file \u0026lt;\u0026lt; vector vector_file \u0026gt;\u0026gt; vector mesh_file = File(\u0026#34;mesh.xml\u0026#34;) mesh_file \u0026lt;\u0026lt; mesh mesh_file \u0026gt;\u0026gt; mesh parameters_file = File(\u0026#34;parameters.xml\u0026#34;) parameters_file \u0026lt;\u0026lt; parameters parameters_file \u0026gt;\u0026gt; parameters 由于FunctionSpace的表示（进而Function的表示）依赖于生成的代码，因此无法读取/写入Function和FunctionSpace对象。\nDOLFIN自动处理压缩的XML文件的读写。 因此，可以通过将网格和其他数据存储在压缩的XML文件中（带有sufﬁx .xml.gz）来节省空间。\n时间序列。 对于时间依赖问题，能以够快速读/写数据的格式，来存储解序列或网格可能很有用。 为此，DOLFIN提供了TimeSeries类。 这使得能够存储（自由度）向量序列和（或）网格。 以下代码说明了如何将矢量序列和网格存储到TimeSeries：\n// C++ code TimeSeries time_series(\u0026#34;simulation_data\u0026#34;); while (t \u0026lt; T) { ... time_series.store(u.vector(), t); time_series.store(mesh, t); t += dt; } # Python code time_series = TimeSeries(\u0026#34;simulation_data\u0026#34;) while t \u0026lt; T: ... time_series.store(u.vector(), t) time_series.store(mesh, t) t += dt TimeSeries中的数据以二进制格式存储，每个存储的数据集（Vector或Mesh）均具有一个文件，并具有一个公共索引。 如下面的代码示例所示，可以通过调用成员函数retrieve从TimeSeries中检索数据。 如果在请求时刻没有存储的数据集，那么将为Vector做线性插值。 对于网格，将使用最接近的数据点。\n// C++ code time_series.retrieve(u.vector(), t); time_series.retrieve(mesh, t); # Python code time_series.retrieve(u.vector(), t) time_series.retrieve(mesh, t) 【章节目录】\n"}),a.add({id:37,href:'/notes/docs/fem/0115/',title:"DOLFIN：C++/Python有限元库》变分形式/组装/边界条件【翻译】",content:"【章节目录】\n10·3·7 变分形式 DOLFIN依靠FEniCS工具链FIAT–UFL–FFC / SFC–UFC来计算有限元变分形式。 使用形式编译器FFC或SFC（第11章和第15章）之一来编译以UFL形式语言表示的变分形式（第17章），DOLFIN使用生成的UFC代码（第16章）来计算（组装）变分形式 。\nUFL形式语言允许广泛的变分形式以接近数学符号的语言来表达，作为例证，下面的表达式定义（或部分定义）了线性弹性问题离散化的双线性和线性形式：\n# UFL code a = inner(sigma(u), epsilon(v))*dx L = dot(f, v)*dx 这应该与相应的数学符号进行比较：\n  \\[ a(u, v) = \\int_\\Omega \\sigma(u) : \\epsilon(v)dx \\tag{10.3} \\]  \\[ L(v) = \\int_\\Omega f \\cdot v dx \\tag{10.4} \\]  在此， \\(\\epsilon(v) = (\\mathrm{grad} \\ v + (\\mathrm{grad} \\ v)^T)/2\\)  表示对称梯度， \\(\\sigma(v) = 2\\mu \\epsilon(v) + \\lambda \\mathrm{tr} \\ \\epsilon(v) I\\)  是应力张量。 有关UFL形式语言的详细介绍，请参阅第17章。\nC++接口的用户必须通过在命令行上调用形式编译器来显式处理代码生成过程。 为了求解选择了特定参数值（Lamé常数 \\(\\mu\\)  和 \\(\\lambda\\)  ）的线性弹性问题，用户可以在名为Elasticity.ufl的文件中键入以下代码：\n# UFL code V = VectorElement(\u0026#34;Lagrange\u0026#34;, tetrahedron, 1) u = TrialFunction(V) v = TestFunction(V) f = Coefficient(V) E = 10.0 nu = 0.3 mu = E / (2.0*(1.0 + nu)) lmbda = E*nu / ((1.0 + nu)*(1.0 - 2.0*nu)) def sigma(v): return 2.0*mu*sym(grad(v)) + lmbda*tr(sym(grad(v)))*Identity(v.cell().d) a = inner(sigma(u), sym(grad(v)))*dx L = dot(f, v)*dx 可以使用符合UFL/UFC的形式编译器来编译此代码，以生成UFC C++代码。 例如，使用FFC：\n# Bash code ffc -l dolfin Elasticity.ufl 这将生成一个名为Elasticity.h的C++头文件（包括实现），该头文件可以包含在C++程序中，并用于实例化 \\(a\\)  和 \\(L\\)  这两种形式：\n// C++ code #include \u0026lt;dolfin.h\u0026gt;#include \u0026#34;Elasticity.h\u0026#34; using namespace dolfin; int main() { UnitSquare mesh(8, 8); Elasticity::FunctionSpace V(mesh); Elasticity::BilinearForm a(V, V); Elasticity::LinearForm L(V); MyExpression f; // code for the definition of MyExpression omitted  L.f = f; return 0; } 形式的实例化涉及其定义所在的FunctionSpace实例化。 在创建形式之后，任何出现在形式定义中的系数（此处为右侧f）必须被加上。 Python用户可依赖于自动代码生成，并直接将变分形式定义为Python脚本的一部分：\n# Python code from dolfin import * mesh = UnitSquare(8, 8) V = VectorFunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 1) u = TrialFunction(V) v = TestFunction(V) f = MyExpression() # code emitted for the definition of f E = 10.0 nu = 0.3 mu = E / (2.0*(1.0 + nu)) lmbda = E*nu / ((1.0 + nu)*(1.0 - 2.0*nu)) def sigma(v): return 2.0*mu*sym(grad(v)) + lmbda*tr(sym(grad(v)))*Identity(v.cell().d) a = inner(sigma(u), sym(grad(v)))*dx L = dot(f, v)*dx 这个脚本将触发自动代码生成，以定义FunctionSpace V。 两种形式 \\(a\\)  和 \\(L\\)  的代码生成被推迟到相应的离散算符（矩阵和向量）被组装的那一刻。\n10·3·8 有限元组装 DOLFIN的核心功能是有限元变分形式的组装。 给定变分形式（ \\(a\\)  ），DOLFIN组装出相应的离散算符（ \\(A\\)  ）。 离散算符的组装服从第6章中描述的一般算法。 以下代码说明了如何分别从泛函（ \\(M\\)  ），线性形式（ \\(L\\)  ）和双线性形式（ \\(a\\)  ）组装出标量（ \\(m\\)  ），向量（ \\(b\\)  ）和矩阵（ \\(A\\)  ）：\n// C++ code Vector b; Matrix A; double m = assemble(M); assemble(b, L); assemble(A, a); # Python code m = assemble(M) b = assemble(L) A = assemble(a) 从Python接口组装变分形式会在运行时自动触发代码生成，编译和链接。 生成的代码将自动实例化并发送到DOLFIN C++编译器。 结果，从Python接口进行有限元组装与从C++接口进行组装同样高效，而处理自动代码生成的开销却很小。 生成的代码将被缓存以供以后重用，因此，相同形式的重复组装或两次运行相同程序不会重新触发代码生成。 相反，先前生成的代码会从缓存中自动加载。\nDOLFIN提供了一种通用的组装算法，用于以任何形式组装任何等级的张量（标量，向量，矩阵等）。 这是可能的，因为组装算法依赖于GenericTensor接口，组装算法依赖于变体形式及其特定离散化的部分是在组装之前生成的，并且网格接口是维数无关的。 组装算法接受许多可选参数，这些参数控制在组装之前是否应重置已组装张量的稀疏性，以及在组装之前是否应将张量清零。 如果在特定子域（使用dx(0)， dx(1)等）上定义了形式，参数也可以支持网格的特定子域。\n除了assemble函数外，DOLFIN还提供assemble_system函数，该函数可组装由双线性和线性形式组成的一对形式，并在组装过程中应用基本边界条件。 边界条件的应用作为assemble_system的调用的一部分，可保持所组装矩阵的对称性（请参见第6章）。\n组装算法已针对使用MPI的分布式内存架构（集群）和使用OpenMP的共享内存架构（多核）进行了并行化。 第10.4节对此进行了更详细的讨论。\n10·3·9 边界条件 DOLFIN可以处理Neumann（自然）边界和Dirichlet（基本）边界条件的应用。 自然边界条件通常通过问题的变分陈述来应用，而基本边界条件通常应用于离散的方程组。\n自然边界条件。 自然边界条件通常是作为边界项出现的，这是将微分方程的部分乘以测试函数再积分得到的结果。 作为一个简单的例子，我们考虑线性弹性变分问题。 支配弹性体位移的偏微分方程可以表示为\n\\[ \\begin{aligned} - \\mathrm{div} \\ \\sigma(u) \u0026= f \\qquad \\mathrm{in} \\ \\Omega \\\\ \\sigma \\cdot n \u0026= g \\qquad \\mathrm{on} \\ \\Gamma_N \\subset \\partial \\Omega \\\\ u \u0026= u_0 \\qquad \\mathrm{on} \\ \\Gamma_D \\subset \\partial \\Omega \\end{aligned} \\tag{10.5} \\]  其中， \\(u\\)  是要计算的未知位移场， \\(\\sigma(u)\\)  是应力张量， \\(f\\)  是给定的力密度， \\(g\\)  是在边界的一部分 \\(\\Gamma_N\\)  上的给定牵引， \\(u_0\\)  是在边界的一部分 \\(\\Gamma_D\\)  上的给定位移。 乘以测试函数v并分部积分，我们得到\n\\[ \\int_\\Omega \\sigma(u) : \\epsilon(v)dx − \\int_{\\partial \\Omega}(\\sigma \\cdot n) \\cdot v ds = \\int_\\Omega f \\cdot v dx \\tag{10.6} \\]  这里，我们利用 \\(\\sigma(u)\\)  的对称性，可将 \\(\\mathrm{grad} \\ v\\)  替换为对称梯度 \\(\\epsilon(v)\\)  。 由于位移 \\(u\\)  在Dirichlet边界 \\(\\Gamma_D\\)  上是已知的，因此让 \\(\\Gamma_D\\)  上的 \\(v=0\\)  。 此外，我们用边界 \\(\\Gamma_N\\)  其余部分（Neumann）上的给定牵引 \\(g\\)  替换 \\(\\sigma \\cdot n\\)  以获得\n\\[ \\int_\\Omega \\sigma(u) : \\epsilon(v)dx = \\int_\\Omega f \\cdot v dx + \\int_{\\partial \\Omega}(\\sigma \\cdot n) \\cdot v ds\\int_{\\partial \\Omega}g \\cdot v ds \\tag{10.7} \\]  以下代码演示了，作为.ufl文件的一部分或Python脚本的一部分，如何以UFL形式语言实现此变分问题：\n# UFL code a = inner(sigma(u), sym(grad(v)))*dx L = dot(f, v)*dx + dot(g, v)*ds 要指定边界积分dot(g, v)*ds只沿Neumann边界 \\(\\Gamma_N\\)  求值，必须指定边界的哪一部分包括在 \\(ds\\)  积分中。 如果只有一个Neumann边界，则可以简单地将 \\(ds\\)  积分写为，包括Dirichlet边界在内的，整个边界的积分，因为将沿着Dirichlet边界将测试函数v设置为零。\n如果存在多个Neumann边界条件，则必须使用FacetFunction来指定Neumann边界。 此FacetFunction必须为Mesh的每个维面指定其所属的边界部分。 对于当前示例，一种适当的策略是用0标记Neumann边界上的每个维面，并用1标记所有其他维面（包括域内部维面）。 这可以通过许多不同的方式来完成。 一种简单的方法是使用程序MeshBuilder，并以图形方式标记Mesh的各个维面。 另一个选择是通过DOLFIN类SubDomain。 以下代码说明了如何将 \\(x = 0.5\\)  左侧的所有边界维面标记为第一Neumann边界，而将所有其他边界维面标记为第二Neumann边界。 注意，用on_boundary作为参数，提供给DOLFIN的inside函数。 此参数表明一个点是否位于 \\(\\Omega\\)  的边界 \\(\\partial \\Omega\\)  上，这使我们可以仅标记 \\(x = 0.5\\)  左侧边界维面。 还要注意，使用DOLFIN_EPS可以确保由于有限精度算术而包含的点可能恰好位于 \\(x = 0.5\\)  的右侧。\n// C++ code  class NeumannBoundary : public SubDomain { bool inside(const Array\u0026lt;double\u0026gt;\u0026amp; x, bool on_boundary) const { return x[0] \u0026lt; 0.5 + DOLFIN_EPS \u0026amp;\u0026amp; on_boundary; } }; NeumannBoundary neumann_boundary; FacetFunction\u0026lt;uint\u0026gt; exterior_facet_domains(mesh); exterior_facet_domains.set_all(1); neumann_boundary.mark(exterior_facet_domains, 0); # Python code class NeumannBoundary(SubDomain): def inside(self, x, on_boundary): return x[0] \u0026lt; 0.5 + DOLFIN_EPS and on_boundary neumann_boundary = NeumannBoundary() exterior_facet_domains = FacetFunction(\u0026#34;uint\u0026#34;, mesh) exterior_facet_domains.set_all(1) neumann_boundary.mark(exterior_facet_domains, 0) 当与使用ds(0)和ds(1)定义的积分组合时，这些积分将分别对应于x = 0.5左侧和x = 0.5右侧所有维面边界上的积分。\n一旦将边界指定为FacetFunction，就可以使用该对象来定义相应的积分域。 这在C++和Python中是不同的。 对C++，必须将ds成员变量分配给相应形式的：\n// C++ code a.ds = exterior_facet_domains; L.ds = exterior_facet_domains; 除了根据ds成员变量指定的external_facet_domains之外，可以类似地使用dx成员变量指定cell_domains和使用dS变量指定interior_facet_domains。 请注意，不同形式可能会使用不同的边界定义。 对Python，可以通过下标简单地将边界定义连接到相应的测度：\n# Python code dss = ds[neumann_boundary] a = ... + g*v*dss(0) + h*v*dss(1) + ... 是否正确指定边界是常见的错误来源。 为了调试边界条件的详情，可通过将FacetFunction写入VTK文件（请参阅文件I/O部分）或使用plot命令来绘制指定边界标记的FacetFunction可能会有所帮助。 使用plot命令时，绘图会显示插值到Mesh顶点的维面值。 因此，在这种情况下，必须小心解释靠近区域边界（角）的图。 在VTK输出中不存在该问题。\n基本边界条件。 基本边界条件的应用是由DirichletBC类处理的。 使用此类，可以根据FunctionSpace，Function或Expression以及子域来指定Dirichlet边界条件。 可以根据SubDomain对象或FacetFunction的各项来指定子域。 DirichletBC指定的解应等于给定子域上的给定值。\n以下代码示例说明了，对弹性问题 (10.5)，在Dirichlet边界 \\(\\Gamma_D\\)  （此处假定为 \\(x = 0.5\\)  右侧的边界的一部分）上，如何使用SubDomain类来定义Dirichlet条件 \\(u(x) = u_0(x) = \\sin x\\)  。 或者，可以使用FacetFunction指定子域。\n// C++ code class DirichletValue : public Expression { void eval(Array\u0026lt;double\u0026gt;\u0026amp; values, const Array\u0026lt;double\u0026gt;\u0026amp; x) const { values[0] = sin(x[0]); } }; class DirichletBoundary : public SubDomain { bool inside(const Array\u0026lt;double\u0026gt;\u0026amp; x, bool on_boundary) const { return x[0] \u0026gt; 0.5 - DOLFIN_EPS \u0026amp;\u0026amp; on_boundary; } }; DirichletValue u_0; DirichletBoundary Gamma_D; DirichletBC bc(V, u_0, Gamma_D); # Python code class DirichletValue(Expression): def eval(self, value, x): values[0] = sin(x[0]) class DirichletBoundary(SubDomain): def inside(self, x, on_boundary): return x[0] \u0026gt; 0.5 - DOLFIN_EPS and on_boundary u_0 = DirichletValue() Gamma_D = DirichletBoundary() bc = DirichletBC(V, u_0, Gamma_D) Python用户还可以使用以下紧凑语法：\n# Python code u_0 = Expression(\u0026#34;sin(x[0])\u0026#34;) bc = DirichletBC(V, u_0, \u0026#34;x[0] \u0026gt; 0.5 \u0026amp;\u0026amp; on_boundary\u0026#34;) 为了加快Dirichlet边界条件的应用，Python接口的用户还可以使用函数compile_subdomains。 有关详细信息，请参阅DOLFIN程序员参考。\n可以将Dirichlet边界条件应用于线性系统或与Function相关的自由度矢量，如以下代码示例所示：\n// C++ code bc.apply(A, b); bc.apply(u.vector()); # Python code bc.apply(A, b) bc.apply(u.vector()) 将Dirichlet边界条件应用于线性系统将识别，应设为给定值的，所有自由度，并对线性系统进行修改，以使其解满足边界条件。 这是通过将与Dirichlet值相对应的矩阵行对角线归零并插入1，并将Dirichlet值插入右侧矢量的相应项中来实现的。 边界条件的这种应用不能保持对称性。 如果需要对称性，则可以选择使用assemble_system函数，它在组装过程中对称地应用Dirichlet边界条件。\n多个边界条件可以应用于单个系统或向量。 如果将两个不同的边界条件应用于相同的自由度，则最后应用的值将覆盖任何先前设置的值。\n【章节目录】\n"}),a.add({id:38,href:'/notes/docs/fem/0114/',title:"DOLFIN：C++/Python有限元库》有限元/函数/表达式【翻译】",content:"【章节目录】\n10·3·3 有限元 第2章和第3章讨论的有限元的概念（Ciarlet定义）是由DOLFIN FiniteElement类实现的。 此类在C++和Python接口中的实现方式有所不同。\nFiniteElement类的C++实现依赖于由形式编译器（例如FFC或SFC）生成的代码，分别在第11章和第15章中进行了讨论。 FiniteElement类本质上是UFC类ufc::finite_element的包装器类。 C++ FiniteElement提供了ufc::finite_element的所有功能。 DOLFIN C ++接口的用户通常不会直接使用FiniteElement类，但是它是FunctionSpace类的重要构建块，下面将对此进行讨论。 但是，开发高级算法的用户需要对有限元基函数进行运行时评估，他们需要熟悉FiniteElement接口。 有关详细信息，请参阅DOLFIN程序员参考。\nPython接口也提供了FiniteElement类。 Python FiniteElement类直接从UFL Python模块导入（请参见第17章）。 就其本身而论，它只是可用于定义变分问题的特定有限元标签。 可以使用DOLFIN FunctionSpace类更方便地定义变分问题，因此Python接口的用户很少会遇到FiniteElement类。 但是，希望使用Python开发算法的高级用户， 而此算法需要UFC接口中定义的功能（例如基函数的运行时求值），可以通过在Python接口内显式生成代码来访问此类功能。 这可以通过调用DOLFIN的jit函数（即时编译）来完成，该函数将UFL FiniteElement作为输入并返回一个包含ufc::finite_element和ufc::dofmap的对。 返回的对象是通过首先生成相应的C++代码，然后将该C++代码编译并包装到Python模块中来创建的。 因此，返回的对象可直接在Python中使用。\nFiniteElement的自由度可以通过调用plot(element)从Python接口直接绘制。 这将画出有限元的形状图，并按照第3章中的符号表示其自由度。\n表10.3 DOLFIN 1.0支持的有限元列表。 FEniCS部分支持灰色斜体单元，但并非整个工具链都支持。 表10.3列出了DOLFIN当前支持的有限元（以及工具链FIAT–UFL–FFC / SFC–UFC）。 FiniteElement可以使用其全名或简称来指定（来自Python），如以下代码示例所示：\n// UFL code element = FiniteElement(\u0026#34;Lagrange\u0026#34;, tetrahedron, 5) element = FiniteElement(\u0026#34;CG\u0026#34;, tetrahedron, 5) element = FiniteElement(\u0026#34;Brezzi-Douglas-Marini\u0026#34;, triangle, 3) element = FiniteElement(\u0026#34;BDM\u0026#34;, triangle, 3) element = FiniteElement(\u0026#34;Nedelec 1st kind H(curl)\u0026#34;, tetrahedron, 2) element = FiniteElement(\u0026#34;N1curl\u0026#34;, tetrahedron, 2) 10·3·4 函数空间 DOLFIN FunctionSpace类表示有限元函数空间   \\(V_h\\)  ，如第2章所定义。 FunctionSpace的数据用由Mesh，DofMap和FiniteElement组成的三元组表示：\nFunctionSpace = (Mesh, DofMap, FiniteElement) Mesh定义了计算域及其离散化。 FiniteElement定义了Mesh的任何给定胞元上的局部函数空间。 请注意，如果在同一Mesh上创建两个或更多FunctionSpaces，则该Mesh在两个FunctionSpaces间共享。\n创建函数空间。 对于FiniteElement类，在C++和Python接口中对FunctionSpace的处理方式有所不同。 在C++中，FunctionSpace的实例化依赖于生成的代码。 例如，我们在这里考虑创建一个FunctionSpace，用来表示三角形上的连续分段线性拉格朗日多项式。 首先，必须以UFL形式语言定义相应的有限元。 为此，我们将以下代码输入到名为Lagrange.ufl的文件中：\n// UFL code element = FiniteElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) 然后，我们可以使用FFC之类的形式编译器生成C++代码：\n# Bash code ffc -l dolfin Lagrange.ufl 这将生成一个名为Lagrange.h的文件，我们可以将其包含在C++程序中以实例化给定Mesh上的FunctionSpace：\n// C++ code  #include \u0026lt;dolfin.h\u0026gt;#include \u0026#34;Lagrange.h\u0026#34; using namespace dolfin; int main() { UnitSquare mesh(8, 8); Lagrange::FunctionSpace V(mesh); ... return 0; } 在典型的应用中，不是通过单独的.ufl文件生成FunctionSpace，而是将其作为变分问题的生成代码的一部分来生成的。\n从Python接口，可以直接创建一个FunctionSpace，如以下代码所示，该代码创建与上述示例相同的函数空间（三角形上的分段线性拉格朗日多项式）：\n# Python code mesh = UnitSquare(8, 8) V = FunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 1) 混合空间。 可以从函数空间的任意组合来创建混合函数空间。 作为示例，我们在这里考虑为，离散化的Stokes或不可压缩的Navier–Stokes方程，创建Taylor–Hood函数空间。 此混合函数空间是速度场的矢量值连续分段二次函数空间和压力场的标量连续分段线性函数空间的张量积。 可以很容易地以UFL格式文件（用于代码生成并随后将其包含在C++程序中）或直接在Python脚本中定义，如以下代码示例所示：\n// UFL code V = VectorElement(\u0026#34;Lagrange\u0026#34;, triangle, 2) Q = FiniteElement(\u0026#34;Lagrange\u0026#34;, triangle, 1) W = V*Q # Python code V = VectorFunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 2) Q = FunctionSpace(mesh, \u0026#34;Lagrange\u0026#34;, 1) W = V*Q DOLFIN允许生成任意嵌套的混合函数空间。 混合功能空间可以用作构建较大混合空间的块。 当从两个以上的函数空间（被嵌套在同一级别）创建混合函数空间时，则必须使用MixedElement构造函数（在UFL/C++中）或MixedFunctionSpace构造函数（在Python中）。 这是因为Python会将表达式VQP解释为(V*Q)P，这将创建一个包含两个子空间的混合函数空间：混合空间VQ和空间P。 如果不是这样，则必须使用UFL/C++中的MixedElement([V, Q, P])或Python中的MixedFunctionSpace([V, Q, P])来定义混合函数空间。\n子空间。 对于混合函数空间，可以访问其子空间。 这些子空间通常不同于，被用来在其自由度映射（DofMap对象）中创建混合空间的，函数空间。 子空间对于将边界条件应用于混合单元的组件特别有用。 我们在下面会回到这个问题。\n10·3·5 函数 Function类表示了，在第2章中定义的，有限元空间 \\(V_h\\)  中一个有限元函数 \\(u_h\\)  ：\n\\[ u_h(x) = \\sum^N_{j=1} U_j\\phi_j(x) \\tag{10.2} \\]  其中， \\(U \\in \\mathbb{R}^N\\)  是函数 \\(u_h\\)  的自由度矢量，而 \\(\\{\\phi_j\\}^N_{j=1}\\)  是 \\(V_h\\)  的基底。 Function被表示成FunctionSpace和GenericVector中的项：\nFunction = (FunctionSpace, GenericVector) FunctionSpace定义了函数空间Vh，而GenericVector持有自由度向量U； 参见图10.5。 在分布式内存体系结构上并行运行时，FunctionSpace和GenericVector分布在各个进程中。\n图10.5 由三角形单元组成的网格上的分段线性有限元函数 \\(u_h\\)  。 自由度向量U由网格顶点处的 \\(u_h\\)  值给出。 创建Function。 function!creation\n要在FunctionSpace上创建Function，只需以FunctionSpace作为参数调用Function类的构造函数，如以下代码示例所示：\n// C++ code Function u(V); # Python code u = Function(V) 如果在同一个FunctionSpace上创建了两个或更多Function，则FunctionSpace将在这些Function之间共享。\nFunction通常被用于保存偏微分方程计算出的解。 然后，可以通过求解方程组来获得自由度U，如以下代码例子所示：\n// C++ code Function u(V); solve(A, u.vector(), b); # Python code u = Function(V) solve(A, u.vector(), b) 线性系统的组装和求解过程由Linear/NonlinearVariationalSolver类自动处理，下面将对其进行详细讨论。\nFunction求值。 可以在计算域内的任意点对Function求值。 首先定位包含给定点的网格胞元，然后计算该胞元上基函数的线性组合来，这就是Function的计算值。 查找胞元，利用了一个有效的搜索树算法，该算法是CGAL的一部分。\n以下代码示例说明了标量值和向量值函数在C++和Python接口中的函数求值：\n// C++ code  # Evaluation of scalar function double scalar = u(0.1, 0.2, 0.3); # Evaluation of vector-valued function Array\u0026lt;double\u0026gt; vector(3); u(vector, 0.1, 0.2, 0.3); # Python code # Evaluation of scalar function scalar = u(0.1, 0.2, 0.3) # Evaluation of vector-valued function vector = u(0.1, 0.2, 0.3) 当并行运行在分布式网格时，这些函数只能在存储在本地进程中的网格部分点上求值。\n子函数。 对于在混合FunctionSpace上构造的Function，可以访问Function的子功能（组件），例如绘制混合系统的分量解。 子函数可以以浅拷贝或深拷贝的形式访问。 默认情况下，子函数以浅拷贝形式访问，这意味着子函数与其父函数共享数据。 它们提供对父函数数据的视图。 有时，也可能希望将子函数作为深层副本进行访问。 深度复制的子函数不会与父函数共享其数据（即，所持有自由度向量）。 Function对象的浅层副本和深层副本本身都是Function对象，并且可以（除某些例外）用作常规的Function对象。\n在C++和Python中，创建子函数的浅层副本和深层副本的方式有所不同，如以下代码示例所示：\n// C++ code  Function w(W); // Create shallow copies Function\u0026amp; u = w[0]; Function\u0026amp; p = w[1]; // Create deep copies Function uu = w[0]; Function pp = w[1]; # Python code w = Function(W) # Create shallow copies u, p = w.split() # Create deep copies uu, pp = w.split(deepcopy=True) 请注意，从Python接口访问组件，例如w[0]不会像在C++接口中那样创建新的Function对象。 而是创建一个UFL表达式，该表达式表示原始Function的一个分量。\n10·3·6 表达式 Expression类与Function类密切相关，因为它表示在有限元素空间上可以被求值的函数。 但是，Function必须定义在自由度矢量各项上，而Expression可以根据例如坐标值，其他几何实体或表查询自由地定义。\n通过Expression类的子类，并重载eval函数，可以在C++和Python中定义一个Expression，如下面的代码示例所示，这个示例将函数 \\(f(x, y)= sin x cos y\\)  定义为Expression：\n// C++ code class MyExpression : public Expression { void eval(Array\u0026lt;double\u0026gt;\u0026amp; values, const Array\u0026lt;double\u0026gt;\u0026amp; x) const { values[0] = sin(x[0])*cos(x[1]); } }; MyExpression f; # Python code class MyExpression(Expression): def eval(self, values, x): values[0] = sin(x[0])*cos(x[1]) f = MyExpression() 对于向量值（或张量值）Expression，还必须指定Expression的值形状。 下面的代码示例演示如何实现向量值函数 \\(g(x, y) = (\\sin x, \\cos y)\\)  。 在C++和Python中，值的形状定义略有不同。\n// C++ code  class MyExpression : public Expression { void eval(Array\u0026lt;double\u0026gt;\u0026amp; values, const Array\u0026lt;double\u0026gt;\u0026amp; x) const { values[0] = sin(x[0]); values[1] = cos(x[1]); } uint value_rank() const { return 1; } uint value_dimension(uint i) const { return 2; } }; MyExpression g; # Python code class MyExpression(Expression): def eval(self, values, x): values[0] = sin(x[0]) values[1] = cos(x[1]) def value_shape(self): return (2,) g = MyExpression() 上面的用于表达式定义的函子（functor）构造很强大，并且允许用户定义复杂的表达式，对它的求值可能涉及作为eval函数一部分的任意运算。 对于诸如 \\(f (x, y) = \\sin x \\cos y\\)  和 \\(g(x, y) = (\\sin x, \\cos y)\\)  的简单表达式，Python接口的用户可以使用更简单的语法：\n# Python code f = Expression(\u0026#34;sin(x[0])*cos(x[1])\u0026#34;) g = Expression((\u0026#34;sin(x[0])\u0026#34;, \u0026#34;cos(x[1])\u0026#34;)) 上面的代码将自动生成DOLFIN C++ Expression类的子类，这些子类会使eval函数重载。 这样做的好处是效率更高，因为对eval函数的回调是在C++中而不是在Python中进行的。\n在Python接口中，能被用来实现一个时间依赖表达式的一个特性是，在表达式字符串中使用变量。 例如，可以使用变量 \\(t\\)  表示时间：\n# Python code h = Expression(\u0026#34;t*sin(x[0])*cos(x[1])\u0026#34;, t=0.0) while t \u0026lt; T: h.t = t ... t += dt  \\(t\\)  变量在这里已被用于创建时间依赖表达式。 可以使用任意变量名称，只要它们不与内置函数的名称（例如 \\(\\sin\\)  或 \\(\\exp\\)  ）冲突即可。\n除上述示例外，Python接口还通过提供C++ Expression类的定义来直接定义C++ Expression类的（更复杂的）子类。 有关更多信息，请参阅DOLFIN程序员参考。\n【章节目录】\n"}),a.add({id:39,href:'/notes/docs/fem/0113/',title:"DOLFIN：C++/Python有限元库》网格【翻译】",content:"【章节目录】\n10·3·2 网格 DOLFIN的核心部分是其网格库和Mesh类。 网格库为计算网格提供了数据结构和算法，包括网格连通性（重合关系），网格细化，网格划分和网格相交的计算。\n网格库是用C++实现的，已进行了最小化存储需求的优化，并实现对网格数据的有效访问。 特别是，DOLFIN网格存储在少量连续数组中，在其上是轻量级的面向对象层，可提供对底层数据的查看。 有关网格库设计和实现的详细讨论，请参见Logg（2009）。\n创建一个网格。 DOLFIN提供了用于创建简单网格的功能，例如单位正方形和单位立方体，球体，矩形和盒子的网格。 以下代码演示如何创建单位正方形的16×16三角形网格（由2×16×16 = 512个三角形组成）和单位立方体的16×16×16四面体网格（由6×16×16×16 = 24,576个四面体组成）。\n// C++ code UnitSquareMesh unit_square(16, 16); UnitCubeMesh unit_cube(16, 16, 16); # Python code unit_square = UnitSquareMesh(16, 16) unit_cube = UnitCubeMesh(16, 16, 16) 通过指定网格的胞元和顶点，可以显式构造简单网格（由间隔，三角形或四面体组成的网格）。 类MeshEditor提供了用于创建简单网格的接口。 以下代码演示了如何创建两个三角形组成的网格来覆盖单位正方形：\n// C++ code Mesh mesh; MeshEditor editor; editor.open(mesh, \u0026#34;triangle\u0026#34;, 2, 2); editor.init_vertices(4); editor.init_cells(2); editor.add_vertex(0, 0.0, 0.0); editor.add_vertex(1, 1.0, 0.0); editor.add_vertex(2, 1.0, 1.0); editor.add_vertex(3, 0.0, 1.0); editor.add_cell(0, 0, 1, 2); editor.add_cell(1, 0, 2, 3); editor.close(); # Python code mesh = Mesh(); editor = MeshEditor(); editor.open(mesh, \u0026#34;triangle\u0026#34;, 2, 2) editor.init_vertices(4) editor.init_cells(2) editor.add_vertex(0, [0.0, 0.0]) editor.add_vertex(1, [1.0, 0.0]) editor.add_vertex(2, [1.0, 1.0]) editor.add_vertex(3, [0.0, 1.0]) editor.add_cell(0, [0, 1, 2]) editor.add_cell(1, [0, 2, 3]) editor.close() 从文件读取网格。 尽管内置类UnitSquare和UnitCube可用于测试典型应用程序，但仍需要从文件读取由外部网格生成器生成的网格。 要从文件读取网格，只需将文件名提供给Mesh类的构造函数即可：\n// C++ code Mesh mesh(\u0026#34;mesh.xml\u0026#34;); # Python code mesh = Mesh(\u0026#34;mesh.xml\u0026#34;) 网格必须以DOLFIN XML格式存储。 以下示例说明了单位正方形2×2网格的XML格式：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;dolfin xmlns:dolfin=\u0026#34;http://fenicsproject.org\u0026#34;\u0026gt; \u0026lt;mesh celltype=\u0026#34;triangle\u0026#34; dim=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;vertices size=\u0026#34;9\u0026#34;\u0026gt; \u0026lt;vertex index=\u0026#34;0\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;1\u0026#34; x=\u0026#34;0.5\u0026#34; y=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;2\u0026#34; x=\u0026#34;1\u0026#34; y=\u0026#34;0\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;3\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;4\u0026#34; x=\u0026#34;0.5\u0026#34; y=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;5\u0026#34; x=\u0026#34;1\u0026#34; y=\u0026#34;0.5\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;6\u0026#34; x=\u0026#34;0\u0026#34; y=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;7\u0026#34; x=\u0026#34;0.5\u0026#34; y=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;vertex index=\u0026#34;8\u0026#34; x=\u0026#34;1\u0026#34; y=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/vertices\u0026gt; \u0026lt;cells size=\u0026#34;8\u0026#34;\u0026gt; \u0026lt;triangle index=\u0026#34;0\u0026#34; v0=\u0026#34;0\u0026#34; v1=\u0026#34;1\u0026#34; v2=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;1\u0026#34; v0=\u0026#34;0\u0026#34; v1=\u0026#34;3\u0026#34; v2=\u0026#34;4\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;2\u0026#34; v0=\u0026#34;1\u0026#34; v1=\u0026#34;2\u0026#34; v2=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;3\u0026#34; v0=\u0026#34;1\u0026#34; v1=\u0026#34;4\u0026#34; v2=\u0026#34;5\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;4\u0026#34; v0=\u0026#34;3\u0026#34; v1=\u0026#34;4\u0026#34; v2=\u0026#34;7\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;5\u0026#34; v0=\u0026#34;3\u0026#34; v1=\u0026#34;6\u0026#34; v2=\u0026#34;7\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;6\u0026#34; v0=\u0026#34;4\u0026#34; v1=\u0026#34;5\u0026#34; v2=\u0026#34;8\u0026#34;/\u0026gt; \u0026lt;triangle index=\u0026#34;7\u0026#34; v0=\u0026#34;4\u0026#34; v1=\u0026#34;7\u0026#34; v2=\u0026#34;8\u0026#34;/\u0026gt; \u0026lt;/cells\u0026gt; \u0026lt;/mesh\u0026gt; \u0026lt;/dolfin\u0026gt; 可以使用命令dolfin-convert将以其他数据格式存储的网格转换为DOLFIN XML格式，如下文更详细的解释。\n网格实体。 从概念上讲，网格（由类Mesh建模）由一组网格实体组成。 网格实体是一对   \\((d, i)\\)  ，其中 \\(d\\)  是网格实体的拓扑维数，而 \\(i\\)  是网格实体的唯一索引。 网格实体在每个拓扑维数中从 \\(0\\)  到 \\(n_d−1\\)  编号，其中 \\(n_d\\)  是拓扑维数 \\(d\\)  的网格实体数。\n图10.3 网格的每个实体由一对 \\((d, i)\\)  标识，对其指定了拓扑维数 \\(d\\)  和在 \\(d\\)  维实体集中的唯一索引i。 表10.1 网格实体及其维数/余维数。 实体的余维数为 \\(D-d\\)  ，其中 \\(D\\)  为最大维数， \\(d\\)  为维数。 为了方便起见，将拓扑0维网格实体称为顶点，将1维实体称为边，将2维实体称为面。 余1维实体称为维面(facet)，而余0维实体称为胞元(cell)。 这些概念总结在图10.3和表10.1中。 我们注意到，三角形网格由顶点，边和胞元组成，并且这些边也可以称为维面，而胞元则称为面。 我们进一步注意到，四面体网格由顶点，边，面和胞元组成，并且这些面也可以称为维面。 这些概念由类MeshEntity，Vertex，Edge，Face，Facet和Cell来实现。 这些类不存储任何数据。 相反，它们是轻量级对象，提供基础网格数据的视图。 可以从一个Mesh，一个拓扑维数和一个索引创建一个MeshEntity。 以下代码演示了如何在网格上创建各种实体：\n// C++ code MeshEntity entity(mesh, 0, 33); // vertex number 33 Vertex vertex(mesh, 33); // vertex number 33 Cell cell(mesh, 25); // cell number 25 # Python code entity = MeshEntity(mesh, 0, 33) # vertex number 33 vertex = Vertex(mesh, 33) # vertex number 33 cell = Cell(mesh, 25) # cell number 25 网格拓扑和几何。 网格的拓扑与其几何分开存储。 网格的拓扑是对网格各个实体间关系的描述，而几何则描述了这些实体如何嵌入 \\(\\mathbb{R}^d\\)  中。\n用户很少直接面对MeshTopology和MeshGeometry类，因为大多数关于网格的算法都可以用网格迭代器来表示。 但是，用户有时可能需要访问网格的维数，这涉及访问作为网格的一部分存储的MeshTopology或MeshGeometry，如以下代码示例所示：\n// C++ code uint gdim = mesh.topology().dim(); uint tdim = mesh.geometry().dim(); # Python code gdim = mesh.topology().dim() tdim = mesh.geometry().dim() 应当注意，拓扑和几何维数可能不同。 特别是对于网格边界这种情况，通常是嵌入在 \\(\\mathbb{R}^{D+1}\\)  中的拓扑 \\(D\\)  维网格。 也就是说，几何维数为 \\(D+1\\)  。\n网格连通性。 网格的拓扑由网格的连通性（重合关系）表示，这是对网格实体间相互连接的完整描述。 这种连通性通过MeshConnectivity类存储在DOLFIN中。 对于每对拓扑维 \\(d \\to d'\\quad d, d'= 0, 1, \\dots, D\\)  ，将一个这样的数据集存储为类MeshTopology的一部分，其中 \\(D\\)  是拓扑维。\n表10.2 DOLFIN计算网格的连通性 \\(d \\to d'\\)  ，对每对 \\(d,d' = 0, 1, \\dots, D\\)  。 该表指示哪些连通性对（用×表示）已计算了，以便计算四面体网格的连通性 \\(1 \\to 1\\)  （边-边连通性）。 创建Mesh时，将创建最小的MeshTopology。 仅存储从胞元（ \\(D\\)  维）到顶点（ \\(0\\)  维度）的连通性（MeshConnectivity \\(D \\to 0\\)  ）。 当要求某种连通性时，例如连通性 \\(1 \\to 1\\)  （边-边连通性），DOLFIN自动计算所要求连通性所需的任何其他连通性。 表10.2对此进行了说明，其中我们指出了计算 \\(1 \\to 1\\)  连通性需要哪些连通性。 以下代码演示了如何初始化四面体网格（ \\(D=3\\)  ）的各种网格连通：\n// C++ code mesh.init(2); // Compute faces mesh.init(0, 0); // Compute vertex neighbors for each vertex mesh.init(1, 1); // Compute edge neighbors for each edge # Python code mesh.init(2) # Compute faces mesh.init(0, 0) # Compute vertex neighbors for each vertex mesh.init(1, 1) # Compute edge neighbors for each edge 网格迭代器。 在网格上运行的算法通常可以用迭代器表示。 网格库提供了用于在网格实体上进行迭代的常规迭代器MeshEntityIterator，以及专用的网格迭代器VertexIterator，EdgeIterator，FaceIterator，FacetIterator和CellIterator。\n以下代码说明了如何遍历给定网格的所有胞元的所有顶点的所有重合（连接）顶点。 如果两个顶点都属于同一个胞元，则将它们视为邻居。 对于单纯形网格，这等效于连接两个顶点的边。\n// C++ code for (CellIterator c(mesh); !c.end(); ++c) for (VertexIterator v0(*c); !v0.end(); ++v0) for (VertexIterator v1(*v0); !v1.end(); ++v1) cout \u0026lt;\u0026lt; *v1 \u0026lt;\u0026lt; endl; # Python code for c in cells(mesh): for v0 in vertices(c): for v1 in vertices(v0): print v1 也可以使用通用迭代器MeshEntityIterator实现如下：\n// C++ code uint D = mesh.topology().dim(); for (MeshEntityIterator c(mesh, D); !c.end(); ++c) for (MeshEntityIterator v0(*c, 0); !v0.end(); ++v0) for (MeshEntityIterator v1(*v0, 0); !v1.end(); ++v1) cout \u0026lt;\u0026lt; *v1 \u0026lt;\u0026lt; endl; # Python code D = mesh.topology().dim() for c in entities(mesh, D): for v0 in entities(c, 0): for v1 in entities(v0, 0): print v1 网格函数。 MeshFunction类是用于存储与Mesh相关数据的有用类。 这使得存储，例如决定性参数，子域指示符，网格胞元上的细化标记或网格维面上的边界标记，变得很容易。 MeshFunction是一个离散函数，在给定拓扑维数 \\(d\\)  的每个网格实体上取一个值。 存储在MeshFunction中的值的数量等于 \\(d\\)  维实体 \\(n_d\\)  的数量。 MeshFunction是关于值类型的模板，因此可以用于存储任何类型的值。 为了方便起见，由VertexFunction，EdgeFunction，FaceFunction，FacetFunction和CellFunction类来具体命名MeshFunction。 以下代码说明了如何创建一对MeshFunction，一个用于在胞元上存储子域指示器，另一个用于在维面上存储边界标记：\n// C++ code CellFunction\u0026lt;uint\u0026gt; sub_domains(mesh); sub_domains.set_all(0); for (CellIterator cell(mesh); !cell.end(); ++cell) { Point p = cell.midpoint(); if (p.x() \u0026gt; 0.5) sub_domains[cell] = 1; } FacetFunction\u0026lt;uint\u0026gt; boundary_markers(mesh); boundary_markers.set_all(0); for (FacetIterator facet(mesh); !facet.end(); ++facet) { Point p = facet.midpoint(); if (near(p.y(), 0.0) || near(p.y(), 1.0)) boundary_markers[facet] = 1; } # Python code sub_domains = CellFunction(\u0026#34;uint\u0026#34;, mesh) sub_domains.set_all(0) for cell in cells(mesh): p = cell.midpoint() if p.x() \u0026gt; 0.5: sub_domains[cell] = 1 boundary_markers = FacetFunction(\u0026#34;uint\u0026#34;, mesh) boundary_markers.set_all(0) for facet in facets(mesh): p = facet.midpoint() if near(p.y(), 0.0) or near(p.y(), 1.0): boundary_markers[facet] = 1 网格数据。 MeshData类提供了一种将数据与Mesh关联的简单方法。 它允许将任意MeshFunction（以及其他量）与Mesh关联。 以下代码说明了如何在网格上附加和检索名为“sub_domains”的MeshFunction：\n// C++ code MeshFunction\u0026lt;uint\u0026gt;* sub_domains = mesh.data().create_mesh_function(\u0026#34;sub_domains\u0026#34;); sub_domains = mesh.data().mesh_function(\u0026#34;sub_domains\u0026#34;); # Python code sub_domains = mesh.data().create_mesh_function(\u0026#34;sub_domains\u0026#34;) sub_domains = mesh.data().mesh_function(\u0026#34;sub_domains\u0026#34;) 要列出与给定网格相关的数据，请在C++中发出命令info(mesh.data(), true)或在Python中发出info(mesh.data(), True)。\n网格细化。 如下面的代码示例所示，可以调用refine函数，通过统一或局部细化来细化网格。\n// C++ code  // Uniform refinement mesh = refine(mesh); // Local refinement CellFunction\u0026lt;bool\u0026gt; cell_markers(mesh); cell_markers.set_all(false); Point origin(0.0, 0.0, 0.0); for (CellIterator cell(mesh); !cell.end(); ++cell) { Point p = cell.midpoint(); if (p.distance(origin) \u0026lt; 0.1) cell_markers[cell] = true; } mesh = refine(mesh, cell_markers); # Python code # Uniform refinement mesh = refine(mesh) # Local refinement cell_markers = CellFunction(\u0026#34;bool\u0026#34;, mesh) cell_markers.set_all(False) origin = Point(0.0, 0.0, 0.0) for cell in cells(mesh): p = cell.midpoint() if p.distance(origin) \u0026lt; 0.1: cell_markers[cell] = True mesh = refine(mesh, cell_markers) 目前，局部细化默认为按边平分进行递归细化（Rivara，1984，1992）。 图10.4中显示了通过重复标记靠近立方体一角的胞元获得的局部细化网格的示例。\n图10.4 通过重复标记靠近立方体一角的胞元来获得的局部细化网格。 并行网格。 在分布式内存体系结构上并行运行程序时（通过使用mpirun包装器调用程序来使用MPI），DOLFIN会自动划分和分布网格。 然后，每个进程将全局网格一部分存储为标准网格对象。 此外，它存储辅助数据，以正确计算每个进程上的本地到全局映射以及将数据传送到相邻区域。 在10.4节中讨论了使用DOLFIN进行并行计算。\n【章节目录】\n"}),a.add({id:40,href:'/notes/docs/fem/0112/',title:"DOLFIN：C++/Python有限元库》线性代数【翻译】",content:"【章节目录】\n10·3 功能 DOLFIN被组织为库（模块）的集合，每个库都覆盖某个功能区域。 我们在这里回顾这些领域，并解释最常用的类和函数的用途和用法。 回顾是自下而上的； 也就是说，我们首先描述DOLFIN的核心低层功能（线性代数和网格），然后向上移动以描述高层功能。 有关更多详细信息，请参阅FEniCS项目网页上的DOLFIN程序员参考和Logg and Wells（2010）。\n10·3·1 线性代数 DOLFIN提供了一系列线性代数对象和函数，包括向量，稠密和稀疏矩阵，直接和迭代线性求解器以及特征值求解器，并通过一个简单且一致的接口来实现。 对于大多数基础功能，DOLFIN依赖于第三方库，例如PETSc和Trilinos。 DOLFIN定义了抽象基类GenericTensor，GenericMatrix和GenericVector，它们在整个库中被了广泛使用。 在DOLFIN中提供了针对多个后端这些通用接口的实现，从而实现了针对不同后端的通用接口。 用户还可以通过实现通用接口来包装其他线性代数后端。\n矩阵和向量。 创建矩阵和向量的最简单方法是通过Matrix和Vector类。 通常，Matrix和Vector表示分布式线性代数对象，当并行运行时，这些对象可以跨（MPI）进程存储。 与有限元库中最常用的用法一致，Vector使用稠密存储，而Matrix使用稀疏存储。 可以如下创建向量：\n// C++ code Vector x; # Python code x = Vector() 可以通过以下方式创建矩阵：\n// C++ code Matrix A; # Python code A = Matrix() 在大多数应用程序中，用户可能需要创建矩阵或向量，但是对线性代数对象的大多数操作（包括调整大小）将在库内部进行，并且用户无需直接对对象进行操作。\n以下代码说明了如何创建大小为100的向量：【原文的代码已经过期了，被我注释掉了】\n// C++ code // Vector x(100); x.init(100); # Python code # x = Vector(100) x.init(100) 许多后端支持分布式线性代数用于并行计算，在这种情况下，向量x的全局大小为100，而DOLFIN将在（近）相等大小的部分中跨进程划分向量。\n创建一个给定大小的矩阵（稀疏矩阵）要更复杂，因此通常需要根据稀疏矩阵的结构（稀疏模式）进行初始化（分配数据结构）。 必要时，稀疏矩阵的初始化由DOLFIN处理。\n尽管DOLFIN支持分布式线性代数对象用于并行计算，但很少有用户在并行数据布局级别接触到细节。 库将自动处理跨进程的对象分配。\n求解线性系统。 解决线性系统   \\(Ax = b\\)  的最简单方法是使用\n// C++ code solve(A, x, b); # Python code solve(A, x, b) DOLFIN将使用默认方法来求解方程组。 可以给出可选的参数来指定求解线性系统时使用的算法，对于迭代方法，则指定使用的前置条件：\n// C++ code solve(A, x, b, \u0026#34;lu\u0026#34;); solve(A, x, b, \u0026#34;gmres\u0026#34;, \u0026#34;ilu\u0026#34;); # Python code solve(A, x, b, \u0026#34;lu\u0026#34;); solve(A, x, b, \u0026#34;gmres\u0026#34;, \u0026#34;ilu\u0026#34;) 可用的方法和预处理器取决于DOLFIN配置了哪个线性代数后端。 要列出可用的求解器方法和预处理器，可以使用以下命令：\n// C++ code list_lu_solver_methods(); list_krylov_solver_methods(); list_krylov_solver_preconditioners(); # Python code list_lu_solver_methods() list_krylov_solver_methods() list_krylov_solver_preconditioners() 使用函数solve很简单，但是对解决过程的细节几乎没有控制。 对于许多应用程序，希望对求解过程进行一定程度的控制，并在整个模拟过程中重用求解器对象。\n线性系统 \\(Ax = b\\)  可以使用LU分解（一种直接方法）求解，如下所示：\n// C++ code LUSolver solver(A); solver.solve(x, b); # Python code solver = LUSolver(A) solver.solve(x, b) 或者，可以在构造后设置与线性求解器关联的算符 \\(A\\)  ：\n// C++ code LUSolver solver; solver.set_operator(A); solver.solve(x, b); # Python code solver = LUSolver() solver.set_operator(A) solver.solve(x, b) 当通过函数接口传递线性求解器并将算符设置在函数内部时，这很有用。\n在某些情况下，对于给定的矩阵 \\(A\\)  和不同的向量 \\(b\\)  ，或对于不同的 \\(A\\)  ，但具有相同的非零结构，系统 \\(Ax = b\\)  可以求解多次。 如果A的非零结构不变，那么可以通知LU求解器来重复求解来提高效率：\n// C++ code solver.parameters[\u0026#34;same_nonzero_pattern\u0026#34;] = true; # Python code solver.parameters[\u0026#34;same_nonzero_pattern\u0026#34;] = True 在 \\(A\\)  不变的情况下，可以通过重新使用 \\(A\\)  的LU分解来显着减少后续求解时间。 分解重用由参数reuse_factorization控制。\n某些后端可能会规定要使用的特定LU求解器。 这取决于DOLFIN为后端配置了哪些求解器，以及如何配置第三方线性代数后端。\n方程组 \\(Ax = b\\)  可以使用预处理Krylov求解器通过以下方式求解：\n// C++ code KrylovSolver solver(A); solver.solve(x, b); # Python code solver = KrylovSolver(A) solver.solve(x, b) 上面将使用默认的预处理器和求解器以及默认参数。 如果构造的KrylovSolver没有矩阵算符A，则可以在构造后设置算符：\n// C++ code KrylovSolver solver; solver.set_operator(A); solver.solve(x, b); # Python code solver = KrylovSolver() solver.set_operator(A) solver.solve(x, b) 在某些情况下，使用不同于 \\(A\\)  的前置条件矩阵 \\(P\\)  可能会有用：\n// C++ code KrylovSolver solver; solver.set_operators(A, P); solver.solve(x, b); # Python code solver = KrylovSolver() solver.set_operators(A, P) solver.solve(x, b) 可以设置Krylov求解器的各种参数。 一些常见的参数是：\n# Python code solver = KrylovSolver() solver.parameters[\u0026#34;relative_tolerance\u0026#34;] = 1.0e-6 solver.parameters[\u0026#34;absolute_tolerance\u0026#34;] = 1.0e-15 solver.parameters[\u0026#34;divergence_limit\u0026#34;] = 1.0e4 solver.parameters[\u0026#34;maximum_iterations\u0026#34;] = 10000 solver.parameters[\u0026#34;error_on_nonconvergence\u0026#34;] = True solver.parameters[\u0026#34;nonzero_initial_guess\u0026#34;] = False 可以类似地从C++设置参数。 可以通过参数控制打印KrylovSolver收敛的摘要和收敛历史的详细信息：可以通过参数控制打印KrylovSolver收敛的摘要和收敛历史的详细信息：\n// C++ code KrylovSolver solver; solver.parameters[\u0026#34;report\u0026#34;] = true; solver.parameters[\u0026#34;monitor_convergence\u0026#34;] = true; # Python code solver = KrylovSolver() solver.parameters[\u0026#34;report\u0026#34;] = True solver.parameters[\u0026#34;monitor_convergence\u0026#34;] = True 可以在构造求解器对象时设置要使用的特定Krylov求解器和预处理器。 最简单的方法是通过字符串描述设置Krylov方法和前置条件。 例如：\n// C++ code KrylovSolver solver(\u0026#34;gmres\u0026#34;, \u0026#34;ilu\u0026#34;); # Python code solver = KrylovSolver(\u0026#34;gmres\u0026#34;, \u0026#34;ilu\u0026#34;) 上面指定了通用最小残差（GMRES）方法作为求解器，以及不完全LU（ILU）预处理。\n当配置好后端（如PETSc和Trilinos），可以应用各种各样的Krylov方法和预处理器，并且有大量的求解器和预处理器参数可设置。 除了此处描述的内容外，DOLFIN还提供了更高级的接口，允许对求解过程进行更精细的控制。 用户也可以提供自己的预处理器。\n求解特征值问题。 DOLFIN使用基于PETSc的库SLEPc来求解特征值问题。 SLEPc接口仅适用于基于PETSc的线性代数对象。 因此，有必要使用基于PETSc的对象，或将默认的线性代数后端设置为PETSc和向下转换的对象（如下一节所述）。 以下代码说明了特征值问题 \\(Ax =\\lambda x\\)  的解：\n// C++ code  // Create matrix PETScMatrix A; // Code omitted for setting the entries of A  // Create eigensolver SLEPcEigenSolver eigensolver(A); // Compute all eigenvalues of A eigensolver.solve(); // Get first eigenpair double lambda_real, lambda_complex; PETScVector x_real, x_complex; eigensolver.get_eigenpair(lambda_real, lambda_complex, x_real, x_complex, 0); # Python code # Create matrix A = PETScMatrix() # Code omitted for setting the entries of A # Create eigensolver eigensolver = SLEPcEigenSolver(A) # Compute all eigenvalues of A eigensolver.solve() # Get first eigenpair lambda_r, lambda_c, x_real, x_complex = eigensolver.get_eigenpair(0) 特征值的实分量和复分量分别以lambda_real和lambda_complex返回，特征向量的实分量和复分量分别以x_real和x_complex返回。\n要为广义特征值问题 \\(Ax =\\lambda Mx\\)  创建求解器，可以使用 \\(A\\)  和 \\(M\\)  来构造特征求解器：\n// C++ code PETScMatrix A; PETScMatrix M; // Code omitted for setting the entries of A and M SLEPcEigenSolver eigensolver(A, M); # Python code A = PETScMatrix() M = PETScMatrix() # Code omitted for setting the entries of A and M eigensolver = SLEPcEigenSolver(A, M) 用户可以通过参数系统设置许多选项，以控制特征值问题求解过程。 要打印可用参数的列表，请分别从C ++和Python调用info(eigensolver.parameters, true)和 info(eigensolver.parameters, True)。\n选择线性代数后端。 Matrix，Vector，LUSolver和KrylovSolver对象均基于特定的线性代数后端。 默认后端取决于配置DOLFIN时启用了哪些后端。 可以通过全局参数linear_algebra_backend设置后端。 将PETSc用作线性代数后端：\n// C++ code parameters[\u0026#34;linear_algebra_backend\u0026#34;] = \u0026#34;PETSc\u0026#34;; # Python code parameters[\u0026#34;linear_algebra_backend\u0026#34;] = \u0026#34;PETSc\u0026#34; 在创建线性代数对象之前，应先设置此参数。 要使用Trilinos集合中的Epetra，应将参数linear_algebra_backend设置为Epetra。 对于uBLAS，参数应设置为uBLAS，对于MTL4，参数应设置为MTL4。\n用户可以显式创建使用特定后端的线性代数对象。 通常，此类对象以后端名称开头。 例如，通过以下方法创建基于PETSc的向量和LU求解器：\n// C++ code PETScVector x; PETScLUSolver solver; # Python code x = PETScVector() solver = PETScLUSolver() 求解非线性系统。 DOLFIN提供了类NewtonSolver的牛顿求解器，用于求解如下的非线性方程组\n\\[ F(x) = 0 \\tag{10.1} \\]  其中， \\(x \\in \\mathbb{R}^n\\)  和 \\(F : \\mathbb{R}^n \\to \\mathbb{R}^n\\)  。 为了使用DOLFIN的牛顿求解器解决此类问题，用户需要提供NonlinearProblem的子类。 NonlinearProblem对象的目的是求 \\(F\\)  及其雅可比行列式 \\(J : \\mathbb{R}^n \\to \\mathbb{R}^n \\times \\mathbb{R}^n\\)  。 下面是一个用户提供的用于求解非线性微分方程的MyNonlinearProblem类的概要。\n// C++ code class MyNonlinearProblem : public NonlinearProblem { public: // Constructor MyNonlinearProblem(const Form\u0026amp; L, const Form\u0026amp; a, const BoundaryCondition\u0026amp; bc) : L(L), a(a), bc(bc) {} // User-defined residual vector F void F(GenericVector\u0026amp; b, const GenericVector\u0026amp; x) { assemble(b, L); bc.apply(b, x); } // User-defined Jacobian matrix J void J(GenericMatrix\u0026amp; A, const GenericVector\u0026amp; x) { assemble(A, a); bc.apply(A); } private: const Form\u0026amp; L; const Form\u0026amp; a; const BoundaryCondition\u0026amp; bc; }; MyNonlinearProblem对象是使用线性形式L（组装时对应于F）和双线性形式a（组装时对应于J）构造的。 稍后将在例子中详细讨论使Form和BoundaryCondition类的使用。 可以在Python中定义相同的MyNonlinearProblem类：\n# Python code class MyNonlinearProblem(NonlinearProblem): def __init__(self, L, a, bc): NonlinearProblem.__init__(self) self.L = L self.a = a self.bc = bc def F(self, b, x): assemble(self.L, tensor=b) self.bc.apply(b, x) def J(self, A, x): assemble(self.a, tensor=A) self.bc.apply(A) 一旦定义了非线性问题的类，就可以创建一个NewtonSolver对象，并且可以使用牛顿求解器来计算非线性问题的解向量 \\(x\\)  ：\n// C++ code MyNonlinearProblem problem(L, a, bc); NewtonSolver newton_solver; newton_solver.solve(problem, u.vector()); # Python code problem = MyNonlinearProblem(L, a, bc) newton_solver = NewtonSolver() newton_solver.solve(problem, u.vector()) NewtonSolver有许多参数可设。 确定牛顿求解器行为的一些参数有：\n# Python code newton_solver = NewtonSolver() newton_solver.parameters[\u0026#34;maximum_iterations\u0026#34;] = 20 newton_solver.parameters[\u0026#34;relative_tolerance\u0026#34;] = 1.0e-6 newton_solver.parameters[\u0026#34;absolute_tolerance\u0026#34;] = 1.0e-10 newton_solver.parameters[\u0026#34;error_on_nonconvergence\u0026#34;] = False 类似地，C++也可设置参数。 在测试收敛性时，通常会检查残差F的范数。 有时，用检查迭代校正 \\(dx\\)  的范数替代会很有用的。 这由参数convergence_criterion控制，可以将其设置为\u0026quot;residual\u0026quot;以检查残差F的大小，或设置为\u0026quot;incremental\u0026quot;以检查增量 \\(dx\\)  的大小。\n对于更高级的用法，可以使用指定在求解过程中使用的线性求解器和前置条件的构造的NewtonSolver。\n【章节目录】\n"}),a.add({id:41,href:'/notes/docs/fem/0111/',title:"DOLFIN：C++/Python有限元库》概述/接口【翻译】",content:"【章节目录】\nDOLFIN是一个用作FEniCS主要用户接口的C++/Python库。 在本章中，我们将回顾DOLFIN的功能。 我们还将详细讨论DOLFIN某些关键特性的实现。 有关DOLFIN的设计和实现的一般讨论，请参见Logg and Wells（2010）。\n10·1 概述 FEniCS的大部分功能是DOLFIN一部分实现的。 它为基于偏微分方程的模型提供了一个问题解决环境，并实现了FEniCS功能的核心部分，包括计算网格和有限元组装的数据结构和算法。 为了提供简单一致的用户接口，DOLFIN封装了其他FEniCS组件和外部软件的功能，并处理了这些组件之间的通信。\n图10.1概述了FEniCS组件与外部软件之间的关系。 如图所示的软件地图显示了在C++或Python中在DOLFIN用户接口之上的用户应用实现。 用户应用也可以使用FEniCS Apps开发，FEniCS Apps是在FEniCS / DOLFIN之上实现的一组求解器。 DOLFIN本身既是用户接口，又是FEniCS的核心组件。 用户程序，FEniCS的其他核心组件和外部软件之间的所有通信都通过包装层进行路由，这些包装层是DOLFIN用户接口的一部分。 特别地，将UFL形式语言（第17章）表示的变分形式传递给形式编译器FFC（第11章）或SFC（第15章）以生成UFC代码（第16章），然后被DOLFIN用来组装线性系统。 对于FFC，代码生成取决于有限单元后端FIAT（第13章），即时编译实用程序Instant（第14章）和可选的优化后端FErari（第12章）。 最后，DOLFIN提供的绘图功能由Viper实现。 DOLFIN C++接口的用户可能会遇到这种通信，要求用户可通过在命令行上调用形式编译器从UFL形式文件显式地生成UFC代码。\nDOLFIN也依赖于外部软件来实现重要功能，例如线性代数库PETSc，Trilinos，uBLAS和MTL4，以及网格剖分库ParMETIS和SCOTCH（Pellegrini）。\n图10.1 DOLFIN充当FEniCS的主要用户接口，并处理FEniCS的各个组件与外部软件之间的通信。 实线表示依赖关系，虚线表示数据流。 10·2 用户接口 DOLFIN提供了两个用户接口。 一个接口被实现为传统的C++库，另一个接口被实现为标准的Python模块。 这两个接口几乎相同，但是在某些情况下，C++或Python的特定语言功能要求接口有所不同。 尤其是，Python接口通过使用运行时（即时）代码生成，增加了自动化程度。 下面，我们对DOLFIN的两个用户接口的设计和实现进行评论。\n10·2·1 C＋＋接口 DOLFIN C++接口被设计为标准的面向对象的C++库。 它提供了诸如Matrix，Vector，Mesh，FiniteElement，FunctionSpace和Function的类，这些类为有限元计算的重要概念建模（请参见图10.2）。 它还提供了少量的自由函数（不是类的成员函数的函数），特别是组装和求解，可以与DOLFIN类对象一起使用以实现有限元求解器。 该接口被设计为尽可能简单，并且不影响通用性。 包装外部软件时，将提供一个简单且一致的用户接口，以允许快速开发求解器而无需处理外部库接口中的差异。 但是，DOLFIN旨在与外部软件灵活地进行交互。 特别是在DOLFIN为外部库提供包装器的情况下，例如Matrix和Vector类，它们包装了线性代数库（例如PETSc和Trilinos）中的数据结构，高级用户可以在必要时访问基础数据结构以便使用包装了外部库中的本地功能。\n图10.2 DOLFIN的一些最重要的组件和类的示意图。 箭头指示依赖性。  为了使用DOLFIN C++接口求解偏微分方程，用户必须使用UFL形式语言表达有限元变分问题。 就是通过将形式输入到单独的.ufl文件中并使用形式编译器编译这些文件以生成符合UFC的C++代码来完成的。 然后可以将生成的代码包含在DOLFIN C++程序中。 我们在10.3节中回到这个问题。\n为了在C++中使用DOLFIN，用户需要包括DOLFIN C++库中的一个或多个头文件。 在最简单的情况下，其中包括头文件dolfin.h，该头文件又包括所有其他DOLFIN头文件：\n// C++ code  #include \u0026lt;dolfin.h\u0026gt; using namespace dolfin; int main() { return 0; } 10·2·2 Python接口 在过去的十年中，Python已成为快速开发用于科学计算的仿真代码的有吸引力的选择。 Python带来了高级脚本语言的优点，面向对象语言的优势以及大量用于数值计算的库。\nDOLFIN Python接口的大部分是使用SWIG从C++接口自动生成的（Beazley，1996； SWIG）。 由于C++和Python接口的功能都是作为DOLFIN C++库的一部分实现的，因此对于大多数操作，通过C++和Python接口，DOLFIN同样有效。\nDOLFIN Python接口提供了一些C++接口无法提供的功能。 特别是，将UFL形式语言无缝集成到Python接口中，并且在运行时自动处理代码生成。 要从Python使用DOLFIN，用户需要从DOLFIN Python模块导入功能。 在最简单的情况下，其中Python模块中的dolfin包括了所有功能：\n# Python code from dolfin import * 【章节目录】\n"}),a.add({id:42,href:'/notes/docs/fem/0110/',title:"有限元矩阵计算的离散优化【翻译】",content:"【章节目录】\n第8章中，用于单元张量   \\(A_T\\)  计算的张量缩并结构不仅可以构造变分形式编译器，而且还可以优化编译器。 对于典型的变分形式，参考张量 \\(A^0\\)  具有显著的结构，允许以较低计算成本在任意胞元 \\(T\\)  上计算单元张量 \\(A_T\\)  。 利用这种结构减少运算次数，自然会导致离散数学中的几个问题。 本章介绍了一些可能的优化，并讨论了构成FErari项目核心的编译时组合优化问题（Kirby等，2006； Kirby和Scott，2007； Kirby和Logg，2008），这是 第12章的主题。\n在本章中，我们考虑两种基本的优化。 首先，我们考虑参考张量中成对行之间的关系。 这自然会导出一个图，用于建模这些成对行之间的接近度。 如果两行相互“接近”，则可以复用第一行计算的结果，来计算第二行所需的量。 使用汉明距离和线性关系来计算两个这样的行的接近度。 这种方法产生了一个（几乎）是度量空间的加权图，因此我们将这种优化称为“拓扑的”。 其次，我们考虑参考张量的多行（2行以上）之间的关系。 这种关系通常依赖于行集，这些行集被视为欧几里得空间中的向量。 因为我们使用平面和超平面来减少计算量，所以我们将这些优化描述为“几何的”。 为了进行比较，我们简要讨论了使用更传统的优化过稠密线性代数软件包的优化。\n9·1 优化框架 在第8章中发展的张量范式可表示为\n\\[ A_{T,i} = \\sum_{\\alpha\\in \\mathcal{A}} A^0_{i\\alpha} G_T^\\alpha \\quad \\forall i \\in \\mathcal{I} \\tag{9.1} \\]  或简写成\n\\[ A_T = A^0 : G_T \\tag{9.2} \\]  其中， \\(\\mathcal{I}\\)  是单元张量 \\(A_T\\)  所允许多重索引集，而 \\(\\mathcal{A}\\)  是几何张量 \\(G_T\\)  所允许多索引集。 可以在编译时计算参考张量 \\(A^0\\)  ，然后在运行时与 \\(G_T\\)  缩并，以获得有限元网格中每个胞元 \\(T\\)  的单元张量 \\(A_T\\)  。 计算大小为 \\(n_T \\times n_T\\)  的局部有限元刚度矩阵的情况，对应的 \\(\\mathcal{I}\\)  包含长为2的 \\(|\\mathcal{I}|=n^2_T\\)  个多重索引，其中 \\(n_T\\)  是 \\(T\\)  上局部有限元空间的维数。\n就矩阵-向量乘积而言，重做（9.2）很方便：\n\\[ A^0 : G_T \\leftrightarrow \\tilde{A}^0\\tilde{g}_T \\tag{9.3} \\]  在此，矩阵 \\(\\tilde{A}^0\\)  躺在 \\(\\mathbb{R}^{|\\mathcal{I}|\\times|\\mathcal{A}|}\\)  中，向量 \\(\\tilde{g}_T\\)  躺在 \\(\\mathbb{R}^{|\\mathcal{A}|}\\)  中。 然后可以将所得的矩阵-向量乘积变形到单元张量 \\(A_T\\)  中。 由于必须对有限元网格中的每个胞元 \\(T\\)  进行此计算，因此尝试使此操作尽可能高效是有意义的。\n在下文中，我们将删除（9.3）的下标和上标，并考虑计算通用矩阵-矢量积的问题\n\\[ y = Ax \\tag{9.4} \\]  其中， \\(A = \\tilde{A}^0\\)  是先验已知的常矩阵，而 \\(x=\\tilde{g}_T\\)  是任意矢量。 我们将研究 \\(A\\)  的结构，可减少形成这些乘积所需的算术运算次数。 通过这种结构，我们能够生成一个计算系统作用的例程，可以比使用常规稀疏或稠密线性代数例程执行的操作更少。\n在继续进行数学公式描述之前，我们先举一个要优化的矩阵A的示例。 在（9.5）中的参考张量 \\(A^0\\)  ，用于计算标准刚度矩阵，可离散化二维拉普拉斯算子与三角形上二次拉格朗日单元。 4秩张量在此被描述成项为2×2矩阵的6×6矩阵。 完全的分析将使用对应的扁平化36×4矩阵 \\(A\\)  。\n9·2 拓扑优化 与标准矩阵-矢量乘法所需的144个乘法-加法对相比，可以用更少的运算将对应于（9.5）中描述的参考张量 \\(A^0\\)  的矩阵 \\(A\\)  应用于任意矢量 \\(x\\)  。这就需要对 \\(A\\)  进行仔细的分析，并需要为将特定 \\(A\\)  应用于一般 \\(x\\)  生成专用代码。 对 \\(A \\in \\mathbb{R}^{M \\times N}\\)  ，令 \\(\\{a^i\\}^M_{i=1} \\subset \\mathbb{R}^N\\)  表示 \\(A\\)  的行。 矢量 \\(y = Ax\\)  可由形如 \\(y_i = a^ix\\)  的 \\(M\\)  个点乘来计算。 下面，我们研究 \\(A\\)  各行之间的关系，以找到矩阵-矢量积的优化计算。\n就所描述的目的，我们考虑（9.5）的以下子集，该子集将仅花40个乘-加对，但包含我们用作优化的较大版本的所有关系：\n检查（9.6），发现 \\(a^9\\)  为零； 因此，不需要将其乘以 \\(x\\)  的项。 特别地，如果 \\(a^i\\)  有 \\(z\\)  个项为零，那么点乘 \\(a^i x\\)  需要 \\(N−z\\)  个乘-加对，而不是 \\(N\\)  。\n如果对某些 \\(i \\ne j\\)  ， \\(a^i = a^j\\)  ，显然 \\(A\\)  的第6行和第10行就是，于是有 \\(y_i = y_j\\)  ，并且只需要执行一个点乘，而不是两个。 类似地，对于某个数 \\(\\alpha\\)  ， \\(\\alpha a^i = a^j\\)  ，正如 \\(A\\)  的第1行和第2行。 这意味着在计算 \\(y_i\\)  之后，可以用一个乘法来计算 \\(y_j=\\alpha y_i\\)  。\n除了上面讨论的相等和共线性以外，还可以考虑 \\(A\\)  的行间其他关系。 进一步检查（9.6）中的 \\(A\\)  ，会发现行间有一些共同的项，但既不相等也不共线。 这样的行间汉明距离很小。 即，两行间不同的项数少。 如第5行和第6行所示，这种情况经常发生。 我们可以写成 \\(a^j = a^i+(a^j-a^i)\\)  ，其中 \\(a^j-a^i\\)  具有 \\(d_H \\le N\\)  个非零项，而 \\(d_H\\)  是 \\(a^i\\)  与 \\(a^j\\)  之间的汉明距离。 一旦计算出 \\(y_i\\)  ，就可以将 \\(y_j\\)  计算为\n\\[ y_j = y_i +(a_j − a_i)x \\tag{9.7} \\]  只需 \\(d_H\\)  个额外的乘-加对。 如果 \\(d_H\\)  小于 \\(N\\)  ，则可节省大量存储。\n在Wolf和Heath（2009）中，这些二元关系被扩展为包括两个向量的部分共线性。 例如，第6行和第7行有部分共线，即 \\(a^6_{2:4} = −a^7_{2:4}\\)  。 这样可以通过以下方式计算 \\(y_j\\)  ：\n\\[ y_j = \\alpha(y_i − y_{i,\\text{不匹配}}) + a^j_{\\text{不匹配}} x \\tag{9.8} \\]  下标表示向量的不匹配部分用零填充。 这样的关系将 \\(y_j\\)  的计算减少到不匹配贡献的减法，用 \\(y_i\\)  计算结果的缩放，然后再与 \\(a_j\\)  中不匹配的项进行额外的乘法。\n所有这些结构示例都与 \\(A\\)  的单个行或 \\(A\\)  的一对行有关。 行对之间的这种二元关系适用于图论结构的表述，如9.3节所述。 \\(A\\)  的行间也发生高阶关系。 例如，可以第1行和第3行相加，再缩放构成第4行。 在这种情况下，一旦知道 \\(a^1 x\\)  和 \\(a^3 x\\)  ，则可以使用一个加法和一个乘法来计算结果，而直接计算点乘 \\(a^4 x\\)  则需要四个乘法和三个加法。\n9·3 图问题 如果我们只考虑A的行间的二元关系，那么我们自然会得到一个加权的无向图，其顶点是 \\(A\\)  的 \\(a_i\\)  行。 权重为 \\(d\\)  的 \\(a^i\\)  和 \\(a^j\\)  的边表示：如果 \\(a^i x\\)  已知，那么可用 \\(d\\)  个乘-加对来计算 \\(a^j x\\)  。 实际上，这种边还需要用指示关系类型的信息标记，例如相等性，共线性或低汉明距离。\n为了通过图找到最佳计算，我们使用Prim的算法(Prim, 1957)来计算最小生成树。 最小生成树是连接图的所有顶点并且具有最小总边权重的树。 Kirb等（2006年）证明了，在行间给定的一组关系下，最小生成树实际上编码了一种算法，该算法可以最佳地减少所需的算术运算次数。 这里的讨论假定初始图是已连接的。 原则上，每个 \\(a^i\\)  与任何 \\(a^j\\)  的距离都不超过 \\(N\\)  。 然而，实际上，图中仅包含 \\(d 的边，因为 \\(N\\)  是不考虑 \\(y_j\\)  的计算 \\(y_i\\)  的成本。 这通常会使图断开连接，因此必须构造最小的生成森林而不是树（一组不相交的树，它们一起连接所有顶点）。 使用二元关系的最小生成树的示例如图9.1所示。 另请参阅表9.1。\n图9.1 （9.6）中向量的最小生成树（森林）。 虚边表示不会减少操作次数（相对于N − z），因此是不连通图形。  表9.1 图优化过的拉普拉斯算子（MAPS）的乘-加对的数量与乘-加对的基本数量（MN）相比。 然后可以使用这种森林来确定评估 \\(A x\\)  的有效算法，如下所示。 从一些 \\(a^i\\)  开始，最多直接以 \\(N\\)  个乘-加对来计算 \\(y^i = a^i x\\)  。 如果 \\(a^i\\)  的一个或多个项为零，则乘-加对的数量可能小于N。 然后，如果 \\(a^j\\)  是森林中 \\(a^i\\)  的最近邻居，则使用 \\(a^j\\)  和 \\(a^i\\)  间的关系来计算 \\(y^j = a^j x\\)  。 然后，取 \\(a^j\\)  的最近邻居，并继续直到 \\(y\\)  的所有项都已计算出。\n注意到输入张量 \\(G_T \\leftrightarrow x\\)  对于某些算子（如拉普拉斯算子）是对称的，可以进一步改进。 在两维空间中，拉普拉斯算子 \\(G_T\\)  是2×2的，只有3个唯一项，而在三维空间中，则是3×3，只有6个唯一项。 此事实可用于构造具有较少列的修改后的参考张量 \\(A^0\\)  。 对于其他算子，它可能沿某些轴而不是全部轴具有对称性。\nHeath和Wolf提出了对该算法的细微改动。 他们没有选择一个任意的起始行 \\(a^i\\)  ，而是使用“内积”（标记为IP）这个额外顶点来丰富图。 每个 \\(a^i\\)  与IP的距离为 \\(N − z\\)  ，其中 \\(z\\)  是 \\(a^i\\)  中消失的项数。 顶点IP始终被选为最小生成树的根。 它允许对诸如稀疏性等一元关系进行更稳健的处理，并检测部分共线性关系。\n9·4 几何优化 当考虑多于两行间的关系时，优化问题可能不再用图来表述，而是需要一些其他结构。 在这些情况下，通常很难证明已经找到了最佳解决方案，并且怀疑相关组合的问题是NP难题。\n第一次尝试，可以完全根据数据之间的线性相关性进行工作，如下所示。 令 \\(B=\\{b^i\\}_i\\subseteq\\{a^i\\}^N_{i=1}\\)  是 \\(A\\)  的非零行的最大集合，这样就没有两行是共线的。 然后枚举所有线性相关的三元组，\n\\[ S = \\left\\{ \\{b^i, b^j, b^k\\}\\subseteq B : \\exist \\alpha_1, \\alpha_2, \\alpha_3 \\ne 0 , \\alpha_1 b^i + \\alpha_2 b^j + \\alpha_3 b^k = 0 \\right\\} \\tag{9.9} \\]  现在的想法是确定 \\(B\\)  的一些子集 \\(C\\)  ，可以使用 \\(S\\)  中的关系来递归构造 \\(B\\)  中的其余行。\n给定一些 \\(C \\subset B\\)  ，我们可以如下定义 \\(C\\)  的闭包，记作 \\(\\bar{C}\\)  。 首先，如果 \\(b \\in C\\)  ，则 \\(b \\in \\bar{C}\\)  。 其次，如果 \\(b \\in B\\)  并且存在 \\(c, d \\in \\bar{C}\\)  使得 \\(\\{b, c, d\\} \\in S\\)  ，那么 \\(b \\in \\bar{C}\\)  也成立。 如果 \\(\\bar{C} = B\\)  ，我们说 \\(C\\)  是 \\(B\\)  的生成器，或者 \\(C\\)  生成 \\(B\\)  。\n递归定义建议了一个贪心过程，用于构造任何集合 \\(C\\)  的闭包。 \\(B\\)  中的每个向量都放置在优先级队列中，其初值是与其他向量无关地计算成本。 当 \\(C \\ne B\\)  时，将具有最低计算成本的 \\(B\\backslash C\\)  向量添加到 \\(C\\)  ，并根据 \\(S\\)  更新 \\(B\\)  的优先级。 此过程将构造一个有向无环图，该图指示所使用的线性相关性。 每个 \\(b\\in C\\)  将没有邻居，而每个 \\(b \\in \\bar{C}\\backslash C\\)  将指向 \\(\\bar{C}\\)  的另外两个成员。 该图称为生成图。 使用（9.6），我们得到以下 \\(B\\)  ， \\(S\\)  和 \\(C\\)  集，其生成图如图9.2所示：\n\\[ \\begin{aligned}B \u0026= \\{a_1, a_3, a_4, a_5, a_6, a_7, a_8\\} \\\\ S \u0026= \\{(a_1, a_3, a_4), (a_4, a_5, a_6), (a_4, a_7, a_8)\\} \\\\ C \u0026= \\{a_3, a_4, a_5, a_7\\} \\end{aligned} \\tag{9.10} \\]  图9.2 （9.6）中的向量生成图。 表9.2 在四面体上使用二至四次多项式的拉普拉斯算子进行拓扑和几何优化的比较。 在每种情况下，都会报告优化算法的最终MAP数量。 没有报告 \\(q = 1\\)  的情况，因为两种策略产生的操作次数相同。  如果 \\(C\\)  生成 \\(B\\)  ，则生成图表示用于计算 \\(\\{y^i = b^i x\\}_i\\)  的优化（但可能不是最佳）过程。 根据此图对向量 \\(b^i\\)  进行拓扑排序。 然后，对于拓扑顺序中的每个 \\(b^i\\)  ，如果 \\(b^i\\)  没有邻居，则显式计算 \\(b^i x\\)  。 否则， \\(b^i\\)  将指向另外两个向量 \\(b^j\\)  和 \\(b^k\\)  ，其与x的点乘是已知的。 由于生成图是根据一组线性相关的三元组 \\(S\\)  构建的，因此必须存在一些 \\(\\beta_1,\\beta_2\\)  ，使得 \\(b^i =\\beta_1 b^j+\\beta_2 b^k\\)  。 因此，我们可以通过下式计算 \\(y^i\\)  \\[ y^i = b^i x = \\beta_1 b^j x + \\beta_2 b^k x \\tag{9.11} \\]  它只需要两个乘-加对，而不是 \\(N\\)  个。\n为了充分利用线性相关性信息，我们希望找到一个生成器 \\(C\\)  ，它具有尽可能少的成员。 我们说，如果没有也能生成 \\(B\\)  的 \\(C'\\subset C\\)  ，那么生成器 \\(C\\)  对于 \\(B\\)  而言是最小的。 一个更严格的要求是使生成器最小。 如果没有其他生成器 \\(C'\\)  具有更低的基数，则生成器 \\(C\\)  是最小的。 Kirby和Scott（2007）考虑了构建最小生成器的更完整的细节和启发式方法。 目前尚不清楚这种启发式方法是否构成了最小生成器，或者发现最小生成器是个困难问题。\n给定一个 \\(B\\)  的最小生成器 \\(C\\)  ，可以考虑在 \\(C\\)  的元素间搜索更高阶的线性关系，例如一组具有三维跨度的四项。 在这种情况下，生成图及其用法的讨论是相同的。\n在Wolf和Heath（2009）中，研究了超图模型中 \\(A\\)  的行间二元关系和高阶关系。 尽管贪婪算法为图模型提供了最佳解决方案，但事实证明，直接推广到超图可能不是最优的。 虽然超图问题很可能非常棘手，但是启发式算法的性能很好，并提供了除图模型之外的其他优化。 因此，即使找到的是非最佳解决方案，它仍然可以改善算术要求。\n在表9.2中，使用四面体上的二次至四次多项式对拉普拉斯算子的拓扑和几何优化进行了比较。 在几何情况下，对向量 \\(a^i\\)  进行过滤以使其具有唯一的方向。 也就是说，每类共线向量仅保留一个向量。 然后，使用成对线的性相关性向量为其余向量构建生成图。 然后，针对该集合的生成器搜索四个向量的集合之间的线性相关性，并构造生成图。 也许令人惊讶的是，几何优化发现浮点运算次数减少量与基于图的二元关系相当或更好。 这些如表9.2所示。\n9·5 稠密线性代数的优化 作为试图找到一种用来计算单元张量AT简化算法的优化替代，可以考虑通过高效的稠密线性代数来计算单元张量。 如上所述，我们注意到单元张量 \\(A_T\\)  的项可以由矩阵-向量乘积 \\(\\bar{A}^0\\bar{g}_T\\)  计算。 尽管在 \\(\\bar{A}^0\\)  中可能出现零，但这通常是一个稠密的矩阵，因此可以使用2级BLAS有效地计算矩阵-矢量积，尤其是使用dgemv的调用。 BLAS存在许多优化的实现，包括手动优化的实现，凭经验和自动调整的库（Whaley等，2001）以及用于自动推导算法的形式化方法（Bientinesi等，2005）。\n注意到可以在一个矩阵-矩阵乘法中为一批单元 \\(\\{T_i\\}_i\\subset \\mathcal{T}\\)  计算单元张量，于是可进一步优化单元张量 \\(A_T\\)  的计算：\n\\[ \\left[\\bar{A}^0 \\bar{g}_{T_1}, \\bar{A}^0 \\bar{g}_{T_2},\\dots \\right] =\\bar{A}^0 \\left[\\bar{g}_{T_1}, \\bar{g}_{T_2},\\dots \\right] \\tag{9.12} \\]  可以使用单个3级BLAS调用（dgemm）而不是2级BLAS调用的序列来有效地计算此矩阵-矩阵乘积，通常可以提高浮点性能。\n9·6 实现注记 本章讨论的优化的子集可以作为FErari Python模块的一部分使用。 FErari(0.2.0)实现的优化是基于寻找单元张量的各项间二元关系的。 启用优化后，FFC在编译时调用FErari以生成优化的代码。 当从命令行调用FFC时，可以通过-O参数打开FFC的优化，或者从DOLFIN Python接口调用即时编译器时，通过设置parameters[\u0026quot;form_compiler\u0026quot;][\u0026quot;optimize\u0026quot;] = True来打开FFC的优化。 请注意，仅当FFC基于第8章所描述张量表示时生成的代码，才使用FErari优化。 当FFC基于正交生成代码时，优化的处理方式有所不同，如第7章所述。 Kirby和Logg（2008）详细介绍了针对几个问题所改善的运行时间。\n【章节目录】\n"}),a.add({id:43,href:'/notes/docs/fem/0109/',title:"有限元变分形式的张量表示【翻译】",content:"【章节目录】\n在第6章中，对有限元变分问题离散化，我们看到在矩阵和向量组装中的一个重要步骤是计算由下式定义的胞元（单元）张量   \\(A_T\\)  \\[ A_{T,i} = a_T(\\phi_{i_\\rho}^{T,\\rho}, \\dots , \\phi_{i_2}^{T,2}, \\phi_{i_1}^{T,1}) \\tag{8.1} \\]  这里， \\(a_T\\)  是对多重线性形式 \\(a:V_\\rho\\times\\dots\\times V_2\\times V_1 \\to \\mathbb{R}\\)  的局部贡献， \\(i=(i_1,i_2,\\dots,i_\\rho)\\)  是长为 \\(\\rho\\)  的多重指标，并且 \\(\\{\\phi_k^{T,j}\\}^{n_j}_{k=1}\\)  是局部胞元 \\(T\\)  上的局部有限元空间 \\(V_{j,h} \\subset V_j,\\quad j = 1, 2, \\dots, \\rho\\)  的基底。 在本章中，我们描述了如何通过称为张量表示的方法来有效地计算胞元张量 \\(A_T\\)  。\n8·1 泊松方程的张量表示 我们首先描述如何将泊松方程的胞元张量表达为一种特殊的张量缩并，并在下面解释如何将其推广到其他变分形式。 对泊松方程，胞元张量（矩阵） \\(A_T\\)  定义如下\n\\[ A_{T,i} = \\int_T \\nabla\\phi_{i_1}^{T,1} \\cdot \\nabla\\phi_{i_2}^{T,2} dx = \\int_T \\sum^d_{\\beta=1}\\frac{\\partial \\phi_{i_1}^{T,1}}{\\partial x_\\beta}\\frac{\\partial \\phi_{i_2}^{T,2}}{\\partial x_\\beta}dx \\tag{8.2} \\]  图8.1 从参考胞元 \\(\\hat{T}\\)  到胞元 \\(T \\in \\mathcal{T}_h\\)  的（仿射）映射 \\(F_T\\)  。 令 \\(F_T:\\hat{T}\\to T\\)  是从参考胞元 \\(\\hat{T}\\)  到当前胞元 \\(T\\)  的仿射映射，如图8.1所示。 使用这个仿射映射，我们作变量变化\n\\[ A_{T,i} = \\int_{\\hat{T}}\\sum^d_{\\beta=1}\\sum^d_{\\alpha_1=1}\\frac{\\partial \\hat{x}_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial \\hat{\\phi}_{i_1}^1}{\\partial \\hat{x}_{\\alpha_1}}\\sum^d_{\\alpha_2=1}\\frac{\\partial \\hat{x}_{\\alpha_2}}{\\partial x_\\beta}\\frac{\\partial \\hat{\\phi}_{i_2}^2}{\\partial \\hat{x}_{\\alpha_2}}\\mathrm{det} \\ F'_T d\\hat{x} \\tag{8.3} \\]  在此， \\(\\hat{\\phi}_i^j = \\phi_i^{T,j} \\circ F_T\\)  表示与当前胞元 \\(T\\)  上的基函数 \\(\\phi_i^{T,j}\\)  相对应的参考胞元 \\(\\hat{T}\\)  上的基函数。 由于 \\(F_T\\)  是仿射的，因此偏导数 \\(\\partial \\hat{x}/\\partial x\\)  和行列式 \\(\\mathrm{det} \\ F'_T\\)  都是常量的。 因此，我们有\n\\[ \\begin{aligned}A_{T,i} \u0026= \\mathrm{det} \\ F'_T \\sum^d_{\\alpha_1=1}\\sum^d_{\\alpha_2=1}\\sum^d_{\\beta=1}\\frac{\\partial \\hat{x}_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial \\hat{x}_{\\alpha_2}}{\\partial x_\\beta}\\int_{\\hat{T}}\\frac{\\partial \\hat{\\phi}_{i_1}^1}{\\partial \\hat{x}_{\\alpha_1}}\\frac{\\partial \\hat{\\phi}_{i_2}^2}{\\partial \\hat{x}_{\\alpha_2}}d\\hat{x} \\\\ \u0026= \\sum^d_{\\alpha_1=1}\\sum^d_{\\alpha_2=1} A^0_{i\\alpha} G^\\alpha_T \\end{aligned} \\tag{8.4} \\]  其中\n\\[ \\begin{aligned} A^0_{i\\alpha} \u0026= \\int_{\\hat{T}}\\frac{\\partial \\hat{\\phi}_{i_1}^1}{\\partial \\hat{x}_{\\alpha_1}}\\frac{\\partial \\hat{\\phi}_{i_2}^2}{\\partial \\hat{x}_{\\alpha_2}}d\\hat{x} \\\\ G^\\alpha_T \u0026= \\mathrm{det} \\ F'_T \\sum^d_{\\beta=1}\\frac{\\partial \\hat{x}_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial \\hat{x}_{\\alpha_2}}{\\partial x_\\beta} \\end{aligned}\\tag{8.5} \\]  我们将张量 \\(A^0\\)  称为参考张量，将张量 \\(G_T\\)  称为几何张量。 因此，我们可以将泊松方程胞元张量 \\(A_T\\)  的计算表示为张量缩并\n\\[ A_T = A^0 : G_T \\tag{8.6} \\]  可以通过预先计算参考张量 \\(A^0\\)  的项来高效计算张量缩并。这是可能做到的，因为参考张量是常量的，并且不依赖于胞元 \\(T\\)  或网格 \\(\\mathcal{T}_h = \\{T\\}\\)  。 因此，在每个胞元 \\(T\\in \\mathcal{T}_h\\)  上，可以通过首先计算几何张量 \\(G_T\\)  ，然后将其与预先计算的参考张量进行缩并来计算胞元张量。 在第11章中，我们描述了FEniCS形式编译器（FFC），它在编译时预先计算参考张量 \\(A^0\\)  并生成用于计算张量缩并的代码。\n对二维泊松方程，张量缩并涉及将2×2几何张量GT与3×3×2×2参考张量 \\(A^0\\)  的每个对应块缩并，以形成3×3胞元张量 \\(A_T\\)  的项。 因此，可以仅在四个乘-加对中计算各项（加上计算几何张量的成本）。 与通过运行时正交计算相比，这带来了可观的提速，尤其是对于高次单元。 在第9章中，我们讨论了如何通过检查参考张量A0的结构以发现张量缩并的简化算法来进一步改善这一点。\n8·2 表示定理 在Kirby和Logg（2006）中，证明了任何仿射映射的单项式多重线性形式的胞元张量都可以表示为张量缩并之和：\n\\[ A_T = \\sum_k A^{0,k} : G_{T,k} \\tag{8.7} \\]  单项式多重线性形式，在这里是指可表示为单项式之和的多重线性形式，其中每个单项式都是系数与试探/测试函数及其导数的乘积。 此类可涵盖通过加法，乘法和微分表示的所有形式。 早期版本的形式编译器FFC实现了一种简单的形式语言，该语言仅限于这三个操作。 现在，这种简单的形式语言已被新的更具表示力的UFL形式语言所取代。 结果，张量表示只能应用到可以用UFL表示的形式的子集。 这是由FFC自动检查的； 如果张量表示不适用，则使用数值正交。\n表示定理后来扩展到Rognes等人（2009）的Piola-映射单元，以及Ølgaard等人（2008年）证明了如何为不连续的Galerkin方法计算张量表示。\n参考张量和几何张量的秩由多重线性形式 \\(a\\)  决定，特别是由形式的系数和导数确定。 由于胞元张量 \\(A_T\\)  的秩等于多重线性形式 \\(a\\)  的元数 \\(\\rho\\)  ，因此参考张量 \\(A^0\\)  的秩必须为 \\(|i\\alpha| = \\rho + |\\alpha|\\)  ，其中 \\(|\\alpha|\\)  是几何张量的秩。 对于泊松方程，我们有 \\(|i\\alpha|=4\\)  和 \\(|\\alpha|=2\\)  。在表8.1和8.2中，我们演示如何计算双线性形式的张量表示形式： \\(a(u, v) =\\lang u, v \\rang\\)  （质量矩阵）和 \\(a(w; u, v) =\\lang w \\cdot \\nabla u, v \\rang\\)  （平流，advection）。\n表8.1 与质量矩阵相关的双线性形式的胞元张量 \\(A_T\\)  的张量表示 \\(A_T = A^0 : G_T\\)  。 表8.2 与平流 \\(w \\cdot \\nabla u\\)  相关的双线性形式的胞元张量 \\(A_T\\)  的张量表示 \\(A_T=A^0:G_T\\)  。 假定速度场 \\(w\\)  可以插值到带展开系数 \\(w_{\\alpha_1}^T\\)  的局部有限元空间中。 请注意， \\(w\\)  是向量值函数，其分量由 \\(w[\\beta]\\)  引用。  8·3 扩展和限制 张量缩并（8.7）假设来自参考胞元的映射 \\(F_T\\)  是仿射的，从而允许将变换 \\(\\partial \\hat{x}/\\partial x\\)  和行列式 \\(\\mathrm{det} \\ F'_K\\)  从积分中提出来。 如果映射是非仿射的（有时称为“高次”映射），则可以对相应有限元空间的基函数进行展开，并将系数从积分中提出，如表8.2中的平流项所示。 或者，如Kirby和Logg（2006）所述，可以通过正交来计算胞元张量，并将正交点的和表示为张量缩并。 如上所述，张量缩并很容易扩展到由Piola变换所映射的基函数。\n这种方法的局限性在于，它要求在胞元 \\(T\\)  上的每个基函数，都在仿射的Piola变换下，成为单个参考单元基函数的像。 尽管这涵盖了广泛的常用单元，但不包括某些具有基于导数自由度的单元，例如Hermite和Argyris单元。 令 \\(F_T\\)  是参考单元函数空间到胞元 \\(T\\)  上函数空间的映射，例如仿射映射或Piola变换。 然后，物理单元基函数可以表示为参考单元基函数变换后的线性组合：\n\\[ \\phi_i^T = \\sum^n_{j=1} M_{T,ij} \\mathcal{F}_T(\\hat{\\phi}_j) \\tag{8.8} \\]  该矩阵 \\(M_T\\)  的结构取决于自由度的种类，并且根据胞元的几何，每个胞元 \\(T\\)  的值通常是不同的。 通常，矩阵 \\(M_T\\)  是稀疏的。 给定 \\(M_T\\)  ，张量缩并框架可被扩展来处理更一般的单元。 如前所述，可以通过参考单元基函数映射来计算参考张量 \\(A^0\\)  。 但是，张量缩并 \\(A^0 : G_T\\)  必须通过矩阵 \\(M_T\\)  对其进行校正。 目前尚未在形式编译器FFC中实现，因此FEniCS不支持Hermite和Argyris单元。\n对于许多简单的变分形式，例如上面讨论的泊松方程，质量矩阵和平流项，张量缩并（8.7）导致在数值正交上显着提速，有时甚至高达几个数量级。 但是，随着形式的复杂性增加，正交的相对效率也增加。 简而言之，形式的复杂性可以通过形式中出现的导数和系数的数量来度量。 对于每个导数和系数，参考张量A0的秩增加1。 因此，对于泊松方程，由于形式具有两个导数，因此秩为2 + 2 = 4；对于质量矩阵，由于既没有导数也没有系数，秩为2 + 0。 对于平流项，秩为2 + 2 + 1 = 5，因为该形式具有一个导数，一个系数和一个内积 \\(w\\cdot\\nabla\\)  。 由于参考张量 \\(A^0\\)  的大小随其秩呈指数增长，因此对于高复杂度的形式，张量缩并可能会变得非常昂贵。 在这些情况下，正交更为有效。 正交有时也可能是唯一可用的选择，因为张量缩并不能直接应用于不能表示为系数，试探/测试函数及其导数乘积的简单形式。 因此，能够在两种方法之间进行选择非常重要。 张量表示有时可能是最有效的方法，而在其他情况下，正交更为有效，甚至是唯一可能的选择。 这种权衡有在第7章和第12章中讨论。\n【章节目录】\n"}),a.add({id:44,href:'/notes/docs/fem/0108/',title:"有限元变分形式的正交表示（二）【翻译】",content:"【章节目录】\n7·3 性能比较 在本节中，我们研究上一节概述的优化策略对运行时性能的影响。 关键不是要对优化进行严格的分析，而是要提供有关不同策略何时最有效的指示。 我们还将比较正交表示和张量表示的运行时性能（在第8章中进行了介绍），以说明两种方法的优缺点。\n7·3·1 正交优化的性能 将使用两种形式来研究正交优化的性能，即加权拉普拉斯方程（7.1）的双线性形式和第17章方程（17.6）中提供的超弹性模型的双线性形式。 在两种情况下，都将使用二次拉格朗日有限元。\n所有测试均在1.7GHz的Intel Pentium M CPU上进行，带有1.0GB的RAM，运行带有Linux内核2.6.38的Ubuntu 11.10。 我们使用Python v2.7.2和NumPy v1.5.1（均与FFC有关）和g++ v4.6.1来编译符合UFC v2.0.2的C++代码。\n用不同的FFC优化来编译这两种形式，并确定用于计算局部单元张量的浮点运算（flops）次数。 我们将浮点运算（flops）次数定义为代码中“ +”和“ *”运算符所有出现的次数总和。 还可以计算当前FFC优化与标准正交表示的浮点运算次数比（“o/q”）。 然后使用四个不同的优化选项，通过g++编译生成代码，并测量计算单元张量N次所需的时间。 在下面的代码中，我们将用-zeros作为-f eliminate_zeros选项的简写，用-simplify作为-f simplify_expressions选项的简写，用-ip作为-f precompute_ip_const选项的简写，用-basis作为-f precompute_basis_const选项的简写 。\n表7.1显示了具有不同FFC优化的加权拉普拉斯方程的运算次数，而图7.6显示了   \\(N = 1 \\times 10^7\\)  时不同编译器选项的运行时性能。 FFC编译器选项可以在图的x轴上看到，并且四个g++编译器选项以不同的颜色显示。\n表7.1 加权拉普拉斯方程的运算次数。 图7.6 不同编译器选项的加权拉普拉斯方程的运行时性能。 x轴显示FFC编译器选项，颜色表示g++编译器选项。 对所有的优化选项，FFC和g++编译时间均不到2秒。 从图7.6可以明显看出，g++优化极大地影响了运行时性能。 与不使用g++优化（-O0标记）的情况相比，使用-O2选项时，标准正交代码的运行时间改善了3.31倍，使用-O2 -funroll-loops选项时，改善了5.23倍， -O3选项时为7.75。 使用FFC优化选项-zeros时，-O3选项似乎不会明显改善-O2 -funroll-loops选项的运行时间。 单独使用FFC优化选项-zeros不能改善运行时性能。 实际上，即使将此选项与-simplify选项组合使用，使用此选项与任何其他优化选项的组合也会增加运行时间，与标准的正交表示相比，该选项的操作数明显减少。 值得注意的一点是，如果没有g++优化，即使-ip和-basis选项在运行时存在相同的浮点运算次数，它们在运行时也存在很大差异。 启用g++优化后，将完全消除这种差异，并且两个FFC优化的运行时间相同。 这表明不可能仅凭操作次数就可以预测运行时性能，因为必须考虑FFC优化的类型以及g++编译器选项的预期用途。 这种形式的优化的最佳组合是FFC选项-ip或-basis与g++选项-O3组合，在这种情况下，与没有g++优化的标准正交代码相比，运行时间改善了10.2倍。\n表7.2 对于超弹性示例，FFC的编译时间和操作次数。 图7.7 不同编译器选项的超弹性示例的运行时性能。 x轴显示FFC编译器选项，颜色表示g++编译器选项。 表7.2给出了具有不同FFC优化的超弹性的双线性形式的操作次数和FFC编译时间，而图7.7显示了 \\(N = 1 \\times 10^4\\)  时不同编译器选项的运行时性能。 计算单元张量所涉及的浮点运算次数，与加权拉普拉斯示例进行比较，很明显，这个问题要复杂得多。 表7.2中的FFC编译时间表明，-simplify优化，正如预期，是执行成本最高的。 对于所有优化选项，所有测试用例的g++编译时间在2到7秒之间。 需要注意的一点是，该问题减少浮点运算次数的范围比加权拉普拉斯问题大得多，不同FFC优化之间的浮点运算次数差异跨越几个数量级。 相比之下，加权拉普拉斯问题的未经优化和最有效的优化策略之间的差异大约为2倍。 在不使用g++优化的情况下，超弹性问题的运行时性能可以直接与浮点运算的次量相关。 当g++优化-O2打开时，此效果变得不太明显。 与g++优化有关的另一点要注意的是，启用-O2以外的其他优化似乎并不能在运行时提供任何进一步的改进。 对于超弹性示例，选项-zeros会对性能产生积极影响，不仅是单独使用时，尤其是与其他FFC优化结合使用时。 这与加权拉普拉斯方程相反。 原因是测试和试探函数是矢量值而不是标量值，从而可以消除更多的零。 最后，请注意，与加权拉普拉斯问题相比，-simplify选项在此示例中的效果特别好。 原因是超弹性形式的性质会导致要用相对复杂的表达式来计算局部单元张量中的项。 但是，此表达式仅包含几个不同的变量（雅可比的逆分量和基函数），这使-simplify选项非常有效，因为许多项是通用的并且可以预先计算和外提的。 对于超弹性形式，优化的最佳组合是FFC选项-simplify -zeros和g++选项-O2 -funroll-loops，与使用FFC或g++而没有优化的情况相比，该代码将代码的运行时性能提高了335倍 。\n对于所考虑的示例，很明显，没有一种优化策略可以在所有情况下都达到最佳。 此外，生成阶段优化能作到最好的程度，取决于g++编译器执行的优化。 对于上述测试案例，不同的C++编译器也很有可能给出不同的结果。 因此，为选择适当的生产代码优化，一般的建议是，选择应基于针对特定问题的基准程序。\n7·3·2 正交和张量表示的相对性能 表7.3 对于二维下的不同多项式阶次和函数个数， 类弹性张量的两种表示形式的操作次数比率（取自Ølgaard和Wells（2010））。 如上一节所述，给定类型的优化可能对一类形式有效，而对另一类形式则无效。 类似地，对于不同的方程，可以在正交和张量表示之间观察到差异。 Ølgaard和Wells（2010）对此问题进行了详细研究。 为方便起见，我们在此用表7.3重现这篇论文的主要结论。 本节中显示的结果与二维的类弹性双线性形式有关，该形式预先乘以了多个标量系数 \\(f_i\\)  ：\n\\[ a(u,v)=\\int_\\Omega{(f_0 f_1,\\dots,f_{n_f})\\nabla^su : \\nabla^s v dx} \\tag{7.7} \\]  其中， \\(n_f\\)  是预乘系数的个数。 测试和试探函数用 \\(v, u \\in V_h\\)  表示，其中\n\\[ V_h = \\left\\{v \\in [H^1(\\Omega)]^2 : v|_T \\in [P_q(T)]^2 \\ \\forall T \\in \\mathcal{T}\\right\\} \\tag{7.8} \\]  和系数函数 \\(f_i \\in W_h\\)  ，其中\n\\[ W_h = \\left\\{f \\in H^1(\\Omega) : f|_T \\in P_p(T) \\ \\forall T \\in \\mathcal{T} \\right\\}\\tag{7.9} \\]  其中 \\(q\\)  和 \\(p\\)  表示拉格朗日基函数的多项式次数。 系数的个数和多项式的次数是变化的，并且同时记录用张量和正交表示计算局部单元张量所需的浮点运算次数。 通过对正交表示使用优化选项-f eliminate_zeros -f simplify_expressions可获得结果。 在表7.3中，给出了正交表示和张量表示的浮点运算次数比（q/t）。 对浮点运算次数，比率q/t\u0026gt;1表示张量表示更有效，而q/t\u0026lt;1表示正交表示更有效。 在比较两个表示形式的运行时性能时，浮点运算次数是性能的良好指标。 但是，正如我们在上一节中所显示的，对于给定的形式，具有最低浮点运算次数的正交代码并不总是表现最佳。 此外，运行时性能甚至取决于所使用的g++选项。 这就产生了一个问题，即是否有可能仅根据浮点运算次数的估计在表示之间进行良好的选择，如Ølgaard和Wells（2010）所建议的那样。\n但是，仍然可以从表中读取一些一般趋势。 形式中增加系数函数的个数 \\(n_f\\)  ，显然有利于正交表示。 对于 \\(n_f=3\\)  ，可以期望正交表示对于 \\(q\\)  和 \\(p\\)  的所有值表现最佳。 增加系数的多项式次数 \\(p\\)  也有助于正交表示，尽管与增加系数的效果相比，效果不那么明显。 当测试和试探函数的多项式次数 \\(q\\)  增加时，张量表示似乎表现更好，尽管当系数变低时效果最明显。\n7·4 表示的自动选择 我们已经说明了如何通过为FFC和g++编译器使用各种优化选项，以及通过更改形式的表示来改善变分形式生成代码的运行时性能。 选择形式表示和优化选项的组合以实现最佳性能将不可避免地需要一个所研究特定问题的基准。 但是，通常需要许多复杂程度不同的变分形式来解决更复杂的问题。 为所有这些设置基准既麻烦又耗时。 此外，在模型开发阶段，与变分形式的快速原型制作相比，运行时性能至关重要，只要生成的代码执行得相当好即可。\n因此，FFC的默认是用张量表示的成本测量来自动确定应使用哪种形式表示。 简而言之，成本简单地计算为代表形式的单项式中存在的系数和导数个数之和的最大值。 如果此成本大于当前设置为3的指定阈值，则选择正交表示。 回顾表7.3，当 \\(n_f=3\\)  时，对于几乎所有测试用例，正交表示的浮点运算次数显着降低。 尽管这种方法似乎是临时的，但对于运行时性能差异非常明显的情况，它会很好地起作用。 重要的是要记住，生成的代码仅与局部单元张量的求值有关，并且值插入稀疏矩阵和求解方程组所需的时间将会降低任何差异，尤其是对于简单形式。 因此，对于运行时性能差异较小的形式，正确选择表示的重要性不那么重要。 未来的改进可能是设计一种策略，使系统也可以自动为正交表示选择优化策略。\n【章节目录】\n"}),a.add({id:45,href:'/notes/docs/fem/0107/',title:"有限元变分形式的正交表示（一）【翻译】",content:"【章节目录】\n本章介绍了与有限元变分形式相关的局部单元张量数值积分的常规运行时正交方法，尤其是可以减少浮点运算次数的自动优化。 运行时正交方法的替代方法是第8章中介绍的张量表示。 正交和张量方法都在FFC中实现了（参见第11章）。 在本章中，我们讨论了四种用于优化所生成代码的运行时性能的正交表示策略，并表明优化策略比单纯的实现带来了运行时性能的显着提高。 我们还研究了针对不同方程的正交和张量方法的性能，这将导致人们希望能够在两种表示形式之间进行选择。\n7·1 标准正交表示 为了说明在FFC中实现的标准正交表示和优化，我们考虑加权拉普拉斯算子   \\(-\\nabla\\cdot(w\\nabla u)\\)  的双线性形式，其中 \\(u\\)  是未知的， \\(w\\)  是给定的系数。 此方程变分问题的双线性形式为\n\\[ a(u, v) = \\int_\\Omega{ w\\nabla u \\cdot \\nabla v dx} \\tag{7.1} \\]  通过使用可直接在正交点求值的“正交函数”，正交方法可以处理的情况，所涉及的所有函数并非都来自有限元空间。 而张量表示法仅支持所有函数都来自有限元空间的情况（必要时使用插值法）。 因此，为了确保在表示之间进行适当的性能比较，我们假设形式中的所有函数（包括系数函数）都来自有限元函数空间。 对于（7.1），所有函数都将来自\n\\[ V_h=\\left\\{v\\in H^1(\\Omega) : v|_T \\in P_q(T) \\ \\forall T \\in \\mathcal{T} \\right\\} \\tag{7.2} \\]  其中， \\(P_q(T)\\)  表示 \\(\\Omega\\)  的标准三角剖分 \\(\\mathcal{T}\\)  的单元 \\(T\\)  上 \\(q\\)  次拉格朗日多项式空间。 如果令 \\(\\{\\phi_i^T\\}\\)  表示能够张成 \\(T\\)  上离散函数空间 \\(V_h\\)  的局部有限元基底，那么单元 \\(T\\)  的局部单元张量可以计算为：\n\\[ A_{T,i} = \\int_T{ w\\nabla\\phi_{i_1}^T \\cdot \\nabla\\phi_{i_2}^T dx} \\tag{7.3} \\]  其中， \\(i = (i_1, i_2)\\)  。\n（7.3）中局部单元张量的表达式可以用UFL表示（请参阅第17章），FFC会从中生成形式的中间表示形式（请参阅第11章）。 假设从参考单元 \\(T_0\\)  到给定单元 \\(T\\in \\mathcal{T}\\)  的标准仿射映射 \\(F_T:T_0\\to \\mathcal{T}\\)  ，那么此中间表示为\n\\[ \\begin{aligned}A_{T,i} = \\sum^N_{q=1}\\sum^n_{\\alpha_3=1}\\Phi_{\\alpha_3}(X^q) w_{\\alpha_3}\u0026\\sum^d_{\\beta=1}\\sum^d_{\\alpha_1=1}\\frac{\\partial X_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial \\Phi_{i_1}(X^q)}{\\partial X_{\\alpha_1}}\\\\ \u0026 \\qquad \\sum^d_{\\alpha_2=1}\\frac{\\partial X_{\\alpha_2}}{\\partial x_\\beta}\\frac{\\partial \\Phi_{i_2}(X^q)}{\\partial X_{\\alpha_2}} \\mathrm{det} \\ F_T' W^q \\end{aligned}\\tag{7.4} \\]  其中，使用了从参考坐标 \\(X\\)  到实际坐标 \\(x = F_T(X)\\)  的变量变化。 在上面的等式中， \\(N\\)  表示积分点数， \\(d\\)  是 \\(\\Omega\\)  的维数， \\(n\\)  是 \\(w\\)  的局部基底的自由度个数， \\(\\Phi_i\\)  表示参考单元上的基函数， \\(\\mathrm{det} \\ F_T'\\)  是雅可比行列式， \\(W^q\\)  是积分点 \\(X^q\\)  的正交权重。 默认情况下，FFC应用可精确积分变分形式的正交方案。\n根据（7.4）中的表示，由FFC生成用于计算局部单元张量各项的代码。 代码如图7.1所示。 为正交表示所生成代码，按如下方式构造。 首先，取决于当前单元 \\(T\\)  几何量的值，例如雅可比矩阵 \\(\\partial X_{\\alpha_1}/\\partial x_\\beta\\)  和 \\(\\partial X_{\\alpha_2}/\\partial x_\\beta\\)  的逆分量的计算，在代码中分配的变量K_01（此代码未显示，因为它对于理解正交表示的性质并不重要）。 接下来，在参考单元的积分点上的基函数及其导数值，如 \\(\\Phi_{\\alpha_3}(X^q)\\)  和 \\(\\partial\\Phi_{i_1}(X^q)/\\partial X_{\\alpha_1}\\)  。 有限元基函数由FIAT计算。 参考单元上的基函数及其导数独立于当前单元 \\(T\\)  ，因此编译成表并存储在图7.1中的表Psi_w，Psi_vu_D01和Psi_vu_D10中。 将基函数值制成表后，开始循环积分点。 在该示例中，我们考虑了线性单元，并且仅需要一个积分点就可进行精确积分。 因此，省略了积分点上的循环。 积分点循环中的首个任务是计算当前积分点的系数值。 对于所考虑的问题，这涉及计算系数 \\(w\\)  的值。 图7.1中用于计算F0的代码是表示 \\(\\sum^n_{\\alpha_3=1}\\Phi_{\\alpha_3}(X^q)w_{\\alpha_3}\\)  的精确变换。 图7.1中代码的最后一部分是基函数索引 \\(i_1\\)  和 \\(i_2\\)  上的循环，其中添加了从当前积分点到局部单元张量 \\(A_T\\)  中每项的贡献。 要生成正交表示的代码，应使用FFC命令行选项-r quadrature。\n图7.1 与使用二维线性单元的加权拉普拉斯算子相关的，双线性形式的部分生成代码。 像K_00这样的变量是雅可比矩阵逆矩阵的分量，而 \\(\\mathrm{det}\\)  是雅可比矩阵的行列式。 没有显示计算这些变量的代码。 A包含局部单元张量的值，w包含加权函数 \\(w\\)  的节点值。 7·2 正交优化 现在，我们讨论用于提高所生成代码的运行时性能的优化。 在FFC中实现的优化策略的基本原理：以减少计算局部单元张量次数的方式来操作表达式。 以下各节所描述的策略，除了零消除操作外，都具有一些共同的特征，可以归类为：\n移动不变的循环代码 简而言之，该过程力图确定与一个或多个求和索引无关的项，并将它们移到这些特定索引的循环之外。 例如，在（7.4）中，关于系数 \\(w\\)  ，正交权重 \\(W_q\\)  和行列式 \\(\\mathrm{det}\\ F'_T\\)  的项均与基函数索引 \\(i_1\\)  和 \\(i_2\\)  无关，因此对于每个积分点只需要计算一次。 可以在Alfred等人（1986）的文章中找到对此技术的一般性讨论，也称为“循环外提（loop hoisting）”。\n重用通用项 表达式中，可识别的多次出现的项，只计算一次，存储为临时值，然后在表达式中所有出现的地方重复使用。 这可能对运算次数有很大影响，因为用于计算AT中各项的表达式位于基函数索引上的循环内，如图7.1中用于标准正交表示的代码所示。\n要打开优化，除了以下各节中提供的任何FFC优化选项外，还应附加使用命令行选项-O。\n7·2·1 零消除操作 对于特定问题，某些基函数及其导数可能在所有积分点均为零值。 由于这些值是在编译时列出的，因此可以识别包含非零值的列。 这样可以减少与这些表有关索引的维循环。 但是，减少表的结果是必须创建索引映射才能正确访问值。 映射导致内存在运行时无法连续访问，并且可能导致运行时性能下降。\n可以通过使用命令行选项-f eliminate_zeros打开此优化。 用此选项生成的加权拉普拉斯方程的代码如图7.2所示。 为简洁起见，仅包含与图7.1不同的代码。\n图7.2 使用带优化选项`-f eliminate_zeros`的二维线性单元，为加权拉普拉斯算子生成部分代码。 数组nzc0和nzc1包含用于值映射的非零列索引。 注意是如何零消除的，这里使用表（Psi_vu）来替换图7.1中基函数导数的两张表Psi_vu_D01和Psi_vu_D10。  尽管零消除导致涉及索引 \\(j\\)  和 \\(k\\)  的维循环数从3减小到2，但是操作数量却增加了。 原因是映射导致在循环内同时计算四个项，并与图7.1中的代码相比，用于计算每个项的代码并未显著减少。 实际上，通常不建议单独使用这种优化策略，但结合以下各节中概述的策略，可以显著提高运行时性能。 当形式包含混合单元时，此效果尤其明显，其中基函数表中的许多值均为零。 应用此策略时要小心的另一个原因是，由于项数的增加可能由于硬件限制而阻止FFC编译。\n7·2·2 化简表达式 用于计算局部单元张量各项的表达式可能会变得非常复杂。 由于此类表达式通常位于循环内部，因此降低复杂度可以显着减少总操作数。 可用表达式 \\(x(y + z)+ 2xy\\)  来说明此方法，在将第1项展开后，通过同类项分组和可以简化为 \\(x(3y + z)\\)  ，这样就从五个操作减少到三个操作 。 这种策略的另一个好处是，在简化之前进行表达式的展开通常会允许对更多的项进行预先计算并提到循环外部，如本节开头所述。 对于加权拉普拉斯方程，项\n\\[ \\sum^d_{\\beta=1}\\sum^d_{\\alpha_1=1}\\frac{\\partial X_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial \\Phi_{i_1}(X^q)}{\\partial X_{\\alpha_1}}\\sum^d_{\\alpha_2=1}\\frac{\\partial X_{\\alpha_2}}{\\partial x_\\beta}\\frac{\\partial \\Phi_{i_2}(X^q)}{\\partial X_{\\alpha_2}} \\tag{7.5} \\]  将被展开为\n\\[ \\sum^d_{\\beta=1}\\sum^d_{\\alpha_1=1}\\sum^d_{\\alpha_2=1}\\frac{\\partial X_{\\alpha_1}}{\\partial x_\\beta}\\frac{\\partial X_{\\alpha_2}}{\\partial x_\\beta}\\frac{\\partial \\Phi_{i_1}(X^q)}{\\partial X_{\\alpha_1}}\\frac{\\partial \\Phi_{i_2}(X^q)}{\\partial X_{\\alpha_2}} \\tag{7.6} \\]  其中， \\((\\partial X_{\\alpha_1}/\\partial x_\\beta)(\\partial X_{\\alpha_2}/\\partial x_\\beta)\\)  独立于索引 \\(i_1\\)  和 \\(i_2\\)  ，因此可以移出这些循环。\n应使用FFC命令行选项-f simplify_expressions来生成启用了此优化的代码。 由此选项为（7.4）中表示生成的代码，如图7.3所示，其中再次仅包含与图7.1不同的代码。\n图7.3 使用带优化选项`-f simplify_expressions`的二维线性单元，为加权拉普拉斯算子生成代码部分。  由于表达式的展开，许多与几何相关的项以及移到基函数索引j和k循环之外，并存储在数组G中。 另外，请注意如何通过将变量det和W1移到括号之外来简化用于计算G中值的表达式。 类似地，仅依赖于积分点的项被外提并存储在数组I中。 与图7.1中标准正交表示的代码相比，操作数量有所减少。 因此可以期待运行时性能的提高。\n就FFC代码生成时间和内存消耗而言，上述优化是执行正交优化中最昂贵的，因为它涉及在展开表达式时创建新项。 该过程不适用于复杂的表达式，但是就减少操作数而言，在许多情况下它是最有效的方法。 这种特殊的优化策略，加上一节中概述的零消除，是FFC中首先实现的策略。 有关更多详细信息，请读者参考Ølgaard和Wells（2010）的研究， 以及与张量表示的比较。\n7·2·3 积分点常量预计算 上一节中描述的优化是以增加代码生成时间为代价的。 为了在减少操作次数的同时减少生成时间，可以采取另一种方法，包括在不首展开表达式的情况下外提相对于积分点为常量的表达式。\n要通过这种优化生成代码，应使用FFC命令行选项-f precompute_ip_const。 用这种方法生成的用于（7.4）中表示的代码如图7.4所示。\n图7.4 使用带有优化选项`-f precompute_ip_const`的二维线性单元，为加权拉普拉斯算子生成代码部分。 从生成的代码中可以明显看出，这种策略不会导致这种特定形式的操作数显著减少。 但是，对于具有许多系数的更复杂的形式，可以外提项数将显着增加，从而改善运行时性能。\n7·2·4 基常量预计算 此优化策略是上节所描述策略的扩展。 除了与几何和积分点相关的外提项外，还会在循环内部预先计算依赖于基底索引的值。 对于某些在循环内频繁出现的项，这将导致操作减少，从而一旦计算出给定值就可以重新使用。\n要通过这种优化生成代码，应使用FFC命令行选项-f precompute_basis_ const。 图7.5所示，用这种方法为（7.4）中表达式生成的代码，其中仅包括与图7.4不同的代码。 在这种特殊情况下，如果与先前的方法相比，则不会实现额外的操作减少，因为在索引j和k循环内没有可重用的项。\n图7.5 使用带有优化选项`-f precompute_basis_const`的二维线性单元，为加权拉普拉斯算子生成代部分。 数组B包含依赖于索引j和k的预计算的值。 7·2·5 进一步优化 初步研究表明，可以通过应用两个附加优化来提高正交表示的性能。 查看图7.5中的代码，我们看到数组B中大约一半的临时值仅取决于循环索引j，因此可以将其外提，就像我们在上一节中对其项所做的那样。 另一种方法是针对生成的代码中的j和k展开循环。 这将导致可重用值数量急剧增加，并且该方法可以很容易地与所有其他优化策略结合使用。 但是，临时值的总数也会增加。 因此，这种优化策略可能不适用于所有形式。\n对单纯形上不高于6次的多项式的积分，FFC实施了一些有效的正交方案。 对于高于6次的多项式，它调用FIAT（请参阅第13章）以计算正交方案。 FIAT提供的方案基于映射到单纯形的Gauss–Legendre–Jacobi规则（有关此类方案的详细信息，请参阅Karniadakis和Sherwin（2005））。 这意味着，为了积分七阶多项式，FFC将在每个空间方向上使用四个正交点，即在三维中每个胞元有 \\(4^3 = 64\\)  个点。 正交表示的进一步优化可通过对单纯形上更高阶多项式实施更有效的正交方案来实现，因为积分点数量的减少将带来运行时性能的提高。 但是，FFC确实为用户提供了一个选项，可以指定变分形式的正交度，从而允许不精确的正交。 要将正交度设置为1，应使用命令行选项-f quadrature_degree=1。\n【章节目录】\n"}),a.add({id:46,href:'/notes/docs/fem/0106/',title:"有限元组装【翻译】",content:"【章节目录】\n有限元方法可以看作是形成离散线性系统   \\(AU = b\\)  或非线性系统 \\(b(U)= 0\\)  的方法，对应于微分方程变分形式的离散化。 因此，有限元方法实现的核心部分是根据变分形式计算矩阵和向量。 在本章中，我们描述了用于计算离散算符（张量） \\(A\\)  的标准算法。 将此算法称为有限元组装（ﬁnite element assembly）。 我们还将讨论标准算法的效率以及对无矩阵方法的扩展。\n6·1 组装算法 正如第5章所见， \\(\\rho\\)  重线性形式 \\(V_\\rho \\times \\dots \\times V_2 \\times V_1 \\to \\mathbb{R}\\)  的离散算符，就是由下式定义的 \\(\\rho\\)  秩张量 \\(A\\)  ：\n\\[ A_I = a(\\phi^\\rho_{I_\\rho} , \\dots , \\phi^2_{I_2} , \\phi^1_{I_1} ) \\tag{6.1} \\]  其中， \\(I = (I_1, I_2, \\dots , I_\\rho)\\)  是长度为 \\(\\rho\\)  的多重索引， \\(\\{\\phi_k^j\\}^{N_j}_{k=1}\\)  是 \\(V_{j,h} \\subset V_j, \\quad j = 1, 2, \\dots , \\rho\\)  的基底. 这个离散算符是典型的稀疏张量，其秩为 \\(\\rho\\)  ，维数为 \\(N_1 \\times N_2 \\times \\dots \\times N_\\rho\\)  。\n一种计算张量 \\(A\\)  的简单算法是遍历其所有项并按算法1所述逐一计算。 由于该算法有两个主要缺点，而在实践中很少使用。 首先，它没有考虑到稀疏张量 \\(A\\)  的大多数项可能为零。 其次，没有考虑到每个条目通常是来自基函数 \\(\\phi^1_{I_1},\\phi^2_{I_2},\\dots \\phi^\\rho_{I_\\rho}\\)  所支持的胞元集的贡献（积分）之和。 其结果导致，在计算对张量 \\(A\\)  不同项的局部贡献时，必须多次访问网格的每个胞元。 因此，通常通过对网格的胞元进行迭代，并将每个局部胞元对全局张量 \\(A\\)  的贡献相加来计算张量 \\(A\\)  . 为了了解如何将张量 \\(A\\)  分解为局部贡献的总和，我们先回顾第5章对胞元张量 \\(A_T\\)  的定义：\n\\[ A_{T,i} = a_T(\\phi^{T,\\rho}_{i_\\rho}, \\dots , \\phi^{T,2}_{i_2}, \\phi^{T,1}_{i_1}) \\tag{6.2} \\]  其中， \\(i=(i_1, i_2, \\dots, i_\\rho)\\)  是长为 \\(\\rho\\)  的多重索引， \\(A_{T,i}\\)  是 \\(\\rho\\)  秩张量 \\(A_T\\)  的第 \\(i\\)  项， \\(a_T\\)  是胞元 \\(T\\in \\mathcal{T}_h\\)  对多重线性形式的局部贡献， \\(\\{\\phi_k^{T,j}\\}^{n_j}_{k=1}\\)  是 \\(T\\)  上 \\(V_{j, h}\\)  的局部有限元基底。 在此，我们假设多重线性形式可表示为域 \\(\\Omega\\)  上的积分，进而可以自然分解为局部贡献之和。 如果这个形式包含维面或边界积分的贡献，则可以类似地将多重线性形式分解为维面的局部贡献。\n为了制定通用的组装算法，令 \\(\\iota_T^j: [1,n_j] \\to [1, N_j]\\)  表示第2章介绍的，为每个离散函数空间 \\(V_{j,h}, \\quad j = 1,2,\\dots,\\rho\\)  引入局部到全局映射，并且为每个 \\(T \\in \\mathcal{T}_h\\)  由下式定义的局部到全局的集映射 \\(\\iota_T:\\mathcal{I}_T \\to \\mathcal{I}\\)  ：\n\\[ \\iota_T(i) = (\\iota^1_T(i_1), \\iota^1_T(i_1), \\dots , \\iota^\\rho_T(i_\\rho)) \\quad \\forall i \\in \\mathcal{I}_T \\tag{6.3} \\]  其中， \\(\\mathcal{I}_T\\)  是索引集\n\\[ \\begin{aligned}\\mathcal{I}_T \u0026= \\prod^\\rho_{j=1}[1, n_j] \\\\ \u0026= \\{(1, 1, \\dots , 1), (1, 1, \\dots , 2), \\dots , (n_1, n_2,\\dots , n_{\\rho−1}), (n_1, n_2,\\dots , n_\\rho)\\}\\end{aligned} \\tag{6.4} \\]  即， \\(\\iota_Τ\\)  将局部自由度的元组映射为全局自由度的元组。 此外，令 \\(\\mathcal{T}_I\\subset \\mathcal{T}_h\\)  表示 \\(\\{\\phi_{I_j}^j\\}^\\rho_{j=1}\\)  均非零的网格胞元的子集。 我们注意到，如果 \\(T \\in \\mathcal{T}_I\\)  ，那么 \\(\\iota_T\\)  是可逆的。 现在，我们可以通过对网格胞元的局部贡献求和来计算张量 \\(A\\)  ：\n\\[ \\begin{aligned}A_I \u0026= \\sum_{T \\in \\mathcal{T}_h}a_T(\\phi^\\rho_{I_\\rho} , \\dots , \\phi^2_{I_2}, \\phi^1_{I_1} ) = \\sum_{T \\in \\mathcal{T}_I}a_T(\\phi^\\rho_{I_\\rho} , \\dots , \\phi^2_{I_2}, \\phi^1_{I_1} ) \\\\ \u0026= \\sum_{T\\in \\mathcal{T}_I}a_T\\left(\\phi^{T,\\rho}_{(\\iota^\\rho_T)^{−1}(I_\\rho)}, \\dots , \\phi^{T,2}_{(\\iota^2_T)^{−1}(I_2)}, \\phi^{T,1}_{(\\iota^1_T)^{−1}(I_1)}\\right) = \\sum_{T\\in \\mathcal{T}_I}A_{T,\\iota^{−1}_T(I)} \\end{aligned} \\tag{6.5} \\]  可以通过对所有胞元 \\(T\\in \\mathcal{T}_h\\)  进行一次迭代来有效地执行此计算。 在每个胞元 \\(T\\)  上，计算胞元张量 \\(A_T\\)  ，然后将其添加到全局张量 \\(A\\)  中（算法2），如图6.1。\n图6.1 使用局部到全局映射 \\(\\iota_T\\)  ，将胞元张量 \\(A_T\\)  的项添加到全局张量 \\(A\\)  ，图中描绘了，在三角形上分段线性单元的二秩张量（矩阵）的组装。 在每个单元 \\(T\\)  上，计算一个 \\(3\\times3\\)  矩阵 \\(A_T\\)  ，并将其各项添加到全局矩阵中。 将第一行的项分别添加到由 \\(\\iota^2_T(1),\\iota^2_T(2),\\iota^2_T(3)\\)  标定列的全局矩阵的第 \\(\\iota^1_T(1)\\)  行。 第二行的项则添加到全局矩阵的第 \\(\\iota^1_T(2)\\)  行等。 6·2 实现 图6.2 DOLFIN中的组装算法（算法2）的实际实现（摘录）（来自DOLFIN 1.0中的`Assembler.cpp`）。  在FEniCS中，组装算法（算法2）作为DOLFIN的一部分实现（见图6.2）。 组装算法的步骤（1），（2）和（3），DOLFIN依赖于外部代码。 步骤（1）和（2），DOLFIN调用由形式编译器（例如FFC或SyFi）生成的代码。 特别是，DOLFIN通过UFC接口分别针对步骤（1）和（2）调用了两个函数tabulate_dofs和tabulate_tensor。 步骤（3）通过DOLFIN的GenericTensor::add接口执行，并映射到多个线性代数后端之一作相应的操作，比如PETSc的MatSetValues和Trilinos/Epetra的SumIntoGlobalValues。\n在典型的组装实现中，胞元张量 \\(A_T\\)  的计算是组装算法最昂贵的操作。 但是，对于DOLFIN，由形式编译器生成了用于计算 \\(A_T\\)  的优化算法（请参见第7章和第8章），因此将局部张量 \\(A_T\\)  的项添加到全局张量 \\(A\\)  中的适当位置的这步操作，通常会构成总组装时间的重要部分。 该操作是昂贵的，因为即使将稀疏矩阵的布局初始化了，向稀疏张量的任意项添加值也不是一件容易的事。 在标准情况下，当 \\(A\\)  是稀疏矩阵（2秩的张量）时，线性代数后端将稀疏矩阵存储为行压缩存储（compressed row storage, CRS）格式或其他某种稀疏格式。 对于每个给定的项，线性代数后端必须沿着第 \\(I\\)  行搜索以找到存储给定第 \\(J\\)  行的值的位置。 结果，对于许多问题，目前在FEniCS中用于稀疏矩阵的组装速度受到插入到稀疏线性代数数据结构中的速度的限制。 稀疏矩阵的初始化会带来额外的成本，这涉及稀疏模式的计算。 对于大多数线性代数库，有必要在插入项之前初始化稀疏矩阵的布局，以实现可容许的插入速度。 稀疏模式的计算是一个中等成本的操作，但是在非线性问题的情况下，通常会随时间摊销。\n算法2可以轻松扩展为在网格的维面上组装。 在维面上进行组装，对于处理包含在网格（外部维面）边界上积分的变分形式（以解决Neumann边界条件）以及作为不连续Galerkin公式一部分在网格的内部维面上包含积分的形式都是必要的。 因此，DOLFIN实现了三种不同的组装算法。 它们分别是胞元，外部维面和内部维面上的组装。\n6·3 边界条件的对称应用 对于对称问题，以保持矩阵对称性的方式应用Dirichlet边界条件是有用的，因为这允许使用限于对称矩阵的求解算法，例如共轭梯度法和Cholesky分解 。 边界条件的对称应用可以通过在组装成全局张量 \\(A\\)  之前修改胞元张量 \\(A_T\\)  来处理。 在DOLPHIN的类SystemAssembler中实现了应用对称性边界条件的组装。\n为了解释对称组装算法，请考虑全局系统 \\(AU=b\\)  以及相应的单元矩阵 \\(A_T\\)  和单元向量 \\(b_T\\)  。 如果全局索引 \\(I\\)  与Dirichlet边界条件 \\(U_I = D_I\\)  关联，则可以强行设定 \\(A_{II} = 1, A_{IJ}=0，\\quad I \\ne J\\)  和 \\(b_I = D_I\\)  。 可调用DOLFIN函数DirichetBC::apply应用此方法。 但是，为了保持矩阵的对称性，我们可以执行部分高斯消去法来获得 \\(A_{JI} = A_{IJ}=0,\\quad I \\ne J\\)  。 局部地，可通过从第 \\(J\\)  个方程中减去第 \\(I\\)  行乘以 \\(A_{JI}\\)  来实现的。 这些部分高斯消去是在单元级别的线性系统上执行的。 然后将局部线性系统添加到全局矩阵。 结果，Dirichlet条件被多次添加到全局向量，每个胞元一次，通过对 \\(A\\)  对角线项添加多次来补偿。 算法3中对此进行了总结。 或者，可以选择从线性系统中消去与Dirichlet边界条件相对应的自由度（因为这些值是已知的）。 最后，这些值出现在线性系统的右侧。 此算法没有消去与Dirichlet边界条件相关的自由度。 取而代之的是，保留这些自由度以维持线性系统的维数，以便它始终与解的自由度总数（包括已知的Dirichlet值）匹配。\n6·4 并行组装 如果线性代数后端支持分布式矩阵以及进程内和进程外矩阵项的插入，并且网格数据结构支持分布式网格，则在分布式并行环境中，组装算法将保持不变。 PETSc（Balay等人，2001，2004）和Trilinos/Epetra（Heroux等人，2005）都支持分布式矩阵和向量。 有效的并行组装依赖于适当划分的网格和适当分布的自由度图，以最大程度地减少进程间的通信。 通常，仅使用形式编译器是不可能生成有效的自由度映射，因为自由度映射应反映网格的划分。 取而代之的是，可以使用由形式编译器生成的自由度映射来在运行时构造合适的映射。 DOLFIN支持分布式网格，并且能为分布式组装计算分布式自由度映射。\n多线程组装比分布式组装表面上看更简单，并且鉴于多核体系结构的快速增长，它具有吸引力。 可以使用例如OpenMP轻松修改组装代码，在胞元上并行化组装循环。 多线程组装需要格外小心，以免多个线程不会写入同一内存位置（当多个线程尝试写入同一内存位置时，这称为竞争条件）。 最近，DOLFIN（从1.0版开始）基于对网格的胞元进行着色，从而使两个相邻胞元（在拉格朗日单元的情况下，具有相同顶点的单元）都不具有相同的颜色，进而实现了多线程组装。 然后可以遍历网格的颜色，对于每种颜色，使用OpenMP并行化组装循环。 这样可确保没有两个胞元会从同一位置（网格中）读取数据，或将数据写入同一位置（全局张量中）。\n6·5 无矩阵方法 对形如 \\(AU = b\\)  的线性系统，Krylov子空间方法和其他一些迭代方法的一个特点是，它们仅依赖矩阵算符 \\(A\\)  对向量的作用，而无需直接操纵 \\(A\\)  。 这与直接线性求解器相反。 因此，如果可以计算 \\(A\\)  对任意向量 \\(v\\)  的作用，则可以使用Krylov求解器来求解系统 \\(AU=b\\)  ，而无需组装 \\(A\\)  。 对于非常适合Krylov求解器的，并且 \\(A\\)  的组装成本很高（就CPU时间和/或内存而言）的问题，这种无矩阵的方法可能很有吸引力。 无矩阵方法的一个缺点是，常用于改善Krylov求解器的收敛性和鲁棒性的预处理器要涉及 \\(A\\)  的操纵，进而无法应用无矩阵方法。 为了进行组装，无矩阵方法用向量 \\(Av\\)  （ \\(A\\)  对给定向量 \\(v\\)  的作用）的重复组装代替矩阵 \\(A\\)  的组装。 有效地应用这些方法的关键要素是向量的快速组装。 与插入稀疏矩阵相比，插入密集向量的成本相对较低。 因此，胞元张量的计算是主要成本。 FEniCS支持线性或线性化算法作用的组装。\n【章节目录】\n"}),a.add({id:47,href:'/notes/docs/fem/0105/',title:"有限元变分形式【翻译】",content:"【章节目录】\nFEniCS软件的大部分都致力于变分形式的公式（UFL），变分形式的离散化（FIAT，FFC，SyFi）以及相应离散运算（UFC，DOLFIN）的组装。 本章总结了FEniCS所使用变分形式的表示。\n5·1 背景 在第二章中，我们介绍了以下典型的变分问题：需求   \\(u \\in V\\)  , 满足\n\\[ a(u, v) = L(v) \\quad \\forall v \\in \\hat{V} \\tag{5.1} \\]  其中， \\(V\\)  给出试探空间， \\(\\hat{V}\\)  给出测试空间。双线性形式\n\\[ a : V \\times \\hat{V} \\to \\mathbb{R} \\tag{5.2} \\]  将一对试探和测试函数映射到一个实数，并且对两个参数都是线性的。 类似地，线性形式 \\(L:\\hat{V} \\to \\mathbb{R}\\)  将给定测试函数映射到实数。 我们也能构造出非线性变分问题的离散化：需求 \\(u \\in V\\)  ，以满足\n\\[ F(u; v) = 0 \\quad \\forall v \\in \\hat{V} \\tag{5.3} \\]  在里， \\(F:V \\times \\hat{V} \\to \\mathbb{R}\\)  也是将一对函数映射到实数。 这个半线性形式 \\(F\\)  对函数 \\(u\\)  是非线性的，而对测试函数 \\(v\\)  是线性的。 或者，我们可以考虑映射\n\\[ L_u \\equiv F(u; \\cdot) : \\hat{V} \\to \\mathbb{R} \\tag{5.4} \\]  并注意到，对于任何固定的 \\(u\\)  ， \\(L_u\\)  都是 \\(\\hat{V}\\)  上的线性形式。 在第2章中，我们还考虑了在给定函数 \\(M:V \\to \\mathbb{R}\\)  下的误差估计。 在这里，可能的非线性函数 \\(M\\)  将给定的函数 \\(u\\)  映射到实数 \\(M(u)\\)  。\n在所有这些例子中，核心概念是将给定的函数元组映射为实数的形式。 我们将这些称为多重线性形式。 下面，我们将多重线性形式的概念形式化，讨论多重线性形式的离散化，以及相关概念，例如多重线性形式的作用，导数和伴随。\n5·2 多重线性形式 一个形式，是从给定的函数空间序列 \\(\\{V_j\\}^\\rho_{j=1}\\)  的乘积到实数的映射：\n\\[ a : V_\\rho \\times \\dots \\times V_2 \\times V_1 \\to \\mathbb{R} \\tag{5.5} \\]  如果形式 \\(a\\)  对其每个参数都是线性的，那么我们说此形式是多重线性的。 形式的参数个数 \\(\\rho\\)  是形式的元数（arity）。 请注意，空间是从右到左编号的。 正如我们将在下面的5.3节中看到的那样，这是考虑多重线性形式的离散化时的惯例。\n形式通常可以用一个或更多系数参数化。 一个典型的例子是正则变分问题（5.1）的右手边的 \\(L\\)  ，它是在给定系数 \\(f\\)  上参数化的线性形式。 我们将使用符号 \\(a(f; v) \\equiv L_f(v) \\equiv L(v)\\)  ，并将测试函数 \\(v\\)  称为自变量，将函数 \\(f\\)  称为系数。 通常，我们将对每个参数都是线性的（但对系数上可能是非线性的）形式称为多重线性形式。 这种多重线性形式是参数空间和系数空间序列乘积的映射：\n\\[ \\begin{aligned}a : W_1 \\times W_2 \\times \\dots \\times W_n \\times V_\\rho \\times \\dots \\times V_2 \\times V_1 \\to \\mathbb{R} \\\\ a \\mapsto a(w_1, w_2, \\dots , w_n; v_\\rho, \\dots , v_2, v_1)\\end{aligned} \\tag{5.6} \\]  参数空间 \\(\\{V_j\\}^\\rho_{j=1}\\)  和系数空间 \\(\\{W_j\\}^n_{j=1}\\)  可能都是相同的空间，但是它们通常是不同的，例如当Dirichlet边界条件施加于一个或多个空间时，或者当多重线性形式时 产生于混合问题的离散化时，例如第2.2.2节。\n在有限元应用中，形式的元数通常为 \\(\\rho=2\\)  ，在这种情况下，形式被称为是双线性的，或者在 \\(\\rho=1\\)  的情况下，形式被称为是线性的。 在 \\(\\rho=0\\)  的特殊情况下，我们将多重线性形式称为函数。 有时还可能考虑使用较高元数的形式（ \\(\\rho2\\)  ）。 下面，我们举例说明一些不同元数的多重线性形式。\n5·2·1 例子 泊松方程。 考虑电导率为 \\(\\kappa=\\kappa(x)\\)  的泊松方程，\n\\[ −\\mathrm{div}(\\kappa \\mathrm{grad} u) = f \\tag{5.7} \\]  假设边界 \\(\\partial \\Omega\\)  上的Dirichlet边界条件，相应的正则变分问题被定义在一对多重线性形式中： \\(a(\\kappa; u，v)= \\int_\\Omega{\\kappa \\mathrm{grad} \\ u \\cdot \\mathrm{grad} \\ v dx}\\)  和 \\(L(v)=\\int_\\Omega{f v dx}\\)  。 在此， \\(a\\)  是双线性形式（ \\(\\rho=2\\)  ）， \\(L\\)  是线性形式（ \\(\\rho=1\\)  ）。 这两种形式都有一个系数（ \\(n=1\\)  ），分别为 \\(\\kappa\\)  和 \\(f\\)  ：\n\\[ \\begin{aligned}a \u0026= a(\\kappa; u, v) \\\\ L \u0026= L(f ; v)\\end{aligned} \\tag{5.8} \\]  我们通常从表示中删除系数，并使用简写表示 \\(a = a(u, v)\\)  和 \\(L = L(v)\\)  。\n不可压缩Navier-Stokes方程。 不可压缩流的速度 \\(u\\)  和压强 \\(p\\)  满足不可压缩Navier-Stokes方程：\n\\[ \\begin{aligned}\\rho(\\dot{u} + \\mathrm{grad} \\ u \\cdot u) − \\mathrm{div} \\ \\sigma(u, p) \u0026= f \\\\ \\mathrm{div} \\ u \u0026= 0\\end{aligned} \\tag{5.9} \\]  其中，应力张量 \\(\\sigma\\)  由 \\(\\sigma(u, p)=2\\mu \\epsilon(u)− pI\\)  给出， \\(\\epsilon\\)  为对称梯度; 即 \\(\\epsilon(u)= \\frac{1}{2}(\\mathrm{grad} \\ u +(\\mathrm{grad} \\ u)^T)\\)  ， \\(\\rho\\)  是流密度， \\(f\\)  是力密度(body force)。 这里考虑通过将非线性项 \\(\\mathrm{grad} \\ u \\cdot u\\)  与测试函数 \\(v\\)  积分而获得的形式：\n\\[ a(u; v) = \\int_\\Omega{(\\mathrm{grad} \\ u \\cdot u) \\cdot v dx} \\tag{5.10} \\]  这是一个线性形式（ \\(\\rho=1\\)  ），有一个系数（ \\(n=1\\)  ）。 我们可以通过在固定速度 \\(\\bar{u}\\)  附近线性化来获得：\n\\[ a(u; v) = a(\\bar{u}; v) + a'(\\bar{u}; v)\\delta u + \\mathcal{O}(\\delta u^2) \\tag{5.11} \\]  其中， \\(u = \\bar{u} + \\delta u\\)  。 线性算子 \\(a'\\)  由下式给出:\n\\[ \\begin{aligned}a'(\\bar{u}; \\delta u, v) \u0026\\equiv a'(v; \\bar{u})\\delta u \\\\ \u0026= \\int_\\Omega{[(\\mathrm{grad} \\ \\delta u \\cdot \\bar{u}) \\cdot v + (\\mathrm{grad} \\ \\bar{u} \\cdot \\delta u) \\cdot v] dx}\\end{aligned} \\tag{5.12} \\]  这是一个双线性形式（ \\(\\rho=2\\)  ），系数为（ \\(n=1\\)  ）。 我们也可以考虑三重线性形式：\n\\[ a(w, u, v) = \\int_\\Omega{(\\mathrm{grad} \\ u \\cdot w) \\cdot v dx} \\tag{5.13} \\]  可以将此三重线性形式组装成三阶张量，并将其应用于 \\(w\\)  的给定展开系数向量，以获得与双线性形式 \\(a(w; u, v)\\)  对应的二阶张量（矩阵）。 这对于用不动点迭代方法求解Navier-Stokes方程可能很有用，在这种情况下， \\(w\\)  是从先前迭代获得的对流速度的给定（冻结）值。 由于组装全局三张量的成本，在实践中很少这样做。 但是，在每个局部胞元上，对应的局部三阶张量可能会与局部展开系数 \\(w\\)  缩并以计算与 \\(a(w; u, v)\\)  对应的矩阵。\n升力和阻力（Lift and drag）。 在求解Navier-Stokes方程时，可能需要计算浸入流体中某些物体的升力和阻力。 升力和阻力由作用在对象的力的z分量和x分量给出（相对x方向的流）：\n\\[ \\begin{aligned}L_{\\mathrm{lift}}(u, p; ) \u0026= \\int_\\Gamma(\\sigma(u, p)\\cdot n) \\cdot e_z ds \\\\ L_{\\mathrm{drag}}(u, p; ) \u0026= \\int_\\Gamma(\\sigma(u, p) \\cdot n) \\cdot e_x ds \\end{aligned} \\tag{5.14} \\]  此处， \\(\\Gamma\\)  是物体的边界， \\(n\\)  是 \\(\\Gamma\\)  的向外单位法线，而 \\(e_x, e_z\\)  分别是 \\(x\\)  方向和 \\(z\\)  方向上的单位矢量。 如图5.1所示。 这两种形式的元数都是 \\(\\rho=0\\)  ，并且这两种形式都有两个系数。\n图5.1 物体（此处为NACA 63A409机翼）的升力和阻力分别是物体表面 \\(\\Gamma\\)  上应力 \\(\\sigma\\cdot n\\)  的垂直分量和水平分量的积分。 在每个点，应力张量 \\(\\sigma\\)  与向外单位法向矢量 \\(n\\)  的乘积给出作用在表面上的每单位面积的力。 5·2·2 正则形式 FEniCS可自动处理一大类多重线性形式的表示和求值，但不是全部。 FEniCS当前仅限于可以表示为给定网格的胞元（域），外部维面（边界）和内部维面上的积分之和的形式。 特别是，FEniCS可处理表示如下的正则形式：\n\\[ \\begin{aligned}\u0026a(w_1, w_2,\\dots , w_n; v_\\rho, \\dots , v_2, v_1) \\\\ = \u0026\\sum^{n_c}_{k=1}\\int_{\\Omega_k}{I_k^c dx} + \\sum^{n_f}_{k=1} \\int_{\\Gamma_k}{I_k^f ds} + \\sum^{n^0_f}_{k=1} \\int_{\\Gamma^0_k}{I_k^{f,0} dS} \\end{aligned} \\tag{5.15} \\]  在此，每个 \\(\\Omega_k\\)  表示覆盖计算域 \\(\\Omega\\)  某子集的网格胞元并集。 同样，每个 \\(\\Gamma_k\\)  表示网格边界上维面的某个子集，而 \\(\\Gamma^0_k\\)  表示网格内部维面的某个子集。 后者对于不连续Galerkin方法的公式化特别有意义，该方法通常涉及跨胞元边界（内部维面）的积分。 每个子集的贡献是一些被积子集的积分。 因此，第 \\(k\\)  个胞元子集的贡献是被积量 \\(I_k^c\\)  等在 \\(\\Omega_k\\)  上的积分。\n可以考虑（5.15）的扩展，其中涉及单个胞元（切割胞元）或维面的子集上的点值或积分。 FEniCS当前不支持此类扩展，但将来可能会添加。\n5·3 离散多重线性形式 正如我们在第2章中看到的那样，可以通过求解线性方程组 \\(A U = b\\)  来获得正则变分问题（5.1）的有限元逼近 \\(u_h = \\sum^N_{j=1}{U_j \\phi_j} \\approx u\\)  ，其中\n\\[ \\begin{aligned}A_{ij} \u0026= a(\\phi_j, \\hat{\\phi}_i), \\quad i,j = 1, 2, \\dots , N \\\\ b_i \u0026= L(\\hat{\\phi}_i),\\quad i = 1, 2, \\dots , N \\end{aligned} \\tag{5.16} \\]  这里，在给定试探空间和测试空间的基底下， \\(A\\)  和 \\(b\\)  是离散算符，分别对应于双线性形式 \\(a\\)  和线性形式 \\(L\\)  。 请注意，离散算符被定义为作用于基函数的多重线性形式的转置，可由以下事实解释：在双线性形式 \\(a(u, v)\\)  中，试探函数 \\(u\\)  与矩阵 \\(A\\)  的列相关联， 而测试函数 \\(v\\)  与矩阵 \\(A\\)  的行（方程式）相关联。\n通常，我们可以离散化一个 \\(\\rho\\)  重线性形式 \\(a\\)  以获得秩为 \\(\\rho\\)  的张量 \\(A\\)  。 离散算符 \\(A\\)  定义如下：\n\\[ A_i = a(w_1, w_2, \\dots , w_n; \\phi_{i_\\rho}^\\rho,\\dots , \\phi_{i_2}^2, \\phi_{i_1}^1) \\tag{5.17} \\]  其中， \\(i =(i_1, i_2, \\dots, i_\\rho)\\)  是长度为 \\(\\rho\\)  的多重索引，而 \\(\\{\\phi_k^j\\}^N_{k=1}\\)  是 \\(V_{j,h}\\subset V_j, j = 1,2,\\dots,\\rho\\)  的基底。 这个离散算符是秩为 \\(\\rho\\)  且维数为 \\(N_1 \\times N_2\\times\\dots\\times N_\\rho\\)  的典型稀疏张量。\n可以使用称为组装（assembly）的算法高效地计算离散算符 \\(A\\)  ，这是下一章的主题。 正如我们将看到的那样，一个重要的工具是胞元张量（the cell tensor），它是由网格的局部胞元上双线性形式的离散化而得到的。 特别地，考虑可以表示为网格 \\(\\mathcal{T}_h=\\{T\\}\\)  的每个胞元 \\(T\\)  的局部贡献之和的多重线性形式的离散化。\n\\[ \\begin{aligned}\u0026a(w_1, w_2, \\dots, w_n; v_\\rho, \\dots , v_2, v_1) \\\\ = \u0026\\sum_{T\\in \\mathcal{T}_h} a_T(w_1, w_2, \\dots , w_n; v_\\rho, \\dots , v_2, v_1)\\end{aligned} \\tag{5.18} \\]  对于 \\(j = 1,2,\\dots,\\rho\\)  ，在 \\(T\\)  上使用局部有限元基底 \\(\\{\\phi_k^{T,j}\\}^{n_j}_{k=1}\\)  来离散化 \\(a_T\\)  ，得到胞元张量\n\\[ A_{T,i} = a_T(w_1, w_2, \\dots , w_n; \\phi^{T,\\rho}_{i_\\rho}, \\dots , \\phi^{T,2}_{i_2}, \\phi^{T,1}_{i_1}) \\tag{5.19} \\]  胞元张量 \\(A_T\\)  是典型的稠密张量，其秩为 \\(\\rho\\)  和维度为 \\(n_1 \\times n_2\\times\\dots\\times n_\\rho\\)  。 离散算符A可以通过对每个胞元张量 \\(A_T\\)  贡献适当求和来获得。 我们将在后面的第6章中进行详细介绍。\n类似地，可以将外部和内部维面张量 \\(A_S\\)  和 \\(A_{S, 0}\\)  定义为网格边界上或内部的维面的贡献。 如（5.19）所述，可用维面 \\(S\\)  代替积分域 \\(T\\)  来定义外部维面张量 \\(A_S\\)  。 \\(A_S\\)  的维度通常与 \\(A_T\\)  的维度相同。 内部维面张量 \\(A_{S, 0}\\)  的定义则略有不同，通过考虑由包含共享公共维面 \\(S\\)  的两个单元组成的宏单元（如图5.2所示）来定义。 有关详细信息，请参见Ølgaard等（2008）。\n图5.2 网格上的胞元张量 \\(A_T\\)  ，外部维面张量 \\(A_S\\)  和内部维面张量 \\(A_{S, 0}\\)  ，分别通过胞元，外部维面或内部维面对多重线性形式的局部贡献的离散化获得的。 通过组装来自所有胞元和维面张量的局部贡献，可以通过多重线性形式离散化来获得全局离散算符 \\(A\\)  。 5·4 多重线性形式的作用 考虑双线性形式\n\\[ a(u, v) = \\int_\\Omega{ \\mathrm{grad}\\ u \\cdot \\mathrm{grad}\\ v dx} \\tag{5.20} \\]  来自从泊松方程左侧的离散化。 这里， \\(u\\)  和 \\(v\\)  是一对试探和测试函数。 另外，我们可以将 \\(v\\)  视为一个测试函数，并将 \\(u\\)  视为一个给定的解，以获得系数 \\(u\\)  上参数化的线性形式：\n\\[ (\\mathcal{A}a)(u; v) = \\int_\\Omega{ \\mathrm{grad} \\ u \\cdot \\mathrm{grad} \\ v dx} \\tag{5.21} \\]  我们将线性形式 \\(\\mathcal{A}a\\)  称为双线性形式 \\(a\\)  的作用。 通常，具有 \\(n\\)  个系数的 \\(\\rho\\)  重线性形式的作用是具有 \\(n+1\\)  个系数的 \\((\\rho−1)\\)  线性形式。 特别地，双线性形式的作用是线性形式，而线性形式的作用是函数。\n双线性形式的作用在求解微分方程的无矩阵法的定义中起着重要作用。 考虑通过Krylov子空间方法（例如GMRES（广义最小残差方法）（Saad和Schultz，1986）或CG（共轭梯度方法）（Hestenes和Stiefel，1952））求解正则形式（5.1）的变分问题。 Krylov方法，通过由向量 \\(b, A b, A^2 b, \\dots, A^k b\\quad k \\ll N\\)  张成的 \\(\\mathbb{R}^N\\)  子空间寻求 \\(U\\)  的近似，来获得线性方程组 \\(A U = b\\)  的近似解 \\(U \\in \\mathbb{R}^N\\)  。 这些向量可以通过重复应用前面定义的离散算符 \\(A\\)  来计算：\n\\[ A_{ij} = a(\\phi^2_j, \\phi^1_i) \\tag{5.22} \\]  对任何给定的矢量 \\(U \\in \\mathbb{R}^N\\)  ，有\n\\[ \\begin{aligned}(AU)_i =\u0026\\sum^N_{j=1}A_{ij}U_j =\\sum^N_{j=1}a(\\phi^2_j, \\phi^1_i)U_j \\\\ = \u0026a \\left(\\sum^N_{j=1}U_j\\phi^2_j, \\phi^1_i\\right) = a(u_h, \\phi^1_i) = (\\mathcal{A}a)(u_h; \\phi^1_i)\\end{aligned} \\tag{5.23} \\]  其中， \\(u_h = \\sum^N_{j=1}U_j\\phi^2_j\\)  是对应于系数向量 \\(U\\)  的有限元近似。 换句话说，矩阵 \\(A\\)  在给定向量 \\(U\\)  上的应用，是由相应的有限元近似下双线性形式取值的作用给出：\n\\[ (AU)_i = (\\mathcal{A}a)(u_h; \\phi^1_i) \\tag{5.24} \\]  因此，可以通过对线性形式（双线性形式 \\(a\\)  的作用 \\(\\mathcal{A}a\\)  ）的计算（组装）来求解变分问题（5.1），以代替先计算（组装）矩阵 \\(A\\)  ，后重复计算与 \\(A\\)  的矩阵-矢量积。 哪种方法更有效取决于与矩阵组装相比作用的计算效率，以及可用的预处理器。 对于多重线性形式作用的进一步讨论，参考Bagheri和Scott（2004）。\nUFL形式语言通过调用action函数来支持计算多重线性形式的作用：\n# Python code a = inner(grad(u), grad(v))*dx Aa = action(a) 5·5 多重线性形式的导数 当离散化非线性变分问题时，可能需要计算一个或多个系数的多重线性形式的导数。 考虑这个非线性变分问题：需求 \\(u \\in V\\)  ，满足\n\\[ a(u; v) = 0 \\quad \\forall v \\in \\hat{V} \\tag{5.25} \\]  为了用牛顿方法解决这个问题，我们在固定值 \\(\\bar{u}\\)  附近进行线性化处理，以获得\n\\[ 0 = a(u; v) \\approx a(\\bar{u}; v) + a'(\\bar{u}; v)\\delta u \\tag{5.26} \\]  对于给定的非线性变分问题（5.25）的近似解 \\(\\bar{u}\\)  ，我们可能希望通过求解以下线性变分问题来改善近似解：需求 \\(\\delta u \\in V\\)  ，满足\n\\[ a'(\\bar{u}; \\delta u, v) \\equiv a'(\\bar{u}; v)\\delta u = −a(\\bar{u}; v) \\quad \\forall v \\in \\hat{V} \\tag{5.27} \\]  在这里， \\(a'\\)  是一个双线性形式，具有两个参数 \\(\\delta u\\)  和 \\(v\\)  ，以及一个系数 \\(\\bar{u}\\)  。 此外， \\(−a\\)  是具有一个参数 \\(v\\)  和一个系数 \\(\\bar{u}\\)  的线性形式。\n当系数不止一个时，我们使用符号 \\(\\mathrm{D}_w\\)  表示相对于特定系数 \\(w\\)  的导数。 通常，具有 \\(n0\\)  个系数的 \\(\\rho\\)  重线性形式的导数 \\(\\mathcal{D}\\)  是具有 \\(n\\)  个系数的 \\((\\rho+1)\\)  重线性形式。 要使用无矩阵牛顿法求解变分问题（5.25），我们将需要针对给定的有限元近似 \\(u_h\\)  和增量 \\(\\delta u_h\\)  重复计算线性形式 \\((\\mathcal{A}\\mathcal{D}_u a)(\\bar{u}_h, \\delta u_h; v)\\)  。\n注意，可以等效地考虑将牛顿法应用于非线性离散系统方程组，该方程组是通过将有限元方法直接应用于变分问题（5.25）而获得的，如第二章所述。\nUFL形式语言通过调用derivative函数来支持计算多重线性形式的导数：\n# Python code a = inner((1 + u)*grad(u), grad(v))*dx Da = derivative(a, u) 5·6 双线性形式的伴随 双线性形式 \\(a\\)  的伴随 \\(a^*\\)  是通过交换两个参数而获得的形式：\n\\[ a^*(v, w) = a(w, v) \\quad \\forall v \\in V^1 \\ \\forall w \\in V^2 \\tag{5.28} \\]  双线性形式的伴随在有限元方法的误差分析中起着重要的作用，正如我们在第2章中看到的，以及将在第29章中进一步讨论的那样，其中我们考虑了一般非线性变分的线性伴随问题（对偶问题） 问题（5.25）。 对偶问题采取形式\n\\[ (\\mathcal{D}_u a)^*(u; z, v) = \\mathcal{D}_u \\mathcal{M}(u; v) \\quad \\forall v \\in V \\tag{5.29} \\]  或简写成\n\\[ a'*(z, v) = \\mathcal{M}'(v) \\quad \\forall v \\in V \\tag{5.30} \\]  其中， \\((\\mathcal{D}_u a)^*\\)  是双线性形式， \\(\\mathcal{D}_u M\\)  是线性形式（泛函 \\(\\mathcal{M}\\)  的导数）， \\(z\\)  是对偶问题的解。 UFL形式语言通过调用adjoint函数来支持计算多重线性形式的伴随函数：\n# Python code a = div(u)*q*dx a_star = adjoint(a) 5·7 关于试探函数和测试函数的说明 在文献中通常考虑双线性形式，其中试探函数 \\(u\\)  是第一个参数，而测试函数 \\(v\\)  是第二个参数：\n\\[ a = a(u, v) \\tag{5.31} \\]  通过这种表示法，可以将离散算符 \\(A\\)  定义为\n\\[ A_{ij} = a(\\phi_j, \\phi_i) \\tag{5.32} \\]  也就是说，必须引入转置以解决以下事实：试探和测试函数的次序与矩阵中行和列的次序不匹配。 或者，可以更改试探和测试函数的次序，并写成 \\(a = a(v，u)\\)  ，并避免在离散算符 \\(A_{ij} = a(\\phi_i, \\phi_j)\\)  的定义中进行转置。 这在定义和实现变分形式的通用软件，诸如FEniCS之类的软件系统中很实用。\n在本书以及FEniCS项目的所有代码和文档中，我们采用了以下折衷方案。 变分形式使用常规的试探和测试函数次序表示； 那就是，\n\\[ a = a(u, v) \\tag{5.33} \\]  但对使用非常规编号的试探和测试函数。 此时， \\(v\\)  是双线性形式的第一个参数， \\(u\\)  是第二个参数。 这样可以确保人们可以用常规符号表示有限元的变分问题，但同时又允许实现使用一种更实际的编号方案。\n【章节目录】\n"}),a.add({id:48,href:'/notes/docs/fem/0104/',title:"构造通用参考单元（二）【翻译】",content:"【章节目录】\n4·4 单元的例子 我们用一些标准的有限元来说明这些概念。 也请读者参考第3章，以便更全面地审查单元及其属性。\n例4.1 拉格朗日单元\n图4.2 一次和二次的拉格朗日单元。 图4.2所示， 最常见的拉格朗日单元。 其自由度由黑点表示，黑点表示点值。 一次单元显示在左边的三角形中，其自由度包括每个顶点的点值。 也就是说，自由度   \\(\\ell_i:V \\to \\mathbb{R}\\)  为：\n\\[ \\ell_i(v) = \\int_T{v \\delta_{x_i} dx} = v(x_i) \\tag{4.22} \\]  其中， \\(x_i\\)  是顶点 \\((0,0), (1,0), (0,1)\\)  ，而 \\(\\delta\\)  是狄拉克函数。 相应的基函数是 \\(1−x−y, x, y\\)  。 二次单元显示在右边的三角形中。 它具有六个自由度，三个在顶点，三个在边上，都是点值。 拉格朗日单元产生分段连续多项式，因此非常适合用作 \\(H^1\\)  的近似。 在任意维上的单纯形上， \\(q\\)  次拉格朗日单元可张 \\(\\mathcal{P}_q\\)  。\n例4.2 Hermite单元\n图4.3 三次Hermite单元。 图4.3所示，2维参考三角形上的Hermite单元。 黑点表示点值，而深灰色圆圈表示x和y偏导数值。 也就是说，与顶点 \\(x_i\\)  相关的自由度 \\(\\ell_{i_k}:\\mathcal{V} \\to \\mathbb{R}\\)  为：\n\\[ \\ell_{i_1}(v) = \\int_T{v \\delta_{x_i} dx} = v(x_i) \\tag{4.23} \\]  \\[ \\ell_{i_2}(v) = \\int_T{\\frac{\\partial v}{\\partial x} \\delta_{x_i} dx}=\\frac{\\partial}{\\partial x} v(x_i) \\tag{4.24} \\]  \\[ \\ell_{i_3}(v) = \\int_T{\\frac{\\partial v}{\\partial y} \\delta_{x_i} dx} =\\frac{\\partial}{\\partial y} v(x_i) \\tag{4.25} \\]  再加上一个内部点值，一共十个自由度，这与 \\(\\mathcal{P}_3\\)  中的自由度数相同。 Hermite单元的一个特征就是它在顶点处具有连续导数（但是不一定有 \\(H^2\\)  -符合的近似）。\n例4.3 Raviart–Thomas单元\n图4.4 三角形的一次Raviart–Thomas单元。 如图4.4所示，这是最低阶的Raviart–Thomas单元。 与之前的单元相比，此单元有一个向量值函数空间。 箭头代表法线矢量； 也就是说，自由度 \\(\\ell_i:\\mathcal{V} \\to \\mathbb{R}\\)  ：\n\\[ \\ell_i(v) = \\int_T{v \\cdot n_i dx} \\tag{4.26} \\]  其中， \\(n_i\\)  是边 \\(i\\)  上的向外法向矢量。 Raviart–Thomas单元是具有三个自由度的矢量空间。 因此，标准基底 \\([\\mathcal{P}_q]^d\\)  不是合适的起点，我们改用 \\(V = [\\mathcal{P}_0]^2 \\oplus x \\mathcal{H}_0\\)  。 Raviart–Thomas单元通常用于 \\(H(\\mathrm{div})\\)  中的近似值。 我们注意到，也可以根据法向分量的点值来定义此单元。\n4·4·1 其它多项式空间的基底 上面介绍的基底适合构造许多有限元，但是正如我们刚刚看到的，它们并非在所有情况下都有效。 二维的Raviart–Thomas函数空间由下张成：\n\\[ [\\mathcal{P}_n]^2 \\oplus \\left(\\begin{aligned}y \\\\ x\\end{aligned}\\right) \\mathcal{H}_n^2 \\tag{4.27} \\]  因此，该单元需要用 \\(\\left(\\begin{aligned}y \\\\ x\\end{aligned}\\right) \\mathcal{H}_n^2\\)  加强多项式向量 \\((P_n^2)^2\\)  的基底。 另一方面，三角形上的Brezzi-Douglas-Fortin-Marini单元被定义为：\n\\[ \\{u \\in [\\mathcal{P}_n(T)]^2 : u \\cdot n \\in \\mathcal{P}_{n−1}(E_i), E_i \\in \\mathcal{E}(T)\\} \\tag{4.28} \\]  其中， \\(\\mathcal{E}(T)\\)  表示 \\(T\\)  的维面。\n因此，该单元要求从 \\([\\mathcal{P}_n(T)]^2\\)  中剔除一部分函数。 这种剔除由约束 \\(u \\cdot n \\in \\mathcal{P}_{n-1}(E_i)\\)  表示。\n该空间基底的获得，有些微妙。 FIAT和SyFi已经开发了不同的，但在数学上等效的解决方案。 在SyFi中，由于它使用符号表示，因此可以轻松地用幂基底来表达多项式，并将与垂直于边缘的n阶多项式相对应的系数设置为零。 FIAT以类似的方式利用勒让德多项式的正交性来表示约束。 也就是说，在边缘 \\(E_i\\)  上，以下约束适用：\n\\[ \\ell_i^C(u) = \\int_{E_i}{(u \\cdot n)\\mu_n^i} = 0 \\tag{4.29} \\]  其中， \\(\\mu_n^i\\)  是边 \\(E_i\\)  上的n次勒让德多项式。\n通常，假设有 \\(m\\)  个约束和 \\(n - m\\)  个自由度。令\n\\[ V^1_{ij} = \\ell_i(\\phi_j), 1 \\le i \\le n − m, 1 \\le j \\le n \\tag{4.30} \\]  \\[ V^2_{ij} = \\ell^C_i(\\phi_j), n-m 和\n\\[ V = \\left(\\begin{aligned}V^1 \\\\ V^2\\end{aligned}\\right) \\tag{4.32} \\]  现在考虑矩阵方程\n\\[ V \\alpha^T= I^{n,n−m} \\tag{4.33} \\]  其中， \\(I^{n,n-m}\\)  表示 \\(n \\times (n-m)\\)  单位矩阵。 如前所述， \\(\\alpha\\)  的第 \\(j\\)  列 \\(\\{\\phi_j\\}\\)  中第 \\(j\\)  项的，以 \\(\\{\\psi_i\\}\\)  为节点基底函数的展开系数。 此外， \\(V^2 \\alpha^T= 0\\)  ，意味着节点基底函数应该满足约束条件。 除了Brezzi-Douglas-Fortin-Marini单元之外，还有根据约束多项式定义的其他例子，比如Nédélec（Nédélec，1980），Arnold-Winther（Arnold and Winther，2002），Mardal-Tai-Winther（ Mardal等，2002），Tai-Winther（Tai和Winther，2006）和Bell（Ciarlet，2002）的单元族。\n4·5 多项式空间上的操作 在这里，我们展示了如何根据线性代数运算来转换各种重要运算，并假设这些运算可在原始基底 \\(\\{\\psi_i\\}^n_{i=1}\\)  上执行。\n4·5·1 求值 为了计算在给定点 \\(x \\in T\\)  处的节点基底 \\(\\{\\phi_i\\}^n_{i=1}\\)  ，只需简单地计算向量\n\\[ \\Psi_i = \\psi_i(x) \\tag{4.34} \\]  进而\n\\[ \\phi_i(x) \\equiv \\Phi_i = \\sum_j{\\alpha_{ij} \\Psi_j} \\tag{4.35} \\]  通常，节点基函数被要求是在点组 \\(\\{x_j\\}^m_{j=1} \\subset T\\)  上的。 出于性能原因，优先考虑执行矩阵乘积。 因此，不妨定义 \\(\\Psi_{ij}=\\Psi_i(x_j)\\)  和 \\(\\Phi_{ij}=\\Phi_i(x_j)\\)  。 然后，所有节点基函数都可以通过乘法来计算：\n\\[ \\Phi_{ij} = \\sum_k{\\alpha_{ik}\\Psi_{kj}} \\tag{4.36} \\]  4·5·2 微分 微分则更复杂，并提供更多选择。 令 \\(\\alpha=（\\alpha_1, \\alpha_2, \\dots, \\alpha_d）\\)  为多重索引，因此\n\\[ D^\\alpha \\equiv \\frac{\\partial^{|\\alpha|}}{\\partial x_1^{\\alpha_1} \\partial x_2^{\\alpha_2} \\dots \\partial x_d^{\\alpha_d}} \\tag{4.37} \\]  其中， \\(|\\alpha| = \\sum^d_{i=1} \\alpha_i\\)  ，并且我们想计算数组：\n\\[ \\Phi_i^\\alpha = D^\\alpha \\phi_i(x) \\tag{4.38} \\]  对一些 \\(x \\in T\\)  。\n一个明显的选择是对原始基函数 \\(\\{\\psi_i\\}\\)  微分得到一个数组：\n\\[ \\Psi_i^\\alpha = D^\\alpha \\psi_i(x) \\tag{4.39} \\]  进而\n\\[ \\Phi_i^\\alpha = \\sum_j{\\alpha_{ij}\\Psi^\\alpha_{ji}} \\tag{4.40} \\]  根据这些预设，可以方便地计算 \\(\\{\\psi_i\\}\\)  的所有导数。 在符号计算或使用幂基底时，通常这是对的。 对于Bernstein，雅可比和勒让德多项式，有递归关系可用，请参见Karniadakis和Sherwin（2005）； Kirby（2010b）。 通常情况下，Dubiner基底包含一个坐标奇点，以防止自动微分作用于顶部顶点。 Kirby（2010a）的最新工作重新制定了递归关系以考虑这种可能性。\n如果乐意的话（或者由特定开始基底所要求的），还可以计算 \\(\\{\\phi_i\\}\\)  的一阶导数矩阵，并构造比它们更高阶的导数。 对于每个坐标方向 \\(x_k\\)  ，构造矩阵 \\(D^k\\)  以满足：\n\\[ \\frac{\\partial \\phi_i}{\\partial x_i} = D^k_{ij} \\phi_j \\tag{4.41} \\]  如何做到这种依赖于所选择基底的操作。 有关基于Dubiner的更详细信息，请参见Dubiner（1991）。\n4·5·3 积分 在参考域上，对基函数（包括基本函数和/或其导数的乘积）的积分，可以通过数值，符号或精确地用一些已知公式来执行。 通常，正交的情况很容易执行。 例如，可以从各种参考单元获得正交规则（Dunavant，1985； Keegan等，2008；Šolín等，2004）。\n4·5·4 维面（facet）关联 正如我们在定义Brezzi-Douglas-Marini单元时所看到的，有必要有与多边形域的各个维面相关联的多项式。 Bernstein多项式通过重心坐标表示，因此自然与维面关联。 勒让德和雅可比多项式也很容易与重心坐标中的一维面关联。\n4·5·5 线性泛函 线性泛函通常是根据积分，逐点求值和微分的线性组合进行转换的。\n4·5·6 参考单元的映射 FEniCS软件和许多其他有限元代码中，普遍采用的一种惯例是将节点基函数从参考胞元映射到网格中的每个胞元。 有时，这就像更改坐标一样简单。 在其他情况下，则更为复杂。 为了完整起见，我们简要地描述了根据参考单元映射创建全局有限元的基底。 因此，令 \\(T\\)  为网格中的一个全局多边形， \\(\\hat{T}\\)  为对应的参考多边形。 在坐标 \\(x \\in T\\)  和 \\(\\hat{x} \\in \\hat{T}\\)  之间，我们使用映射\n\\[ x = F_T(\\hat{x}) = A_T(\\hat{x}) + x_0 \\tag{4.42} \\]  这个映射的雅可比：\n\\[ J(\\hat{x}) =\\frac{\\partial x}{\\partial \\hat{x}} = \\frac{\\partial A_T(\\hat{x})}{\\partial \\hat{x}} \\tag{4.43} \\]  目前，FEniCS仅支持 \\(T\\)  和 \\(\\hat{T}\\)  间的仿射映射，这意味着 \\(x = F_T(\\hat{x})= A_T \\hat{x} + x_0\\)  和 \\(J = A_T\\)  。 等参单元的一个基函数，被定义成参考单元上的相应基函数：\n\\[ \\phi(x) = \\hat{\\phi}(\\hat{x}) \\tag{4.44} \\]  然后可以在参考多边形上执行积分，\n\\[ \\int_T{\\phi(x) dx} = \\int_{\\hat{T}}{\\hat{\\phi}(\\hat{x}) \\mathrm{det} \\ J d\\hat{x}} \\tag{4.45} \\]  空间导数由参考单元上的导数和使用链规则的几何映射来定义，\n\\[ \\frac{\\partial \\phi}{\\partial x_i} = \\sum_j{\\frac{\\partial \\hat{\\phi}}{\\partial \\hat{x}_j}\\frac{\\partial \\hat{x}_j}{\\partial x_i} } \\tag{4.46} \\]  上面基函数映射通常对于 \\(H^1\\)  中的近似值。 对于 \\(H(\\mathrm{div})\\)  或 \\(H(\\mathrm{curl})\\)  的近似，必须使用Piola映射，其中基函数的映射不同于几何映射。 也就是说，对于 \\(H(\\mathrm{div})\\)  单元，Piola映射为：\n\\[ \\phi(x) = \\frac{1}{|\\mathrm{det} \\ J|} J \\hat{\\phi}(\\hat{x}) \\tag{4.47} \\]  当通过UFC使用网格实体编号时（参见第16章），使用 \\(\\frac{1}{\\mathrm{det} \\ J}\\)  代替 \\(\\frac{1}{|\\mathrm{det} \\ J|}\\)  是有利的。 这是因为行列式的符号与法向矢量的符号相关，参见Rognes等（2009），以了解Piola映射及其在FFC中的实施的更多信息。 某些单元，比如Rannacher-Turek单元（Turek，1999； Rannacher和Turek，1992），相对参考单元的类似定义，在全局定义时具有更好的性质。\n4·5·7 局部到全局的自由度映射 图4.5 在一对胞元上将一对二次局部函数空间拼接在一起，以形成全局连续的分段二次函数空间。  如图4.5所示，有限元通过自由度连续地拼接在一起。 为了完成这种拼接，单元应提供决定是否应共享某些相邻单元自由度的标识符。 一种替代方案是使参考胞元上的每个自由度与参考胞元中的一个点相关。 然后，几何映射通过（4.42）给出网格中的全局点，该全局点标识了自由度。 也就是说，如果不同单元对应于网格中的相同全局点，则它们的自由度是共享的。 也就是说，每个自由度可以与参考单元上的局部网格实体，例如顶点，边或面有关。 单元映射后，自由度将与全局网格中的相应网格实体相关。 此替代方法要求对相应的网格实体进行编号。\n【章节目录】\n"}),a.add({id:49,href:'/notes/docs/fem/0103/',title:"构造通用参考单元（一）【翻译】",content:"【章节目录】\n本章介绍了在参考域上构造通用有限元类的数学框架。 FIAT和SyFi项目均使用此框架，请分别参见第13章和第15章。 我们的目标是提供一个框架，可以自动构建具有非常复杂基底的单纯有限元。 我们从有限元的经典Ciarlet定义及其“节点”基底（这个抽象概念，比标准的面向节点的拉格朗日多项式更加通用和强大）出发开展工作。\n迄今为止，我们的方法还没有包括样条线型空间（例如在等几何分析中变得越来越流行（Hughes等人，2005）），也没有完全解决XFEM（Chessa等人，2002）或hp-型方法（ Schwab，1998）。 但是，在等几何分析中，基函数很容易通过样条线理论由简单递归关系来定义，因此不需要FIAT或SyFi之类的工具。 XFEM通过特殊的基函数增强现有的有限元空间来捕获奇异的行为 - 我们的方法可以提供常规基底，而不是“额外”的（基）函数。 最后，可以处理hp方法中施加的约束，虽然用我们的方法困难，但是对四面体hp基底是合适的（Ainsworth和Coyle，2003年）。 我们稍后再讨论其中一些问题。\n4·1 背景 有限元文献包含大量的近似空间和自由度，其中许多在第3章中进行过介绍。 某些应用,比如Cahn-Hilliard和其他四阶问题，可受益于非常光滑的有限元基底，而多孔介质流则需要通过分段多项式函数来离散化矢量场，其中只有跨胞元边界的法向分量是连续的。 电磁学中的许多问题都通过使用到Nédélec单元来获得切向连续的矢量场（Nédélec，1980，1986）。 许多单元经过精心设计以满足inf-sup条件（Brezzi和Fortin，1991； Girault和Raviart，1986），最初是为了解释不可压缩流问题离散化的稳定性而设计的。 此外，有些问题需要低阶离散化，而另一些问题可以通过高阶多项式来有效解决。\n自动生成有限元方法的计算机程序，尽管需要面对文献中已发现的大量有限元族，但它也提供了一条便捷的途径，可以更广泛地使用Raviart-Thomas，Nédélec和其他难于编程的单元。 理想的情况是，人们希望在抽象的层次上描述不同的有限元空间，然后计算机代码可以识别出如何对基函数进行求值和微分。 此类目标在很大程度上由FIAT和SyFi项目实现，其实现在第13章和第15章中将有描述。\n对于有限元系统的最终用户而言，像FIAT和SyFi之类的项目最终仍可能是神秘的，因为与有限元库的交互通常是通过构造全局有限元运算符的工具来进行的。 如果满足两个条件，则最终用户通常会感到满意。 首先，有限元系统应支持目标应用领域中常用的单元。 其次，它提供了近似阶次的灵活性。\n通过只实现一组先验的有限元，就完全有可能满足许多用户的需求。 在某些时候，这甚至看起来更理想。 例如，在大量研究，诸如Raviart-Thomas-Nédélec单元和Brezzi-Douglas-Marini单元族的研究，导致新的单元族的发展大大放缓了。 然后，Arnold，Falk和Winther在外微积分背景下进行的最新工作不仅使人们对现有单元族有了更好的了解，而且还带来了性能得到改善的新一波单元，请参见Arnold等（2006a）的概述。 有限元基底的生成系统可以更容易地吸收这些及其未来的发展。 自动化还提供了标准库可能无法提供的近似阶次方面的通用性。 最后，最终用户甚至可以轻松定义自己的新单元，并在对其进行数学分析之前测试其数值属性。\n在本章中，我们描述了诸如FIAT，SyFi和Exterior项目（Logg和Mardal，2009）之类的数学形式。 这种形式起于由Ciarlet（2002）经典定义给出的有限元。 然后，它使用基本的线性代数，根据易于实现且在浮点运算中表现良好的多项式，为抽象有限元构造适当的基底。 我们专注于为单个固定参考单元构建节点基底。 正如我们将在第11章和第15章中看到的那样，形式编译器（例如FFC和SFC）将在单个参考单元上工作。\n文献中还存在其他方法，例如Szabó等人 （1991）研究的层次基底（the hierarchical bases ），还有Ainsworth和Coyle（2003）等人对   \\(H(\\mathrm{curl})\\)  和 \\(H(\\mathrm{div})\\)  空间扩展的工作。 这些方法可以为有限元方法中的网格和多项式阶次的定义提供更大的灵活性，但是它们在组装过程中也需要更多的注意，并且通常针对每个单元族视情况构造基底。 当它们可用时，它们的构造可能比使用此处所研究的技术更方便，但是该技术更易于应用于“任意”有限元，因此在自动软件的环境中应该被考虑。\n4·2 预备 FIAT和SyFi都使用了Ciarlet引入的有限元抽象定义的略微修改版。\n定义4.1 (有限元(Ciarlet, 2002)) 一个有限元被定义成一个三元组 \\((T, \\mathcal{V}, \\mathcal{L})\\)  ：\n  域 \\(T\\)  是 \\(\\mathbb{R}^d,\\quad d=1,2,3,\\dots\\)  的有界闭子集，具有非空内部和分段光滑边界；\n   \\(\\mathcal{V} = \\mathcal{V}(T)\\)  是 \\(T\\)  上的 \\(n\\)  维有限维函数空间；\n  自由度（节点）集 \\(\\mathcal{L} = \\{\\ell_1, \\ell_2, \\dots , \\ell_n\\}\\)  是对偶空间 \\(\\mathcal{V}'\\)  的基底；也就是 \\(V\\)  上的有界线性泛函空间。\n  在此定义中，术语“有限元”，不仅指网格中的特定胞元，还指代相关的函数空间和自由度。 通常，域 \\(T\\)  是一些简单的多边形或多面体，函数空间 \\(\\mathcal{V}\\)  则由多项式组成。\n给定一个有限元，可以使用以下定义来计算该单元的的具体基底（通常称为节点基底）。\n定义4.2 有限元 \\((T, \\mathcal{V}, \\mathcal{L})\\)  的节点基底，是一个函数集 \\(\\{\\phi_i\\}^n_{i=1}\\)  ，满足：\n\\[ \\ell_i(\\phi_j) = \\delta_{ij},\\quad 1\\le i,j\\le n \\tag{4.1} \\]  本章中的主要问题是此节点基底的构建。 对于任何给定的有限元，都可以用基本代数显式地构造节点基底。 但是，这会变得很乏味，因为我们考虑了许多不同的单元族，并希望包括每个族的任意次单元。 因此，我们在这里提出了一个新的范式，用于支持自动构建节点基底的计算机程序。\n除了构造节点基底之外，我们还需要记住，有限元需要被修补在一起，使得在网格上形成分段多项式场。 针对特定问题的特定有限元方法的适用性（或稳定性）取决于问题的连续性要求。 通常会选择特定单元的自由度，以满足这些连续性要求。\n因此，除了计算节点基底之外，这里开发的框架还简化了用于以下任务的软件：\n  基函数及其导数在各点的取值。\n  将基函数（或自由度）与 \\(T\\)  的拓扑维面（例如其顶点，边及其在边上的位置）相关联。\n  将每个基本函数与其他元数据相关联，这些元数据描述了用于基函数及其导数取值的映射。\n  提供用于计算任意函数的自由度的规则（Dirichlet边界条件的需要）。\n  第1点在符号计算框架（SyFi）中相对简单，但是如果使用数值算术（FIAT）来实现，则需要格外小心。 当有限元小于或大于 \\(C^0\\)  连续时，中间的两点包括客户代码所需的信息，用以对参考基底进行变换，并且组装成全局自由度。 最终的任务，是以某点取值、微分、（更一般地）对点和权重求和的形式，非常类似于正交规则。\n4·3 数学框架 4·3·1 基底变更 构造节点基底的基本思想来自基本线性代数：一个将所需的（节点）基底构造为另一种可用基底的线性组合。 我们将从张成 \\(\\mathcal{V}\\)  的某个基底 \\(\\{\\psi_i\\}^n_{i=1}\\)  开始。 据此，我们将每个节点基函数 \\(\\phi_j\\)  构造为：\n\\[ \\phi_j = \\sum^n_{k=1}{\\alpha_{jk}\\psi_k} \\tag{4.2} \\]  任务是计算出矩阵 \\(\\alpha\\)  , 使得每个固定的 \\(\\phi_j\\)  满足：\n\\[ \\ell_i(\\phi_j) = \\delta_{ij} \\tag{4.3} \\]  并且使用上面 \\(\\phi_j\\)  的展开式，得到：\n\\[ \\delta_{ij} = \\sum^n_{k=1}{\\ell_i(\\alpha_{jk}\\psi_k)} = \\sum^n_{k=1}{\\alpha_{jk}\\ell_i(\\psi_k)} \\tag{4.4} \\]  所以，对固定的 \\(j\\)  , 我们有 \\(n\\)  元方程组：\n\\[ \\sum^n_{k=1}{B_{ik}\\alpha_{jk}} = \\delta_{ij} \\tag{4.5} \\]  其中，\n\\[ B_{ik} = \\ell_i(\\psi_k) \\tag{4.6} \\]  这是广义范德蒙矩阵的一种。 当然 (4.5) 还可以写成：\n\\[ B \\alpha^T= I \\tag{4.7} \\]  并且有：\n\\[ \\alpha = B^{-T} \\tag{4.8} \\]  在实践中，假定总能找到一个很容易计算自由度的原始基底。 自由度通常涉及点取值，微分，积分等。\n4·3·2 多项式空间 在定义4.1中，我们在有限维函数空间 \\(\\mathcal{V}\\)  中定义了有限元。 尽管不是严格必须的，但有限元中使用的函数通常是多项式。 虽然我们的一般策略，原则上，将容纳非多项式基底，但本章仅处理多项式。 最常见的空间是 \\([\\mathcal{P}_q]^d\\)  ，即 \\(\\mathbb{R}^d\\)  中的 \\(q\\)  次多项式空间。 表示 \\([\\mathcal{P}_q]^d\\)  的方式有很多。 我们将讨论幂和伯恩斯坦（Bernstein）基底以及正交基底（例如Dubiner，雅可比和勒让德）。 这些基底中的每一个都有明确的表示形式或递归关系，使它们易于求值和微分。 相反，大多数有限元基底是通过定义4.2求解线性方程组来确定的。 除了 \\([\\mathcal{P}_q]^d\\)  之外，对于某些单元，我们还将需要 \\(\\mathcal{H}^d_q\\)  ，即 \\(d\\)  元齐 \\(q\\)  次多项式的空间。\n通常，这个技术被开发用于单纯形的，其多项式没有很好的张量积结构。 但是，SyFi支持矩形域，而FIAT不支持。\n幂基底。 在线段上，对能张成 \\(\\mathcal{P}_q\\)  的单项式或幂式基底 \\(\\{x^i\\}^q_{i=0}\\)  ，任何 \\(\\psi\\in\\mathcal{P}_q\\)  都可以写成：\n\\[ \\psi = a_0 + a_1 x + \\dots + a_q x^q = \\sum^q_{i=0}{a_i x^i} \\tag{4.9} \\]  对二维的三角形上情况， \\([\\mathcal{P}_q]^2\\)  是由形如 \\(\\{x^i y^j\\}^{i + j \\le q}_{i,j=0}\\)  函数张成的，对三维的情况也有类似的定义。\n这个基底很容易求值，微分和积分。 但是，这种基底在数值计算中是非常病态的（ill-conditioned）。 例如， \\(\\mathcal{P}_{10}\\)  中，使用幂基底的质量矩阵的条件数是5E+14，而伯恩斯坦多项式和拉格朗日多项式的对应条件数分别为4E+6和2E+3。\n勒让德基底。 在区间，矩形或箱形上流行的多项式基底是勒让德基底。 该多项式基底还可用于表示高阶次多项式。 此基底在区间[-1，1]上可定义为\n\\[ \\psi_i(x) =\\frac{1}{2^i i!}\\frac{d^i}{dx^i}(x^2 − 1)^i,\\quad i = 0, 1, \\dots \\tag{4.10} \\]  这些多项式的一个很好的特性是它们是 \\(L^2\\)  内积正交的；即，\n\\[ \\int^1_{-1}{\\psi_i(x)\\psi_j(x) dx} = \\left\\{\\begin{aligned}\\frac{2}{2i+1} \u0026\\quad i = j\\\\ 0 \u0026\\quad i \\ne j\\end{aligned}\\right. \\tag{4.11} \\]  勒让德多项式可以通过张量积扩展到任意维度的矩形域。 例如，2维情况下的基底：\n\\[ \\psi_{ij}(x, y) = \\psi_i(x)\\psi_j(y), \\quad i, j \\le q \\tag{4.12} \\]  这些多项式的递归关系可以在Karniadakis和Sherwin（2005）中找到。\n雅可比基底。 雅可比多项式 \\(P_i^{\\alpha,\\beta}(x)\\)  推广了勒让德多项式，给出了加权内积的正交性。 特别地， \\(\\int^1_{-1}{(1-x)^\\alpha(1 + x)^\\beta P_i^{\\alpha,\\beta} P_j^{\\alpha,\\beta} dx} = 0, \\quad i \\ne j\\)  。 这种多项式由下给出：\n\\[ \\begin{aligned}P_0^{\\alpha,\\beta} \u0026= 1 \\\\ P_1^{\\alpha,\\beta} \u0026=\\frac{1}{2}(\\alpha − \\beta + (\\alpha + \\beta + 2) x) \\end{aligned} \\tag{4.13} \\]  第三项开始（ \\(j \\ge 1\\)  ）是递归式：\n\\[ P_{i+1}^{\\alpha,\\beta}(x) = (a_i^{\\alpha,\\beta}x + b_i^{\\alpha,\\beta})P_i^{\\alpha,\\beta}(x) − c_i^{\\alpha,\\beta}P_{i-1}^{\\alpha,\\beta}(x) \\tag{4.14} \\]  一般来说，雅可比多项式被用在1维的情况，而在张量积域中的使用频率远低于勒让德多项式，但它们在构造基于单纯形的正交基中起着重要作用，我们现在转向它。\nDubiner基底。 又被称为单纯域中的正交多项式，尽管它们缺乏勒让德多项式的某些旋转对称性。 Dubiner基底， 常被用在单纯谱单元（simplicial spectral elements，Dubiner，1991）中，这在文献中有许多不同的名称。 它是一个 \\(L^2\\)  -正交基底，可以通过将奇异坐标更改为固定三角形，映射到正方形上的雅可比多项式的特定张量积来构造。 令 \\(P_n^{\\alpha,\\beta}\\)  表示权重为 \\(\\alpha,\\beta\\)  的第n个雅可比多项式。 然后，定义新坐标：\n\\[ \\begin{aligned}\\eta_1 \u0026= 2\\left(\\frac{1 + x}{1 − y} \\right)− 1 \\\\ \\eta_2 \u0026= y \\end{aligned}\\tag{4.15} \\]  图4.1 从参考三角形到矩形区域的折叠坐标变换。 它将具有顶点 \\((-1,-1),(-1,1),(1,-1)\\)  的三角形映射到正方形 \\([-1,1]^2\\)  ，如图4.1所示。 这是定义Dubiner多项式的自然域，但是通过仿射映射可以很容易将它们映射到其他具有顶点 \\((0,0),(0,1),(1,0)\\)  的三角形的域。 然后，定义:\n\\[ \\psi_{ij}(x, y) = P_i^{0,0}(\\eta_1)\\left(\\frac{1 − \\eta_2}{2}\\right)^i P_j^{2i+1,0}(\\eta_2) \\tag{4.16} \\]  尽管从定义中看并不明显，但 \\(\\psi_{ij}(x,y)\\)  实际是关于x和y的 \\(i + j\\)  次多项式。 另外，对 \\((i,j) \\ne (p,q)\\)  ， \\(\\psi_{ij}\\)  与 \\(\\psi_{pq}\\)  是 \\(L^2\\)  -正交的。\n尽管此基底比幂基底更复杂，但即使用高阶次多项式，对数值计算也是良好的。 这个多项式也可以进行分层排序，使得对于每个 \\(n1\\)  ， \\(\\{\\psi_i\\}^n_{i=1}\\)  构成 \\(\\mathcal{P}_{n-1}\\)  的基底。 一个可能的缺点，这种基底缺少在其他基底具有的旋转对称性。\nBernstein基底。 Bernstein基底是另一中具有良好条件数的基底，可用于生成有限元基底。 在1维情况中， \\(\\mathcal{P}_q\\)  中的基函数形如：\n\\[ \\psi_i^q = \\left(\\begin{aligned}q \\\\ i \\end{aligned}\\right)x^i(1 − x)^{q−i}, \\quad i = 0, \\dots , q \\tag{4.17} \\]  并且， \\(\\mathcal{P}_q\\)  可由 \\(\\{\\psi_i^q\\}^q_{i=0}\\)  张成.\n请注意，Bernstein基底由 \\(x\\)  和 \\(1-x\\)  的幂组成，它们是[0,1]的重心坐标，根据这一点，可以轻松地将这种基底推广到更高维的单纯形上。 令 \\(b_1, b_2, b_3\\)  是为参考三角形的重心坐标（译者注：对2维的情况，也被称作面积坐标）； 也就是说， \\(b_1 = 1-x-y,b_2 = x,b_3 = y\\)  。 那么这种基底形如：\n\\[ \\psi_{ijk}^q = \\frac{q!}{i!j!k!}b^i_1 b^j_2 b_3^k, \\quad i + j + k = q \\tag{4.18} \\]  于是 \\(\\mathcal{P}_q\\)  的基底是：\n\\[ \\{\\psi_{ijk}^q\\}^{i+j+k=q}_{i,j,k\\ge 0} \\tag{4.19} \\]  四面体上的Bernstein多项式，甚至更高维的单纯形，都是完全相似的。\n这些多项式虽然在有限元社区中并不常见，但在图形和样条曲线中是众所周知的。 它们具有旋转对称性，并且是非负的，因此给出正质量矩阵，尽管它们不是分层的。 最近，Kirby（2011，2010b）分析了基于Bernstein多项式的有限元算子。 在这些论文中， 利用Bernstein多项式的特殊性质来开发有限元算子的无矩阵应用算法，其复杂度与谱单元不相上下。\n齐次多项式。 有时, 另一组有用的多项式是齐次多项式 \\(\\mathcal{H}_q\\)  。 这就是所有项具有相同次数的多项式。 对二维的情况， \\(\\mathcal{H}_q\\)  形如下式的多项式张成：\n\\[ \\{x^i y^j\\}_{i+j=q} \\tag{4.20} \\]  类似，也可定义d维的情况。\n矢量值或张量值的多项式。 可先前讨论的标量值多项式直接推广到矢量或张量值多项式。 令 \\(\\{e_i\\}\\)  为 \\(\\mathbb{R}^d\\)  中的正则基底。 那么向量值多项式的基底为：\n\\[ \\phi_{ij} = \\phi_j e_i \\tag{4.21} \\]  类似的定义，可将基底推广到张量值情况。\n【章节目录】\n"}),a.add({id:50,href:'/notes/docs/fem/0102/',title:"常见有限元（三）【翻译】",content:"【章节目录】\n3·6 L² 有限元    \\(L^2\\)  单元，通常指的是其元素非 \\(C^0\\)  的有限元空间。 这些单元自然存在于泊松方程，Stokes流和弹性的混合公式中。 或者，这样的单元也可以以不符合的方式被使用，而不是直接施以所期望的弱连续性。 不连续Galerkin（DG）方法为此提供了一个典型例子。 在这种情况下，单元维面的数值通量被组合为弱形式的一部分。 DG方法的许多变体就是以不同的数值通量来定义的。 DG方法最初是针对双曲问题开发的，但现已成功应用于许多椭圆和抛物线问题中。 而且，每个单独单元的去耦化为并行性和hp适应性提供了更多的机会。\n3·6·1 不连续拉格朗日 图3.13 三角形和四面体上的0次，1次，2次和3次不连续拉格朗日单元的图示。可以任意选择自由度，只要可以张成对偶空间 \\(\\mathcal{V}'\\)  。 在这里，自由度被选为与标准拉格朗日有限元相同，不同之处在于这个自由度被视为单元的内部。 图3.14 不连续拉格朗日有限元的所有自由度都在该单元内部，这意味着这些单元没有强加全局连续性。 此处针对不连续的二次拉格朗日单元进行了图示。 定义3.11 (不连续拉格朗日单元) 不连续拉格朗日单元（ \\(\\mathrm{DG}_q, \\quad q=0,1,2,\\dots\\)  ）被定义为：\n\\[ T \\in \\{\\mathrm{interval}, \\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.56} \\]  \\[ \\mathcal{V} = \\mathcal{P}_q(T) \\tag{3.57} \\]  \\[ \\ell_i(v) = v(x^i) \\tag{3.58} \\]  其中， \\(\\{x^i\\}^{n(q)}_{i=1}\\)  是 \\(T\\)  上由下式定义的点序列：\n\\[ x = \\left\\{\\begin{aligned}i/q \u0026\\quad 0 \\le i \\le q \u0026T \\ \\mathrm{interval} \\\\ (i/q,j/q) \u0026\\quad 0 \\le i+j \\le q \u0026T \\ \\mathrm{triangle} \\\\ (i/q,j/q,k/q) \u0026\\quad 0 \\le i+j+k \\le q \u0026T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.59} \\]   \\(\\mathrm{DG}_q\\)  的维度是：\n\\[ n(q) = \\left\\{\\begin{aligned}q+1 \u0026 \\quad T \\ \\mathrm{interval} \\\\ \\frac{1}{2}(q+1)(q+2) \u0026\\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{6}(q+1)(q+2)(q+2) \u0026\\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.60} \\]  令 \\(\\Pi^q_T\\)  表示上面这个自由度的插值算符， \\(q\\)  次 \\(\\mathrm{DG}_q\\)  单元的插值性质：\n\\[ \\|u - \\Pi^q_T u\\|_{L^2(T)} \\le C h^{q+1}_T|u|_{H^{q+1}(T)} \\tag{3.61} \\]  3·7 H²有限元  \\(H^2\\)  单元通常用于四阶问题的近似，或用于至少 \\(C^1\\)  连续的其他空间。 由于连续性要求的局限性，符合的单元通常具有较高的多项式阶次，但是事实证明，较低阶次的不符合单元已经被证明是成功的。 因此，我们在这里考虑符合的Argyris单元，以及不符合的Hermite单元和Morley单元。\n3·7·1 Argyris单元 Argyris单元（Argyris等人，1968； Ciarlet，2002）是基于三角形 \\(T\\)  上的五次多项式的空间 \\(\\mathcal{P}_5(T)\\)  的。 可以将其各单元之间以完全 \\(C^1\\)  连续性拼接在一起，并且在三角剖分的顶点处是 \\(C^2\\)  连续的。\n图3.15 五次Argyris三角形。 这个自由度是三角形顶点处的点值，所有一阶导数值和所有二阶导数值，以及在每个边中点处的法向导数值。 定义3.12 (Argyris单元) (5次) Argyris单元 ( \\(\\mathrm{ARG}_5\\)  )被定义为：\n\\[ T = \\mathrm{triangle} \\tag{3.62} \\]  \\[ \\mathcal{V} = \\mathcal{P}_5(T) \\tag{3.63} \\]  \\[ \\mathcal{L}=\\left\\{\\begin{aligned} v(x^i) \u0026 \\quad \\text{对每个顶点}x^i \\\\ \\mathrm{grad}\\ v(x^i)_j \u0026 \\quad \\text{对每个顶点}x^i,\\text{每个分量}j \\\\ D^2v(x^i)_{jk} \u0026 \\quad \\text{对每个顶点}x^i,\\text{每个分量}jk,j\\le k \\\\ \\mathrm{grad}\\ v(m^i) \\cdot n \u0026 \\quad \\text{对每个边中点}m^i \\end{aligned} \\right. \\tag{3.64} \\]   \\(\\mathrm{ARG}_5\\)  的维数：\n\\[ n = 21 \\tag{3.65} \\]  令 \\(\\Pi_t\\)  表示上面自由度的插值算符，这个（5次）Argyris单元的插值性质为 (Braess, 2007, 第II.6章节):\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H^2(T)} \\le C h^4_T|u|_{H^6(T)} \\\\ \\|u - \\Pi_T u\\|_{H^1(T)} \\le C h^5_T|u|_{H^6(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \\le C h^6_T|u|_{H^6(T)} \\end{aligned} \\tag{3.66} \\]  对Argyris单元，其对偶基底中的法向导数 阻止了它成为仿射插值等价。 这样就阻止了将节点基底构建在参考胞元上并且仿射映射的做法。 Domínguez和Sayas的最新工作（2008）开发了一种可纠正此问题的转换，与直接在网格中的每个单元上形成基底相比，所需的计算工作量更少。 可以将Argyris单元素推广到高于五次的多项式，依然给出 \\(C^1\\)  连续性，并且在顶点处 \\(C^2\\)  连续（Šolín等人，2004）。\n3·7·2 Hermite单元 Hermite单元是经典三次Hermite插值多项式在线段上的推广（Ciarlet，2002）。 Hermite型单元几乎从一开始就出现在有限元文献中，至少早在Ciarlet和Raviart（1972）的经典论文中就出现了。 长期以来，它们一直被认为是有用的 \\(C^1\\)  -符合的单元（Braess，2007； Ciarlet，2002）。 在仿射映射下，Hermite单元形成仿射插值等价族（Brenner和Scott，2008）。\n在三角形上，三次多项式空间是十维的，而Hermite单元的十个自由度是在三角形顶点和质心处的点值，以及顶点处梯度分量值。 可类似地推广到四面体。\n图3.16 3次Hermite三角形和四面体。自由度是顶点和质心处的点值，以及顶点处所有一阶导数值。  定义3.13 (Hermite单元) (3次) Hermite单元 (\\mathrm{HER})被定义如下：\n\\[ T \\in \\{\\mathrm{interval}, \\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.67} \\]  \\[ \\mathcal{V} = \\mathcal{P}_3(T) \\tag{3.68} \\]  \\[ \\mathcal{L}=\\left\\{\\begin{aligned} v(x^i) \u0026 \\quad \\text{对每个顶点}x^i \\\\ \\mathrm{grad}\\ v(x^i)_j \u0026 \\quad \\text{对每个顶点}x^i,\\text{每个分量}j \\\\ v(b) \u0026 \\quad \\text{对(3维中各面的)质心}b \\end{aligned} \\right. \\tag{3.69} \\]   \\(\\mathrm{HER}\\)  的维数：\n\\[ n = \\left\\{\\begin{aligned} 10 \u0026 \\quad T \\ \\mathrm{triangle} \\\\ 20 \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.70} \\]  令 \\(\\Pi_T\\)  表示由上述自由度定义的插值算符，（三次）Hermite单元的插值性质为：\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H^1(T)} \\le C h^3_T|u|_{H^4(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \\le C h^4_T|u|_{H^4(T)} \\end{aligned} \\tag{3.71} \\]  与线段上的三次Hermite函数不同，三次Hermite三角形和四面体不能以完全 \\(C^1\\)  的方式连接在一起。 三次Hermite单元可以扩展到更高的次数（Brenner和Scott，2008年）。\n3·7·3 Morley单元 Morley（1968）定义的Morley三角形是一个简单的 \\(H^2\\)  -不符合的二次单元，被用于四阶问题中。 其函数空间 \\(\\mathcal{V}\\)  只是 \\(\\mathcal{P}_2(T)\\)  ，这是二次的六维空间。 自由度包括每个顶点的逐点值和每个边中点法向导数的值。 有趣的是，Morley三角形既不是 \\(C^1\\)  也不是 \\(C^0\\)  ，但是它适用于四阶问题的已知最简单的单元。\nMorley单元是由Morley（1968，1971）首次引入工程文献的。 在数学文献中，Lascaux和Lesaint（1975）在研究板弯曲单元的拼接测试中考虑了这一点。 Morley单元的最新应用还包括了Huang等（2008）； Ming和Xu（2006）。\n图3.17 二次Morley三角形。 自由度是在顶点处的点值和在每个边中点法向导数的值。 定义3.14 (Morley单元) （2次）Morley单元 ( \\(\\mathrm{MOR}\\)  ) 被定义为：\n\\[ T = \\mathrm{triangle} \\tag{3.72} \\]  \\[ \\mathcal{V} = \\mathcal{P}_2(T) \\tag{3.73} \\]  \\[ \\mathcal{L}=\\left\\{\\begin{aligned} v(x^i) \u0026 \\quad \\text{对每个顶点}x^i \\\\ \\mathrm{grad}\\ v(m^i) \\cdot n \u0026 \\quad \\text{对每个边中点}m^i \\end{aligned} \\right. \\tag{3.74} \\]  Morley单元的维数：\n\\[ n = 6 \\tag{3.75} \\]  让 \\(\\Pi_T\\)  表示由上述自由度定义的插值算符，（二次）Morley单元的插值性质为：\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H^1(T)} \\le C h^2_T|u|_{H^3(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \\le C h^3_T|u|_{H^3(T)} \\end{aligned} \\tag{3.76} \\]  3·8 强化有限元 如果 \\(U\\)  ， \\(V\\)  是线性空间，则可以定义新的线性空间 \\(W\\)  ：\n\\[ W = \\{w = u + v : u \\in U, v \\in V\\} \\tag{3.77} \\]  在这里，我们称如此选择的空间 \\(W\\)  为强化空间（enriched space）。\n有限元空间的强化可以提高稳定性，特别是对于混合有限元方法。 例如，使用Stokes方程的气泡函数（bubble functions）的拉格朗日单元的强化，或者使用线性弹性的Raviart-Thomas单元的强化（Arnold等，1984a，b）。 此后，气泡函数被用于许多方面。 我们在此定义一个气泡单元，以方便参考。 气泡单元的使用例子包括：\n用于Stokes方程的MINI单元。 在最低阶次的情况下，线性矢量拉格朗日单元被三次矢量气泡单元所强化 ，用于进行速度逼近（Arnold等，1984b）。\n用于弱对称线性弹性的PEERS单元。 应力张量的每一行都近似于，被三次气泡单元的旋度所强化的，最低阶次Raviart–Thomas单元（Arnold等，1984a）。\n定义3.15 (气泡单元，Bubble element) 气泡单元 ( \\(B_q, q\\ge (d+1)\\)  )被定义为：\n\\[ T \\in \\{\\mathrm{interval}, \\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.78} \\]  \\[ \\mathcal{V} = \\{v \\in \\mathcal{P}_q(T) : v|_{\\partial T}=0\\} \\tag{3.79} \\]  \\[ \\ell_i(v)=v(x^i), \\quad i=1,\\dots,n(q) \\tag{3.80} \\]  其中， \\(\\{x^i\\}^{n(q)}_{i=1}\\)  是 \\(T\\)  中的点序列，被定义为：\n\\[ x = \\left\\{\\begin{aligned}\u0026 (i+1)/q \\quad 0 \\le i \\le q-2 \\quad T \\ \\mathrm{interval} \\\\ \u0026 ((i+1)/q,(j+1)/q) \\quad 0 \\le i+j \\le q-3 \\quad T \\ \\mathrm{triangle} \\\\ \u0026((i+1)/q,(j+1)/q,(k+1)/q) \\quad 0 \\le i+j+k \\le q-4 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.81} \\]  气泡单元的维数：\n\\[ n(q) = \\left\\{\\begin{aligned}q-1 \u0026 \\quad T \\ \\mathrm{interval} \\\\ \\frac{1}{2}(q-2)(q-1) \u0026\\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{6}(q-3)(q-2)(q-1) \u0026\\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.82} \\]  3·9 有限元外微积分（FEEC） 最近证明，多年来发现或发明的许多有限元都可以作为更一般的有限元的特殊情况， 在一个统一的框架中表述和分析。 这种新的框架称为有有限元外微积分(FEEC,ﬁnite element exterior calculus) ，并在Arnold等人的文章中进行了总结（2006a）。 在有限元外微积分中，两个有限元空间 \\(\\mathcal{P}_q \\Lambda^k(T)\\)  和 \\(\\mathcal{P}_q^- \\Lambda^k(T)\\)  被定义为一般的 \\(d \\ge 1\\)  维单纯形。 \\(\\mathcal{P}_q \\Lambda^k(T)\\)  单元是 \\(T\\)  上微分k-形式的多项式空间，其自由度的选择必须确保维面上迹的连续性。 当这些单元被解释为常规单元时，通过微分k-形式与标量或矢量值函数之间的适当标识，可以得到一系列众所周知的单元（ \\( 0 \\le k \\le d \\le 3\\)  ）。 在表3.2中，我们总结了这些单元与本章前面介绍过的单元之间的关系。\n表3.2 有限元外微积分所定义的有限元 \\(\\mathcal{P}_q \\Lambda^k\\)  和 \\(\\mathcal{P}_q^- \\Lambda^k\\)  之间的关系，以及本章所使用的编号和标签。 3·10 小结 在下表中，我们总结了本章讨论的单元列表。 为简便起见，我们仅包括最高 \\(q=3 \\)  次的单元。 对于更高次的单元，我们参考（作为FEniCS一部分的）脚本dolfin-plot，该脚本可用于轻松绘制各种单元的自由度：\n# Bash code $ dolfin-plot BDM tetrahedron 3 $ dolfin-plot N1curl triangle 4 $ dolfin-plot CG tetrahedron 5 下表中用（*）所表示的单元得到FEniCS的完全支持。\n【章节目录】\n"}),a.add({id:51,href:'/notes/docs/fem/0101/',title:"常见有限元（二）【翻译】",content:"【章节目录】\n3·4 H（div）有限元 Sobolev空间   \\(H(\\mathrm{div})\\)  由分量和弱散度（the weak divergence）都平方可积的矢量场组成。 这是一个比d-矢量场（ \\([H^1]^d, \\quad d \\ge 2\\)  ）还要更弱的要求。 这个空间自然是与二阶椭圆问题，多孔介质流和弹性方程的混合形式有关的。 对于 \\(H(\\mathrm{div})\\)  -符合的有限元族，虽然每个分量不必是连续的，但是法向分量必须是连续的。 为了确保这种连续性， \\(H(\\mathrm{div})\\)  -符合的单元的自由度通常包括单元的维面（facets）上的法向分量。\n \\(H(\\mathrm{div})\\)  -符合的两个主要单元族是Raviart–Thomas单元和Brezzi–Douglas–Marini单元。这两个族如后所述。 此外还包括：可以离散化具有平方可积的逐行散度对称张量场空间的Arnold-Winther单元，和Mardal-Tai-Winther单元。 【译者注：所谓逐行散度（row-wise divergence），比如对矩阵而言，就是对每行求散度】\n3·4·1 Raviart–Thomas单元 Raviart-Thomas单元由Raviart和Thomas（1977）引入。 这是对三角形上二阶椭圆方程混合形式离散化的第一个单元。 这个单元的空间 \\(\\mathcal{V}\\)  被设计成最小多项式空间 \\(\\mathcal{V} \\subset \\mathcal{P}_q(T), \\quad q = 1, 2, \\dots\\)  ，从中可以将散度映射到 \\(\\mathcal{P}_{q-1}(T)\\)  。 此后不久，Nédélec（1980）将其扩展到四面体和方盒体。 因此，有时也将其称为Raviart–Thomas–Nédélec单元。 在这里，我们将其二维和三维的版本都标记为Raviart–Thomas单元。\n以下给出的定义是基于Nédélec（1980）（和Brezzi和Fortin（1991））提出的。 原始的Raviart–Thomas论文使用略有不同的形式。 此外，Raviart和Thomas最初是从 \\(q=0\\)  开始计数的。 因此，这种最低阶次的单元，传统上被称为 \\(\\mathrm{RT}_0\\)  单元。 为了保持一致性，这种 \\(\\mathcal{P}_q(T)\\)  中的多项式有限元阶次 \\(q\\)  ，我们在这里改用 \\(q=1\\)  来标记最低阶次单元（Nédélec也是如此） 。\n图3.6 三角形和四面体上的1次，2次和3次Raviart-Thomas单元的自由度图示。 这个自由度是指相对于维面（相应还有边和面）上 \\(\\mathcal{P}_{q-1}\\)  的法向分量矩； 对于更高阶次单元，则是相对于 \\([\\mathcal{P}_{q-2}]^d\\)  的内部矩。 或者，如图所示，法向分量的矩，可用法向分量的点值替代。 定义3.5（Raviart–Thomas单元） Raviart–Thomas单元（ \\(\\mathrm{RT}_q, \\quad q = 1, 2, \\dots\\)  ）的定义为：\n\\[ T \\in \\{\\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.18} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_{q-1}(T)]^d + x \\mathcal{P}_{q-1}(T) \\tag{3.19} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_f{ v \\cdot n p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_{q-1}(f) \\ \\text{ 对每个维面 } f \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in [\\mathcal{P}_{q-2}(T)]^d, \\ q \\ge 2 \\end{aligned}\\right. \\tag{3.20} \\]  例如，三角形上最低阶次Raviart–Thomas空间是一个三维空间，由以下形式的矢量场组成\n\\[ v(x) = \\alpha + \\beta x \\tag{3.21} \\]  其中， \\(\\alpha\\)  是矢量值常量， \\(\\beta\\)  是标量常量。\n \\(\\mathrm{RT}_q\\)  的维数：\n\\[ n(q) = \\left\\{\\begin{aligned}q(q+2) \u0026 \\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{2}q(q+1)(q+3) \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned}\\right. \\tag{3.22} \\]  令 \\(\\Pi^q_T, q = 1, 2, \\dots\\)  表示由自由度定义的插值算符，我们有（Brezzi和Fortin，1991，第III.3章）。\n\\[ \\begin{aligned}\\|u - \\Pi^q_T u\\|_{H(\\mathrm{div})(T)} \u0026\\le C h^q_T|u|_{H^{q+1}(T)} \\\\ \\|u - \\Pi^q_T u\\|_{L^2(T)} \u0026\\le C h^q_T|u|_{H^q(T)} \\end{aligned} \\tag{3.23} \\]  3·4·2 Brezzi–Douglas–Marini单元 Brezzi–Douglas–Marini单元由Brezzi，Douglas和Marini在Brezzi等人（1985a）的二维（三角形）基础上引入的。 这个单元可被看作是使用完全多项式空间的Raviart–Thomas单元的另一种选择。 后来被Nédélec（1986）和Brezzi等人（1987a）将其扩展到三维的（四面体，棱柱和立方体）。 此处给出的定义基于Nédélec（1986）的。\n引入Brezzi–Douglas–Marini单元，可用于二阶椭圆方程的混合公式。 但是，它对于弹性应力张量的弱对称离散化也是有用的。 参见Farhloul和Fortin（1997）； Arnold等（2007） 。\n图3.7 三角形和四面体上的1次，2次和3次Brezzi–Douglas–Marini单元的图示。 这个自由度是指相对于维面（相应还有边和面）上 \\(\\mathcal{P}_q\\)  的法向分量矩； 对于更高阶次单元，则是相对于 \\(\\mathrm{NED}^1_{q-1}\\)  的内部矩。 或者，如图所示，法向分量的矩，可用法向分量的点值替代。 定义3.6（Brezzi–Douglas–Marini单元） Brezzi–Douglas–Marini单元（ \\(\\mathrm{BDM}_q,\\quad q = 1, 2, \\dots\\)  ）的定义为\n\\[ T \\in \\{\\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.24} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_q(T)]^d \\tag{3.25} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_f{ v \\cdot n p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_q(f) \\ \\text{ 对每个维面 } f \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathrm{NED}^1_{q-1}(T), \\ q \\ge 2 \\end{aligned}\\right. \\tag{3.26} \\]  其中， \\(\\mathrm{NED}^1\\)  指是后面第3.5.1节中定义的第一种Nédélec \\(H(\\mathrm{curl})\\)  单元。\n \\(\\mathrm{BDM}_q\\)  的维数：\n\\[ n(q) = \\left\\{\\begin{aligned}(q+1)(q+2) \u0026 \\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{2}(q+1)(q+2)(q+3) \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned}\\right. \\tag{3.27} \\]  令 \\(\\Pi^q_T,\\quad q = 1, 2, \\dots\\)  表示由自由度定义的插值算符，于是有（Brezzi和Fortin，1991，第III.3章）：\n\\[ \\begin{aligned}\\|u - \\Pi^q_T u\\|_{H(\\mathrm{div})(T)} \u0026\\le C h^q_T|u|_{H^{q+1}(T)} \\\\ \\|u - \\Pi^q_T u\\|_{L^2(T)} \u0026\\le C h^{q+1}_T|u|_{H^{q+1}(T)} \\end{aligned} \\tag{3.28} \\]  Brezzi–Douglas–Marini单元的一个轻微修改，约束在单元空间 \\(\\mathcal{V}\\)  上，通过仅允许 \\(q-1\\)  次多项式（而不是 \\(q\\)  次完全多项式）在边界的法向分量。 Brezzi等人（1987b）在矩形上建议使用这种单元，并且Brezzi和Fortin（1991）也给出了在三角形上的类似的物。 以类似的精神，Brezzi等人（1985b），在合适的边界上，调整三角形间的多项式阶次，推导出具有不同阶次的单元。\n3·4·3 Mardal–Tai–Winther单元 Mardal-Tai-Winther单元由Mardal等人 (2002)引入，用作适用于二维Darcy和Stokes流速度空间的有限元。 在Darcy流方程中，速度空间仅要求 \\(H(\\mathrm{div})\\)  -正则性。 此外，基于 \\(H^1\\)  -符合的有限元的离散化通常不稳定。 另一方面，对于Stokes方程，速度空间明确规定了 \\(H^1\\)  -正则性。 Mardal–Tai–Winther单元是 \\(H(\\mathrm{div})\\)  -符合的，但是 \\(H^1\\)  -不符合的。 在Tai和Winther（2006）中，该单元被扩展到三维，但是在这里我们仅介绍二维情况。\n图3.8 Mardal–Tai–Winther单元的图示。 这个自由度是每个维面上的法向分量的两个矩和每个维面上的切向分量的一个矩。 在此图中，法向分量的矩可用法向分量的点值描述。 定义3.7（Mardal–Tai–Winther单元） Mardal–Tai–Winther单元 ( \\(\\mathrm{MTW}\\)  )被定义为：\n\\[ T = \\mathrm{triangle} \\tag{3.29} \\]  \\[ \\begin{aligned}\\mathcal{V} = \\{v \u0026\\in [\\mathcal{P}_3(T)]^2, \\\\ \u0026 \\qquad \\mathrm{s.t.} \\ \\mathrm{div}\\ v\\in\\mathcal{P}_0(T) \\text{ and } v\\cdot n|_f\\in\\mathcal{P}_1(T),\\\\ \u0026\\qquad \\qquad \\text{ 对每个维面}f \\} \\end{aligned} \\tag{3.30} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_f{ v \\cdot n p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_1(f) \\text{ 对每个维面} f \\\\ \\int_f v \\cdot t dx \u0026 \\quad \\text{ 对每个维面} f \\end{aligned}\\right. \\tag{3.31} \\]   \\(\\mathrm{MTW}\\)  的维数为：\n\\[ n = 9 \\tag{3.32} \\]  令 \\(\\Pi_T\\)  表示由自由度定义的插值算子，我们有\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H^1(T)} \u0026\\le C h_T|u|_{H^2(T)} \\\\ \\|u - \\Pi_T u\\|_{H(\\mathrm{div})(T)} \u0026\\le C h_T|u|_{H^2(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \u0026\\le C h^2_T|u|_{H^2(T)} \\end{aligned} \\tag{3.33} \\]  3·4·4 Arnold–Winther单元 Arnold-Winther单元由Arnold和Winther（2002）引入。 这篇论文提出了用于线性弹性应力-位移公式的首个稳定的混合（非复合）有限元。 被用于应力空间的这种有限元，在这里表示为Arnold-Winther单元。 此有限元是一个逐行 \\(H(\\mathrm{div})\\)  -符合的对称张量单元。 此有限元是为多项式阶次的层次结构引入的，并且被Adams和Cockburn（2005）和Arnold等人（2008年）扩展到了三维。 但这里我们仅介绍最低阶次的二维情况。\n图3.9 Arnold–Winther单元的图示。 这里的24个自由度是顶点值，在每个维面上张量场的每一行的法向分量的两个第一矩和三个内部矩。 定义3.8（Arnold–Winther单元） （最低阶次）Arnold–Winther单元 ( \\(\\mathrm{AW}\\)  )被定义为：\n\\[ T = \\mathrm{triangle} \\tag{3.34} \\]  \\[ \\mathcal{V} = \\left\\{v\\in\\mathcal{P}_3(T;S): \\mathrm{div}\\ v\\in \\mathcal{P}_1(T;\\mathbb{R}^2) \\right\\} \\tag{3.35} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}v(x^k)_{ij} \u0026 \\quad 1 \\le i \\le j \\le 2 \\ \\text{在每个顶点} x^k \\\\ \\int_f{ \\sum^2_{j=1}{v_{ij} n_j} p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_1(f), \\\\ \u0026 \\qquad \\text{ 对每个维面} f,\\ 1 \\le i \\le 2 \\\\ \\int_T v_{ij} dx \u0026 \\quad 1 \\le i \\le j \\le 2 \\end{aligned}\\right. \\tag{3.36} \\]   \\(\\mathrm{AW}\\)  的维数为：\n\\[ n = 24 \\tag{3.37} \\]  令 \\(\\Pi_T\\)  表示由自由度定义的插值算子，我们有\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H(\\mathrm{div})(T)} \u0026\\le C h^2_T|u|_{H^3(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \u0026\\le C h^3_T|u|_{H^3(T)} \\end{aligned} \\tag{3.38} \\]  3·5 H（curl）有限元 Sobolev空间 \\(H(\\mathrm{curl})\\)  经常出现在与电磁有关的问题中。 Nédélec单元（俗称边单元）被广泛用于解决此类问题，并且是“非标准”（即非最低拉格朗日）有限元的典范（Nédélec，1980，1986）。 为了使分段多项式成为 \\(H(\\mathrm{curl})\\)  -符合的，切向分量必须是连续的。 因此， \\(H(\\mathrm{curl})\\)  -符合的有限元的自由度通常包括切向分量。\nNédélec（1980，1986）在论文中引入了四族有限元空间。 第一篇论文（1980年）介绍了四面体，立方体和棱柱上的两个有限元空间族：一个是 \\(H(\\mathrm{div})\\)  -符合的族，另一个是 \\(H(\\mathrm{curl})\\)  -符合的族。 这两个族分别被称为第一种Nédélec \\(H(\\mathrm{div})\\)  单元和第一种Nédélec \\(H(\\mathrm{curl})\\)  单元。 \\(H(\\mathrm{div})\\)  单元可以看作是Raviart–Thomas单元的三维扩展。（因此，作为前面的Raviart–Thomas单元而呈现。） 后面将介绍第一种Nédélec \\(H(\\mathrm{curl})\\)  单元。\n第二篇论文（1986年）介绍了更多的有限元空间族： 相应有, 一个是 \\(H(\\mathrm{div})\\)  -符合的族， 另一个是 \\(H(\\mathrm{curl})\\)  -符合的族。 相应的，这两个族分别被称为第二种Nédélec \\(H(\\mathrm{div})\\)  单元和第二种Nédélec \\(H(\\mathrm{curl})\\)  单元。 \\(H(\\mathrm{div})\\)  单元可看作是Brezzi–Douglas–Marini单元的三维扩展。 (因此，作为前面的Brezzi–Douglas–Marini单元而呈现。) 后面将介绍第二种Nédélec \\(H(\\mathrm{curl})\\)  单元。\nNédélec在他的两篇经典论文中只考虑了三维情况。 但是，也可以定义一个二维curl和二维 \\(H(\\mathrm{curl})\\)  -符合的有限元空间。 在此，我们在三角形上展示Nédélec单元。 尽管是否能将这些单元归到Nédélec名下不得而知，但出于完整性考虑，我们还是将它们包括在内。\nNédélec的工作在许多方面都预见了Arnold等人（2006a）最近提出的有限元外微积分。 ，其中第一种空间表现为 \\(\\mathcal{P}_q^-\\Lambda^k\\)  空间，第二种则表现为 \\(\\mathcal{P}_q\\Lambda^k\\)  。 此外，在Nédélec（1980）中使用微分算子（弹性应变）来表征函数空间，预示着Arnold等人（2006b）使用的微分复形（differential complexes）。\n3·5·1 第一种Nedelec H（curl）单元 图3.10 三角形和四面体上的1次，二次和三次 \\(H(\\mathrm{curl})\\)  单元的图示。 请注意，这些单元可能被视为Raviart–Thomas单元的旋转。 对于一次Nédélec单元，其自由度是边上的平均值，或者是边中点处的切向分量的值。 因此，有“边单元”之称。  定义3.9（第一种Nédélec H(curl)单元） 对 \\(q = 1, 2, \\dots\\)  , 定义空间：\n\\[ S_q(T) = \\left\\{s \\in [\\mathcal{P}_q(T)]^d : s(x) \\cdot x = 0 \\quad \\forall x \\in T\\right\\} \\tag{3.39} \\]  第一种Nédélec单元 ( \\(\\mathrm{NED}^1_q,\\quad q = 1, 2, \\dots\\)  )被定义为(二维的情况)：\n\\[ T = \\mathrm{triangle} \\tag{3.40} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_{q-1}(T)]^2 + S_q(T) \\tag{3.41} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_e{ v \\cdot t p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_{q-1}(e) \\text{ 对每个边} e \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in [\\mathcal{P}_{q-2}(T)]^2,\\quad q \\ge 2 \\end{aligned}\\right. \\tag{3.42} \\]  其中t是边的切线; 对于的三维情况：\n\\[ T = \\mathrm{tetrahedron} \\tag{3.43} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_{q-1}(T)]^3 + S_q(T) \\tag{3.44} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_e{ v \\cdot t p dl} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_{q-1}(e) \\text{ 对每个边} e \\\\ \\int_f{ v \\times n \\cdot p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in [\\mathcal{P}_{q-2}(f)]^2, \\\\ \u0026\\qquad \\qquad \\text{ 对每个面} f, \\quad q \\ge 2 \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in [\\mathcal{P}_{q-3}]^3,\\quad q \\ge 3 \\end{aligned}\\right. \\tag{3.45} \\]   \\(\\mathrm{NED}^1_q\\)  的维数为：\n\\[ n(q) = \\left\\{\\begin{aligned}q(q+2) \u0026 \\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{2}q(q+2)(q+3) \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned}\\right. \\tag{3.46} \\]  令 \\(\\Pi^q_T\\)  表示由上面的自由度定义的插值算符，我们有（Nédélec, 1980, 定理2）\n\\[ \\begin{aligned}\\|u - \\Pi^q_T u\\|_{H(\\mathrm{curl})(T)} \u0026\\le C h^q_T|u|_{H^{q+1}(T)} \\\\ \\|u - \\Pi^q_T u\\|_{L^2(T)} \u0026\\le C h^q_T|u|_{H^q(T)} \\end{aligned} \\tag{3.47} \\]  3·5·2 第二种Nedelec H（curl）单元 图3.11 三角形上1次，2次和3次Nédélec \\(H(\\mathrm{curl})\\)  单元的图示。 请注意，这些单元可能被视为Brezzi–Douglas–Marini单元的旋转。 图3.12 四面体上第二种Nédélec \\(H(\\mathrm{curl})\\)  单元的图示。 定义3.10（第二种Nédélec H(curl)单元） 第二种Nédélec单元( \\(\\mathrm{NED}^2_q,\\quad q = 1, 2, \\dots\\)  )被定义为（二维的情况）：\n\\[ T = \\mathrm{triangle} \\tag{3.48} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_q(T)]^2 \\tag{3.49} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_e{ v \\cdot t p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_q(e) \\text{ 对每个边} e \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathrm{RT}_{q-1}(T),\\quad q \\ge 2 \\end{aligned}\\right. \\tag{3.50} \\]  其中t是边的切线; 对于的三维情况：\n\\[ T = \\mathrm{tetrahedron} \\tag{3.51} \\]  \\[ \\mathcal{V} = [\\mathcal{P}_q(T)]^3 \\tag{3.52} \\]  \\[ \\mathcal{L} = \\left\\{\\begin{aligned}\\int_e{ v \\cdot t p dl} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathcal{P}_q(e) \\text{ 对每个边} e \\\\ \\int_f{ v \\cdot p ds} \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathrm{RT}_{q-1}(f), \\\\ \u0026\\qquad \\qquad \\text{ 对每个面} f, \\quad q \\ge 2 \\\\ \\int_T v \\cdot p dx \u0026 \\quad \\text{ 对基函数集 } p \\in \\mathrm{RT}_{q-2}(T),\\quad q \\ge 3 \\end{aligned}\\right. \\tag{3.53} \\]   \\(\\mathrm{NED}^2_q\\)  的维数为：\n\\[ n(q) = \\left\\{\\begin{aligned}(q+1)(q+2) \u0026 \\quad T \\ \\mathrm{triangle} \\\\ \\frac{1}{2}(q+1)(q+2)(q+3) \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned}\\right. \\tag{3.54} \\]  令 \\(\\Pi^q_T\\)  表示由上面的自由度定义的插值算符，我们有（Nédélec, 1986, 命题3）\n\\[ \\begin{aligned}\\|u - \\Pi^q_T u\\|_{H(\\mathrm{curl})(T)} \u0026\\le C h^q_T|u|_{H^{q+1}(T)} \\\\ \\|u - \\Pi^q_T u\\|_{L^2(T)} \u0026\\le C h^{q+1}_T|u|_{H^{q+1}(T)} \\end{aligned} \\tag{3.55} \\]  【章节目录】\n"}),a.add({id:52,href:'/notes/docs/fem/0100/',title:"常见有限元（一）【翻译】",content:"【章节目录】\n本章简要介绍了文献中的有限元。 这里介绍的许多单元已经作为FEniCS项目的一部分实现了； 一些是未来的工作。 有限元的范围远远超出了我们在此考虑的范围。 特别是，我们仅考虑基于简单多项式的单元。 因此，我们绕过了在四边形和六面体，复合和宏单元技术以及XFEM类型方法中定义的单元。 即使在基于简单多项式单元中，也可以扩展单元列表。 尽管如此，本章还是全面介绍了一些最常见的和较不寻常的有限元。\n3·1 有限元定义 Ciarlet（1975）在一系列讲义中首次引入了有限元的Ciarlet定义，并在其1978年的著作（Ciarlet，2002）之后变得流行。 今天，它仍然是标准定义，例如参见Brenner和Scott（2008）。 第2章也介绍了该定义，内容如下：\n定义3.1（有限元（Ciarlet，2002年）） 有限元被定义成一个三元组   \\((T, \\mathcal{V}, \\mathcal{L})\\)  ，其中\n  域 \\(T\\)  是 \\(\\mathbb{R}^d\\)  的有界封闭子集（对于 \\(d = 1, 2, 3, \\dots\\)  ），具有非空内部和分段光滑边界；\n   \\(\\mathcal{V} = \\mathcal{V}(T)\\)  是在 \\(T\\)  上的 \\(n\\)  维有限维函数空间；\n  自由度（节点）的集合 \\(\\mathcal{L} = \\{\\ell_1, \\ell_2, \\dots , \\ell_n\\}\\)  是对偶空间 \\(\\mathcal{V'}\\)  的基底; 也就是 \\(\\mathcal{V}\\)  上的有界线性泛函的空间。\n  相似的想法早在Ciarlet和Raviart（1972）中已有介绍，其中讨论了一组插值点 \\(\\{x^i\\}_i\\)  的唯一可解性（unisolvence）。 当由 \\(\\ell_i(v) = v(x^i)\\)  给出自由度时，就与 \\(\\mathcal{L}\\)  的唯一可解性（unisolvence）密切相关。 Bramble和Zlámal（1970）也讨论了基于一组点上的插值函数值和导数值，唯一确定多项式的条件，尽管未使用术语“唯一可解性（unisolvence）”。\n对于任何有限元，都可以定义 \\(\\mathcal{V}\\)  的局部基底，这就是自由度的对偶。 满足 \\(\\ell_i(\\phi_j^T) = \\delta_{ij}, \\quad 1 \\le i, j \\le n\\)  的基底 \\(\\{\\phi_1^T, \\phi_2^T, \\dots , \\phi_n^T\\}\\)  ，被称为节点基底（nodal basis）。 通常在有限元计算中要使用此基底。\n与有限元关联的局部插值算子，有时也称为节点插值（nodal interpolant）。 给定 \\(T\\)  上的函数 \\(f\\)  ，节点插值由下式定义：\n\\[ \\Pi_T(f) = \\sum_{i=1}^n{\\ell_i(f) \\phi_i^T} \\tag{3.1} \\]  假设 \\(f\\)  足够光滑，对于可以很好定义的、作用与其上的所有自由度。\n一旦一个局部有限元空间被定义了，那么定义一个镶嵌在 \\(\\mathcal{T}_h\\)  上的全局有限元空间，就相对简单了。 一个全局空间定义所包含的任意函数，在每个 \\(T \\in \\mathcal{T}_h\\)  上的限制都是躺在局部空间 \\(\\mathcal{V}(T)\\)  中的函数，这些函数还满足任何所需的连续性要求。 通常，所选择的每个局部单元的自由度，满足：如果两个相邻胞元 \\(T\\)  和 \\(T'\\)  的公共面上的自由度一致，则函数将满足所需的连续性条件。\n在构造全局有限元空间时，通常会构造单个参考有限元 \\((\\hat{T}, \\hat{\\mathcal{V}}, \\hat{\\mathcal{L}})\\)  ，并将其映射 到网格中的每个胞元。 当我们处理简单几何时，在 \\(\\hat{T}\\)  和每个 \\(T \\in \\mathcal{T}_h\\)  间的这个映射是仿射的。 仿射等价（afﬁne equivalence）这个概念，虽然最初是为误差估计而定义的，但是对计算也很有用的。 令 \\(F_T : \\hat{T} \\to T\\)  表示这个仿射映射。 让 \\(v \\in \\mathcal{V}\\)  。 那么这个仿射映射所关联的拉回映射（pullback），由 \\(\\mathcal{F}^*(v)(\\hat{x}) = v(F_T(\\hat{x})),\\quad \\forall \\hat{x} \\in \\hat{T}\\)  给出。 给定一个 \\(\\hat{\\ell} \\in \\hat{\\mathcal{V}}'\\)  ，其推前映射（pushforward）作用于 \\(v \\in \\mathcal{V}\\)  中的函数的结果，则由 \\(\\mathcal{F}_*(\\hat{\\ell})(v) = \\hat{\\ell}(\\mathcal{F}^*(v))\\)  给出。\n定义3.2（仿射等价） 令 \\((\\hat{T}, \\hat{\\mathcal{V}}, \\hat{\\mathcal{L}})\\)  和 \\((T, \\mathcal{V}, \\mathcal{L})\\)  都是有限元，并且 \\(F_T : \\hat{T} \\to T\\)  是一个非退化的仿射映射。 如果 \\(\\mathcal{F}^*(\\mathcal{V}) = \\hat{\\mathcal{V}}\\)  ,并且 \\(\\mathcal{F}_*(\\hat{\\mathcal{L}}) = \\mathcal{L}\\)  ，那么称这两个有限元是仿射等价的。\n仿射等效的一个推论是：只需要构造一个节点基底，然后就可以将其映射到网格中的每个胞元。 而且，当使用某些类型的Piola映射时，这种等价概念还可以扩展到某些矢量值单元。 在这种情况下，仿射映射是相同的，但是相应的拉回映射（pull-back）和推前映射（push-forward）需要进行了适当的修改。 还值得指出的是，并非所有有限元都生成仿射等价族或Piola等价族。 拉格朗日单元在 \\(H^1\\)  中是仿射等价的，而Hermite单元和Argyris单元则不是。 Raviart–Thomas单元在 \\(H(\\mathrm{div})\\)  中Piola等价的，而Mardal–Tai–Winther单元则不是。\n表3.1列出了本章讨论的有限元字典。\n表3.1 本章讨论的有限元字典，包括全名和相应的（最高阶次）Sobolev空间单元，还有符合与否。 3·2 记号   域 \\(T \\subset \\mathbb{R}^d\\)  上阶次最高为 \\(q\\)  的多项式空间，被记作 \\(\\mathcal{P}_q(T)\\)  ；而相应的d-矢量场，则被记作 \\([\\mathcal{P}_q(T)]^d\\)  。\n  如果 \\(E \\subseteq V\\)  ，那么有限元空间 \\(E\\)  被称为V-符合的（V-conforming）。 如果不是，则称为（V-）不符合的。\n   \\(\\mathcal{L}\\)  的元素，通常是指单元 \\((T, \\mathcal{V}, \\mathcal{L})\\)  的自由度。 当描述有限元族时，通常以某种示意记号来表示自由度。 我们在下面的列表和图3.1中总结了此处使用的表示法。\n  图3.1 用于自由度的记号摘要。 比如，三个同心球表示一组由内部矩定义的三个自由度。 点值（Point evaluation）。 点 \\(x\\)  处的黑色球体（圆盘）表示函数 \\(v\\)  在该点处的值：\n\\[ \\ell(v) = v(x) \\tag{3.2} \\]  对于具有 \\(d\\)  个分量的矢量值函数 \\(v\\)  ，黑色球体表示对所有分量的求值，因此对应 \\(d\\)  个自由度。\n所有一阶导数值。 点 \\(x\\)  处的深灰色略大的球体（圆盘）表示该点上函数 \\(v\\)  的所有一阶导数的值：\n\\[ \\ell_i(v) =\\frac{\\partial v(x)}{\\partial x_i} \\quad i = 1,\\dots, d \\tag{3.3} \\]  因此对应于 \\(d\\)  个自由度。\n所有二阶导数值。 点 \\(x\\)  处的浅灰色甚至更大的球体（圆盘）表示该点上函数 \\(v\\)  的所有二阶导数的值：\n\\[ \\ell_{ij}(v) = \\frac{\\partial^2 v(x)}{\\partial x_i \\partial x_j} \\quad 1 \\le i \\le j \\le d \\tag{3.4} \\]  因此对应 \\(d(d + 1)/2\\)  个自由度。\n方向分量的值。 点 \\(x\\)  处沿方向 \\(n\\)  的箭头，表示在点 \\(x\\)  处的矢量值函数 \\(v\\)  的沿方向 \\(n\\)  的值：\n\\[ \\ell(v) = v(x) \\cdot n \\tag{3.5} \\]  方向 \\(n\\)  通常是维面（facet）的法线方向，或者是维面或边的切线方向。 有时，我们会在某点使用箭头来表示一个函数在维面或边上分量的矩（对权重函数积分）。\n方向导数的值。 点 \\(x\\)  处沿方向 \\(n\\)  的黑线，表示在点 \\(x\\)  处标量函数 \\(v\\)  沿方向 \\(n\\)  的方向导数的值：\n\\[ \\ell(v) = \\nabla v(x) \\cdot n \\tag{3.6} \\]  内部矩的值（Evaluation of interior moments）。 一组同心球（圆盘）表示内部矩自由度； 也就是说，这种自由度，是通过在域 \\(T\\)  内部，对权重函数进行积分而定义得到的。 球体颜色为白色，黑色，白色等。\n我们注意到，对于下面介绍的某些有限元，文献将使用不同的符号和编号方案，因此我们的表示形式可能与单元的原始表示形式完全不同。 特别是，Raviart–Thomas单元族和第一种Nédélec空间的族传统上从0开始编号，而我们随后对有限元外微积分，采用了最新的方案-从1开始编号。\n3·3 H¹有限元  \\(H^1\\)  空间是分析和离散化二阶椭圆问题弱形式的基础，而且 \\(H^1\\)  的有限元子空间可产生了一些最著名的有限元。 通常，这些单元使用 \\(C^0\\)  近似空间，因为有界域上的分段光滑函数属于 \\(H^1\\)  ，当且仅当它连续的（Braess，2007，定理5.2）。 我们考虑经典的拉格朗日单元，以及一个不符合的的例子，Crouzeix-Raviart空间。 值得注意的是，稍后考虑的Hermite单元在技术上仅是 \\(H^1\\)  单元，但可以用作更光滑空间的不符合的单元。 同样，更光滑的单元（例如Argyris）可用于离散化 \\(H^1\\)  ，尽管这在实践中不太常见。\n3·3·1 拉格朗日单元 最著名和使用最广泛的有限元是 \\(\\mathcal{P}_1\\)  拉格朗日单元。 这个最低阶次三角形有时称为Courant三角形，在Courant（1943）发表的开创性论文之后，其中变分技术与 \\(\\mathcal{P}_1\\)  三角形一起使用导出有限差分法。 有时，这被视为“有限元法”，但实际上，这是由多项式阶次参数化得到单元族，这些单元族将单变量拉格朗日多项式一般化为单纯形，方盒形和其他形状。 较高阶次的拉格朗日单元提供较高阶的近似性质。 而且，这些可以减轻使用线性单元时观察到的锁定现象，或者改进的离散稳定性。 参见Taylor和Hood（1973）； Scott和Vogelius（1985）。\n定义3.3（拉格朗日单元） 拉格朗日单元（CGq）被定义为（对 \\(q = 1, 2, \\dots\\)  ）：\n\\[ T \\in \\{\\mathrm{interval}, \\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.7} \\]  \\[ \\mathcal{V} = \\mathcal{P}_q(T) \\tag{3.8} \\]  \\[ \\mathcal{l}_i(v) = v(x^i), i = 1, \\dots , n(q) \\tag{3.9} \\]  其中， \\(\\{x^i\\}^{n(q)}_{i=1}\\)  是 \\(T\\)  中点的枚举：\n\\[ x = \\left\\{\\begin{aligned} i/q \u0026 \\quad 0 \\le i \\le q \\quad T \\ \\mathrm{interval} \\\\ (i/q, j/q) \u0026 \\quad 0 \\le i + j \\le q \\quad T\\ \\mathrm{triangle} \\\\ (i/q, j/q, k/q) \u0026 \\quad 0 \\le i + j + k \\le q \\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.10} \\]  因此，拉格朗日有限元的维数对应于 \\(T\\)  上 \\(q\\)  次完全多项式的维数，即为：\n\\[ n(q) = \\left\\{\\begin{aligned} q+1 \u0026 \\quad T \\ \\mathrm{interval} \\\\ \\frac{1}{2}(q+1)(q+2) \u0026 \\quad T\\ \\mathrm{triangle} \\\\ \\frac{1}{6}(q+1)(q+2)(q+3) \u0026 \\quad T \\ \\mathrm{tetrahedron} \\end{aligned} \\right. \\tag{3.11} \\]  上面的定义为点集 \\(\\{x^i\\}\\)  提供了一个选择。 但是，这不是唯一可能的选择。 通常，可以保证点集 \\(\\{x^i\\}\\)  是唯一可解的，并且允许边界点进行 \\(C^0\\)  拼接。 该点集必须包括顶点，每个边上的 \\(q-1\\)  个点，每个面的 \\(\\frac{1}{2}(q-1)(q-2)\\)  个点，依此类推。 边界点应对称放置，以使相邻胞元上的点匹配。 尽管通过巧妙地选择这些点可以极大地改善数值条件和插值属性（Warburton，2005），但出于本章的目的，可以假定这些点位于等距晶格（an equispaced lattice）上。 参见图3.2、3.3和3.4。\n图3.2 线性拉格朗日区间，三角形和四面体。 图3.3 拉格朗日CGq三角形 q = 1, 2, 3, 4, 5, 6. 图3.4 拉格朗日CGq四面体 q = 1, 2, 3, 4, 5, 6. 令 \\(\\Pi^q_T\\)  表示由 \\(q\\)  次拉格朗日单元的自由度定义的插值，我们从Brenner和Scott（2008）得到\n\\[ \\begin{aligned}\\|u − \\Pi^q_T u\\|_{H^1(T)} \u0026\\le C h^q_T|u|_{H^{q+1}(T)} \\\\ \\|u - \\Pi^q_T u\\|_{L^2(T)} \u0026\\le C h^{q+1}_T|u|_{H^{q+1}(T)} \\end{aligned} \\tag{3.12} \\]  其中，在这里和始终， \\(C\\)  被用来表示正常数，不依赖 \\(h_T\\)  ，而是依赖阶次 \\(q\\)  和单纯形的长宽比（the aspect ratio），并且 \\(u\\)  是足够正则的函数（或矢量场）。\n向量值或张量值的拉格朗日单元通常是通过对每个分量使用拉格朗日单元来构造的。\n3·3·2 Crouzeix–Raviart单元 Crouzeix–Raviart单元在Crouzeix和Raviart（1973）中引入，被作为一种求解固定Stokes方程的技术。 对于线性拉格朗日单元，全局单元空间由分段线性多项式组成。 但是，与拉格朗日单元相反，全局基函数并不一定要在所有点上都是连续的。 连续性仅在维面的中点被要求。 因此，该单元不是 \\(H^1\\)  -符合的，但通常用于 \\(H^1\\)  函数（和矢量场）的非符合的近似。 Crouzeix-Raviart单元的其他应用包括线性弹性（Hansbo和Larson，2003）和Reissner-Mindlin板（Arnold和Falk，1989）。\n图3.5 Crouzeix–Raviart单元在三角形和四面体上。自由度是每个维面中点的点值。 定义3.4（Crouzeix–Raviart单元） （线性）Crouzeix–Raviart单元（CR）由下式定义：\n\\[ T \\in \\{\\mathrm{triangle}, \\mathrm{tetrahedron}\\} \\tag{3.13} \\]  \\[ \\mathcal{V} = \\mathcal{P}_1(T) \\tag{3.14} \\]  \\[ \\mathcal{l}_i(v) = v(x^i), i = 1, \\dots , n \\tag{3.15} \\]  其中 \\(\\{x_i\\}\\)  是域 \\(T\\)  每个维面的质心（中点）。\n因此， \\(T \\subset \\mathbb{R}^d\\)  上Crouzeix–Raviart单元的维度为\n\\[ n = d + 1, d = 2, 3 \\tag{3.16} \\]  令 \\(\\Pi_T\\)  表示由自由度定义的插值算符，Crouzeix-Raviart单元作为线性拉格朗日单元来进行插值（Braess，2007，第3章.I）：\n\\[ \\begin{aligned}\\|u - \\Pi_T u\\|_{H^1(T)} \u0026\\le C h_T|u|_{H^2(T)} \\\\ \\|u - \\Pi_T u\\|_{L^2(T)} \u0026\\le C h^2_T|u|_{H^2(T)} \\end{aligned} \\tag{3.17} \\]  向量值的Crouzeix-Raviart单元可以通过对每个分量使用Crouzeix-Raviart单元来定义，或者通过在每个维面的中点使用维面法线和维面切向分量作为自由度来定义。 Crouzeix-Raviart单元可以扩展到更高的奇数阶次（q = 3、5、7 \u0026hellip;）（Crouzeix和Falk，1989）。\n【章节目录】\n"}),a.add({id:53,href:'/notes/docs/fem/0099/',title:"有限元方法（三）【翻译】",content:"【章节目录】\n2·6 有限元误差估计和适应性 相对于（2.20）精确解   \\(u\\)  ，有限元近似解 \\(u_h\\)  的误差 \\(e = u - u_h\\)  可以是先验的，也可以是后验的。\n先验误差估计表示精确（未知）解的规则性方面（terms of the regularity）的误差，并且可以提供有关有限元方法收敛顺序的有用信息。 后验误差估计以则可表示为计算量（如残差）的误差，并且（可能）表示为辅助对偶问题的解，具体如下所述。\n2·6·1 先验误差分析 我们考虑这个线性变分问题（2.20）。 我们首先假设双线性形式 \\(a\\)  和线性形式 \\(L\\)  是连续的（有界的）。 也就是说，存在一个常数 \\(C0\\)  ，使得\n\\[ \\begin{aligned}a(v, w) \u0026\\le C \\|v\\|_V \\|w\\|_V \\\\ L(v) \u0026\\le C \\|v\\|_V\\end{aligned} \\tag{2.61} \\]   \\(\\forall v, w \\in V\\)  。为简单起见，我们在本节中假设 \\(V = \\hat{V}\\)  是希尔伯特空间。 对于（2.1），这对应于齐次Dirichlet边界条件和 \\(V = H_0^1(\\Omega)\\)  的情况。 完全可以扩展到一般情况 \\(V = \\hat{V}\\)  ； 参见例如Oden和Demkowicz（1996）。 我们进一步假设双线性形式 \\(a\\)  是矫顽的 (V-椭圆)； 也就是说，存在一个常数 \\(\\alpha0\\)  ，使得\n\\[ a(v, v) \\ge \\alpha \\|v\\|_V^2, \\quad \\forall v \\in V \\tag{2.62} \\]  然后根据Lax-Milgram定理（Lax和Milgram，1954），存在一个唯一解 \\(u \\in V\\)  满足变分问题（2.20）。\n为了推导出由离散变分问题（2.22）定义的近似解 \\(u_h\\)  的先验误差估计，我们首先注意到\n\\[ a(u-u_h, v) = a(u, v)-a(u_h, v) = L(v) - L(v) = 0 \\tag{2.63} \\]  对于所有 \\(v \\in V_h \\subset V\\)  （Galerkin正交）。 通过双线性形式 \\(a\\)  的矫顽性和连续性，我们发现\n\\[ \\begin{aligned}\\alpha \\|u - u_h\\|_V^2 \u0026\\le a(u - u_h, u - u_h) \\\\ \u0026= a(u - u_h, u - v) + a(u_h - u, v - u_h) \\\\ \u0026= a(u - u_h, u - v) \\le C\\|u - u_h\\|_V \\|u - v\\|_V \\end{aligned} \\tag{2.64} \\]  即有，\n\\[ \\|u - u_h\\|_V \\le \\frac{C}{\\alpha} \\|u - v\\|_V,\\quad \\forall v \\in V_h \\tag{2.65} \\]  估计值（2.65）被称为Cea引理。 我们注意到，当双线性形式 \\(a\\)  是对称时，它也是一个内积。 然后我们可以取 \\(\\|v\\|_V = \\sqrt{a(v, v)}\\)  和 \\(C=\\alpha=1\\)  。 在这种情况下， \\(u_h\\)  是 \\(u\\)  在 \\(V_h\\)  的a-投影，而Cea引理指出：\n\\[ \\|u - u_h\\|_V \\le \\|u - v\\|_V,\\quad \\forall v \\in V_h \\tag{2.66} \\]  也就是说， \\(u_h\\)  是子空间 \\(V_h\\)  中变分问题（2.20）的最佳解。 如图2.7所示。\n图2.7 如果双线性形式 \\(a\\)  是对称的，则有限元解 \\(u_h \\in V_h \\subset V\\)  是 \\(u\\in V\\)  在子空间 \\(V_h\\)  上的a-投影，进而是子空间 \\(V_h\\)  中u的最佳近似（对于由双线性形式a所定义范数而言）。 并且采用Galerkin正交化 \\(\\langle u - u_h, v \\rangle_a \\equiv a(u - uh,v)= 0,\\quad v \\in V_h\\)  。  Cea的引理配合适当的插值估计，现在能产生 \\(u_h\\)  的先验误差估计。 通过选择 \\(v =\\pi_h u\\)  ，其中 \\(\\pi_h:V \\to V_h\\)  是到 \\(V_h\\)  的插值算子，我们发现\n\\[ \\|u - u_h\\|_V \\le \\frac{C}{\\alpha}\\|u - \\pi_h u\\|_V \\le \\frac{C C_i}{\\alpha} \\|h^p D^{q+1} u\\|_{L^2} \\tag{2.67} \\]  其中 \\(C_i\\)  是一个插值常数，p和q的值取决于插值的精度和 \\(\\|\\cdot\\|_V\\)  的定义。 对于 \\(V = H_0^1\\)  中的泊松方程解，我们有 \\(C=\\alpha=1\\)  和 \\(p=q=1\\)  。\n2·6·2 后验误差分析 能量范数误差估计（Energy norm error estimates）。 双线性形式的连续性和矫顽性还允许导出后验误差估计。 这种类型的误差估计，是将误差的大小关联到由下式定义的（弱）残差 \\(r : V \\to \\mathbb{R}\\)  的大小 ：\n\\[ r(v) = L(v) - a(u_h, v) \\tag{2.68} \\]  注意：弱残差在形式上与强残差 \\(R \\in \\hat{V}'\\)  相关，即 \\(r(v) = \\langle R, v\\rangle ,\\quad \\forall v \\in \\hat{V}\\)  。\n我们首先注意到，误差 \\(e=u-u_h\\)  的V-范数 等于 残差 \\(r\\)  的V'-范数。 要看清这一点，请注意，利用双线性形式a的连续性，我们有\n\\[ \\begin{aligned}r(v) \u0026= L(v) - a(u_h, v) = a(u, v) - a(u_h, v) \\\\ \u0026= a(u - u_h, v) \\le C\\|u - u_h\\|_V \\|v\\|_V \\end{aligned} \\tag{2.69} \\]  此外，利用矫顽性，我们发现\n\\[ \\begin{aligned}\\alpha \\|u - u_h\\|_V^2 \u0026\\le a(u - u_h, u - u_h) = a(u, u - u_h) - a(u_h, u - u_h) \\\\ \u0026= L(u - u_h) - a(u_h, u - u_h) = r(u - u_h) \\end{aligned} \\tag{2.70} \\]  即有：\n\\[ \\alpha \\|u - u_h\\|_V \\le \\|r\\|_{V'} \\le C \\|u - u_h\\|_V \\tag{2.71} \\]  其中， \\(\\|r\\|_{V'} = \\sup_{v \\in V,v \\ne 0} r(v)/\\|v\\|_V\\)  。.\n估计式（2.67）和（2.71）有时称为能量范数误差估计。 当双线性形式a是对称时，进而可定义一个内积时，就是这种情况。 然后可以取 \\(\\|v\\|_V=a(v, v)\\)  和 \\(C=\\alpha=1\\)  。在这种情况下，得出\n\\[ \\eta \\equiv \\|e\\|_V = \\|r\\|_{V'} \\tag{2.72} \\]  术语能量范数所指的 \\(a(v,v)\\)  ，在许多应用中对应于物理能量。\n面向目标的错误估计(Goal-oriented error estimates)。 经典先验和后验误差估计（2.67）和（2.71）,分别与精确解u的规则性误差 \\(e=u-u_h\\)  的V-范数 和 有限元解 \\(u_h\\)  的残差 \\(r = L(v)-a(u_h,v)\\)  有关。 但是，在应用中，通常需要将计算出的解的某个输出函数 \\(\\mathcal{M}:V\\to \\mathbb{R}\\)  中的误差控制在给定的公差 \\(\\epsilon 0\\)  内。 典型的函数是计算出的解的平均值，例如浸入流场中的物体的升力或阻力。 在这种情况下，理想的情况是选择有限元空间 \\(V_h \\subset V\\)  ，以使有限元解 \\(u_h\\)  满足\n\\[ \\eta \\equiv |\\mathcal{M}(u) - \\mathcal{M}(u_h)| \\le \\epsilon \\tag{2.73} \\]  为了最少的计算量。 我们在这里假设输出函数和变分问题都是线性的，但是分析很容易扩展到完全非线性的情况[Eriksson et al.1995, Becker and Rannacher 2001]。\n为了估计输出函数 \\(\\mathcal{M}\\)  的误差，我们引入了一个辅助对偶问题：找到 \\(z \\in V\\)  ，使得\n\\[ a^*(z, v) = \\mathcal{M}(v) \\quad \\forall v \\in \\hat{V}^* \\tag{2.74} \\]  在这里对偶问题中，我们注意到函数 \\(\\mathcal{M}\\)  作为数据输入。 对偶（伴随）双线性形式 \\(a^*: V^* \\times \\hat{V}^* \\to \\mathbb{R}\\)  由下式定义：\n\\[ a^*(v, w) = a(w, v) \\quad \\forall (v, w) \\in V^* \\times \\hat{V}^* \\tag{2.75} \\]  对偶的试探空间和测试空间，则由下式给出：\n\\[ \\begin{aligned}V^* \u0026= Vˆ \\\\ \\hat{V}^* \u0026= V_0 = \\{v - w : v, w \\in V\\} \\end{aligned} \\tag{2.76} \\]  也就是说，对偶的试探空间对应原始的测试空间， 对偶的测试空间则是原始的试探空间（满足模边界条件，modulo boundary conditions）。 特别是，如果 \\(V = u_0 + \\hat{V}\\)  ，则 \\(V^* = \\hat{V}^* = \\hat{V}\\)  ，对偶测试函数和对偶试探函数都在Dirichlet边界处消失。 对偶问题的定义使我们得出以下误差表示：\n\\[ \\begin{aligned} \\mathcal{M}(u) - \\mathcal{M}(u_h) \u0026= \\mathcal{M}(u - u_h) \\\\ \u0026= a^*(z, u - u_h) = a(u - u_h, z) \\\\ \u0026 = L(z) - a(u_h, z) \\\\ \u0026= r(z) \\end{aligned} \\tag{2.77} \\]  据此发现，这个误差可由对偶解的残差来精确表示：\n\\[ \\mathcal{M}(u) - \\mathcal{M}(u_h) = r(z) \\tag{2.78} \\]  2·6·3 适应性 如前所述，可以根据已经算出的有限元解 \\(u_h\\)  ， 基于V-范数来估计误差， 或者基于输出函数来估计残差 \\(r\\)  的大小。 这可以以几种不同的方式来完成。 该估算通常涉及各部分的集成，以恢复原始PDE的逐元强残差，可能要与胞元或拼接在一起的胞元组上的局部问题的解相结合。 对于泊松方程（2.1）的标准分段线性有限元逼近，可以得到以下估计：\n\\[ \\|u − u_h\\|_V \\equiv \\|\\nabla e\\|_{L^2} \\le C \\left(\\sum_{T \\in \\mathcal{T}_h} h^2_T\\|R\\|^2_T + h_T\\|[\\partial_n u_h]\\|^2_{\\partial T} \\right)^{1/2} \\tag{2.79} \\]  其中 \\(R|_T = f|_T+\\Delta u_h|_T\\)  是强残差， \\(h_T\\)  表示网格大小（每个胞元T周围最小外接球的直径）， \\([\\partial_n u_h]\\)  表示法向导数跨过网格维面（facet）的跳跃 。有关此估计的推导，请参见例如 Elman et al. (2005)。 令 \\(\\eta_T^2= h^2_T \\|R\\|^2_T + h_T \\|[\\nabla_n u_h]\\|^2_{\\partial T}\\)  ，我们得到的估计：\n\\[ \\|u - u_h\\|_V \\le \\eta_h \\equiv C \\left(\\sum_T {\\eta^2_T}\\right)^{1/2} \\tag{2.80} \\]  自适应算法试图确定网格大小 \\(h=h(x)\\)  ，使得 \\(\\eta_h \\le \\epsilon\\)  。 从初始的粗网格开始，逐个检查每个胞元，如果误差指示器 \\(\\eta_T\\)  比较大，那么细化该网格。 有几种可用的策略，例如细化所有 \\(\\eta_T\\)  较大的胞元的上半部分，即按 \\(\\eta_T\\)  的大小排序的所有胞元的前20％。 其他策略包括细化所有 \\(\\eta_T\\)  高于 \\(\\max_{T\\in \\mathcal{T}_h}\\eta_T\\)  特定比例(比如：\u0026gt;MAX10%)的胞元，或细化所有胞元的最高特定比例（比如：TOP10%），以使它们的误差指标之和占 \\(\\eta_h\\)  的重要部分（所谓的Dörﬂer标记（Dörﬂer （1996））。\n图2.8 通过对原始粗网格的连续细化获得的一系列自适应细网格。  一旦网格被细化，就可以计算出新的解和新的误差指示器。 然后重复该过程，直到要么 \\(\\eta_h \\le \\epsilon\\)  （停止标准），要么可用资源（CPU时间和内存）耗尽为止。 自适应算法会产生一系列连续细分的网格，如图2.8所示。 对于与时间依赖的问题，自适应算法需要根据空间和时间确定局部网格大小和（局部）时间步长。 理想情况下，误差估计 \\(\\eta_h\\)  接近实际误差，这是由效率指标 \\(\\eta_h/\\eta\\)  测得的，效率指标 \\(\\eta_h/\\eta\\)  应当接近并以1为界。\n2·7 自动化有限元方法 FEniCS项目寻求使微分方程的求解自动化。 这是一项艰巨的任务，但可以通过有限元方法的自动化来解决。 特别是，这种自动化依赖于以下关键步骤：\n  (i) 离散化的自动化，\n  (ii) 离散解的自动化，\n  (iii) 自动化的误差控制。\n  自2003年成立以来，FEniCS项目主要关注离散化的自动化，从而开发了形式编译器（the form compilers）FFC和SyFi/SFC，代码生成接口UFC，形式语言（the form language）UFL，以及作为为DOLFIN的一部分的一般组装实现（a generic assembler implemented）。 结果，现在可以使用FEniCS通过有限元方法自动离散化大量偏微分方程对应的变分问题。 用于离散解的自动化； 也就是说，由于变分问题的自动离散化而产生的线性和非线性系统的解，线性代数的最新库的接口已经作为DOLFIN的一部分实现了。 现在正在进行的工作正在寻求通过自动误差估计和适应性来自动进行误差控制。 在接下来的章节中，我们将回到有限元方法自动化的特定方面，这些方法是FEniCS项目的一部分。 FEniCS项目背后的数学方法也已经在许多科学著作中进行了描述。 欲了解更多信息，请参见Logg（2007）； Logg and Wells（2010）； Kirby（2004）; Kirby和Logg（2006）； Alnæs等。 （2009）； Alnæs和Mardal（2010）； Kirby等。 （2005，2006）; Kirby and Logg（2007，2008）; Kirby and Scott（2007）； Kirby（2006b）; Ølgaard等。 （2008）； Rognes等。 （2009）； Ølgaard和Wells（2010）； Logg（2009）。\n2·8 历史评注 1915年，鲍里斯·格里高里维奇·加勒金（Boris Grigoryevich Galerkin）提出了求解微分方程的通用方法（Galerkin，1915年）。 Bubnov早些时候提出了一种类似的方法。 Galerkin方法或Bubnov–Galerkin方法最初是用全局多项式表述的，可以追溯到莱布尼兹，欧拉，拉格朗日，狄里克雷特，哈密顿，卡斯蒂利亚诺（Castigliano，1879），瑞利（Rayleigh，1870）和里兹（ Ritz，1908年）。 具有分段多项式空间 \\((V_h,\\hat{V}_h)\\)  的Galerkin方法被称为有限元方法。 有限元方法是工程师在1950年代为结构分析而引入的，并且由库兰特（Courant，1943年）独立提出的。 在1960年代，工程师和数学家对有限元方法的使用激增。 从那时起，有限元方法的机制被扩展并精炼为用于设计和分析微分方程数值方法的综合框架。 参见Zienkiewicz等。 （2005）； Strang和Fix（1973）； Ciarlet（1976）； Becker等（1981）； Hughes（1987）; Brenner and Scott（2008）。 最近，对混合变分问题的兼容（稳定）离散的追求导致有限元外部演算的发展（Arnold等，2006a）。\n对有限元方法进行后验误差分析的工作可以追溯到Babuška和Rheinboldt（1978）的开创性工作。 重要参考资料包括Bank and Weiser（1985）的著作。 Zienkiewicz和Zhu（1987）； Eriksson和Johnson（1991，1995a）; Eriksson and Johnson，1995b，c）； Eriksson等（1998）； Ainsworth and Oden（1993）和评议论文（Eriksson等，1995；Verfürth，1994，1999； Ainsworth和Oden，2000； Becker和Rannacher，2001）。\n【章节目录】\n"}),a.add({id:54,href:'/notes/docs/fem/0098/',title:"有限元方法（二）【翻译】",content:"【章节目录】\n2·4 有限元函数空间 在前面的讨论中，我们假设总可以构造无限维函数空间的离散子空间   \\(V_h \\subset V\\)  。有限元方法的一个核心方面是通过将由一组有限元定义的局部函数空间拼凑在一起来构造此类子空间。至此，我们对有限元函数空间的构造进行了总体概述，并将在第3章和第4章中回头讨论一些特定函数空间的构造： \\(H^1, H(\\mathrm{curl}), H(\\mathrm{div}), L^2\\)  。\n2·4·1 网格 为了定义 \\(V_h\\)  ，我们首先将域 \\(\\Omega\\)  划分为有限胞元集(a finite set of cells) \\(\\mathcal{T}_h = \\{T\\}\\)  ，内部不相交，并且满足：\n\\[ \\cup_{T\\in \\mathcal{T}_h} T = \\Omega \\tag{2.39} \\]  这些胞元一起形成了域 \\(\\Omega\\)  的网格。胞元通常是简单的多边形形状，例如：区间、三角形、四边形、四面体或六面体，如下图所示。但是其他形状也是可能的，特别是弯曲的胞元可以正确捕获非多边形区域的边界。\n图2.2 一、二、三维空间的有限元胞示例。 2·4·2 有限元定义 一旦将域 \\(\\Omega\\)  划分为一组胞元，就可以在每个胞元 \\(T\\)  上定义一个局部函数空间 \\(\\mathcal{V}\\)  ，并使用这些局部函数空间来构建全局函数空间 \\(V_h\\)  。胞元T与局部函数空间 \\(\\mathcal{V}\\)  以及用于描述 \\(\\mathcal{V}\\)  中函数的一组规则一起称为有限元。该定义是由Ciarlet（1976）首次正式提出的，并且至今仍然是标准的表述（Brenner and Scott，2008）。形式化定义如下：有限元是一个三元组 \\((T, \\mathcal{V}, \\mathcal{L})\\)  ，其中\n  区域 \\(T\\)  是 \\(\\mathbb{R}^d\\)  的有界封闭子集（ \\(d=1,2,3,\\dots\\)  ），具有非空的内部和分段光滑边界；\n  空间 \\(\\mathcal{V} = \\mathcal{V}(T)\\)  是在 \\(T\\)  上的 \\(n\\)  维有限维函数空间；\n  自由度（节点）的集合 \\(\\mathcal{L} = \\{\\ell_1,\\ell_2,\\dots,\\ell_n\\}\\)  是对偶空间 \\(\\mathcal{V}'\\)  的基底；也就是 \\(\\mathcal{V}\\)  上有界线性泛函的空间。\n  图2.3 线性拉格朗日三角形的自由度是通过在三角形的三个顶点值给出的。 例如，考虑上图中三角形上的标准线性拉格朗日有限元。这个胞元 \\(T\\)  由三角形给定，空间 \\(\\mathcal{V}\\)  则由是 \\(T\\)  上的一次多项式的空间（维数为3的空间）给定。我们可以指定 \\(T\\)  的三个顶点值作为 \\(\\mathcal{V}'\\)  的基底；那是：\n\\[ \\begin{aligned}\\ell_i : \\mathcal{V} \\to \\mathbb{R} \\\\ \\ell_i(v) = v(x^i) \\end{aligned} \\tag{2.40} \\]  对于 \\(i = 1,2,3\\)  ，其中 \\(x_i\\)  是第i个顶点的坐标。为了确认这确实是有限元，我们需要验证 \\(\\mathcal{L}\\)  是 \\(\\mathcal{V}'\\)  的基底。这等效于 \\(\\mathcal{L}\\)  的唯一性。也就是说，如果 \\(v \\in \\mathcal{V}\\)  并且 \\(\\ell_i(v)= 0,\\quad \\forall l_i\\)  ，那么有 \\(v = 0\\)  （Brenner and Scott，2008）。对于线性拉格朗日三角形，我们注意到如果 \\(v\\)  在每个顶点为零，那么则 \\(v\\)  在任何地方都必须为零，因为一个平面由其在三个非共线点的值唯一地确定。由此可见，线性拉格朗日三角形确实是一个有限元。一般而言，确定 \\(\\mathcal{L}\\)  的唯一性可能并非易事。\n2·4·3 节点基底 通过引入 \\(\\mathcal{V}\\)  的节点基底，可以大大简化用局部函数空间 \\(\\mathcal{V}\\)  的基函数表示的 \\(V_h\\)  中有限元解。 \\(\\mathcal{V}\\)  的节点基底 \\(\\{\\phi_i\\}^n_{i=1}\\)  是 \\(\\mathcal{V}\\)  的基底，若满足：\n\\[ \\ell_i(\\phi_j) = \\delta_{ij},\\quad i,j=1,2,\\dots,n \\tag{2.41} \\]  因此，任何 \\(v \\in \\mathcal{V}\\)  都可以表示为：\n\\[ v = \\sum^n_{i=1}{\\ell_i(v)\\phi_i} \\tag{2.42} \\]  特别地，对于线性拉格朗日三角形， \\(\\mathcal{V}\\)  中的任何函数 \\(v\\)  可由 \\(v = \\sum^3_{i=1}{v(x^i)\\phi_i}\\)  给出。换句话说，对任何函数 \\(v\\)  ，可以通过计算 \\(v\\)  处 \\(\\mathcal{L}\\)  中的线性泛函值来获得 \\(v\\)  的展开系数。因此，我们可以将 \\(u_h\\)  的展开系数U和 \\(\\mathcal{L}\\)  的线性泛函互相称为对方的自由度。\n例2.2 (线性拉格朗日单纯形的节点基底) 顶点为 \\(x^1 = 0\\)  和 \\(x^2 = 1\\)  的线性拉格朗日区间的节点基底为：\n\\[ \\phi_1(x)=1-x, \\quad \\phi_2(x) = x \\tag{2.43} \\]  顶点为 \\(x^1=(0, 0), x^2=(1, 0), x^3=(0, 1)\\)  的线性拉格朗日三角形的节点基底为：\n\\[ \\phi_1(x)=1-x_1-x_2, \\quad \\phi_2(x) = x_1, \\quad \\phi_3(x) = x_2 \\tag{2.44} \\]  顶点为 \\(x^1=(0, 0, 0), x^2=(1, 0, 0),x^3=(0, 1, 0), x^4=(0, 0, 1)\\)  的线性拉格朗日四面体的节点基底是：\n\\[ \\begin{aligned} \u0026\\phi_1(x) = 1-x_1-x_2-x_3, \u0026 \\phi_2(x)=x_1 \\\\ \u0026\\phi_3(x)=x_2, \u0026 \\phi_4(x)=x_3 \\end{aligned} \\tag{2.45} \\]  对于任何有限元 \\((T, \\mathcal{V}, \\mathcal{L})\\)  ，可以通过求解大小为 \\(n \\times n\\)  的线性方程组来计算节点基底。 为了看出这一点，令 \\(\\{\\psi_i\\}^n_{n=1}\\)  是 \\(\\mathcal{V}\\)  的任意基底（主基底）。如果 \\(\\mathcal{V}\\)  是一个完全多项式空间，或者可以通过奇异值分解或Gram-Schmidt程序计算得出，则这样的基底很容易构造。参见Kirby（2004）。然后，我们可以以主基底项为节点基底建立展开式：\n\\[ \\phi_j = \\sum^n_{k=1}{\\alpha_{jk}\\psi_k}, \\quad j = 1,2,\\dots, n \\tag{2.46} \\]  带入到本小节（2.4.3节）第一个公式中，有：\n\\[ \\sum^n_{k=1}{\\alpha_{jk}\\ell_i(\\psi_k)} = \\delta_{ij},\\quad i,j=1,2,\\dots,n \\tag{2.47} \\]  换句话说，可以通过求解线性方程组来计算以主基底展开的节点基函数的系数 \\(\\alpha\\)  :\n\\[ B \\alpha^T = I \\tag{2.48} \\]  其中， \\(B_{ij}=\\ell_i(\\psi_j)\\)  2·4·4 局部到全局映射 现在，要从有限元的给定集合 \\(\\left\\{(T, \\mathcal{V}_T, \\mathcal{L}_T)\\right\\}_{T\\in \\mathcal{T}_h}\\)  ， 定义 \\(\\Omega\\)  上的全局函数空间 \\(V_h = \\mathrm{span}\\left\\{\\phi_i\\right\\}^N_{i=1}\\)  ，我们还需要指定如何将局部函数空间修补在一起。 为此，我们为每个胞元 \\(T\\in \\mathcal{T}_h\\)  指定一个局部到全局的映射：\n\\[ \\iota_T : [1,n_T] \\to [1, N] \\tag{2.49} \\]  该映射指定了如何将局部自由度 \\(\\mathcal{L}_T = \\{\\ell^T_i\\}^{n_T}_{i=1}\\)  映射到全局自由度 \\(\\mathcal{L} = \\{\\ell_i\\}^N_{i=1}\\)  。更确切地说，全局自由度定义为：\n\\[ \\ell_{\\iota_T(i)}(v) = \\ell^T_i(v|_T), \\quad i = 1,2,\\dots,n_T \\tag{2.50} \\]  对于任何 \\(v\\in V_h\\)  ，因此，每个局部自由度 \\(\\ell^T_i \\in \\mathcal{L}_T\\)  对应于由局部到全局映射 \\(\\iota_T\\)  确定的全局自由度 \\(\\ell_{\\iota_T(i)} \\in \\mathcal{L}\\)  。正如我们将看到的，局部到全局的映射以及自由度的选择决定了全局函数空间 \\(V_h\\)  的连续性。\n对于标准连续分段线性，可以通过简单地将 \\(i=1,2,3\\)  的每个局部顶点数 \\(i\\)  映射到相应的全局顶点数 \\(\\iota_T(i)\\)  来定义局部到全局的映射。 对于连续的分段二次，可以将局部到全局的映射基于全局顶点和边号，如图2.4所示，用于由两个三角形组成的简单网格。\n图2.4 由两个三角形组成的简单网格的局部到全局映射。 左三角形（T）的六个局部自由度被映射到全局自由度 \\(\\iota_T(i)=1,2,4,9,8,5 \\quad \\ i = 1,2,\\dots,6\\)  。并且右三角形（T'）的六个局部自由度则被映射到全局自由度 \\(\\iota_{T'}(i)=2,3,4,7,9,6 \\quad \\ i = 1,2,\\dots,6\\)  。 2·4·5 全局函数空间 现在可以将全局函数空间 \\(V_h\\)  定义为满足以下两个条件的 \\(\\Omega\\)  上的一组函数。首先要求\n\\[ v|_T = \\mathcal{V}_T \\qquad \\forall T \\in \\mathcal{T}_h \\tag{2.51} \\]  即，对每个胞元 \\(T\\)  ， \\(v\\)  的限制位于局部函数空间 \\(\\mathcal{V}_T\\)  中。其次，我们要求对于任何一对胞元 \\((T,T') \\in \\mathcal{T}_h \\times \\mathcal{T}_h\\)  和任何一对 \\((i, i') \\in [1,n_T] \\times [1, n_{T'}]\\)  都满足：\n\\[ \\iota_{T}(i) = \\iota_{T'}(i') \\tag{2.52} \\]  进而有：\n\\[ \\ell^T_i(v|_T) = \\ell^{T'}_{i'}(v|_{T'}) \\tag{2.53} \\]  换句话说，如果两个局部自由度 \\(\\ell_i^T\\)  和 \\(\\ell_{i'}^{T'}\\)  映射到相同的全局自由度，则它们必须针对每个函数 \\(v \\in V_h\\)  达成一致。在此， \\(v|_T\\)  表示v在T内部的限制（的连续扩展）。对于通过将两个二次拉格朗日三角形拼凑在一起而获得连续的分段二次空间，在图2.5中对此进行了说明。\n图2.5 将一对胞元 \\((T, T')\\)  上的一对二次局部函数空间拼凑在一起，形成一个在 \\(\\Omega= T \\cup T'\\)  上的全局连续分段二次函数空间。 注意，通过这种构造， \\(V_h\\)  中的函数在胞元边界上是未定义的， 除非（2.53）强制约束 \\(V_h\\)  中的函数在胞元边界上是连续的。 但是，这通常不是问题，因为我们可以在函数限制到局域胞元下执行所有操作。\n局部到全局的映射以及自由度的选择决定了全局函数空间 \\(V_h\\)  的连续性。 对于线性拉格朗日三角形，选择顶点处的值作为自由度，可确保 \\(V_h\\)  中的所有函数在任意一对相邻三角形的公共边的两个顶点处连续，因此沿整个公共边也连续。 因此， \\(V_h\\)  中的函数在整个域 \\(\\Omega\\)  中都是连续的。 结果，由拉格朗日三角形产生的分段线性空间是 \\(H^1\\)  -符合的, 即 \\(V_h \\subset H^1(\\Omega)\\)  。\n人们还可以考虑由每个边的中点定义的自由度。 这就是所谓的Crouzeix-Raviart三角形。 因此，相应的全局Crouzeix-Raviart空间 \\(V_h\\)  仅在边中点处连续。 Crouzeix-Raviart三角形是 \\(H^1\\)  -不符合的单元的一个示例。 也就是说，由一组Crouzeix–Raviart单元构成的函数空间 \\(V_h\\)  不是 \\(H_1\\)  的子空间。 自由度的其他选择可以确保法向分量的连续性，例如， \\(H(\\mathrm{div})\\)  -符合的Brezzi–Douglas–Marini单元； 或者确保切向分量的连续性，例如， \\(H(\\mathrm{curl})\\)  -符合的Nédélec单元。 在第3章中，给出了其它单元的示例，这些单元可通过选择自由度和局部到全局映射来确保不同种类的连续性。\n2·4·6 参考单元的映射 如我们所见，全局函数空间 \\(V_h\\)  可以用网格 \\(\\mathcal{T}_h\\)  ：一组有限元 \\(\\{(T, \\mathcal{V}_T, \\mathcal{L}_T)\\}_{T \\in \\mathcal{T}_h}\\)  和一组局部到全局映射 \\(\\{\\iota_T\\}_{T\\in \\mathcal{T}_h}\\)  来描述 。 我们可以通过引入参考有限元 \\((\\hat{T},\\hat{\\mathcal{V}}, \\hat{\\mathcal{L}})\\)  来进一步简化此描述，其中 \\(\\hat{\\mathcal{L}}= \\{\\hat{\\ell}_1,\\hat{\\ell}_2,\\dots,\\hat{\\ell}_{\\hat{n}}\\}\\)  和一组可逆映射 \\(\\{F_T\\}_{T \\in \\mathcal{T}_h}\\)  ，它们将参考单元 \\(\\hat{T}\\)  映射到网格的单元：\n\\[ T=F_T(\\hat{T})\\qquad \\forall T\\in \\mathcal{T}_h \\tag{2.54} \\]  如图2.6所示。 注意， \\(\\hat{T}\\)  通常不是网格的一部分。\n图2.6: 从参考胞元 \\(\\hat{T}\\)  到胞元 \\(T \\in \\mathcal{T}_h\\)  的（仿射）映射 \\(F_T\\)  。 对于比如（2.7）中这样的离散函数空间 \\(H^1\\)  ，映射 \\(F_T\\)  通常是仿射的。 也就是说， \\(F_T\\)  可以写成 \\(F_T(\\hat{x})= A_T \\hat{x} + b_T\\)  的形式，其中 \\(A_T \\in \\mathbb{R}^{d \\times d}, b_T \\in \\mathbb{R}^d\\)  ，或者也可是等参的(isoparametric)，在这种情况下 \\(F_T\\)  的分量就是 \\(\\hat{\\mathcal{V}}\\)  中的函数。 对于比如（2.16）中的离散函数空间 \\(H(\\mathrm{div})\\)  ，或者 \\(H(\\mathrm{curl})\\)  ，适当的映射是分别保留法向分量和切向分量的协变和协变Piola映射； 参见Rognes等.（2009）。 为简单起见，我们将下面的讨论限制在 \\(F_T\\)  是仿射的或等参的情况下。\n对于每个胞元 \\(T \\in \\mathcal{T}_h\\)  ，由映射 \\(F_T\\)  生成一个T上的函数空间：\n\\[ \\mathcal{V}_T = \\{v : v = \\hat{v} \\circ F_T^{-1}, \\hat{v} \\in \\hat{\\mathcal{V}} \\} \\tag{2.55} \\]  也就是说,对每个函数 \\(v = v(x)\\)  ，都存在某些 \\(\\hat{v} \\in \\hat{\\mathcal{V}}\\)  ，可以将其表示为 \\(v(x)= \\hat{v}(F_T^{-1}(x))= \\hat{v} \\circ F_T^{-1}(x)\\)  。\n映射 \\(F_T\\)  还可以在 \\(\\mathcal{V}_T\\)  上产生一组自由度 \\(\\mathcal{L}_T\\)  \\[ \\mathcal{L}_T = \\{\\ell_i : \\ell_i(v) = \\hat{\\ell}_i(v \\circ F_T), \\quad i = 1, 2,\\dots, \\hat{n}\\} \\tag{2.56} \\]  由了映射集 \\(\\{F_T\\}_{T \\in \\mathcal{T}_h}\\)  ，我们就可以从参考有限元 \\((\\hat{T}, \\hat{\\mathcal{V}}, \\hat{\\mathcal{L}})\\)  生成有限元集 \\(\\{(T, \\mathcal{V}_T, \\mathcal{L}_T)\\}_{T \\in \\mathcal{T}_h}\\)  ：\n\\[ \\begin{aligned} T \u0026= F_T(\\hat{T}) \\\\ \\mathcal{V}_T \u0026= \\{v : v = \\hat{v} \\circ F_T^{-1}, \\quad \\hat{v} \\in \\hat{\\mathcal{V}}\\} \\\\ \\mathcal{L}_T \u0026= \\{\\ell_i : \\ell_i(v) = \\hat{\\ell}_i(v \\circ F_T), \\quad i = 1, 2,\\dots, \\hat{n} = n_T\\} \\end{aligned} \\tag{2.57} \\]  通过这种构造，我们还能从满足 \\(\\hat{\\ell}_i(\\hat{\\phi}_j)=\\delta_{ij}\\)  的参考元上的一组节点基函数 \\(\\{\\hat{\\phi}_i\\}^{\\hat{n}}_{i=1}\\)  ，获得T上的节点基函数 \\(\\{\\phi^T_i\\}^{n_T}_{i=1}\\)  。\n为了看到这一点，我们令 \\(\\phi^T_i=\\hat{\\phi}_i \\circ F^{-1}_T, \\quad i=1,2,\\dots,n_T\\)  ，发现有\n\\[ \\ell_i^T(\\phi_j^T)=\\hat{\\ell}_i(\\phi_j^T \\circ F_T) = \\hat{\\ell}_i(\\hat{\\phi}_j \\circ F_T^{-1} \\circ F_T) = \\hat{\\ell}_i(\\hat{\\phi}_j) = \\delta_{ij} \\tag{2.58} \\]  因此 \\(\\{\\phi^T_i\\}^{n_T}_{i=1}\\)  是 \\(\\mathcal{V}_T\\)  的节点基底。\n因此，我们可以定义指定网格 \\(\\mathcal{T}_h\\)  的函数空间 \\(V_h\\)  ： 一个参考有限元 \\((\\hat{T}, \\hat{\\mathcal{V}}, \\hat{\\mathcal{L}})\\)  ，一组局部到全局映射 \\(\\{\\iota_T\\}_{T \\in \\mathcal{T}_h}\\)  和一组映射 \\(\\{F_T\\}_{T \\in \\mathcal{T}_h}\\)  。 一般而言，对于所有的胞元T， 这个映射不必具有相同的类型，并且并非所有有限元都需要由同一参考有限元生成。 特别地，可以对弯曲边界上的胞元采用不同的（较高阶次）的等参映射。\n上面的构造，对于所谓的仿射等价单元（afﬁne-equivalent elements）（Brenner和Scott，2008）是有效的，如 \\(H^1\\)  -符合的拉格朗日有限元族。 对于 \\(H(\\mathrm{div})\\)  -符合的和 \\(H(\\mathrm{curl})\\)  的单元，例如Brezzi–Douglas–Marini和Nédélec单元，也可以使用类似的构造，其中必须使用适当的Piola映射来映射基函数（而一个仿射映射仍可能用于几何映射）。 但是，并非所有有限元都可以使用这种简单的构造从参考有限元中生成。 例如，对于Hermite有限元族来说，这种构造是失败的（Ciarlet，2002； Brenner和Scott，2008）。\n2·5 有限元求解器 有限元为离散化微分方程提供了一种强大的方法，但是求解出代数系统的结果，即使对于线性系统，也带来了挑战。 一个好的求解器必须处理代数系统的稀疏性和可能出现的不适情况，并且必须能在并行计算机上很好地扩展。 线性求解不仅是线性问题的基本操作，而且用牛顿方法的非线性求解、特征值求解，或者时间步长的每次迭代中也是如此。\n一个经典的，最近重新重视的，是基于高斯消去的直接解法。 得益于支持并行可伸缩性和块结构识别的技术，诸如UMFPACK（Davis，2004）和SuperLU（Li，2005）之类的程序包使直接法在相当大的问题上具有竞争力。\n1970年代和1980年代见证了现代迭代方法的出现。 这些源自经典的迭代方法，例如松弛方法以及Hestenes和Stiefel（1952）的共轭梯度迭代。 与直接法相比，这些技术可以使用更少的内存，并且更易于并行化。\n多重网格方法（Brandt，1977； Wesseling，1992）在网格的层次结构上使用松弛技术来在近似线性时间内求解椭圆方程，通常可用于求解对称问题。 但是，它们所要求网格的层次结构可能并不总是可用。 这促使引入了模拟网格粗化的代数多重网格方法（algebraic multigrid methods，AMG），该方法仅对矩阵项起作用。 成功的AMG发行版，包括Hypre软件包（Falgout和Yang，2002）和ML软件包（Trilinos的一部分）发行（Heroux等，2005）。\n共轭梯度和GMRES（Saad and Schultz，1986）等Krylov方法可生成了一系列逼近线性系统解的近似值。 这些方法仅基于矩阵向量乘积。 通过使用预处理器可以显着改善这些方法的性能，这些预处理器可以转换线性系统\n\\[ A U = b \\tag{2.59} \\]  进而\n\\[ P^{-1} A U = P^{-1} b \\tag{2.60} \\]  这就是所谓的左预处理。 预处理器 \\(P^{-1}\\)  也可以从右开始应用，可见 \\(A U =(A P^{-1})(P U)\\)  ，并求解矩阵 \\(A P^{-1}\\)  的这个修正系统，然后再从 \\(P U\\)  求解出U。 为了确保良好的收敛性，预处理器 \\(P^{-1}\\)  应该是 \\(A^{-1}\\)  的很好近似。 一些预处理是严格代数的，这意味着它们仅使用A中的可用信息。 诸如高斯-塞德尔（Gauss-Seidel）之类的经典松弛方法可以用作预处理，所谓的不完全因子分解也可以用作预处理（Manteuffel，1980； Axelsson，1986； Saad，1994）。 无论是几何还是代数的多重网格，都可以充当强大的因式分解。 其他种类的预处理器需要有关微分方程求解的专门知识，并且可能需要新的与物理过程相关的矩阵建模。 这种方法有时称为基于物理学的预处理器。 诸如FEniCS之类的自动化系统提供了一个有趣的机会，可以协助开发和实施这些功能强大但使用较少的方法。\n幸运的是，这里讨论的许多方法都包含在现代库中，例如PETSc（Balay等人，2004）和Trilinos（Heroux等人，2005）。 FEniCS通常通过这些软件包与刚才讨论过的求解器进行交互，因此主要需要从较高的角度了解各种方法，例如何时使用各种方法以及如何访问它们。\n【章节目录】\n"}),a.add({id:55,href:'/notes/docs/fem/0097/',title:"有限元方法（一）【翻译】",content:"有限元法解偏微分方程（FEniCS）\n有限元法求解牛顿流体（FEniCS）\n这两篇笔记仅做入门之用。 为了深入掌握，建议阅读《Automated Solution of Differential Equations by the Finite Element Method》。 为此，我一边学习一边翻译权当笔记。\n【章节目录】\n有限元方法已经成为求解微分方程的通用方法。有限元方法的成功大部分可以归因于它的通用性和优雅性，它允许在一个通用框架内分析和求解来自科学所有领域的各种微分方程。有限元方法成功的另一个因素是公式的灵活性，可以通过选择近似的有限元空间来控制离散化的属性。\n在本章中，我们回顾有限元方法，并总结整本书中使用的一些基本概念和符号。\n在接下来的章节中，我们将更详细地讨论这些概念，并特别关注有限元方法的实现和自动化，这是FEniCS项目的一部分。\n2·1 一个简单的模型问题 1813年，西蒙·丹尼斯·泊松（SiméonDenis Poisson）在《哲学公报》上发表了他的著名公式，作为对皮埃尔-西蒙·拉普拉斯(Pierre-Simon Laplace)早些时候发表的公式的修正。 泊松方程是一个二阶偏微分方程，在域   \\(\\Omega\\subset \\mathbb{R}^d\\)  上，未知场 \\(u = u(x)\\)  被负拉普拉斯算符作用后（ \\(-\\Delta u\\)  ）等于给定函数 \\(f = f(x)\\)  ，并且在 \\(\\Omega\\)  的边界 \\(\\partial \\Omega\\)  上，u被一组边界条件集约束：\n\\[ \\begin{aligned}-\\Delta u = f \u0026 \\qquad \\mathrm{in} \\ \\Omega \\\\ u = u_0 \u0026 \\qquad \\mathrm{on} \\ \\Gamma_D \\subset \\partial \\Omega \\\\ -\\partial_n u = g \u0026 \\qquad \\mathrm{on} \\ \\Gamma_N \\subset \\partial \\Omega \\end{aligned} \\tag{2.1} \\]  Dirichlet边界条件 \\(u=u_0\\)  表示u在边界子集 \\(\\Gamma_D\\)  上的约束值，而Neumann边界条件 \\(-\\partial_n u = g\\)  则表示u在其余边界 \\(\\Gamma_N=\\partial \\Omega - \\Gamma_D\\)  上的（负的）法向导数的约束值。泊松方程是引力，电磁，热传导，流体流动和许多其他物理过程的简单模型。在许多更复杂的物理模型中，它也作为基本构建块出现，包括Navier-Stokes方程，我们将在第20、21、22、23、24、25、28和29章中回头讨论。\n为了推导泊松方程（2.1），我们可以考虑区域 \\(\\Omega\\)  中，热源分布为 \\(f\\)  ，关于温度u的模型。 令 \\(\\sigma=\\sigma(x)\\)  表示热通量，根据能量守恒，对任何测试体 \\(\\omega \\subset \\Omega\\)  ，从其边界 \\(\\partial \\omega\\)  流出的能量必须和热源 \\(f\\)  发出的能量平衡：\n\\[ \\int_{\\partial\\omega}{\\sigma \\cdot n ds} = \\int_\\omega{fdx} \\tag{2.2} \\]  左边的面积分可改写成体积分，于是有：\n\\[ \\int_\\omega{\\nabla \\cdot \\sigma ds} = \\int_\\omega{fdx} \\tag{2.3} \\]  由于上式对于任意测试体 \\(\\omega \\subset \\Omega\\)  均成立，因此在整个 \\(\\Omega\\)  中, \\(\\nabla \\cdot \\sigma = f\\)  （并且在 \\(\\sigma\\)  和 \\(f\\)  上服从适当的正规性假设）。如果现在我们又假设热通量 \\(\\sigma\\)  与温度 \\(u\\)  的负梯度成比例（傅立叶定律）:\n\\[ \\sigma = -\\kappa \\nabla u \\tag{2.4} \\]  于是得到下面这个方程组：\n\\[ \\begin{aligned}\\nabla \\cdot \\sigma = f \u0026 \\qquad \\mathrm{in} \\ \\Omega \\\\ \\sigma + \\nabla u = 0 \u0026 \\qquad \\mathrm{in} \\ \\Omega\\end{aligned} \\tag{2.5} \\]  我们假设热传导系数为 \\(\\kappa = 1\\)  。 如图2.1下所示。 将第一个方程式中的 \\(\\sigma\\)  替换为 \\(-\\nabla u\\)  ，我们得到前面的泊松方程（2.1）。反之，通过对泊松方程（2.1）引入 \\(\\sigma =-\\nabla u\\)  作为辅助变量，也可以得出上面这个一阶方程组（2.5）。 我们还注意到泊松方程（2.1）的两个边界条件：Dirichlet和Neumann边界条件，分别对应于温度和热通量的约束值。\n图2.1: 泊松方程是任意测试体积 \\(\\omega \\subset \\Omega\\)  中能量平衡的简单结果。 2·2 有限元离散化 2·2·1 泊松方程离散化 为了用有限元方法离散化泊松方程（2.1），我们首先乘以测试函数 \\(v\\)  ，然后通过分部积分得：\n\\[ \\int_\\Omega{\\nabla u \\cdot \\nabla v dx} - \\int_{\\partial \\Omega}{\\partial_n u v ds} = \\int_\\Omega{f v dx} \\tag{2.6} \\]  让测试函数(test function) \\(v\\)  在Dirichlet边界 \\(\\Gamma_D\\)  上消失（解u在该边界上已知），我们得到以下经典的变分问题：寻求 \\(u \\in V\\)  ，满足：\n\\[ \\int_\\Omega{\\nabla u \\cdot \\nabla v dx} = \\int_\\Omega{f v dx} - \\int_{\\Gamma_N}{g v ds} \\qquad \\forall v \\in \\hat{V} \\tag{2.7} \\]  测试空间(test space) \\(\\hat{V}\\)  被定义为：\n\\[ \\hat{V} = \\left\\{v \\in H^1(\\Omega) : v=0 \\ \\mathrm{on} \\ \\Gamma_D \\right\\} \\tag{2.8} \\]  试探空间(trial space) \\(V\\)  , 则是测试空间的Dirichlet条件平移后得到的空间：\n\\[ V = \\left\\{u \\in H^1(\\Omega) : u=u_0 \\ \\mathrm{on} \\ \\Gamma_D \\right\\} \\tag{2.9} \\]  现在，我们可以通过将变分问题（2.7）限制在这对离散空间中来离散化泊松方程：寻求 \\(u_h \\in V_h \\subset V\\)  满足：\n\\[ \\int_\\Omega{\\nabla u_h \\cdot \\nabla v dx} = \\int_\\Omega{f v dx} - \\int_{\\Gamma_N}{g v ds} \\qquad \\forall v \\in \\hat{V}_h \\subset \\hat{V} \\tag{2.10} \\]  我们在这里注意到，在 \\(\\Gamma_D\\)  上的Dirichlet条件 \\(u = u_0\\)  直接进入试探空间 \\(V_h\\)  的定义（这是一个基本边界条件），而在 \\(\\Gamma_N\\)  上的Neumann条件 \\(−\\partial_n u = g\\)  则进入了变分问题（它是自然边界条件）。\n为了求解这个离散的变分问题（2.10），我们必须构造合适的一对离散试探空间和测试空间 \\(V_h\\)  和 \\(\\hat{V}_h\\)  。我们后面将回到这个问题，在此之前，现在我们假设 \\(V_h\\)  有一个基 \\(\\{\\phi_j\\}^N_{j=1}\\)  ， \\(\\hat{V}\\)  也有一个基 \\(\\{\\hat{\\phi}_j\\}^N_{j=1}\\)  。在此，N表示空间 \\(V_h\\)  和 \\(\\hat{V}_h\\)  的尺寸。然后，我们可以将 \\(u_h\\)  用试探空间的基函数来展开：\n\\[ u_h(x) = \\sum_{j=1}^N{U_j \\phi_j(x)} \\tag{2.11} \\]  其中， \\(U\\in \\mathbb{R}^N\\)  是要被计算的作为自由度的向量。将其带入离散化的变分问题中，并用离散测试空间 \\(\\hat{V}_h\\)  的基函数来充当测试函数 \\(v\\)  ，于是：\n\\[ \\begin{aligned}\\sum_{j=1}^N{U_j \\int_\\Omega{\\nabla \\phi_j \\cdot \\nabla \\hat{\\phi}_i dx}} = \\int_\\Omega{f \\hat{\\phi}_i dx} - \\int_{\\Gamma_N}{g \\hat{\\phi}_i ds} \\\\ i = 1,2,\\dots,N \\end{aligned} \\tag{2.12} \\]  因此，我们可以通过求解这个线性方程组来计算出有限元解 \\(u_h = \\sum^N_{j=1}{U_j \\phi_j}\\)  :\n\\[ A U = b \\tag{2.13} \\]  其中：\n\\[ A_{ij}=\\int_\\Omega{\\nabla \\phi_j \\cdot \\nabla \\hat{\\phi}_i dx} \\\\ b_i = \\int_\\Omega{f \\hat{\\phi}_i dx} - \\int_{\\Gamma_N}{g \\hat{\\phi}_i ds} \\tag{2.14} \\]  2·2·2 一阶方程组离散化 我们可以类似地离散一个一阶方程组（2.5）： 将第一个一阶方程乘以一个测试函数v，并将第二个一阶方程乘以另一个测试函数τ，然后进行积分再相加合并，得到\n\\[ \\begin{aligned}\\int_\\Omega{\\left[(\\nabla \\cdot \\sigma) v + \\sigma \\cdot \\tau - u \\nabla \\cdot \\tau\\right]dx}+ \\int_{\\partial \\Omega}{u \\tau \\cdot n ds} = \\int_\\Omega{ f v dx} \\\\ \\forall(v,\\tau)\\in \\hat{V} \\end{aligned} \\tag{2.15} \\]  在Neumann边界 \\(\\Gamma_N\\)  上已知单位通量 \\(\\sigma \\cdot n = g\\)  ，因此我们取 \\(\\tau \\cdot n = 0\\)  。 将u的值带入到Dirichlet边界 \\(\\Gamma_D\\)  上，我们得出以下变分问题：寻求 \\((u,\\sigma) \\in V\\)  ，满足\n\\[ \\begin{aligned}\\int_\\Omega{\\left[(\\nabla \\cdot \\sigma) v + \\sigma \\cdot \\tau - u \\nabla \\cdot \\tau\\right]dx} = \\int_\\Omega{ f v dx} - \\int_{\\Gamma_D}{u_0 \\tau \\cdot n ds} \\\\ \\forall (v,\\tau)\\in \\hat{V} \\end{aligned} \\tag{2.16} \\]  试探空间和测试空间的合适选择是\n\\[ \\begin{aligned} V=\\left\\{ (v,\\tau) : v\\in L^2(\\Omega), \\tau \\in H(\\mathrm{div},\\Omega), \\tau \\cdot n = g \\ \\mathrm{on} \\ \\Gamma_N \\right\\} \\\\ \\hat{V}=\\left\\{ (v,\\tau) : v\\in L^2(\\Omega), \\tau \\in H(\\mathrm{div},\\Omega), \\tau \\cdot n = 0 \\ \\mathrm{on} \\ \\Gamma_N \\right\\} \\end{aligned} \\tag{2.17} \\]  请注意，这个变分问题（2.16）与前面的变分问题（2.7）的不同之处在于， \\(\\Gamma_D\\)  上的Dirichlet条件 \\(u = u_0\\)  进入了变分公式（现在是自然边界条件），而Neumann条件 \\(\\sigma \\cdot n = g\\)  则在 \\(\\Gamma_N\\)  上进入试探空间V的定义（现在是基本边界条件）。\n同样，我们将变分问题限制在一对离散的试探空间和测试空间 \\(V_h \\subset V\\)  和 \\(\\hat{V}_h\\subset \\hat{V}\\)  上，并有限元解形如：\n\\[ (u_h,\\sigma_h) = \\sum^N_{j=1}{U_j(\\phi_j,\\psi_j)} \\tag{2.18} \\]  其中， \\(\\left\\{(\\phi_j,\\psi_j)\\right\\}^N_{j=1}\\)  是试探空间 \\(V_h\\)  的基底。 通常， \\(\\phi_j\\)  或 \\(\\psi_j\\)  都将消失，因此这个基底实际上是 \\(L^2\\)  空间基数和 \\(H(\\mathrm{div})\\)  空间基数的张量积。因此，我们通过求解线性方程组 \\(A U = b\\)  来获得自由度为 \\(U \\in \\mathbb{R}^N\\)  的线性系统\n\\[ A_{ij}=\\int_\\Omega{\\left[(\\nabla \\cdot \\psi_j) \\hat{\\phi}_i + \\psi_j \\cdot \\hat{\\psi}_i - \\phi_j \\nabla \\cdot \\hat{\\psi}_i\\right]dx} \\\\ b_i = \\int_\\Omega{f \\hat{\\phi}_i dx} - \\int_{\\Gamma_D}{u_0 \\hat{\\psi}_i \\cdot n ds} \\tag{2.19} \\]  这种有限元离散化（2.19）就是混合方法（mixed method）的一个例子。这种表述需要很小心地为各种不同的函数空间选择兼容的方法，比如这里的 \\(L^2\\)  和 \\(H(\\mathrm{div})\\)  。稳定的离散化必须满足所谓的inf-sup或Ladyzhenskaya-Babuška-Brezzi（LBB）条件。该理论解释了为什么与标准方法相比，混合方法中的许多有限元空间显得更复杂。后面的第3章中，我们将给出了这种有限元空间的几个例子。\n2·3 有限元抽象形式 2·3·1 线性问题 我们在上面看到，泊松方程（2.1）或（2.5）的有限元解可以通过将有限维（连续）变分问题限制为有限维（离散）变分问题并通过求解线性方程组来获得。\n为了对此进行形式化，我们考虑以下规范形式编写的一般线性变分问题：寻求 \\(u \\in V\\)  满足\n\\[ a(u,v) = L(v) \\qquad \\forall v \\in \\hat{V} \\tag{2.20} \\]  其中 \\(V\\)  是试探空间(trial space)， \\(\\hat{V}\\)  是测试空间(test space)。因此，我们用双线性形式 \\(a\\)  和线性形式（泛函） \\(L\\)  表示变分问题：\n\\[ a: V \\times \\hat{V} \\to \\mathbb{R} \\\\ L: \\hat{V} \\to \\mathbb{R} \\tag{2.21} \\]  和前面一样，我们通过限制一对离散的试探空间和测试空间来离散化这个形式的变分问题（2.20）：寻求 \\(u_h \\in V_h \\subset V\\)  满足\n\\[ a(u_h,v) = L(v) \\qquad \\forall v \\in \\hat{V}_h \\subset \\hat{V} \\tag{2.22} \\]  为了解决这种形式化的离散变分问题（2.22），我们将 \\(u_h\\)  展开为：\n\\[ u_h = \\sum^N_{j=1}{U_j \\phi_j} \\tag{2.23} \\]  取 \\(v = \\hat{\\phi}_i, \\ i = 1,2,\\dots, N\\)  。和前面一样， \\(\\{\\phi_j\\}^N_{j=1}\\)  是离散试探空间 \\(V_h\\)  的基底， \\(\\{\\hat{\\phi}_i\\}^N_{i=1}\\)  则是离散测试空间 \\(\\hat{V}_h\\)  的基底。它满足：\n\\[ \\sum^N_{j=1}{U_j a(\\phi_j,\\hat{\\phi}_i)} = L(\\hat{\\phi}_i),\\qquad i = 1,2,\\dots, N \\tag{2.24} \\]  然后可以通过求解线性方程组 \\(A U = b\\)  来计算自由度 \\(U \\in \\mathbb{R}^N\\)  的线性系统，其中\n\\[ A_{ij} = a(\\phi_j, \\hat{\\phi}_i), \\qquad i,j = 1,2,\\dots,N \\\\ b_i = L(\\hat{\\phi}_i) \\qquad i = 1,2,\\dots,N \\tag{2.25} \\]  2·3·2 非线性问题 我们还考虑以下规范形式编写的非线性变分问题：寻求 \\(u \\in V\\)  满足\n\\[ F(u; v) = 0, \\qquad \\forall v \\in \\hat{V} \\tag{2.26} \\]  现在 \\(F:V \\times \\hat{V} \\to \\mathbb{R}\\)  是一个半线性形式，分号后的参数中是线性的。和前面一样，我们通过限制一对离散的试探和测试空间来离散化此变分问题（2.26）：寻找 \\(u_h \\in V_h \\subset V\\)  满足\n\\[ F(u_h; v) = 0, \\qquad \\forall v \\in \\hat{V}_h \\subset \\hat{V} \\tag{2.27} \\]  然后可以通过求解非线性方程组来计算有限元解 \\(u_h = \\sum^N_{j=1}{U_j \\phi_j}\\)  ：\n\\[ b(U) = 0 \\tag{2.28} \\]  其中 \\(b:\\mathbb{R}^N \\to \\mathbb{R}^N\\)  和\n\\[ b_i(U) = F(u_h; \\hat{\\phi}_i), \\qquad i=1,2,\\dots,N \\tag{2.29} \\]  为了用牛顿法或牛顿法的某些变体求解这种非线性方程组（2.28），我们要计算雅可比行列式A = b'。我们注意到，如果半线性形式 \\(F\\)  对 \\(u\\)  是可微的，则雅可比矩阵A的各项由下式给出：\n\\[ \\begin{aligned}A_{ij}(u_h) \u0026= \\frac{\\partial b_i(U)}{\\partial U_j} = \\frac{\\partial}{\\partial U_j} F(u_h; \\hat{\\phi}_i) \\\\ \u0026= F'(u_h; \\hat{\\phi}_i) \\frac{\\partial u_h}{\\partial U_j} = F'(u_h; \\hat{\\phi}_i) \\phi_j \\overset{\\Delta}{=} F'(u_h; \\phi_j,\\hat{\\phi}_i) \\end{aligned} \\tag{2.30} \\]  在每次牛顿迭代中，我们必须计算（组装）矩阵A和向量b，并通过以下方式更新解向量U:\n\\[ U^{k+1} = U^k - \\delta U^k ,\\qquad k = 0,1,\\dots \\tag{2.31} \\]  其中， \\(\\delta U^k\\)  是下面这个线性方程组的解：\n\\[ A(u^k_h) \\delta U^k = b(u^k_h) \\tag{2.32} \\]  我们注意到，对于每个固定的 \\(u_h\\)  ， \\(a = F'(u_h; \\cdot, \\cdot）\\)  是双线性形式，而 \\(L=F(u_h; \\cdot)\\)  是线性形式。因此，在每次牛顿迭代中，我们都是求解标准形式的线性变分问题（2.20）：寻求 \\(\\delta u \\in V_{h,0}\\)  满足\n\\[ F'(u_h; \\delta u, v) = F(u_h; v) ,\\qquad \\forall v\\in \\hat{V}_h \\tag{2.33} \\]  其中， \\(V_{h,0} = \\{v - w : v, w \\in V_h\\}\\)  。 正如上一小节2.3.1的离散化（2.33）一样，我们重新找到了一个线性方程组（2.32）。\n例子2.1 (非线性泊松方程) 例如，考虑以下非线性泊松方程：\n\\[ \\begin{aligned}-\\nabla \\cdot ( (1+u) \\nabla u )= f \u0026 \\qquad \\mathrm{in} \\ \\Omega \\\\ u = 0 \u0026 \\qquad \\mathrm{on} \\ \\partial \\Omega \\end{aligned} \\tag{2.34} \\]  在（2.34）两边乘上测试函数 \\(v\\)  , 并且进行分部积分得到：\n\\[ \\int_\\Omega{((1+u)\\nabla u)\\cdot \\nabla v dx} = \\int_{\\partial \\Omega}{f v dx} \\tag{2.35} \\]  这是非线性变分问题（2.26），其中:\n\\[ F(u; v) = \\int_\\Omega{((1+u)\\nabla u)\\cdot \\nabla v dx} - \\int_{\\partial \\Omega}{f v dx} \\tag{2.36} \\]  对半线性形式 \\(F(u; v)\\)  进行关于 \\(u=u_h\\)  的线性化，我们得到\n\\[ F'(u_h; \\delta u, v) = \\int_\\Omega{(\\delta u\\nabla u)\\cdot \\nabla v dx} + \\int_\\Omega{((1+u)\\nabla \\delta u)\\cdot \\nabla v dx} \\tag{2.37} \\]  因此，我们可以通过以下方式计算雅可比矩阵 \\(A(u_h)\\)  ：\n\\[ \\begin{aligned} A_{ij}(u_h) \u0026= F'(u_h; \\phi_j, \\hat{\\phi}_i) \\\\ \u0026= \\int_\\Omega{(\\phi_j \\nabla u)\\cdot \\nabla \\hat{\\phi}_i dx} + \\int_\\Omega{((1+u)\\nabla \\phi_j)\\cdot \\nabla \\hat{\\phi}_i dx} \\end{aligned} \\tag{2.38} \\]  【章节目录】\n"}),a.add({id:56,href:'/notes/docs/fem/',title:"《有限元法自动求解微分方程》【翻译】",content:"《有限元法自动求解微分方程》【翻译】 有限元法解偏微分方程（FEniCS）\n有限元法求解牛顿流体（FEniCS）\n这两篇笔记仅做入门之用【用来代替第1章】。\n为了深入掌握，建议阅读《Automated Solution of Differential Equations by the Finite Element Method》。 为此，我一边学习一边翻译权当笔记。\n原书链接：https://pan.baidu.com/s/1v-hqfK0Z6HzA5AAQoaVRvg 提取码：ulss 【如果链接失效，评论中通知我，我看到会更新】\n  \\(\\color{red}{学习进行中...}\\)  \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; I.方法论 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 第二章 有限元方法  有限元方法  2·1 一个简单的模型问题 2·2 有限元离散化  2·2·1 泊松方程离散化 2·2·2 一阶方程组离散化   2·3 有限元抽象形式  2·3·1 线性问题 2·3·2 非线性问题   2·4 有限元函数空间  2·4·1 网格 2·4·2 有限元定义            2·4·3 节点基底 2·4·4 局部到全局映射 2·4·5 全局函数空间 2·4·6 参考单元的映射   2·5 有限元求解器 2·6 有限元误差估计和适应性  2·6·1 先验误差分析 2·6·2 后验误差分析 2·6·3 适应性   2·7 自动化有限元方法 2·8 历史评注      第三章 常见有限元  常见有限元  3·1 有限元定义 3·2 记号 3·3 H¹有限元  3·3·1 拉格朗日单元 3·3·2 Crouzeix–Raviart单元   3·4 H(div) 有限元  3·4·1 Raviart–Thomas单元 3·4·2 Brezzi–Douglas–Marini单元 3·4·3 Mardal-Tai-Winther单元 3·4·4 Arnold–Winther单元          3·5 H(curl) 有限元  3·5·1 第一种Nédélec H(curl)单元 3·5·2 第二种Nédélec H(curl)单元   3·6 L² 有限元  3·6·1 不连续拉格朗日   3·7 H²有限元  3·7·1 Argyris单元 3·7·2 Hermite单元 3·7·3 Morley单元   3·8 强化有限元 3·9 有限元外微积分(FEEC) 3·10 小结      第四章 构造通用参考单元  构造通用参考单元  4·1 背景 4·2 预备 4·3 数学框架  4·3·1 基底变更 4·3·2 多项式空间   4·4 单元的例子  4·4·1 其它多项式空间的基底          4·5 多项式空间上的操作  4·5·1 求值 4·5·2 微分 4·5·3 积分 4·5·4 维面（facet）关联 4·5·5 线性泛函 4·5·6 参考单元的映射 4·5·7 局部到全局的自由度映射        第五章 有限元变分形式  有限元变分形式  5·1 背景 5·2 多重线性形式  5·2·1 例子 5·2·2 正则形式          5·3 离散多重线性形式 5·4 多重线性形式的作用 5·5 多重线性形式的导数 5·6 双线性形式的伴随 5·7 关于试探函数和测试函数的说明      第六章 有限元组装  有限元组装  6·1 组装算法 6·2 实现        6·3 边界条件的对称应用 6·4 并行组装 6·5 无矩阵方法      第七章 有限元变分形式的正交表示  有限元变分形式的正交表示  7·1 标准正交表示 7·2 正交优化  7·2·1 零消除操作 7·2·2 化简表达式 7·2·3 积分点常量预计算            7·2·4 基常量预计算 7·2·5 进一步优化   7·3 性能比较  7·3·1 正交优化的性能 7·3·2 正交和张量表示的相对性能   7·4 表示的自动选择      第八章 有限元变分形式的张量表示  有限元变分形式的张量表示  8·1 泊松方程的张量表示        8·2 表示定理 8·3 扩展和限制      第九章 有限元矩阵计算的离散优化  有限元矩阵计算的离散优化  9·1 优化框架 9·2 拓扑优化 9·3 图问题        9·4 几何优化 9·5 稠密线性代数的优化 9·6 实现注记      \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; II·实现 \u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; 第十章 DOLFIN：C＋＋／Python有限元库  DOLFIN：C++/Python有限元库  10·1 概述 10·2 用户接口  10·2·1 C++接口 10·2·2 Python接口   10·3 功能  10·3·1 线性代数 10·3·2 网格 10·3·3 有限元 10·3·4 函数空间 10·3·5 函数 10·3·6 表达式 10·3·7 变分形式            10·3·8 有限元组装 10·3·9 边界条件 10·3·10 变分问题 10·3·11 文件I/O和可视化 10·3·12 日志/诊断 10·3·13 参数   10·4 实现注记  10·4·1 并行计算 10·4·2 实现和Python接口生成 10·4·3 UFL集成和即时编译器 10·4·4 NumPy和SciPy整合   10·5 历史注记      第十七章 UFL：有限元形式语言  UFL：有限元形式语言     17·0·1 相关工作   17·1 概述  17·1·1 设计目标 17·1·2 动机的例子   17·2 定义有限元空间 17·3 定义形式 17·4 定义表达式  17·4·1 形式的参数 17·4·2 索引记号 17·4·3 代数算符和函数 17·4·4 微分算符 17·4·5 其他算符   17·5 形式算符  17·5·1 形式的微分 17·5·2 伴随 17·5·3 替换函数 17·5·4 作用 17·5·5 系统分割 17·5·6 计算函数的敏感性   17·6 表达式的表示  17·6·1 表达式的结构 17·6·2 表达式对象 17·6·3 表达式属性            17·6·4 树表示 17·6·5 图表示 17·6·6 划分   17·7 计算导数  17·7·1 计算导数的方法 17·7·2 前向模式自动微分 17·7·3 张量和索引表达式的扩展 17·7·4 高阶导数 17·7·5 基本微分规则   17·8 算法  17·8·1 Python中的有效树遍历 17·8·2 Python中基于类型的函数分派 17·8·3 表达式变换的实现 17·8·4 重要的变换 17·8·5 表达式求值 17·8·6 表达式查看   17·9 实现的问题  17·9·1 Python作为领域专用语言的基础 17·9·2 确保形式签名的唯一性 17·9·3 效率考量   17·10 结论和未来方向 17·11 致谢      第十八章 Unicorn：统一的连续介质力学求解器  Unicorn：统一的连续介质力学求解器  18·1 背景 18·2 统一的连续介质建模 18·3 时空的一般Galerkin离散化  18·3·1 标准Galerkin 18·3·2 局域ALE 18·3·3 加权最小二乘稳定化   18·4 实现  18·4·1 Unicorn类/接口 18·4·2 TimeDependentPDE 18·4·3 ErrorEstimate            18·4·4 SpaceTimeFunction 18·4·5 SlipBC 18·4·6 ElasticSmoother 18·4·7 MeshAdaptInterface   18·5 解决连续介质力学问题  18·5·1 流固耦合 18·5·2 自适应性 18·5·3 Unicorn-HPC安装和基本测试   18·6 致谢      第二十章 不可压缩流体的有限元  不可压缩流体的有限元  20·1 Stokes方程 20·2 混合Stokes问题的有限元公式  20·2·1 基于兼容函数空间的公式 20·2·2 压力稳定法          20·3 惩罚方法：Scott–Vogelius方法 20·4 数值测试  20·4·1 模拟设置 20·4·2 结果   20·5 结论     "}),a.add({id:57,href:'/notes/categories/%E6%9C%89%E9%99%90%E5%85%83%E6%B3%95/',title:"有限元法",content:""}),a.add({id:58,href:'/notes/tags/julia/',title:"julia",content:""}),a.add({id:59,href:'/notes/docs/julia/0096/',title:"有限元法求解牛顿流体（FEniCS）",content:" 在Julia环境中，使用FenicsPy.jl调用FEniCS库，求解偏微分方程。\n 纳维-斯托克斯方程组 纳维-斯托克斯方程:\n  \\[ \\color{red}{\\frac{\\partial \\boldsymbol{u}}{\\partial t}+(\\boldsymbol{u} \\cdot \\nabla)\\boldsymbol{u}=\\frac{1}{\\rho}\\nabla\\cdot \\boldsymbol{\\sigma}+\\boldsymbol{f}} \\]  其中，张量 \\(\\boldsymbol{\\sigma}\\)  是应力张量, 取决于具体流体的特性假设，比如：牛顿流体。\n连续性方程：\n\\[ \\frac{\\partial \\rho}{\\partial t}+\\nabla \\cdot (\\rho \\boldsymbol{u})=0 \\]  特别地，对不可压缩流体而言：\n\\[ \\color{red}{ \\nabla \\cdot \\boldsymbol{u}=0} \\]  牛顿流体的特性假设：\n\\[ \\color{blue}{\\begin{aligned}\\sigma(\\boldsymbol{u},p) \u0026= -p I + 2\\mu \\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\\\ \\boldsymbol{\\epsilon}(\\boldsymbol{u})\u0026= \\frac{1}{2}\\left(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^T \\right)\\end{aligned}} \\]  在 \\(\\color{blue}{牛顿流体假设}\\)  下，这两个 \\(\\color{red}{红色方程}\\)  的组成不可压缩牛顿流体的运动方程组。\n对平面流体而言，这组方程有有三个方程，有三个待求量： 速度场 \\(u(x,y,t)\\)  和压强场 \\(p(x,y,t)\\)  。 给定边界条件，就可以求解了。\n几个必要公式 \\[ \\begin{aligned}\\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\cdot \\nabla\\boldsymbol{v}\u0026 =\\epsilon_{ij}(\\boldsymbol{u}) \\frac{\\partial v_i}{\\partial x_j} \\qquad \\text{爱因斯坦求和约定} \\\\ \u0026=\\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}+\\frac{\\partial u_j}{\\partial x_i}\\right) \\frac{\\partial v_i}{\\partial x_j} \\\\ \u0026=\\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} \\frac{\\partial v_i}{\\partial x_j}+\\frac{\\partial u_i}{\\partial x_j}\\frac{\\partial v_j}{\\partial x_i}\\right) \\qquad \\text{括号中第二项：由于缩并，指标交换不变} \\\\ \u0026=\\frac{\\partial u_i}{\\partial x_j}\\frac{1}{2}\\left(\\frac{\\partial v_i}{\\partial x_j}+\\frac{\\partial v_j}{\\partial x_i}\\right) \\\\ \u0026=\\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j}+\\frac{\\partial u_j}{\\partial x_i}\\right) \\frac{1}{2}\\left(\\frac{\\partial v_i}{\\partial x_j}+\\frac{\\partial v_j}{\\partial x_i}\\right) \\qquad \\text{由于缩并，指标交换不变} \\\\ \u0026=\\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\cdot \\boldsymbol{\\epsilon}(\\boldsymbol{v}) \\qquad \\text{这里的点乘，实际是双重指标缩并} \\end{aligned} \\]  即(同时有第二式)：\n\\[ \\color{blue}{\\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\cdot \\nabla\\boldsymbol{v} = \\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\cdot \\boldsymbol{\\epsilon}(\\boldsymbol{v}) = \\nabla\\boldsymbol{u} \\cdot \\boldsymbol{\\epsilon}(\\boldsymbol{v}) } \\]  \\[ \\color{blue}{\\boldsymbol{\\sigma}(\\boldsymbol{u},p) \\cdot \\nabla\\boldsymbol{v} = \\boldsymbol{\\sigma}(\\boldsymbol{u},p) \\cdot \\boldsymbol{\\epsilon}(\\boldsymbol{v}) } \\]  不难根据“由于缩并，指标交换不变”类似推导出：\n\\[ \\color{blue}{\\boldsymbol{a} \\cdot \\left[\\boldsymbol{\\epsilon}(\\boldsymbol{u}) \\cdot \\boldsymbol{v}\\right] = \\boldsymbol{a} \\cdot \\left[\\nabla \\boldsymbol{u} \\cdot \\boldsymbol{v}\\right]} \\]  在此基础上，容易推导出：\n\\[ \\color{red}{\\left[\\nabla \\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u},p)\\right]\\cdot \\boldsymbol{v} =2\\mu\\nabla \\cdot \\left[\\nabla \\boldsymbol{u} \\cdot \\boldsymbol{v}\\right] -\\nabla \\cdot (p \\boldsymbol{v}) - \\boldsymbol{\\sigma}(\\boldsymbol{u},p) \\cdot \\boldsymbol{\\epsilon}(\\boldsymbol{v})} \\]  将运动方程转换成变分等式 利用前面的公式，将纳维-斯托克斯方程改写成变分等式（同时用了斯托克斯定理）\n\\[ \\left+\\left+\\frac{1}{\\rho}\\left \\\\ \\qquad \\qquad \\qquad \\qquad \\qquad + \\frac{1}{\\rho}\\left_{\\partial \\Omega}-\\frac{2\\mu}{\\rho}\\left_{\\partial \\Omega} - \\left=0 \\]  约定：\n\\[ \\left \\overset{\\Delta}{=}\\int_\\Omega{\\boldsymbol{u} \\cdot \\boldsymbol{v}d\\omega}\\qquad \\left_{\\partial \\Omega} \\overset{\\Delta}{=}\\int_{\\partial \\Omega}{\\boldsymbol{u} \\cdot \\boldsymbol{v}ds} \\]  对时间有限差分 第1步： 已知 \\(\\boldsymbol{u}^n,p^n\\)  ，求 \\(\\color{red}{\\boldsymbol{u}^*}\\)  \\[ \\boxed{\\begin{aligned}\\rho\\left+\\rho\\left+\\left\\\\ +\\left_{\\partial \\Omega}-2\\mu\\left_{\\partial \\Omega}- \\rho\\left=0 \\end{aligned}} \\]  其中：\n\\[ \\frac{\\partial \\boldsymbol{u}}{\\partial t} \\approx \\frac{\\boldsymbol{u}^*-\\boldsymbol{u}^n}{\\Delta t} \\qquad \\boldsymbol{u}^{n+\\frac{1}{2}} \\approx \\frac{\\boldsymbol{u}^*+\\boldsymbol{u}^n}{2} \\]  对时间有限差分 第2步： 已知 \\(\\boldsymbol{u}^*,p^n\\)  ，求 \\(\\color{red}{p^{n+1}}\\)  :\n第1步对应得运动差分方程实际是：\n\\[ \\frac{\\boldsymbol{u}^*-\\boldsymbol{u}^n}{\\Delta t}+(\\boldsymbol{u}^n \\cdot \\nabla)\\boldsymbol{u}^n=\\frac{1}{\\rho}\\nabla\\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}^{n+\\frac{1}{2}}, p^n)+\\boldsymbol{f}^n \\]  第2步需要运动差分方程则是：\n\\[ \\frac{\\boldsymbol{u}^{n+1}-\\boldsymbol{u}^n}{\\Delta t}+(\\boldsymbol{u}^n \\cdot \\nabla)\\boldsymbol{u}^n=\\frac{1}{\\rho}\\nabla\\cdot \\boldsymbol{\\sigma}(\\boldsymbol{u}^{n+\\frac{1}{2}},p^{n+1})+\\boldsymbol{f}^n \\]  前后两式相减得：\n\\[ \\frac{\\boldsymbol{u}^*-\\boldsymbol{u}^{n+1}}{\\Delta t}=\\frac{1}{\\rho}\\left(\\nabla p^{n+1}-\\nabla p^n\\right) \\]  考虑到 \\(\\nabla \\cdot \\boldsymbol{u}^{n+1}=0\\)  ，对上式两边求散度后得：\n\\[ \\frac{\\nabla \\cdot \\boldsymbol{u}^*}{\\Delta t}=\\frac{1}{\\rho}\\left(\\nabla^2 p^{n+1}-\\nabla^2 p^n\\right) \\]  根据这个等式可构建出变分等式：\n\\[ \\boxed{\\left=\\left-\\frac{\\rho}{\\Delta t}\\left} \\]  对时间有限差分 第3步： 已知 \\(\\boldsymbol{u}^*,p^n,p^{n+1}\\)  ，求 \\(\\color{red}{\\boldsymbol{u}^{n+1}}\\)  :\n从第2步的公式：\n\\[ \\frac{\\boldsymbol{u}^*-\\boldsymbol{u}^{n+1}}{\\Delta t}=\\frac{1}{\\rho}\\left(\\nabla p^{n+1}-\\nabla p^n\\right) \\]  出发, 根据这个等式可构建出变分等式：\n\\[ \\boxed{\\left=\\left-\\frac{\\Delta t}{\\rho}\\left} \\]  实现代码 前面方框中的公式，将在下面的代码中直接用到。\n求解区域如图：\n具体边界条件见有详细注释的代码。\n# https://github.com/chaoskey/FenicsPy.jl using FenicsPy # 参数：ρ,μ,Δt T = 5 num_steps = 5000 Δt = T / num_steps μ = 0.001 ρ = 1 # 解域及网格生成 channel = Rectangle(Point(0.0, 0.0), Point(2.2, 0.41)) cylinder = Circle(Point(0.2, 0.2), 0.05) Ω = channel - cylinder mesh = generate_mesh(Ω, 64) # 函数空间：速度场空间 和 压强场空间 V = VectorFunctionSpace(mesh, \u0026#34;P\u0026#34;, 2) Q = FunctionSpace(mesh, \u0026#34;P\u0026#34;, 1) # 定义边界： 入口，出口，墙，圆柱障碍 inflow = \u0026#34;near(x[0], 0)\u0026#34; outflow = \u0026#34;near(x[0], 2.2)\u0026#34; walls = \u0026#34;near(x[1], 0) || near(x[1], 0.41)\u0026#34; cylinder = \u0026#34;on_boundary \u0026amp;\u0026amp; x[0]\u0026gt;0.1 \u0026amp;\u0026amp; x[0]\u0026lt;0.3 \u0026amp;\u0026amp; x[1]\u0026gt;0.1 \u0026amp;\u0026amp; x[1]\u0026lt;0.3\u0026#34; # 入口边界的速度 inflow_profile = (\u0026#34;4.0*1.5*x[1]*(0.41 - x[1]) / pow(0.41, 2)\u0026#34;, \u0026#34;0\u0026#34;) # 速度场边界条件 bcu_inflow = DirichletBC(V, Expression(inflow_profile, degree=2), inflow) bcu_walls = DirichletBC(V, Constant((0, 0)), walls) bcu_cylinder = DirichletBC(V, Constant((0, 0)), cylinder) bcu = [bcu_inflow,bcu_walls,bcu_cylinder] # 压力场边界条件 bcp_outflow = DirichletBC(Q, Constant(0), outflow) bcp = [bcp_outflow] # 下一时刻（待求）速度场u, 求解后保存在u_ u = TrialFunction(V) u_ = FeFunction(V) # 下一时刻（待求）压力场p, 求解后保存在p_ p = TrialFunction(Q) p_ = FeFunction(Q) # 速度场测试函数 和 压力场测试函数 v = TestFunction(V) q = TestFunction(Q) # 当前时刻（已知）速度场u 和 压力场p u_n = FeFunction(V) p_n = FeFunction(Q) # (u^* + u^n)/2 # 注意：其中包含待求函数 u (即，u^*) # 所以，包含U的变分方程F的a(u,v)必须用 lhs(F)求出 # 对应的L(v)则须用 rhs(F)求出 U = 0.5*(u_n + u) # 法线 n = FacetNormal(mesh) # 力场 f = Constant((0, 0)) # 在缩并的掩护下，可看作是对称梯度 function ϵ(u) return sym(nabla_grad(u)) end # 应力张量 function σ(u, p) return 2*μ*ϵ(u) - p*Identity(len(u)) end # 第1步的变分方程: (u^n,p^n) -\u0026gt; u^*  # 待求的u^*采用u， 结果计划保存在u_ F1 = ρ*dot((u - u_n) / Δt, v)*dx + ρ*dot(dot(u_n, nabla_grad(u_n)), v)*dx + inner(σ(U, p_n), ϵ(v))*dx + dot(p_n*n, v)*ds - dot(2*μ*nabla_grad(U)*n, v)*ds - ρ*dot(f, v)*dx a1 = lhs(F1) L1 = rhs(F1) # 第2步的变分方程: (u^*,p^n) -\u0026gt; p^{n+1}  # u^* 采用第1步的结果 u_ # 待求的p^{n+1}采用p， 结果计划保存在p_ a2 = dot(nabla_grad(p), nabla_grad(q))*dx L2 = dot(nabla_grad(p_n), nabla_grad(q))*dx - (ρ/Δt)*div(u_)*q*dx # 第3步的变分方程: (u^*,p^n, p^{n+1}) -\u0026gt; u^{n+1}  # (u^*, p^{n+1}) 分别采用第1、2步的结果 (u_,p_) # 待求的u^{n+1}采用u， 结果计划保存在u_ a3 = dot(u, v)*dx L3 = dot(u_, v)*dx - (Δt/ρ)*dot(nabla_grad(p_ - p_n), v)*dx # 三个变分方程对应的矩阵 A1 = assemble(a1) A2 = assemble(a2) A3 = assemble(a3) # 将边界条件附加到矩阵上 [bc.apply(A1) for bc in bcu] [bc.apply(A2) for bc in bcp] # 创建XDMF文件（可视化） xdmffile_u = XDMFFile(\u0026#34;navier_stokes_cylinder/velocity.xdmf\u0026#34;) xdmffile_p = XDMFFile(\u0026#34;navier_stokes_cylinder/pressure.xdmf\u0026#34;) # 创建时间序列 timeseries_u = TimeSeries(\u0026#34;navier_stokes_cylinder/velocity_series\u0026#34;) timeseries_p = TimeSeries(\u0026#34;navier_stokes_cylinder/pressure_series\u0026#34;) # 保存网格 File(\u0026#34;navier_stokes_cylinder/cylinder.xml.gz\u0026#34;) \u0026lt;\u0026lt; mesh global t = 0 for i in 1:num_steps # 当前时间 global t += Δt # 第一步 # lvsolve(a1,L1,u_,bcu) # 这个方法求解很慢 # 下面的方法更块的原因是，在循环前已经生成了变分方程对应的矩阵 b1 = assemble(L1) [bc.apply(b1) for bc in bcu] solve(A1, u_.vector(), b1, \u0026#34;bicgstab\u0026#34;, \u0026#34;hypre_amg\u0026#34;) # 第二步 b2 = assemble(L2) [bc.apply(b2) for bc in bcp] solve(A2, p_.vector(), b2, \u0026#34;bicgstab\u0026#34;, \u0026#34;hypre_amg\u0026#34;) # 第三步 b3 = assemble(L3) solve(A3, u_.vector(), b3, \u0026#34;cg\u0026#34;, \u0026#34;sor\u0026#34;) # 更新数据 u_n.assign(u_) p_n.assign(p_) if (i-1)%25 == 0 || i == num_steps xdmffile_u.write(u_, t) xdmffile_p.write(p_, t) timeseries_u.store(u_.vector(), t) timeseries_p.store(p_.vector(), t) println(\u0026#34;第\u0026#34;,i,\u0026#34;步\\tmax:\u0026#34;, max(array(u_)...)) # Plot solution plot(u_) plot(p_) end end # 确保文件不被损坏 xdmffile_u.close() xdmffile_p.close() 第0步	max:2.739542375402953 第25步	max:1.9848943489237132 第50步	max:1.917539036089884  \u0026hellip; \u0026hellip;\n第4950步	max:2.178513430654289 第4975步	max:2.1431069545490455 第4999步	max:2.1574859438440463  用ParaView渲染的结果如下（速度场 和 压力场）：\n"}),a.add({id:60,href:'/notes/tags/%E6%B5%81%E4%BD%93%E5%8A%9B%E5%AD%A6/',title:"流体力学",content:""}),a.add({id:61,href:'/notes/tags/%E7%89%9B%E9%A1%BF%E6%B5%81%E4%BD%93/',title:"牛顿流体",content:""}),a.add({id:62,href:'/notes/tags/jupyter/',title:"jupyter",content:""}),a.add({id:63,href:'/notes/tags/python/',title:"python",content:""}),a.add({id:64,href:'/notes/tags/scipy/',title:"scipy",content:""}),a.add({id:65,href:'/notes/tags/sympy/',title:"sympy",content:""}),a.add({id:66,href:'/notes/docs/julia/0095/',title:"科学计算环境搭建（Win10+WSL2+Ubuntu）",content:"概要   系统平台： Win10_64 + WSL2 + Ubuntu\n  目标：Python3.7+Julia1.5.3+JupyterLab+MatplotLib+SymPy+SciPy+FEniCS2019\n  以Julia作为我主要的使用语言，确保能调用Python的库\n  目前FEniCS不支持Windows，所以我选择 Win10+WSL+Ubuntu\n  目前FEniCS2019有问题（至少存在折磨我的问题），所以我选择FEniCS2018\n  FEniCS2019的问题已经解决，所以我还是选择FEniCS2019（详细见后）。\n  第0步：在Win10上，配置安装好 WSL + Ubuntu 不是本文主题，略。 后面实际以Ubuntu为例。\n第1步：安装Miniconda wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh # 一路yes source .bashrc # 激活 第2步：配置国内源 conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.bfsu.edu.cn/anaconda/cloud/conda-forge/ conda config --remove channels defaults conda config --set show_channel_urls yes conda clean -i # 立刻生效 pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple conda update conda # 升级conda conda clean -p # 清除没用 第3步：安装科学计算环境（Python） conda create --name fenics2019 python=3.7 jupyterlab matplotlib sympy scipy conda activate fenics2019 # 激活环境 # conda install fenics=2019 mshr=2019 有问题 # 建议安装下面这个组合 conda install fenics=2019.1.0=py37_9 conda install mshr=2019.1.0=py37hf9f41d3_3 conda clean -p # 清除没用 conda list # 核对已安装版本 python \u0026gt;\u0026gt;\u0026gt; import matplotlib, sympy, scipy, fenics, mshr # 核对正常加载否 第4步：安装Julia wget https://mirrors.tuna.tsinghua.edu.cn/julia-releases/bin/linux/x64/1.5/julia-1.5.3-linux-x86_64.tar.gz tar -x -f julia-1.5.3-linux-x86_64.tar.gz 第5步：配置整合 # 设定工作目录 jupyter notebook --generate-config 务必仔细检查，根据您的实际情况修改：\n# 修改配置：vim ~/.jupyter/jupyter_notebook_config.py c.NotebookApp.notebook_dir = \u0026#39;/home/chaoskey/sci\u0026#39; c.NotebookApp.use_redirect_file = False 务必仔细检查，根据您的实际情况修改：\n# 在文件末尾添加：vim .bashrc export BROWSER=\u0026#39;/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe\u0026#39; export PATH=\u0026#34;/home/chaoskey/julia-1.5.3/bin:$PATH\u0026#34; export JULIA_PKG_SERVER=\u0026#34;https://mirrors.bfsu.edu.cn/julia\u0026#34; export CONDAENV=fenics2019 conda activate $CONDAENV export JUPYTER=\u0026#34;/home/chaoskey/miniconda3/envs/$CONDAENV/bin/jupyter\u0026#34; export PYTHON=\u0026#34;/home/chaoskey/miniconda3/envs/$CONDAENV/bin/python\u0026#34; 第6步：安装科学计算环境（Julia） julia ] pkg\u0026gt; add PyCall PyPlot SymPy SciPy pkg\u0026gt; add https://github.com/chaoskey/FenicsPy.jl pkg\u0026gt; add GR Plots IJulia pkg\u0026gt; gc # 清除没用 pkg\u0026gt; st # 核对已安装版本 using PyCall, PyPlot, SymPy, SciPy, FenicsPy, GR, Plots, IJulia # 核对正常加载否  可能问题的解决（若没问题，则忽略之）  1） 每次切换Python环境后，为了确保jupyter和Julia能正常调用，务必执行：  务必仔细检查，根据您的实际情况修改：\n# vim .bashrc （手工修改） export CONDAENV=fenics2019 julia ] pkg\u0026gt; build PyCall pkg\u0026gt; precompile using PyCall, PyPlot, SymPy, SciPy, FenicsPy  2）Error: Tree Hash Mismatch!  根据错误提示，依次将 ~/.julia/artifacts/ 中对应的文件夹名作修改（可能要修改的会比较多），然后重新build\nDownloading artifact: Xorg_xcb_util ###################################################### 100.0% ┌ Error: Tree Hash Mismatch！ │ Expected git-tree-sha1: cacd8c147f866d6672e1aca9bb01fb919a81e96a （修改后的文件名）\n│ Calculated git-tree-sha1: 11f8623eb889dadcbbb39a3cd52e8d5e0340a0ca （修改前的文件名）\n注意：如果要修改的很多，我建议将错误信息复制到文本编辑器，通过正则替换，变成修改文件名的 shell脚本，最后执行，就可以批量修改文件名。\njulia ] pkg\u0026gt; build GR Plots IJulia pkg\u0026gt; precompile 常用命令（备忘） # 环境列表 conda info -e # 删除指定环境 conda remove -n tf --all # 创建环境  conda create --name tf # 克隆环境 conda create --clone tensorflow --name tf # 激活特定环境 conda activate tf # 退出当前环境  conda deactivate # 当前环境安装库包 conda list # 启动Jupyter nohup jupyter-lab \u0026gt; nb.log 2\u0026gt;\u0026amp;1 \u0026amp; # 查看日志 tail -f nb.log # 退出Jupyter jobs fg %1 ps -ef | grep lab kill -9 id # 清理Python无用库 conda clean -p # 清理Julia无用库 julia ] pkg\u0026gt; gc # 清理ubuntu无用包 sudo apt autoremove "}),a.add({id:67,href:'/notes/docs/julia/0094/',title:"有限元法解偏微分方程（FEniCS）",content:" 在Julia环境中，使用FenicsPy.jl调用FEniCS库，求解偏微分方程。\n 以泊松方程（第一边界条件）为例   \\[ -\\Delta u = f \\qquad \\boldsymbol{x} \\in \\Omega \\\\ u|_{\\partial \\Omega} =g \\]  范例而已， 本例提供的套路是通用的，大不了多看看文档。\n关键的地方，我特意列出相关链接。\n本文采用软件包： FEniCS。\n第1步：将问题转化成变分等式 \\[ \\begin{aligned}a(u,v)\u0026=L(v)+\\int_{\\partial \\Omega}{\\frac{\\partial g}{\\partial n}vds} \\qquad \\forall v \\in \\left\\{v\\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = g\\right\\} \\\\ a(u,v) \u0026\\overset{\\Delta}{=} \\int_\\Omega{\\nabla u \\nabla v d\\omega} \\\\ L(v) \u0026\\overset{\\Delta}{=} \\int_\\Omega{f v d\\omega} \\end{aligned} \\]  因为第一边界条件可通过变换（ \\(u \\to u + g\\)  ）化归成0边值问题，所以只需要考虑对应的弱形式(0边界条件)：\n\\[ a(u,v)=L(v) \\qquad \\forall v \\in \\left\\{v\\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = 0\\right\\} \\]  解出0边值问题后，不难通过简单变换得到非零边值问题的解。（这步，FEniCS会自动帮我们作了，不必操心）。\n注意：第二、三边界条件就没那么简单了，对应的面积分项是不可省略的。\n问题具体化为，比如：\n\\[ \\begin{aligned} f(x,y)\u0026=-6 \\\\ g(x,y)\u0026=1+x^2+2y^2 \\\\ \u0026 \\\\ \\Omega\u0026=\\left\\{(x,y)|x^2+y^2 \\le 1\\right\\} \\end{aligned} \\]  特别说明：后续Julia代码涉及的变量名，完全和上面的公式一致。\n第2步：对求解域进行刨分 这里用到了Circle, 更多请查阅文档：\nhttps://bitbucket.org/fenics-project/mshr/wiki/API\n也可以通过一组顶点组成的多边形来逼近更复杂的求解域，然后再对这个多边形区域进行刨分，更详细查阅文档：\nhttps://fenicsproject.org/docs/dolfin/1.4.0/python/demo/documented/mesh-generation/python/documentation.html\n这里的求解域很简单，代码如下：\n# https://github.com/chaoskey/FenicsPy.jl using FenicsPy # 求解域Ω设定 Ω = Circle(Point(0.0, 0.0),1) mesh = generate_mesh(Ω,16) plot(mesh) 2-element Array{PyCall.PyObject,1}: PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f8ddf8bd7d0\u0026gt; PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f8ddf07d210\u0026gt;  第3步：构造基于网格的函数空间 函数空间(FunctionSpace)，记作 \\(V\\)  ，其定义为：\n\\[ V = \\left\\{v\\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = g\\right\\} \\]  与此“孪生”对应：测试函数空间，记作 \\(\\hat{V}\\)  ：\n\\[ \\hat{V} = \\left\\{v\\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = 0\\right\\} \\]  这里我们的函数空间选择最简单的线性插值。\n  所谓试探函数(TrialFunction), 特指 \\(V\\)  中的函数。\n  所谓测试函数(testFunction), 则特指 \\(\\hat{V}\\)  中的函数。\n  https://fenicsproject.org/docs/dolfin/1.3.0/python/programmers-reference/functions/functionspace/FunctionSpace.html\n# 试探函数空间 # 1阶多项式插值（线性插值） V = FunctionSpace(mesh, \u0026#34;P\u0026#34;, 1) # 函数空间V上的试探函数u u = TrialFunction(V) # 函数空间V上的测试函数v v = TestFunction(V); 第4步：边界条件及参数设定 关于边界条件的设定参数，可参见：\nhttps://fenicsproject.org/docs/dolfin/1.4.0/python/programmers-reference/cpp/fem/DirichletBC.html\n# 源f(x,y) # f = Expression(\u0026#39;-6\u0026#39;, degree=0) f = Constant(-6.0) # 边界值g(x,y) g = Expression(\u0026#34;1 + x[0]*x[0] + 2*x[1]*x[1]\u0026#34;, degree=2) bc = DirichletBC(V, g, \u0026#34;on_boundary\u0026#34;); 第5步：变分方程的“直译” 几乎是前面数学公式的\u0026quot;直译\u0026quot;, 需要注意的是： dx 是预定义量，代表体元, 对应公式中的 \\(d\\omega\\)  。\n# 定义变分问题(dx是预定的) a = dot(grad(u), grad(v))*dx L = f*v*dx; 第6步：求解并绘图 关于求解器solve，参见：\nhttps://fenicsproject.org/docs/dolfin/1.3.0/python/programmers-reference/fem/solving/solve.html\n但是在 FEniCS.jl中，分成了3个求解器（都是对fenics.solve的封装）：\n~~https://github.com/SciML/FEniCS.jl/blob/master/src/jsolve.jl~~\n1. 线性求解器: solve\n2. 线性变分求解器： lvsolve (本例所采用)\n3. 非线性变分求解器： nlvsolve\n由于FEniCS.jl不太好用，我重写了FEniCS的Julia封装：FenicsPy.jl。\n至于FeFunction, 其实就是fenics.Function的封装（为了避免和类Core.Function和函数Base.Function的命名冲突）。\n# 求解 u = FeFunction(V) solve(a == L,u,bc) plot(u) plot(mesh) Solving linear variational problem. 2-element Array{PyCall.PyObject,1}: PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f8dde997910\u0026gt; PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f8dde997d10\u0026gt;  第7步：将数据导出，然后在ParaView中可视化 先用下面的代码导出数据为VTK文件。\n然后在ParaView中打开，可以用交互的方式可视化（下图仅截图示意而已）\nvtkfile = File(\u0026#34;poisson/solution.pvd\u0026#34;) vtkfile \u0026lt;\u0026lt; u; #exports the solution to a vtkfile 第8步：误差估计及其它 我们注意到，这个具体化的泊松问题的精确解，恰好就等于 \\(g(x,y)=1+x^2+2y^2\\)  ，这种巧合源自：\n\\[ \\Delta g(x,y) = 6 \\]  恰好把 \\(f(x,y)=-6\\)  提供的源抵消了，也就是说，如果作变换： \\(u = U + g(x,y)\\)  ，可得到无源零边界的泊松问题, 对应的解 \\(U=0\\)  ，所以精确解就是： \\(u=g(x,y)\\)  。\n于是可以计算标准差：\n\\[ E = \\sqrt{\\int_\\Omega{(g-u)^2}d\\omega} \\]  可用函数errornorm计算之：\nerrornorm(g, u, \u0026#34;L2\u0026#34;) *** Warning: Degree of exact solution may be inadequate for accurate result in errornorm. 0.00444692071683997  也可以直接计算标准差（奇怪结果不一样，以后再细究）：\n#vertex_values_g = array(project(g, V)) # or vertex_values_g = array(interpolate(g, V)) vertex_values_u = array(u) sqrt(sum((vertex_values_g - vertex_values_u).^2)) 0.0541946910486183  查看结果数据：\n 1）根据表达式生成在网格顶点上的值(投影)  # pg = project(g, V) # or pg = interpolate(g, V) \u0026quot;Coefficient(FunctionSpace(Mesh(VectorElement(FiniteElement('Lagrange', triangle, 1), dim=2), 3), FiniteElement('Lagrange', triangle, 1)), 71)\u0026quot;    查看网格顶点上的值,比如：    array(pg) array(u) 549-element Array{Float64,1}: 2.647985350348445 2.593690657292863 2.4339075463156465 2.712889645782536 2.3863642443300686 2.1981490620535595 2.1831070985479455 2.4655691189520748 2.7609431348948275 2.5253575052502386 2.302218396526692 2.4686047402353437 2.02311867450322 ⋮ 2.261621580085735 2.123167515460912 2.1160030006867037 2.2820357294253473 2.2320866025105017 2.176630600748635 2.0517861914831785 2.5936906572928624 2.5253575052502386 2.4686047402353433 2.4007647581013947 2.3454915028125263  初边值问题典型范例：热传导方程 \\[ \\left\\{\\begin{aligned}\\frac{\\partial u}{\\partial t} \u0026= \\nabla^2 u + f \u0026 \\mathrm{on} \\quad \\Omega \\times (0,T] \\\\ u \u0026= u_D \u0026 \\mathrm{on}\\quad \\partial \\Omega \\times (0,T] \\\\ u \u0026= u_0 \u0026 t=0 \\end{aligned} \\right . \\]  求解思路：对时间用差分法，对空间用有限元法。 进而有：\n\\[ \\left\\{\\begin{aligned}a(u^{n+1},v) \u0026= L_{n+1}(v) \\qquad n\\ge 1 , \\quad v \\in \\left\\{v \\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = 0\\right\\} \\\\ a(u,v) \u0026\\overset{\\Delta}{=} \\int_{\\Omega}{(u v + \\Delta t\\nabla u \\cdot \\nabla v)d\\omega} \\\\ L_{n+1}(v) \u0026\\overset{\\Delta}{=} \\int_{\\Omega}{(u^n + \\Delta t f^{n+1})v d\\omega} \\\\ u^0 \u0026= u_0 \\end{aligned} \\right . \\]  具体化为, 比如：\n\\[ \\begin{aligned} f(x,y,t)\u0026=0 \\\\ u_D(x,y,t)\u0026=0 \\\\ u_0(x,y)\u0026=e^{-a(x^2+y^2)},\\quad a=5 \\\\ \u0026 \\\\ \\Omega\u0026=[-2,2]\\times[-2,2], \\quad t \\in [0,2] \\end{aligned} \\]  T = 2.0 # 时长 num_steps = 50 # 步数 Δt = T / num_steps # 步长 # 在解域空间生成网格 nx = ny = 30 mesh = RectangleMesh(Point(-2, -2), Point(2, 2), nx, ny) # 函数空间（线性插值） V = FunctionSpace(mesh, \u0026#34;P\u0026#34;, 1) # 边界条件 bc = DirichletBC(V, Constant(0), \u0026#34;on_boundary\u0026#34;) # 初值 u_0 = Expression(\u0026#34;exp(-a*pow(x[0], 2) - a*pow(x[1], 2))\u0026#34;, degree=2, a=5) u_n = interpolate(u_0, V) # 定义变分问题 u = TrialFunction(V) v = TestFunction(V) f = Constant(0) a = u*v*dx + Δt*dot(grad(u), grad(v))*dx L = (u_n + Δt*f)*v*dx # 创建VTK文件，用于保存解 vtkfile = File(\u0026#34;heat_gaussian/solution.pvd\u0026#34;) # 从初值开始，逐步计算 u = FeFunction(V) t = 0 for n in 1:num_steps # 当前时间 global t += Δt # 求解 solve(a == L,u,bc) # 保存到文件，并叠加式绘图 vtkfile \u0026lt;\u0026lt; (u, t) plot(u) # 更新上一时刻的解 u_n.assign(u) end 在ParaView中打开生成的VTK文件，进行适当可视化交互操作，然后录制成gif文件如下：\n更复杂的边界条件（以泊松方程为例） 回到最开头的例子，但将泊松方程的边界条件修改为：\n\\[ \\left\\{\\begin{aligned}-\\Delta u \u0026= f \u0026 \\qquad \\boldsymbol{x} \\in \\Omega \\\\ u \u0026=u_L \u0026 \\mathrm{on} \\quad \\partial \\Omega_L \\\\ u \u0026=u_R \u0026 \\mathrm{on} \\quad \\partial \\Omega_R \\\\ \\frac{\\partial u}{\\partial n} \u0026=g \u0026 \\mathrm{on} \\quad \\partial\\Omega \\end{aligned}\\right. \\]  此时，对应的变分方程应改为：\n\\[ \\begin{aligned}a(u,v)\u0026=L(v) \\qquad \\forall v \\in \\left\\{v\\in H^1(\\Omega) \\ : \\ v|_{\\partial \\Omega} = 0\\right\\} \\\\ a(u,v) \u0026\\overset{\\Delta}{=} \\int_\\Omega{\\nabla u \\nabla v d\\omega} \\\\ L(v) \u0026\\overset{\\Delta}{=} \\int_\\Omega{f v d\\omega} +\\int_{\\partial \\Omega}{g v ds} \\end{aligned} \\]  问题具体化为(注意：提供的 \\(u_L\\)  和 \\(u_R\\)  必须保证其在边界上的连续性)，比如：\n\\[ \\begin{aligned} f(x,y)\u0026=-6 \\\\ u_L(x,y)\u0026=2+x+y^2 \\\\ u_R(x,y)\u0026=3+x^2 \\\\ g(x,y)\u0026=4y \\\\ \u0026 \\\\ \\Omega\u0026=\\left\\{(x,y)|x^2+y^2 \\le 1\\right\\} \\\\ \\partial\\Omega_L\u0026=\\left\\{(x,y)|x^2+y^2 = 1, x \\le 0 \\right\\} \\\\ \\partial\\Omega_R\u0026=\\left\\{(x,y)|x^2+y^2 = 1, x  0 \\right\\} \\end{aligned} \\]  在下面的Julia代码中， 前两个边界条件体现在DirichletBC的设置中，而第三个边界条件体现在变分方程中。\n注意：正如预定义量dx代表体元，ds也是预定义量，代表面元。\n# 求解域Ω设定 Ω = Circle(Point(0.0, 0.0),1) mesh = generate_mesh(Ω,16) # 函数空间(线性插值) V = FunctionSpace(mesh, \u0026#34;P\u0026#34;, 1) u = TrialFunction(V) v = TestFunction(V) # 源f(x,y) f = Constant(-6.0) # 左右边界条件 u_L = Expression(\u0026#34;2 + x[0] + pow(x[1], 2)\u0026#34;, degree=2) bc_L = DirichletBC(V, u_L, \u0026#34;on_boundary \u0026amp;\u0026amp; x[0]\u0026lt;=0\u0026#34;) u_R = Expression(\u0026#34;3 + pow(x[0], 2)\u0026#34;, degree=2) bc_R = DirichletBC(V, u_L, \u0026#34;on_boundary \u0026amp;\u0026amp; x[0]\u0026gt;0\u0026#34;) # 诺伊曼边界条件 g = Expression(\u0026#34;4*x[1]\u0026#34;, degree=1) # 定义变分问题(dx 和 ds 都是预定义的) a = dot(grad(u), grad(v))*dx L = f*v*dx + g*v*ds # 求解 u = FeFunction(V) solve(a == L,u,[bc_L,bc_R]) vtkfile = File(\u0026#34;poisson2/solution.pvd\u0026#34;) vtkfile \u0026lt;\u0026lt; u; #exports the solution to a vtkfile plot(u) plot(mesh) Solving linear variational problem. 2-element Array{PyCall.PyObject,1}: PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f4af82ef6d0\u0026gt; PyObject \u0026lt;matplotlib.lines.Line2D object at 0x7f4af82ef8d0\u0026gt;  在ParaView中打开生成的VTK文件，进行适当可视化交互操作，截图如下：\n后记 本文着重有限元法的“套路”， 更多例子可参考：\nhttps://fenicsproject.org/pub/tutorial/html/ftut1.html\n至于，ParaView的用法，参考：\nhttps://www.paraview.org/Wiki/The_ParaView_Tutorial\n"}),a.add({id:68,href:'/notes/tags/Delaunay/',title:"Delaunay",content:""}),a.add({id:69,href:'/notes/tags/%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/',title:"三角剖分",content:""}),a.add({id:70,href:'/notes/docs/julia/0093/',title:"有限元之Delaunay三角剖分",content:"上一篇笔记，讨论了一个单独的三角单元。 本篇讨论，如何将任意给定平面区域刨分成三角单元序列。\n本文用到了 python库scipy.spatial.Delaunay\n参考文献： https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.Delaunay.html\n# 奇怪：这个库必须放在最前面才能一次加载成功 using Plots gr() Plots.GRBackend()  1) 随机生成玩具点集 using LinearAlgebra using Random # 随机生成平面点序(要求任意两点的距离不得太小) n = 10 dmin = 0.1 X = zeros(n,2) X[1,:] = [rand(),rand()] i=2 while i \u0026lt;= n x = [rand(),rand()] if min([norm(X[j,:]-x) for j in 1:i-1]...) \u0026gt;= dmin X[i,:] = x i += 1 end end 2) 生成Delaunay三角刨分 using SciPy: spatial tri = spatial.Delaunay(X) plot() #plot(X[:,1], X[:,2], seriestype = :scatter, label=\u0026#34;\u0026#34;) for i in 1:size(X)[1] plot!(; annotations=[ (X[i,1]+0.01,X[i,2]+0.01,text(i,10)) ] ); end sp = tri.simplices .+ 1 n, = size(sp) for i in 1:n idx = sp[i,:] pts = X[idx,:] plot!(pts[:,1], pts[:,2], color=\u0026#34;black\u0026#34;,label=\u0026#34;\u0026#34;) plot!(pts[[1,3],1], pts[[1,3],2], color=\u0026#34;black\u0026#34;,label=\u0026#34;\u0026#34;) end plot!() 通过下面的代码，可以准确理解simplices（三角形序列）和neighbors（邻居序列）这两个变量的含义。\nsimplices每一行代表：三个顶点索引（0起始索引） neighbors每一行代表：三个顶点对面的三角形索引（0起始索引）\n【注意： Julia数组是1起始索引，为了避免错误不妨先作转换】\n# 转换成1起始索引，确保和Julia习惯一致 sp = tri.simplices .+ 1 # 注意，原本-1代表没有邻居，转换后0代表没有邻居 nb = tri.neighbors .+ 1 println(\u0026#34;【和前图图对照即可明白】\\r\\n\u0026#34;) for j in eachindex(sp[:,1]) println(\u0026#34;第\u0026#34;,j,\u0026#34;个三角形：\u0026#34;,sp[j,:]) for i in 1:3 if nb[j,i] == 0 println(\u0026#34;\\t此三角形的顶点\u0026#34;,sp[j,i],\u0026#34;对面没有三角形邻居\u0026#34;) else println(\u0026#34;\\t此三角形的顶点\u0026#34;,sp[j,i],\u0026#34;对面的邻居第\u0026#34;,nb[j,i],\u0026#34;个三角形：\u0026#34;,sp[nb[j,i],:]) end end end 【和前图图对照即可明白】 第1个三角形：[4, 10, 7] 此三角形的顶点4对面没有三角形邻居 此三角形的顶点10对面的邻居第5个三角形：[6, 4, 7] 此三角形的顶点7对面的邻居第11个三角形：[4, 8, 10] 第2个三角形：[6, 2, 1] 此三角形的顶点6对面没有三角形邻居 此三角形的顶点2对面的邻居第3个三角形：[4, 6, 1] 此三角形的顶点1对面的邻居第4个三角形：[2, 6, 7] 第3个三角形：[4, 6, 1] 此三角形的顶点4对面的邻居第2个三角形：[6, 2, 1] 此三角形的顶点6对面的邻居第6个三角形：[3, 4, 1] 此三角形的顶点1对面的邻居第5个三角形：[6, 4, 7] 第4个三角形：[2, 6, 7] 此三角形的顶点2对面的邻居第5个三角形：[6, 4, 7] 此三角形的顶点6对面没有三角形邻居 此三角形的顶点7对面的邻居第2个三角形：[6, 2, 1] 第5个三角形：[6, 4, 7] 此三角形的顶点6对面的邻居第1个三角形：[4, 10, 7] 此三角形的顶点4对面的邻居第4个三角形：[2, 6, 7] 此三角形的顶点7对面的邻居第3个三角形：[4, 6, 1] 第6个三角形：[3, 4, 1] 此三角形的顶点3对面的邻居第3个三角形：[4, 6, 1] 此三角形的顶点4对面的邻居第7个三角形：[9, 3, 1] 此三角形的顶点1对面的邻居第12个三角形：[3, 8, 4] 第7个三角形：[9, 3, 1] 此三角形的顶点9对面的邻居第6个三角形：[3, 4, 1] 此三角形的顶点3对面没有三角形邻居 此三角形的顶点1对面的邻居第8个三角形：[5, 3, 9] 第8个三角形：[5, 3, 9] 此三角形的顶点5对面的邻居第7个三角形：[9, 3, 1] 此三角形的顶点3对面没有三角形邻居 此三角形的顶点9对面的邻居第10个三角形：[5, 8, 3] 第9个三角形：[8, 5, 10] 此三角形的顶点8对面没有三角形邻居 此三角形的顶点5对面的邻居第11个三角形：[4, 8, 10] 此三角形的顶点10对面的邻居第10个三角形：[5, 8, 3] 第10个三角形：[5, 8, 3] 此三角形的顶点5对面的邻居第12个三角形：[3, 8, 4] 此三角形的顶点8对面的邻居第8个三角形：[5, 3, 9] 此三角形的顶点3对面的邻居第9个三角形：[8, 5, 10] 第11个三角形：[4, 8, 10] 此三角形的顶点4对面的邻居第9个三角形：[8, 5, 10] 此三角形的顶点8对面的邻居第1个三角形：[4, 10, 7] 此三角形的顶点10对面的邻居第12个三角形：[3, 8, 4] 第12个三角形：[3, 8, 4] 此三角形的顶点3对面的邻居第11个三角形：[4, 8, 10] 此三角形的顶点8对面的邻居第6个三角形：[3, 4, 1] 此三角形的顶点4对面的邻居第10个三角形：[5, 8, 3]  3）面积坐标（重心坐标）和普通坐标 在三角形情形中，重心坐标也叫面积坐标。\n1）根据普通坐标计算重心坐标 原则上，我们可根据下面的公式（参见：笔记   \\(\\color{blue}{《有限元之平面三角单元》}\\)  ）算出重心坐标。\n\\[ \\boxed{\\color{red}{\\left\\{\\begin{aligned}l_1\u0026=\\frac{1}{2S}\\left[(x_2 y_3-x_3 y_2)+(y_2-y_3)x+(x_3-x_2)y\\right]\\\\ l_2\u0026=\\frac{1}{2S}\\left[(x_3 y_1-x_1 y_3)+(y_3-y_1)x+(x_1-x_3)y\\right]\\\\ l_3\u0026=\\frac{1}{2S}\\left[(x_1 y_2-x_2 y_1)+(y_1-y_2)x+(x_2-x_1)y\\right]\\end{aligned} \\right.}} \\\\ 2S=\\begin{vmatrix}1 \u0026 x_1 \u0026 y_1 \\\\ 1 \u0026 x_2 \u0026 y_2 \\\\ 1 \u0026 x_3 \u0026 y_3 \\end{vmatrix} \\\\ \\quad \\\\ l_1+l_2+l_3=1 \\]  但scipy.spatial.Delaunay提供了相关的数据支持，我们可更方便计算（具体说明见代码注释）：\n# 在三角形情形中，重心坐标也叫面积坐标 # 函数说明，transform(nsimplex, ndim+1, ndim) # 定义： Tc = x - r # # 第i个三角形的inv(T)：transform(i, 1:ndim, 1:ndim) # 第i个三角形的r： transform(i, ndim+1, 1:ndim) # # 据此, 给定x可算出对应的重心坐标c  # 注意：c是头两个重心坐标，第3个可用l3=1-l1-l2算出 # c = invT (x-r) # 算出X所有点，相对第1个三角形的重心坐标 invT = tri.transform[1,1:2,1:2] r = tri.transform[1,3:3,1:2] # C的第i行，对应X第i行相对第1个三角形的重心坐标 C = (invT * (X .- r)\u0026#39;) C = vcat(C,1 .- sum(C,dims=1))\u0026#39; 10×3 Adjoint{Float64,Array{Float64,2}}: 3.50116 -0.986905 -1.51426 2.55659 -1.8306 0.274005 1.42283 0.235182 -0.658013 1.0 -1.4325e-17 0.0 0.979481 0.704615 -0.684097 1.01646 -0.297105 0.280642 0.0 0.0 1.0 0.716278 0.575829 -0.292108 2.0356 0.0987344 -1.13434 -4.01303e-17 1.0 0.0  2）根据重心坐标计算普通坐标 直接用下面这个公式可直接算出：\n\\[ \\color{red}{\\boxed{\\left\\{\\begin{aligned}x\u0026=l_1 x_1 + l_2 x_2 + l_3 x_3 \\\\ y\u0026=l_1 y_1 + l_2 y_2 + l_3 y_3 \\end{aligned} \\right.}} \\]  # 根据这个公式容易从相对第1个三角元的C算出（复原出）X XX = C * X[sp[1,:],:] 10×2 Array{Float64,2}: 0.979552 0.281205 0.227496 0.0412066 0.717759 0.712636 0.445581 0.649614 0.756364 0.869728 0.3176 0.556612 0.0535513 0.673927 0.594907 0.835987 0.896243 0.655209 0.506035 0.985608  # 验证是否正确复原 XX - X |\u0026gt; (expr-\u0026gt;all(e-\u0026gt;(e\u0026lt;0.000001),expr)) # 全零判断 true "}),a.add({id:71,href:'/notes/docs/julia/0092/',title:"有限元之平面三角单元",content:"本文是有限元法基础之一：三角单元。\n用   \\(\\color{red}{红色}\\)  标注的公式，都给了完整的符号推导（基于Julia）。\n参考文献： 微分方程数值解法（第4版）-李荣华＆刘播-高等教育出版社-2009\n三角单元内点的面积坐标 三角形元 \\(\\Delta(i,j,k)\\)  内任意一点p，可用 \\((x,y)\\)  表示。也可用“归一化面积”，即所谓面积坐标 \\((l_i,l_j,l_k)\\)  表示。 \\(l_i\\)  就是 \\(\\Delta(j,k,p)\\)  对应的归一化面积， \\(l_j,l_k\\)  类似。\n给定 \\((x,y)\\)  ，可求出“面积坐标” \\((l_1,l_2,l_2)\\)  ：\n\\[ \\boxed{\\color{red}{\\left\\{\\begin{aligned}l_1\u0026=\\frac{1}{2S}\\left[(x_2 y_3-x_3 y_2)+(y_2-y_3)x+(x_3-x_2)y\\right]\\\\ l_2\u0026=\\frac{1}{2S}\\left[(x_3 y_1-x_1 y_3)+(y_3-y_1)x+(x_1-x_3)y\\right]\\\\ l_3\u0026=\\frac{1}{2S}\\left[(x_1 y_2-x_2 y_1)+(y_1-y_2)x+(x_2-x_1)y\\right]\\end{aligned} \\right.}} \\\\ 2S=\\begin{vmatrix}1 \u0026 x_1 \u0026 y_1 \\\\ 1 \u0026 x_2 \u0026 y_2 \\\\ 1 \u0026 x_3 \u0026 y_3 \\end{vmatrix} \\\\ \\quad \\\\ l_1+l_2+l_3=1 \\]  这个关系可用下面的Julia代码算出（保存在变量LL中）：\nusing SymPy # 解决Colab不显示输出数学公式的问题 using Markdown: MD, LaTeX function latex(expr) expr |\u0026gt; sympy.latex |\u0026gt; LaTeX end; @vars x y real=true # 三个顶点坐标（逆时针排序） X = [symbols(\u0026#34;x$i\u0026#34;, real=true) for i in 1:3] Y = [symbols(\u0026#34;y$i\u0026#34;, real=true) for i in 1:3] # 面积坐标 L=[symbols(\u0026#34;l$i\u0026#34;, positive=true) for i in 1:3] A = sympy.ones(3,3) A[:,2]=X A[:,3]=Y # 总面积 S = sympy.det(A)/2 # 三个子面积并作归一化 LL = [S(X[i]=\u0026gt;x,Y[i]=\u0026gt;y) for i in 1:3]/S .|\u0026gt; simplify LL = LL .|\u0026gt; t-\u0026gt;collect(t,[x,y]) # 显示 [L[i]⩵LL[i] for i in 1:3] .|\u0026gt; latex |\u0026gt; MD  \\[ l_{1} = \\frac{x \\left(y_{2} - y_{3}\\right) + x_{2} y_{3} - x_{3} y_{2} + y \\left(- x_{2} + x_{3}\\right)}{x_{1} y_{2} - x_{1} y_{3} - x_{2} y_{1} + x_{2} y_{3} + x_{3} y_{1} - x_{3} y_{2}} \\]  \\[ l_{2} = \\frac{x \\left(- y_{1} + y_{3}\\right) - x_{1} y_{3} + x_{3} y_{1} + y \\left(x_{1} - x_{3}\\right)}{x_{1} y_{2} - x_{1} y_{3} - x_{2} y_{1} + x_{2} y_{3} + x_{3} y_{1} - x_{3} y_{2}} \\]  \\[ l_{3} = \\frac{x \\left(y_{1} - y_{2}\\right) + x_{1} y_{2} - x_{2} y_{1} + y \\left(- x_{1} + x_{2}\\right)}{x_{1} y_{2} - x_{1} y_{3} - x_{2} y_{1} + x_{2} y_{3} + x_{3} y_{1} - x_{3} y_{2}} \\]  # 验证归一化条件 sum(LL) .|\u0026gt; simplify  1  作为逆变换，给定“面积坐标” \\((l_1,l_2,l_3)\\)  ，可求出普通 \\((x,y)\\)  ：\n\\[ \\color{red}{\\boxed{\\left\\{\\begin{aligned}x\u0026=l_1 x_1 + l_2 x_2 + l_3 x_3 \\\\ y\u0026=l_1 y_1 + l_2 y_2 + l_3 y_3 \\end{aligned} \\right.}} \\]  推导如下（用到了归一化条件，保存在变量XX和YY中）：\n# 反过来，可用面积坐标表示(x,y) eqs = [LL[i]⩵L[i] for i in 1:2] sol = solve(eqs,[x,y]) (XX,YY) = [x,y] .|\u0026gt; (t-\u0026gt;t(sol)) .|\u0026gt; (t-\u0026gt;collect(t, [X[3],Y[3]])) .|\u0026gt; (t-\u0026gt;t(L[1]+L[2]=\u0026gt;1-L[3])) # 显示 [x⩵XX,y⩵YY] .|\u0026gt; latex |\u0026gt; MD  \\[ x = l_{1} x_{1} + l_{2} x_{2} + l_{3} x_{3} \\]  \\[ y = l_{1} y_{1} + l_{2} y_{2} + l_{3} y_{3} \\]  在面积坐标的表示下，三个顶点坐标分别为(每行代表一个顶点)：\n[LL[j](x=\u0026gt;X[i],y=\u0026gt;Y[i]) for i in 1:3, j in 1:3] .|\u0026gt; simplify |\u0026gt; latex |\u0026gt; MD  \\[ \\left[\\begin{matrix}1 \u0026 0 \u0026 0\\\\0 \u0026 1 \u0026 0\\\\0 \u0026 0 \u0026 1\\end{matrix}\\right] \\]  三角元上的多项式插值 \\[ p_m(x,y)=\\sum^m_{i+j=0}{c_{ij}x^iy^j} \\]  注意，这是一个非齐次多项式。 改用面积坐标表示后，原则上是关于 \\(l_1,l_2,l_3\\)  的非齐次多项式。\n但由于 \\(1=l_1+l_2+l_3\\)  ，我们可以在任何位置反复插入 \\((l_1+l_2+l_3)\\)  ，进而可将低次项提升到最高次项（即 \\(m\\)  次）。\n所以总是可改写成关于 \\(l_1,l_2,l_3\\)  的齐次多项式：\n\\[ \\boxed{p_m(l_1,l_2,l_3)=\\sum_{i+j+k=m}{c_{ijk}l_1^i l_2^j l_3^k}} \\]  这个多项式和原始多项式都是含有 \\(\\frac{1}{2}(m+1)(m+2)\\)  个待定系数\n一次多项式插值 \\[ p_1(l_1,l_2,l_3)=c_1 l_1 + c_2 l_2 + c_3 l_3 \\]  三个待定系数，需要三个节点值，恰好可用上三角形有三个点的值 \\(u_1,u_2,u_3\\)  。\n据此可解出这6个待定系数,进而可写出用面积坐标表示的一次多项式插值：：\n\\[ \\color{red}{\\boxed{p_1(l_1,l_2,l_3)=l_1 u_1 + l_2 u_2 + l_3 u_3}} \\]  推导如下（保存在变量pl中，其实这个结果一望而知）：\n# 3个节点值 U = [symbols(\u0026#34;u$i\u0026#34;, real=true) for i in 1:3] # 3个待定系数 C = [symbols(\u0026#34;c$i\u0026#34;, real=true) for i in 1:3] # 3个顶点面积坐标 M= [LL[j](x=\u0026gt;X[i],y=\u0026gt;Y[i]) for i in 1:3, j in 1:3] .|\u0026gt; simplify # 一次多项式插值（有待定系数） p(r,s,t)=C[1]*r + C[2]*s + C[3]*t # 3个节点方程 eqs = [ p(M[i,1],M[i,2],M[i,3])⩵U[i] for i in 1:3] # 求解这个线性方程组 solC = solve(eqs,C) pl = p(L[1],L[2],L[3])(solC) # 显示 [symbols(\u0026#34;p1\u0026#34;)⩵pl] .|\u0026gt; latex |\u0026gt; MD  \\[ p_{1} = l_{1} u_{1} + l_{2} u_{2} + l_{3} u_{3} \\]  二次多项式插值 \\[ p_2(l_1,l_2,l_3)=c_1 l_1^2 + c_2 l_2^2 + c_3 l_3^2 + c_4 l_1 l_2 + c_5 l_2 l_3 + c_6 l_3 l_1 \\]  这有6个待定系数，除了3个顶点节点外，还需要3个边的中点作为节点。\n据此可解出这6个待定系数,进而可写出用面积坐标表示的二次多项式插值：\n\\[ \\boxed{\\color{red}{p_2(l_1,l_2,l_3)=\\sum^3_{i=1}\\left[l_i(2l_i-1)u_i+4l_jl_k u_{3+i}\\right]}} \\\\ l_{3+i}=l_i,\\qquad j=i+1,k=i+2 \\]  推导如下（用到了归一化条件，保存在变量pl2中）：\n# 六个节点值 U = [symbols(\u0026#34;u$i\u0026#34;, real=true) for i in 1:6] # 六个待定系数 C = [symbols(\u0026#34;c$i\u0026#34;, real=true) for i in 1:6] # 3个顶点面积坐标 M= [LL[j](x=\u0026gt;X[i],y=\u0026gt;Y[i]) for i in 1:3, j in 1:3] .|\u0026gt; simplify # 3个边中点坐标 M = vcat(M,[(M[i%3+1,j]+M[(i+1)%3+1,j])/2 for i in 1:3, j in 1:3]) # 二次多项式插值（有待定系数） p2(r,s,t)=C[1]*r^2 + C[2]*s^2 + C[3]*t^2 + C[4]*r*s + C[5]*s*t + C[6]*t*r # 6个节点方程 eqs = [ p2(M[i,1],M[i,2],M[i,3])⩵U[i] for i in 1:6] # 求解这个线性方程组 solC = solve(eqs,C) # 化简（反复利用了归一化条件） pl2 = p2(L[1],L[2],L[3])(solC) pl2 = collect(pl2 |\u0026gt; expand, U) pl2 = sum(pl2.args .|\u0026gt; factor) pl2 = pl2(L[2]+L[3]=\u0026gt;1-L[1]) pl2 = pl2(L[1]+L[3]=\u0026gt;1-L[2]) pl2 = pl2(L[1]+L[2]=\u0026gt;1-L[3]) pl2 = collect(pl2 |\u0026gt; expand, U) |\u0026gt; simplify # 显示 [symbols(\u0026#34;p2\u0026#34;)⩵pl2] .|\u0026gt; latex |\u0026gt; MD  \\[ p_{2} = 4 l_{1} l_{2} u_{6} + 4 l_{1} l_{3} u_{5} + l_{1} u_{1} \\left(2 l_{1} - 1\\right) + 4 l_{2} l_{3} u_{4} + l_{2} u_{2} \\left(2 l_{2} - 1\\right) + l_{3} u_{3} \\left(2 l_{3} - 1\\right) \\]  三次多项式插值 \\[ p_3(l_1,l_2,l_3)=c_1 l_1^3 + c_2 l_2^3 + c_3 l_3^3 + c_4 l_1^2 l_2 + c_5 l_1^2 l_3 + c_6 l_2^2 l_1 + c_7 l_2^2 l_3 + c_8 l_3^2 l_1 + c_9 l_3^2 l_2 + c10 l_1 l_2 l_3 \\]  这有10个待定系数，1中心点，3个顶点，每个顶点还有2个偏导数，恰好可建10个方程。\n由于涉及偏导数，所以要先给出偏导数函数dpx(r,s,t)和dpy(r,s,t)（见后面的代码）。\n据此可解出这10个待定系数,进而可写出用面积坐标表示的三次多项式插值：\n\\[ \\boxed{\\color{red}{\\left\\{\\begin{aligned}p_3(l_1,l_2,l_3) \u0026= \\alpha_0 u_{10} + \\sum^3_{i=1}{\\left[\\alpha_i u_i+\\beta_i u_{3+i}+\\gamma_i u_{6+i}\\right]}\\\\ \\alpha_0 \u0026= 27 l_1 l_2 l_3 \\\\ \\alpha_i \u0026=l_i^3+3 l_i^2(l_j-l_k)-7 l_1,l_2,l_3 \\\\ \\beta_i \u0026= (x_j-x_i)(l_i^2 l_j-l_1 l_2 l_3)+(x_k-x_i)(l_i^2 l_k-l_1 l_2 l_3) \\\\ \\gamma_i \u0026= (y_j-y_i)(l_i^2 l_j-l_1 l_2 l_3)+(y_k-y_i)(l_i^2 l_k-l_1 l_2 l_3) \\end{aligned}\\right.}} \\\\ l_{3+i}=l_i,\\qquad j=i+1,k=i+2 \\]  其中， \\(u_{10}\\)  对应中点值， \\(u_1,u_2,u_3\\)  对应3个顶点值， \\(u_4,u_5,u_6\\)  对应3个顶点沿 \\(x\\)  偏导数值， \\(u_7,u_8,u_9\\)  对应3个顶点沿 \\(y\\)  偏导数值\n推导如下（保存在变量pl3中，对应的系数保持在数组αβγ中）：\n# 10个节点值 U = [symbols(\u0026#34;u$i\u0026#34;, real=true) for i in 1:10] # 10个待定系数 C = [symbols(\u0026#34;c$i\u0026#34;, real=true) for i in 1:10] # 三次多项式插值（有待定系数） p3(r,s,t)=C[1]*r^3+C[2]*s^3+C[3]*t^3+C[4]*r^2*s+C[5]*r^2*t+C[6]*s^2*r+C[7]*s^2*t+C[8]*t^2*r+C[9]*t^2*s+C[10]*r*s*t # 偏导数函数 ex = p3(L[1],L[2],L[3]) ex1 = sum(diff(ex,L[i])*diff(LL[i],x) for i in 1:3) |\u0026gt; simplify ex2 = sum(diff(ex,L[i])*diff(LL[i],y) for i in 1:3) |\u0026gt; simplify dpx(r,s,t)=ex1(L[1]=\u0026gt;r,L[2]=\u0026gt;s,L[3]=\u0026gt;t) dpy(r,s,t)=ex2(L[1]=\u0026gt;r,L[2]=\u0026gt;s,L[3]=\u0026gt;t); # 3个顶点面积坐标 M= [LL[j](x=\u0026gt;X[i],y=\u0026gt;Y[i]) for i in 1:3, j in 1:3] .|\u0026gt; simplify # 3个顶点方程 eqs = [ p3(M[i,1],M[i,2],M[i,3])⩵U[i] for i in 1:3] # 6个偏导数方程 eqs = vcat(eqs,[dpx(M[i,1],M[i,2],M[i,3])⩵U[3+i] for i in 1:3]) eqs = vcat(eqs,[dpy(M[i,1],M[i,2],M[i,3])⩵U[6+i] for i in 1:3]) # 1个中点方程 eqs = vcat(eqs,[p3(sum(M[:,1])/3,sum(M[:,2])/3,sum(M[:,3])/3)⩵U[10]]) # 解出待定系数 @time solC = solve(eqs,C) # 三次多项式插值（结果） pl3 = p3(L[1],L[2],L[3])(solC) pl3 = collect(pl3 |\u0026gt; expand, U) # 列出u1,...,u10的系数 # αβγ[10]对应α0 # αβγ[1:3]对应α1,α2,α3 # αβγ[4:6]对应β1,β2,β3 # αβγ[7:9]对应γ1,γ2,γ3 αβγ = [diff(pl3,U[i]) for i in 1:10] # 尽可能对每个系数合并同类项 ls = [L[1]^i*L[2]^j*L[3]^k for i in 0:3, j in 0:3, k in 0:3 if i+j+k==3] αβγ = αβγ .|\u0026gt; t-\u0026gt;collect(t, ls) # 显示 tmp = [symbols(\u0026#34;α0\u0026#34;)⩵αβγ[10]] tmp = vcat(tmp,[symbols(\u0026#34;α$i\u0026#34;)⩵αβγ[i] for i in 1:3]) tmp = vcat(tmp,[symbols(\u0026#34;β$i\u0026#34;)⩵αβγ[3+i] for i in 1:3]) tmp = vcat(tmp,[symbols(\u0026#34;γ$i\u0026#34;)⩵αβγ[6+i] for i in 1:3]) tmp .|\u0026gt; latex |\u0026gt; MD  15.244530 seconds (597 allocations: 18.047 KiB)  \\[ α0 = 27 l_{1} l_{2} l_{3} \\]  \\[ α1 = l_{1}^{3} + 3 l_{1}^{2} l_{2} + 3 l_{1}^{2} l_{3} - 7 l_{1} l_{2} l_{3} \\]  \\[ α2 = 3 l_{1} l_{2}^{2} - 7 l_{1} l_{2} l_{3} + l_{2}^{3} + 3 l_{2}^{2} l_{3} \\]  \\[ α3 = - 7 l_{1} l_{2} l_{3} + 3 l_{1} l_{3}^{2} + 3 l_{2} l_{3}^{2} + l_{3}^{3} \\]  \\[ β1 = l_{1}^{2} l_{2} \\left(- x_{1} + x_{2}\\right) + l_{1}^{2} l_{3} \\left(- x_{1} + x_{3}\\right) + l_{1} l_{2} l_{3} \\left(2 x_{1} - x_{2} - x_{3}\\right) \\]  \\[ β2 = l_{1} l_{2}^{2} \\left(x_{1} - x_{2}\\right) + l_{1} l_{2} l_{3} \\left(- x_{1} + 2 x_{2} - x_{3}\\right) + l_{2}^{2} l_{3} \\left(- x_{2} + x_{3}\\right) \\]  \\[ β3 = l_{1} l_{2} l_{3} \\left(- x_{1} - x_{2} + 2 x_{3}\\right) + l_{1} l_{3}^{2} \\left(x_{1} - x_{3}\\right) + l_{2} l_{3}^{2} \\left(x_{2} - x_{3}\\right) \\]  \\[ γ1 = l_{1}^{2} l_{2} \\left(- y_{1} + y_{2}\\right) + l_{1}^{2} l_{3} \\left(- y_{1} + y_{3}\\right) + l_{1} l_{2} l_{3} \\left(2 y_{1} - y_{2} - y_{3}\\right) \\]  \\[ γ2 = l_{1} l_{2}^{2} \\left(y_{1} - y_{2}\\right) + l_{1} l_{2} l_{3} \\left(- y_{1} + 2 y_{2} - y_{3}\\right) + l_{2}^{2} l_{3} \\left(- y_{2} + y_{3}\\right) \\]  \\[ γ3 = l_{1} l_{2} l_{3} \\left(- y_{1} - y_{2} + 2 y_{3}\\right) + l_{1} l_{3}^{2} \\left(y_{1} - y_{3}\\right) + l_{2} l_{3}^{2} \\left(y_{2} - y_{3}\\right) \\] "}),a.add({id:72,href:'/notes/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/',title:"微分方程",content:""}),a.add({id:73,href:'/notes/tags/%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97/',title:"数值计算",content:""}),a.add({id:74,href:'/notes/docs/julia/0091/',title:"有限元法解常微分方程边值问题",content:"有限元法可归结为如下几个步骤：\n 转换成变分问题（应该会用到边界条件）  2）对解域进行刨分（可以是不均匀）\n3）构造基函数（本篇采用基于线性插值的基函数）\n4）推导出有限元方程\n5）求解有限元方程\n6）收敛性和误差估计\n# 奇怪：这个库必须放在最前面才能一次加载成功 using Plots gr() # 解决Colab不显示输出数学公式的问题 using Markdown: MD, LaTeX function latex(expr) expr |\u0026gt; sympy.latex |\u0026gt; LaTeX end; 考虑两点边值问题：\n  \\[ \\begin{aligned} \u0026Lu=-\\frac{d}{dx}\\left(p\\frac{du}{dx}\\right)+qu=f ,\\qquad a 对应的变分方程(用到两个边界条件)：\n\\[ \\begin{aligned}\u0026a(u,v)=(f,v),\\qquad \\forall v \\\\ \u0026 a(u,v)=\\int^b_a{\\left(p\\frac{du}{dx}\\frac{dv}{dx}+quv\\right)dx}\\end{aligned} \\]  区间剖分（可以不均匀）：\n\\[ a = x_0 与此对应的近似解序列 \\(\\{u_i\\}\\)  （待求）为：\n\\[ u_0=0, u_1,u_2,\\dots,u_n \\]  通过这 \\(n+1\\)  个点的值可进行线性插值得到近似解 \\(u_h(x)\\)  ：\n\\[ \\begin{aligned}u_h(x)=\\frac{x_i-x}{h_i}u_{i-1}+\\frac{x-x_{i-1}}{h_i}u_i,\\qquad x_{i-1} 可引入线性无关的“山形函数”序列 \\(\\varphi_i(x)\\)  构成基底：\n\\[ \\boxed{\\xi = \\frac{x-x_{i-1}}{h_i}\\qquad x_{i-1} \\[ \\varphi_0(x)=\\left\\{\\begin{aligned}\u00261-\\xi, \u0026x_0 \\[ \\varphi_i(x)=\\left\\{\\begin{aligned}\u0026\\xi, \u0026x_{i-1} \\[ \\varphi_n(x)=\\left\\{\\begin{aligned}\u0026\\xi, \u0026x_{n-1} 不难验证，前面的线性插值函数 \\(u_h(x)\\)  ，可用这个序列 \\(\\varphi_i\\)  为基底展开(下面考虑了 \\(u_0=0\\)  )：\n\\[ u_h(x)=\\sum^n_{i=1}{u_i \\varphi_i(x)} \\]  由图可知（亦可简单验算）：\n\\[ \\varphi_i(x)\\varphi_j(x)=0, \\qquad |i-j|\\ge 2 \\\\ \\frac{d\\varphi_i}{dx}\\frac{d\\varphi_j}{dx}=0, \\qquad |i-j|\\ge 2 \\]  所以 \\(a(\\varphi_i,\\varphi_j)\\)  的非零值只可能有：\n\\[ \\begin{aligned}\u0026a(\\varphi_{1},\\varphi_1),a(\\varphi_{2},\\varphi_1) \\\\ \u0026a(\\varphi_{j-1},\\varphi_j),a(\\varphi_{j},\\varphi_j),a(\\varphi_{j+1},\\varphi_j),\\qquad j=2,\\dots,n-1\\\\ \u0026 a(\\varphi_{n-1},\\varphi_n),a(\\varphi_{n},\\varphi_{n}) \\end{aligned} \\]  可分别算出这三类非零值：\n\\[ a(\\varphi_{j-1},\\varphi_j)=\\int^1_0{\\left[-h_j^{-1}p(x_{j-1}+h_j\\xi)+h_j q(x_{j-1}+h_j\\xi)(1-\\xi)\\xi\\right]d\\xi} \\]  \\[ \\begin{aligned}a(\\varphi_j,\\varphi_j)\u0026=\\int^1_0{\\left[h_j^{-1}p(x_{j-1}+h_j\\xi)+h_j q(x_{j-1}+h_j\\xi)\\xi^2\\right]d\\xi} \\\\ \u0026 +\\int^1_0{\\left[h_{j+1}^{-1}p(x_{j}+h_{j+1}\\xi)+h_{j+1} q(x_{j} +h_{j+1}\\xi)(1-\\xi)^2\\right]d\\xi}\\end{aligned} \\]  \\[ a(\\varphi_{j+1},\\varphi_j)=\\int^1_0{\\left[-h_{j+1}^{-1}p(x_{j}+h_{j+1}\\xi)+h_{j+1} q(x_{j}+h_{j+1}\\xi)(1-\\xi)\\xi\\right]d\\xi} \\]  \\[ a(\\varphi_n,\\varphi_n)=\\int^1_0{\\left[h_n^{-1}p(x_{n-1}+h_n\\xi)+h_n q(x_{n-1}+h_n\\xi)\\xi^2\\right]d\\xi} \\]  using SciPy #  # “山形”基函数 # function φ(t,i,x,h,n) if i \u0026gt; 1 \u0026amp;\u0026amp; t\u0026gt;=x[i-1] \u0026amp;\u0026amp; t\u0026lt;=x[i] return (t-x[i-1])/h[i-1] elseif i \u0026lt; n+2 \u0026amp;\u0026amp; t\u0026gt;x[i] \u0026amp;\u0026amp; t\u0026lt;=x[i+1] return 1-(t-x[i])/h[i] else return 0 end end; #  # a(φ_i,φ_j) # # 假设已有p(t),q(t) # function aa(i,j,x,h,n) if abs(i-j) \u0026gt;= 2 return 0; end; if i==j-1 α(ξ)=-p(x[j-1]+h[j-1]*ξ)/h[j-1]+h[j-1]*q(x[j-1]+h[j-1]*ξ)*(1-ξ)*ξ; return SciPy.integrate.quad(α, 0, 1)[1]; end; if i==j \u0026amp;\u0026amp; j\u0026lt;n+1 β(ξ)=p(x[j-1]+h[j-1]*ξ)/h[j-1]+h[j-1]*q(x[j-1]+h[j-1]*ξ)*ξ^2+p(x[j]+h[j]*ξ)/h[j]+h[j]*q(x[j]+h[j]*ξ)*(1-ξ)^2; return SciPy.integrate.quad(β, 0, 1)[1]; end; if i==j \u0026amp;\u0026amp; j==n+1 βn(ξ)=p(x[j-1]+h[j-1]*ξ)/h[j-1]+h[j-1]*q(x[j-1]+h[j-1]*ξ)*ξ^2; return SciPy.integrate.quad(βn, 0, 1)[1]; end; if i==j+1 γ(ξ)=-p(x[j]+h[j]*ξ)/h[j]+h[j]*q(x[j]+h[j]*ξ)*(1-ξ)*ξ; return SciPy.integrate.quad(γ, 0, 1)[1]; end; end; 正式求解的julia代码：\nusing Random # 参数选定 a=0; b=1 f(t)=(pi^2/2)sin(pi*t/2); p(t) = 1; q(t) = pi^2/4; function NSolve(n) # 随机生成的不均匀的区间刨分 h = [0.5*rand()+0.5 for i in 1:n]; h = (b-a)*h/sum(h); x = zeros(n+1); x[1]=a; x[n+1]=b; x[2:n]=[sum(h[1:i]) for i in 1:(n-1)]; h[n]=x[n+1]-x[n]; # 待求近似解 u = zeros(n+1); # 计算a(φ_i,φ_j)矩阵 A = [aa(i,j,x,h,n) for j in 2:n+1, i in 2:n+1]; # 计算(f,φ_j)列向量 fφ = [SciPy.integrate.quad(t-\u0026gt;f(t)*φ(t,j,x,h,n), x[j-1], (j==n+1 ? b : x[j+1]) )[1] for j in 2:n+1]; # 解出插值端点值 u[2:n+1] = inv(A)*fφ; # 近似解序列 (x,u) end; 做为对比，也可解出精确解：\nusing SymPy @vars t y = SymFunction(\u0026#34;y\u0026#34;) diffeq = -diff(y(t),t,2)+(PI^2/4)y(t)⩵(PI^2/2)*sin(t*PI/2) # 通解 ex = dsolve(diffeq, y(t)) # 根据边界条件确定积分常数 ex1 = rhs(ex) ex2 = diff(ex1,t) eqs = [ex1(t=\u0026gt;0)⩵0,ex2(t=\u0026gt;1)⩵0] C = solve(eqs,[Sym(\u0026#34;C1\u0026#34;),Sym(\u0026#34;C2\u0026#34;)]) # 解析解 ex = ex(C) ex |\u0026gt; latex |\u0026gt; MD  \\[ y{\\left(t \\right)} = \\sin{\\left(\\frac{\\pi t}{2} \\right)} \\]  绘制近似解和精确解\n# 精确解 plot(rhs(ex),color=\u0026#34;black\u0026#34;,xlims=(-0.1, 1.1),label=\u0026#34;U\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) # 近似解 n=4,8 plot!(NSolve(4),color=\u0026#34;green\u0026#34;,label=\u0026#34;u4\u0026#34;) plot!(NSolve(8),color=\u0026#34;red\u0026#34;,label=\u0026#34;u8\u0026#34;)  《微分方程数值解法（第4版）-李荣华＆刘播-高等教育出版社-2009》\n"}),a.add({id:75,href:'/notes/tags/Galerkin/',title:"Galerkin",content:""}),a.add({id:76,href:'/notes/docs/julia/0090/',title:"Galerkin法解常微分方程边值问题",content:"# 奇怪：这个库必须放在最前面才能一次加载成功 using Plots gr() # 解决Colab不显示输出数学公式的问题 using Markdown: MD, LaTeX function latex(expr) expr |\u0026gt; sympy.latex |\u0026gt; LaTeX end; 选择三角基函数   \\[ \\begin{aligned} \u0026 u''+u=-x \\qquad 0 用微分算符表示之：\n\\[ \\begin{aligned} \u0026\\boxed{Lu=f} \\\\ \\\\ \u0026Lu=-\\frac{d^2 u}{dx^2}-u \\\\ \u0026f = x \\end{aligned} \\]  根据虚功原理，改写成变分等式：\n\\[ \\begin{aligned} \u0026\\boxed{a(u,v)=(f,v)} \\qquad \\forall v \\\\ \\\\ \u0026a(u,v)=\\int^1_0{\\left(\\frac{d u}{dx}\\frac{d v}{dx}-u v\\right)dx} \\\\ \u0026(f,v) = \\int^1_0{x vdx} \\end{aligned} \\]  选择一族基函数（比如选择三角函数）：\n\\[ \\varphi_i(x)=\\sin(i \\pi x) \\qquad i=1,\\dots,n \\]  于是可用 \\(u_n(x)\\)  来逼近 \\(u(x)\\)  :\n\\[ u_n(x)=\\sum^n_{i=1}{c_i \\varphi_i(x)} \\]   \\(v(x)\\)  不妨选择 \\(\\varphi_j(x)\\quad j=1,\\dots,n\\)  , 于是得到一个线性方程组：\n\\[ \\sum^n_{i=1}{a(\\varphi_i,\\varphi_j) c_j}=(f,\\varphi_j)\\qquad j=1,\\dots,n \\]  解出系数 \\(c_j\\)  即求解完毕。\n用Julia实现如下：\nusing SciPy using LinearAlgebra # a(φ_i,φ_j)的被积函数 F(x,i,j) = i*j*pi^2*cos(i*pi*x)*cos(j*pi*x)-sin(i*pi*x)*sin(j*pi*x) # (f,φ_j)的被积函数 f(x,j) = x*sin(j*pi*x) # 自变量序列 x = [(j-1)*0.01 for j in 1:101]; function NSolve(n) # a(φ_i,φ_j) 组成的矩阵 A = [SciPy.integrate.quad(x-\u0026gt;F(x,i,j), 0, 1)[1] for i in 1:n, j in 1:n]; # (f,φ_j)组成的数组 b = [SciPy.integrate.quad(x-\u0026gt;f(x,j), 0, 1)[1] for j in 1:n]; # 解出系数c_j c = inv(A)*b; # 返回近似解 [dot(c,[sin(i*pi*x[j]) for i in 1:n]) for j in 1:101] end; 依次求 \\(n=1,2,3,4\\)  下的近似解：\nplot(x,NSolve(1),color=\u0026#34;red\u0026#34;,label=\u0026#34;u1\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) plot!(x,NSolve(2),color=\u0026#34;green\u0026#34;,label=\u0026#34;u2\u0026#34;) plot!(x,NSolve(3),color=\u0026#34;blue\u0026#34;,label=\u0026#34;u3\u0026#34;) plot!(x,NSolve(4),color=\u0026#34;black\u0026#34;,label=\u0026#34;u4\u0026#34;) 此图表明，随着n的变大，曲线变换越小，解就应该越精确。\n作为对照，我们还可解出这个方程的解析解：\nusing SymPy @vars t y = SymFunction(\u0026#34;y\u0026#34;) diffeq = diff(y(t),t,2)+y(t)⩵-t # 通解 ex = dsolve(diffeq, y(t)) ex |\u0026gt; latex |\u0026gt; MD  \\[ y{\\left(t \\right)} = C_{1} \\sin{\\left(t \\right)} + C_{2} \\cos{\\left(t \\right)} - t \\]  # 根据边界条件确定积分常数 eqs = [ex(t=\u0026gt;0,y(0)=\u0026gt;0),ex(t=\u0026gt;1,y(1)=\u0026gt;0)] C = solve(eqs,[Sym(\u0026#34;C1\u0026#34;),Sym(\u0026#34;C2\u0026#34;)]) Dict{Any,Any} with 2 entries: C1 =\u0026gt; 1/sin(1) C2 =\u0026gt; 0  # 解析解 ex(C) |\u0026gt; latex |\u0026gt; MD  \\[ y{\\left(t \\right)} = - t + \\frac{\\sin{\\left(t \\right)}}{\\sin{\\left(1 \\right)}} \\]  plot(x,NSolve(4),color=\u0026#34;black\u0026#34;,label=\u0026#34;u4\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) plot!(rhs(ex)(C),xlims = (0, 1), ylims = (0, 0.08),color=\u0026#34;red\u0026#34;,label=\u0026#34;U\u0026#34;) 这个图表明 \\(n=4\\)  的近似解已经很接近解析解。\n当 \\(n=10\\)  时，近似解和解析解在图中无法区分:\nplot(x,NSolve(10),color=\u0026#34;black\u0026#34;,label=\u0026#34;u10\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) plot!(rhs(ex)(C),xlims = (0, 1), ylims = (0, 0.08),color=\u0026#34;red\u0026#34;,label=\u0026#34;U\u0026#34;) 选择多项式基函数 \\[ \\begin{aligned} \u0026 u''+u=x^2 \\qquad 0 先做变换 \\(u\\rightarrow u+x\\)  ，得到0边界条件，解完再修正即可：\n\\[ \\begin{aligned} \u0026 u''+u=x^2-x \\qquad 0 改写成变分等式：\n\\[ \\begin{aligned} \u0026\\boxed{a(u,v)=(f,v)} \\qquad \\forall v \\\\ \\\\ \u0026a(u,v)=\\int^1_0{\\left(\\frac{d u}{dx}\\frac{d v}{dx}-u v\\right)dx} \\\\ \u0026(f,v) = \\int^1_0{(x-x^2) vdx} \\end{aligned} \\]  选择一族基函数（比如选择多项式函数,还必须注意满足边界条件）：\n\\[ \\varphi_i(x)=x(1-x)x^{i-1} \\qquad i=1,\\dots,n \\]  求解和前面类似线性方程组即可。\n用Julia实现如下：\n# a(φ_i,φ_j)的被积函数 F(x,i,j) =(i-(i+1)*x)*(j-(j+1)*x)*x^(i+j-2)-x^2*(1-x)^2*x^(i+j-2) # (f,φ_j)的被积函数 f(x,j) = (x-x^2)*x*(1-x)*x^(j-1) function NSolve(n) # a(φ_i,φ_j) 组成的矩阵 A = [SciPy.integrate.quad(x-\u0026gt;F(x,i,j), 0, 1)[1] for i in 1:n, j in 1:n]; # (f,φ_j)组成的数组 b = [SciPy.integrate.quad(x-\u0026gt;f(x,j), 0, 1)[1] for j in 1:n]; # 解出系数c_j c = inv(A)*b; # 返回近似解(注意：u+x才是目标解) [dot(c,[x[j]*(1-x[j])*x[j]^(i-1) for i in 1:n]) for j in 1:101]+x end; 作为对比，同时解出精确解：\ndiffeq = diff(y(t),t,2)+y(t)⩵t^2 # 通解 ex = dsolve(diffeq, y(t)) # 根据边界条件确定积分常数 eqs = [ex(t=\u0026gt;0,y(0)=\u0026gt;0),ex(t=\u0026gt;1,y(1)=\u0026gt;1)] C = solve(eqs,[Sym(\u0026#34;C1\u0026#34;),Sym(\u0026#34;C2\u0026#34;)]) # 解析解 ex(C) |\u0026gt; latex |\u0026gt; MD  \\[ y{\\left(t \\right)} = t^{2} + \\frac{2 \\left(1 - \\cos{\\left(1 \\right)}\\right) \\sin{\\left(t \\right)}}{\\sin{\\left(1 \\right)}} + 2 \\cos{\\left(t \\right)} - 2 \\]  plot(rhs(ex)(C),lims=(-0.2,1.2),color=\u0026#34;red\u0026#34;,lw=2,label=\u0026#34;U\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) plot!(x,NSolve(10),color=\u0026#34;black\u0026#34;,lw=1,label=\u0026#34;u\u0026#34;) 谱方法 \\[ \\begin{aligned} \u0026 -u''+u=2x\\sin x-2\\cos x \\qquad 0 \\le x \\le 2\\pi \\\\ \u0026u(0)=u(2\\pi)=0 \\end{aligned} \\]  设：\n\\[ \\begin{aligned} \u0026 Lu=-u''+u\\\\ \u0026 f=2x\\sin x-2\\cos x \\end{aligned} \\]  f(x)=2*x*sin(x)-2*cos(x); # 输入可以是数值也可是符号 按前面类似得方法（有点小不同），可写出：\n\\[ \\begin{aligned} \u0026\\boxed{a(u,v)=(f,v)} \\qquad \\forall v \\\\ \\\\ \u0026a(u,v)=\\int^{2\\pi}_0{\\left(\\frac{d u}{dx}\\frac{d \\bar{v}}{dx}+u \\bar{v}\\right)dx} \\overset{\\Delta}{=}\\int^{2\\pi}_0{\\alpha dx}\\\\ \u0026(f,v) = \\int^{2\\pi}_0{f(x) \\bar{v}dx} \\end{aligned} \\]  @vars x α(u,v)=diff(u,x)*diff(conj(v),x)+u*conj(v); 选择一族基函数：\n\\[ \\varphi_k(x)=e^{i k x}-1 \\qquad k=\\pm 1,\\dots,\\pm n \\]  那么解可用下式逼近：\n\\[ u_n(x)=\\sum^n_{k=-n \\\\ k\\ne 0}{c_k \\varphi_k(x)}=\\sum^n_{k=-n \\\\ k\\ne 0}{c_k (e^{i k x}-1)}=\\boxed{\\sum^n_{k=-n}{c_k e^{i k x}}} \\\\ c_0=-\\sum^n_{k=-n \\\\ k\\ne 0}{c_k} \\]  这就是所谓“谱方法”的命名由来。\n进而：\n\\[ a(u_n,\\varphi_j)=\\sum^n_{k=-n}{c_k a(e^{ikx},e^{ijx})}-\\sum^n_{k=-n}{c_k a(e^{ikx},1)} \\]  求出 \\(a(e^{ikx},e^{ijx})\\)  分别在 \\(k=j,k\\ne j\\)  情况下的值：\n@vars x real=true k j integer=true # 当k=j时 SymPy.integrate(α(exp(IM*k*x),exp(IM*j*x))(k=\u0026gt;j) |\u0026gt; simplify, (x, 0, 2*PI)) |\u0026gt; latex |\u0026gt; MD  \\[ 2 \\pi \\left(j^{2} + 1\\right) \\]  # 当k!=j时 SymPy.integrate(α(exp(IM*k*x),exp(IM*j*x)) |\u0026gt; simplify, (x, 0, 2*PI)) |\u0026gt; latex |\u0026gt; MD  \\[ 0 \\]  这意味着：\n\\[ a(u_n,\\varphi_j)=c_j a(e^{ijx},e^{ijx})-c_0 a(1,1)=\\boxed{2\\pi(j^2+1)c_j-2\\pi c_0} \\]  此外还可计算出 \\((f,\\varphi_j)\\)  ：\nfφ = SymPy.integrate(f(x)*conj(exp(IM*j*x)-1), (x, 0, 2*PI)) .|\u0026gt; simplify |\u0026gt; latex |\u0026gt; MD  \\[ \\begin{cases} \\pi \\left(1 + 2 i \\pi\\right) \u0026 \\text{for}\\: j = -1 \\\\\\pi \\left(1 - 2 i \\pi\\right) \u0026 \\text{for}\\: j = 1 \\\\\\frac{4 \\pi j^{2}}{j^{2} - 1} \u0026 \\text{otherwise} \\end{cases} \\]  最后联立方程组\n\\[ \\begin{aligned} \u0026a(u_n,\\varphi_j)=(f,\\varphi_j) \\qquad j=\\pm 1,\\dots,\\pm n \\\\ \u0026\\sum^n_{k=-n}{c_k}=0 \\end{aligned} \\]  求出系数 \\(c_j\\)  ：\n# 自变量序列 x=2*pi*[(i-1)*0.01 for i in 1:101]; function NSolve(n) # 给矩阵分配空间 A = zeros(2*n+1,2*n+1); b = (1.0+0.0*im)*zeros(2*n+1); # (f,φ_j) b[1] = pi+2*im*pi^2; b[2] = pi-2*im*pi^2; for j in 2:n b[2*j-1] = 4*pi*j^2/(j^2-1); b[2*j] = b[2j-1]; end # a(u_n,φ_j) for j in 1:n A[2*j-1,2*j-1] = 2*pi*(j^2+1); A[2*j,2*j] = A[2*j-1,2*j-1]; end A[1:2*n,2*n+1] = -2*pi*ones(2*n); # c_k A[2*n+1,:] = ones(2*n+1); # 解出系数c_j c = inv(A)*b # 返回近似解 real([sum(c[2*k-1]*(exp(-im*k*x[i])-1)+c[2*k]*(exp(im*k*x[i])-1) for k in 1:n) for i in 1:101]) end; 作为对比，同时解出精确解：\n@vars t y = SymFunction(\u0026#34;y\u0026#34;) diffeq = -diff(y(t),t,2)+y(t)⩵2*t*sin(t)-2*cos(t) # 通解 ex = dsolve(diffeq, y(t)) # 根据边界条件确定积分常数 eqs = [ex(t=\u0026gt;0,y(0)=\u0026gt;0),ex(t=\u0026gt;2*PI,y(2*PI)=\u0026gt;0)] C = solve(eqs,[Sym(\u0026#34;C1\u0026#34;),Sym(\u0026#34;C2\u0026#34;)]) # 解析解 ex(C) |\u0026gt; latex |\u0026gt; MD  \\[ y{\\left(t \\right)} = t \\sin{\\left(t \\right)} \\]  先绘制精确解：\nplot(rhs(ex(C)),color=\u0026#34;black\u0026#34;,xlims=(-0.5, 6.5),label=\u0026#34;U\u0026#34;,xlabel=\u0026#34;x\u0026#34;,ylabel=\u0026#34;u(x)\u0026#34;) 叠加上近似解 \\(u_4(x)\\)  ：\nplot!(x,NSolve(4),color=\u0026#34;green\u0026#34;,label=\u0026#34;u4\u0026#34;) 叠加上近似解 \\(u_8(x)\\)  ：\nplot!(x,NSolve(8),color=\u0026#34;red\u0026#34;,label=\u0026#34;u8\u0026#34;)  《微分方程数值解法（第4版）-李荣华＆刘播-高等教育出版社-2009》\n"}),a.add({id:77,href:'/notes/tags/%E6%9C%89%E9%99%90%E5%B7%AE%E5%88%86/',title:"有限差分",content:""}),a.add({id:78,href:'/notes/docs/julia/0089/',title:"有限差分法求解一维热传导方程",content:"# 奇怪：这个库必须放在最前面才能一次加载成功 using Plots gr() Plots.GRBackend()  有限差分法求解一维热传导方程   \\[ \\frac{\\partial u}{\\partial t}=\\lambda \\frac{\\partial^2 u}{\\partial x^2} \\]  具体为(时长T，杆长L)：\n\\[ \\begin{aligned} \\frac{\\partial u(x,t)}{\\partial t}\u0026= \\lambda \\frac{\\partial ^2 u(x,t) }{\\partial x^2} \\qquad 0\\leq t\\leq T, 0\\leq x \\leq L \\\\ u(x,0)\u0026=4x(L-x)\\\\ u(0,t)\u0026=0\\\\ u(L,t)\u0026=0 \\end{aligned} \\]  选择合适的步长： \\(\\tau,h\\)  ，确保 \\(n=T/\\tau,m=L/h\\)  都是整数步。\n进而有如下递推关系(序号从0开始标注)：\n\\[ \\begin{aligned} u_{i,j+1}\u0026=\\frac{\\lambda\\tau}{h^2}u_{i+1,j}+(1-\\frac{2\\lambda\\tau}{h^2})u_{i,j}+\\frac{\\lambda\\tau}{h^2}u_{i-1,j} \\\\ \u0026 \\qquad \\qquad \\qquad i=1, 2, \\dots,(m-1) \\qquad j=0,1,\\dots,(n-1) \\\\ u_{i,0}\u0026=4 x_i(L-x_i) \\qquad x_i = i h \\qquad i=0, 1, \\dots,m \\\\ u_{0,j}\u0026=0 \\qquad j=0, 1, \\dots,n \\\\ u_{m,j}\u0026=0 \\qquad j=0, 1, \\dots,n \\end{aligned} \\]  可用Julia实现之（注意代码中数组序号从1开始）：\n# 参数确定 λ=1; L=3; T=1; m=30; n=10000; (h,τ) = (L/m, T/n); # 网格点坐标序列 t = [(i-1)*τ for i in 1:(n+1)]; x = [(j-1)*h for j in 1:(m+1)]; # 分配空间 u = zeros(m+1,n+1); # 边界赋值(零值边界不用赋值) u[:,1] = 4*x.*(L.-x); # 按递推公式计算 for j = 1:n for k = 2:m i = m-k+2 u[i,j+1]=(λ*τ/h^2)*u[i+1,j]+(1-2*λ*τ/h^2)*u[i,j]+(λ*τ/h^2)*u[i-1,j] end end; plot(t, x, u, xlabel=\u0026#34;t\u0026#34;, ylabel=\u0026#34;x\u0026#34;)  《微分方程数值解法（第4版）-李荣华＆刘播-高等教育出版社-2009》\n"}),a.add({id:79,href:'/notes/docs/julia/0088/',title:"平面三体问题（Julia版）",content:"# 奇怪：这个库必须放在最前面才能一次加载成功 using Plots # gr() pyplot() using SciPy using LinearAlgebra Plots.GRBackend()  在平面上引入直角坐标系，每个星体的坐标和速度分别为：\n  \\[ x_i \\in \\mathbb{R}^{2} \\ \\ \\dot{x}_i \\in \\mathbb{R}^{2} \\ \\ i=1,2,3 \\]  直接根据万有引力定律和牛顿第二定律，可写出下面的三体动力学方程组（其中，引力常数可通过选择适当的单位制使得 \\(G=1\\)  ）：\n\\[ \\begin{aligned}\\frac{d x_1}{dt} \u0026=\\dot{x}_1 \\\\ \\frac{d x_2}{dt} \u0026=\\dot{x}_2 \\\\ \\frac{d x_3}{dt} \u0026=\\dot{x}_3 \\\\ \\frac{d \\dot{x}_1}{dt} \u0026=m_2 \\frac{x_2-x_1}{r_3^{\\ \\ 3}} + m_3 \\frac{x_3-x_1}{r_2^{\\ \\ 3}} \\\\ \\frac{d \\dot{x}_2}{dt} \u0026=m_3 \\frac{x_3-x_2}{r_2^{\\ \\ 3}} + m_1 \\frac{x_1-x_2}{r_3^{\\ \\ 3}} \\\\ \\frac{d \\dot{x}_3}{dt} \u0026=m_1 \\frac{x_1-x_3}{r_2^{\\ \\ 3}} + m_2 \\frac{x_2-x_3}{r_1^{\\ \\ 3}} \\end{aligned} \\]  下面的程序中按如下次序装配成12个元素的数组u：\n\\[ u=[x_1,\\dot{x}_1,x_2,\\dot{x}_2,x_3,\\dot{x}_3] \\in \\mathbb{R}^{12} \\]  function threebody(t, u, m1,m2,m3) # 3个星体各自的坐标 x1 = u[1:2] x2 = u[5:6] x3 = u[9:10] # \\vec{r}/r^3 d1 = (x3-x2)/norm(x3-x2)^3 d2 = (x1-x3)/norm(x1-x3)^3 d3 = (x2-x1)/norm(x2-x1)^3 # du du = zeros(12) du[1:2] = u[3:4] du[5:6] = u[7:8] du[9:10] = u[11:12] du[3:4] = m2*d3 - m3*d2; du[7:8] = m3*d1 - m1*d3; du[11:12] = m1*d2 - m2*d1 du end; 初始静止的平面三体，其位置分别在(1,-1) (1,3) (-2,-1)。\nu0 = [1.0;-1.0;0.0;0.0;1.0;3.0;0.0;0.0;-2.0;-1.0;0.0;0.0] tspan = [0,40] # 调用ode进行求解 odeint sol = SciPy.integrate.solve_ivp(threebody, tspan, u0, args=(5.0, 3.0, 4.0)) t = sol[\u0026#34;t\u0026#34;] u = sol[\u0026#34;y\u0026#34;]; 绘制运动过程\n@gif for i in eachindex(t) plot(u[1,1:i], u[2,1:i], color = \u0026#34;red\u0026#34;, label = \u0026#34;\u0026#34;) plot!(u[5,1:i], u[6,1:i], color = \u0026#34;green\u0026#34;, label = \u0026#34;\u0026#34;) plot!(u[9,1:i], u[10,1:i], color = \u0026#34;blue\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((u[1,i], u[2,i]), color = \u0026#34;red\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((u[5,i], u[6,i]), color = \u0026#34;green\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((u[9,i], u[10,i]), color = \u0026#34;blue\u0026#34;, label = \u0026#34;\u0026#34;) end every 5 ┌ Info: Saved animation to │ fn = F:\\谷歌云端硬盘\\Colab Notebooks\\tmp.gif └ @ Plots C:\\Users\\DELL\\.julia\\packages\\Plots\\5ItHH\\src\\animation.jl:104  如果选择三体的质心为坐标原点，那么在此坐标系下，知道三体任意两体的坐标，就知道第三个的坐标：\n\\[ x_3 = -\\frac{1}{m_3}(m_1 x_1+m_2 x_2) \\]  进而只需要求解关于 \\(x_1,x_2\\)  的方程组，此时可重新装配待求变量的数组：\n\\[ u=[x_1,\\dot{x}_1,x_2,\\dot{x}_2] \\in \\mathbb{R}^{8} \\]  于是有：\n(m1,m2,m3) = (5,3,4); function threebody2(t, u, m1,m2,m3) # 3个星体各自的坐标 x1 = u[1:2] x2 = u[5:6] x3 = -(m1*x1+m2*x2)/m3 # \\vec{r}/r^3 d1 = (x3-x2)/norm(x3-x2)^3 d2 = (x1-x3)/norm(x1-x3)^3 d3 = (x2-x1)/norm(x2-x1)^3 # du (只需要其中两体的动力学方程) du = zeros(8) du[1:2] = u[3:4] du[5:6] = u[7:8] du[3:4] = m2*d3 - m3*d2; du[7:8] = m3*d1 - m1*d3; du end; # 为了方便比较，确保初值条件和前面完全一致 u0 = [1.0;-1.0;0.0;0.0;1.0;3.0;0.0;0.0;-2.0;-1.0;0.0;0.0] o = (m1*u0[1:2]+m2*u0[5:6]+m3*u0[9:10])/(m1+m2+m3) u0 = u0[1:8] u0[1:2] -= o u0[5:6] -= o tspan = [0,40] # 调用ode进行求解 odeint sol = SciPy.integrate.solve_ivp(threebody2, tspan, u0, args=(m1,m2,m3)) t = sol[\u0026#34;t\u0026#34;] u = sol[\u0026#34;y\u0026#34;]; x1 = u[[1,2],:]; x2 = u[[5,6],:]; x3 = -(m1*x1+m2*x2)/m3 @gif for i in eachindex(t) plot(x1[1,1:i], x1[2,1:i], color = \u0026#34;red\u0026#34;, label = \u0026#34;\u0026#34;) plot!(x2[1,1:i], x2[2,1:i], color = \u0026#34;green\u0026#34;, label = \u0026#34;\u0026#34;) plot!(x3[1,1:i], x3[2,1:i], color = \u0026#34;blue\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((x1[1,i], x1[2,i]), color = \u0026#34;red\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((x2[1,i], x2[2,i]), color = \u0026#34;green\u0026#34;, label = \u0026#34;\u0026#34;) scatter!((x3[1,i], x3[2,i]), color = \u0026#34;blue\u0026#34;, label = \u0026#34;\u0026#34;) end every 5 ┌ Info: Saved animation to │ fn = F:\\谷歌云端硬盘\\Colab Notebooks\\tmp.gif └ @ Plots C:\\Users\\DELL\\.julia\\packages\\Plots\\5ItHH\\src\\animation.jl:104  我们注意到，原本给出的初值条件的质心本来就在原点：\no 2-element Array{Float64,1}: 0.0 0.0  所以按理说，前后两次的绘图应该完全一样才对，但事实上不一样。其实，这暗含三体运动的不可预测性（数值计算的微小舍入误差可能会被无限放大）。\n"}),a.add({id:80,href:'/notes/categories/julia/',title:"julia",content:""}),a.add({id:81,href:'/notes/docs/julia/',title:"基于Julia科学计算",content:"基于Julia科学计算 目录  1. 整合Julia和Python的集成环境（Win10） 2. 科学计算环境搭建（Win10+WSL2+Ubuntu） 3. Julia中的数学符号演算 4. 基于Julia的科学计算功能库整理 5. 微分几何中的计算 6. 平面三体问题    7. 有限差分法求解一维热传导方程 8. Galerkin法解常微分方程边值问题 9. 有限元法解常微分方程边值问题 10. 有限元之平面三角单元 11. 有限元之Delaunay三角剖分 12. 有限元法解偏微分方程（FEniCS） 13. 有限元法求解牛顿流体（FEniCS）    "}),a.add({id:82,href:'/notes/tags/Casimir%E7%AE%97%E7%AC%A6/',title:"Casimir算符",content:""}),a.add({id:83,href:'/notes/categories/%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86/',title:"理论物理",content:""}),a.add({id:84,href:'/notes/tags/%E8%87%AA%E7%94%B1%E5%9C%BA/',title:"自由场",content:""}),a.add({id:85,href:'/notes/docs/theophy/0087/',title:"自由场--现代物理的基础",content:" 本篇紧接上一篇笔记《半单李代数的Casimir不变算符》。\n分两种情况（有质量、无质量）探讨单粒子的物理态表示。\n 关于物理对称性的总结  本段是前一批相关学习笔记的概要总结。\n考虑的闵氏度规是   \\(\\eta=\\mathrm{diag}(-1,1,1,1)\\)  。\n为了确保不出错，我在草稿中尽可能又重新计算了一遍。\n 1）庞加莱群 庞加莱群=洛伦兹群+平移（P）= 旋转（J）+Boost（K）+平移（P）\n2）生成元（李代数基底） \\[ \\boxed{\\begin{aligned}P_\\mu \u0026= i\\partial_\\mu\\\\ J_i\u0026=-i\\varepsilon_i^{\\ jk}x_j\\partial_k=\\frac{1}{2}\\varepsilon_i^{\\ jk}\\textcolor{red}{J_{jk}}\\\\ K_i \u0026= i(x_i\\partial_0 + x_0 \\partial_i)=\\textcolor{red}{J_{0i}} \\end{aligned}}\\\\ \\mu,\\upsilon=0,1,2,3\\qquad i,j,k=1,2,3 \\\\ \\quad \\\\ \\textcolor{red}{J_{\\mu\\upsilon}}\\overset{\\Delta}{=}\\begin{pmatrix} 0 \u0026 K_1 \u0026 K_2 \u0026 K_3 \\\\ -K_1 \u0026 0 \u0026 J_3 \u0026 -J_2 \\\\ -K_2 \u0026 -J_3 \u0026 0 \u0026 J_1 \\\\ -K_3 \u0026 J_2 \u0026 -J_1 \u0026 0 \\end{pmatrix}\\\\ J^{i0}=-J_{i0} \\quad J^{ij}=J_{ij} \\]  3）李代数的结构常数 \\[ \\boxed{\\begin{aligned}\\quad \u0026[\\textcolor{red}{P_\\mu},\\textcolor{red}{P_\\upsilon}]=0 \\quad \u0026[\\textcolor{blue}{J_i},\\textcolor{blue}{J_j}]=i \\ \\varepsilon^k_{\\ \\ ij}\\textcolor{blue}{J_k} \\\\\u0026 [\\textcolor{green}{K_i},\\textcolor{green}{K_j}]=-i\\ \\varepsilon^k_{\\ \\ ij}\\textcolor{blue}{J_k} \\quad \u0026 \\\\\u0026 [P_0,\\textcolor{blue}{J_i}]=0 \\quad \u0026[\\textcolor{red}{P_i},\\textcolor{blue}{J_j}]=i\\ \\varepsilon^k_{\\ \\ ij}\\textcolor{red}{P_k} \\\\ \u0026 [P_0,\\textcolor{green}{K_i}]=i\\ \\textcolor{red}{P_i} \\quad \u0026 [\\textcolor{red}{P_i},\\textcolor{green}{K_j}]=i\\ \\delta_{ij}P_0 \\quad \\\\ \u0026 [\\textcolor{blue}{J_i},\\textcolor{green}{K_j}]=i\\ \\varepsilon^k_{\\ \\ ij}\\textcolor{green}{K_k} \\quad \u0026 \\end{aligned}}\\\\ \\quad \\\\ [J_{\\mu\\upsilon},P_\\rho]=i(\\eta_{\\mu\\rho}P_\\upsilon-\\eta_{\\upsilon\\rho}P_\\mu)\\\\ [J_{\\mu\\upsilon},J_{\\rho\\sigma}]=i(\\eta_{\\mu\\rho}J_{\\upsilon\\sigma}-\\eta_{\\mu\\sigma}J_{\\upsilon\\rho}-\\eta_{\\upsilon\\rho}J_{\\mu\\sigma}+\\eta_{\\upsilon\\sigma}J_{\\mu\\rho}) \\]  4）洛伦兹群的表示  我特意用颜色标注了(半)整数对 \\((j_{-},j_{+})\\)  在洛伦兹群中的地位。\n \\[ \\boxed{\\begin{aligned}\\Lambda\u0026=\\exp\\left\\{-\\frac{\\mathbf{i}}{2}\\omega_{\\mu\\upsilon}J^{\\mu\\upsilon}\\right\\}=\\exp\\left\\{-\\mathbf{i} \\boldsymbol{\\theta}\\cdot\\boldsymbol{J}+\\mathbf{i} \\boldsymbol{\\alpha}\\cdot \\boldsymbol{K}\\right\\}\\\\ \u0026=\\exp\\left\\{(\\textcolor{blue}{j_{+}-j_{-}})\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\sigma}-\\mathbf{i}(\\textcolor{red}{j_{+}+j_{-}}) \\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}\\right\\}\\end{aligned}}\\\\ \\quad \\\\ \\omega_{\\mu\\upsilon}\\overset{\\Delta}{=}\\begin{pmatrix} 0 \u0026 \\alpha_1 \u0026 \\alpha_2 \u0026 \\alpha_3 \\\\ -\\alpha_1 \u0026 0 \u0026 \\theta_3 \u0026 -\\theta_2 \\\\ -\\alpha_2 \u0026 -\\theta_3 \u0026 0 \u0026 \\theta_1 \\\\ -\\alpha_3 \u0026 \\theta_2 \u0026 -\\theta_1 \u0026 0 \\end{pmatrix}\\\\ \\omega^{i0}=-\\omega_{i0}\\quad \\omega^{ij}=\\omega_{ij}\\\\ \\quad \\\\ \\boldsymbol{J}=J_{-}+J_{+}=(\\textcolor{red}{j_{-}+j_{+}})\\boldsymbol{\\sigma}=\\textcolor{red}{j}\\boldsymbol{\\sigma}\\\\ \\boldsymbol{K}=\\mathbf{i}(J_{-}-J_{+})=\\mathbf{i}(\\textcolor{blue}{j_{-}-j_{+}})\\boldsymbol{\\sigma}\\\\ \\quad \\\\ \\boldsymbol{J}_{+}=j_{+}\\boldsymbol{\\sigma}\\quad \\boldsymbol{J}_{-}=j_{-}\\boldsymbol{\\sigma} \\]  5）自旋的表示 由于洛伦兹群的表示可改写成 \\[ \\boxed{\\begin{aligned}\\Lambda\u0026=\\exp\\left\\{(\\textcolor{blue}{j_{+}-j_{-}})\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\sigma}-\\mathbf{i}(\\textcolor{red}{j_{+}+j_{-}}) \\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}\\right\\}\\\\ \u0026 = \\exp\\left\\{\\textcolor{blue}{j_{-}}(-\\boldsymbol{\\alpha}-\\mathbf{i} \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}\\exp\\left\\{\\textcolor{red}{j_{+}}(\\boldsymbol{\\alpha}-\\mathbf{i} \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}\\\\ \u0026=\\left(\\overline{L^{-1}}\\right)^{\\ \\textcolor{blue}{2j_{-}}}L^{\\ \\textcolor{red}{2j_{+}}}\\end{aligned}}\\\\ \\quad \\\\ L\\overset{\\Delta}{=}\\exp\\left\\{\\frac{1}{2}(\\boldsymbol{\\alpha}-\\mathbf{i} \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\} \\]  这说明： \\[ \\mathfrak{so}(1,3)\\cong \\mathfrak{su}(2)\\otimes\\mathfrak{su}(2) \\]  自旋（旋量张量）可用一对(半)整数 \\((j_{-},j_{+})\\)  标记，若取 \\(j=j_{-}+j_{+}\\)  ，则对应 \\(\\color{red}{\\text{自旋-}j}\\)  。 比如：\n 自旋0，可用 \\((j_{-},j_{+})=(0,0)\\)  表示； 自旋1/2，可用 \\((j_{-},j_{+})=(\\frac{1}{2},0)\\)  或 \\((j_{-},j_{+})=(0,\\frac{1}{2})\\)  表示； 自旋1，可用 \\((j_{-},j_{+})=(\\frac{1}{2},\\frac{1}{2})\\)  表示。  庞加莱群的表示用两个标量来标记： \\(m,j\\)  。其中 \\(m\\)  可取任意值， \\(j\\)  只能取(半)整数。\n6）两个Casimir算符 两个庞加莱群有两个不变量，与任意庞加莱李代数元素对易。可用Casimir算符作用于最高权对应的本征值标记： \\[ P_\\mu P^\\mu=-m^2 \\quad W_\\mu W^\\mu =-m^2 j(j+1)\\\\ W^\\mu=\\frac{1}{2}\\varepsilon^{\\mu\\upsilon\\rho\\sigma}P_\\upsilon J_{\\rho\\sigma} \\]  7）基本粒子 庞加莱群的不可约表示的标记就是物理学对基本粒子的标记：质量 \\(m\\)  与自旋 \\(j\\)  。至于粒子的更多特征量（比如：电荷）将从内禀对称性导出。\n相应地，基本粒子可分为如下几种：\n 自旋1：由标量（记作： \\(\\Phi\\)  或 \\(\\phi\\)  ）描述，标量按庞加莱群的 \\((0,0)\\)  表示来变换。 自旋1/2：由旋量（记作： \\(\\Psi\\)  或 \\(\\phi_A\\)  ）描述，标量按庞加莱群的 \\((\\frac{1}{2},0)\\oplus(0,\\frac{1}{2})\\)  表示来变换。 自旋1：由矢量或二阶旋量张量（记作： \\(A\\)  或 \\(\\phi_{AB}\\)  ）描述，标量按庞加莱群的 \\((\\frac{1}{2},\\frac{1}{2})=(\\frac{1}{2},0)\\otimes(0,\\frac{1}{2})\\)  表示来变换。  注意区分庞加莱群自旋和粒子自旋的区分：前者着重于“变换”，后者表示对应的物理量满足这种“变换规律”。\n内禀对称性 场论中，有两种对称性：1）拉格朗日密度的时空对称性；2）拉格朗日密度在场自身的变换下也保持不变，这种不变性称为内禀对称性（internal symmetries）。\n比如， \\(S,S'\\)  是两个不同观察者，同一个场 \\(\\phi\\)  （省略了标志其性质的指标，比如 \\(\\phi_A,\\phi_{AB}\\)  ） \\[ S \\to \\phi(x)\\quad S'\\to \\phi'(x') \\]  涉及两重变换： \\[ x\\to x'\\quad \\phi\\to\\phi' \\]  a \\[ \\mathcal{J}^a=\\frac{\\partial\\mathscr{L}}{\\partial (\\nabla_a \\phi)}\\mathcal{L}_\\xi\\phi-\\xi^a\\mathscr{L} \\]  考虑闵氏背景时空的一般拉格朗日量密度 \\(\\mathscr{L}(\\phi(x_\\mu),\\partial_\\mu\\phi(x_\\mu),x_\\mu)\\)  。对称性则意味着在前面两重变换下： \\[ \\delta\\mathscr{L}=0 \\]  即 \\[ \\begin{aligned}0=\\delta\\mathscr{L}\u0026=\\frac{\\partial\\mathscr{L}}{\\partial \\phi}\\delta\\phi+\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta(\\partial_\\mu\\phi)+\\frac{\\partial\\mathscr{L}}{\\partial x_\\mu}\\delta x_\\mu\\\\ \u0026=\\frac{\\partial\\mathscr{L}}{\\partial \\phi}\\delta\\phi+\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta(\\partial_\\mu\\phi)+\\frac{\\partial\\mathscr{L}}{\\partial x_\\mu}\\delta x_\\mu\\end{aligned} \\]  注意：\n 1）只考虑 \\(x\\to x'\\)  ，及其诱导的 \\(\\phi\\to\\phi'\\)  ，我以前的笔记涉及过，这就是纯粹的时空对称性。 2）内禀对称性，出现在 \\(\\phi\\to\\phi'\\)  的自身变换，而非 \\(x\\to x'\\)  的诱导变换。  为了描述内禀对称性，不妨把 \\(x\\to x'\\)  这部分变换冻结（ \\(\\delta x_\\mu=0\\)  ），即： \\[ \\begin{aligned}0=\\delta \\mathscr{L}\u0026=\\frac{\\partial\\mathscr{L}}{\\partial \\phi}\\delta\\phi+\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta(\\partial_\\mu\\phi)\\\\ \u0026=\\partial_\\mu\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta\\phi+\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta(\\partial_\\mu\\phi)\\\\ \u0026=\\partial_\\mu\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta\\phi+\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\partial_\\mu(\\delta\\phi)\\\\ \u0026=\\partial_\\mu\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta\\phi\\right)\\end{aligned} \\]  得到纯内禀对称性的守恒流密度 \\(\\mathcal{J}^\\mu\\)  : \\[ \\boxed{\\partial_\\mu \\mathcal{J}^\\mu=0 \\quad \\mathcal{J}^\\mu\\overset{\\Delta}{=}\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\delta\\phi} \\]  1）场自身的平移不变性 此时 \\(\\delta\\phi=i\\epsilon\\)  ，即：【注意： \\(\\epsilon\\)  也忽略了和 \\(\\phi\\)  一致标识其性质的下标】 \\[ \\phi\\to\\phi'=\\phi+i\\epsilon \\]  这个变换的生成元实际是 \\(i \\partial/\\partial\\phi\\)  ，因为 \\[ \\phi'=e^{i\\epsilon\\frac{\\partial}{\\partial\\phi}}\\phi\\approx(1+i\\epsilon\\frac{\\partial}{\\partial\\phi})\\phi=\\phi+i\\epsilon \\]  带入 \\(\\partial_\\mu \\mathcal{J}^\\mu=0\\)  得（约掉了 \\(i\\epsilon\\)  ） \\[ \\partial_\\mu\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\mu\\phi)}\\right)=0\\\\ \\textcolor{red}{\\Longrightarrow }\\partial_t\\pi=\\partial_0\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_0\\phi)}\\right)=-\\partial_i\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_i\\phi)}\\right)\\qquad\\textcolor{red}{时空1+3分解}\\\\ \\textcolor{red}{\\Longrightarrow } \\boxed{\\begin{aligned}\\partial_t\\Pi\u0026=\\int_V{\\partial_t\\pi}=-\\int_V\\partial_i\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_i\\phi)}\\right)\\boldsymbol{\\varepsilon}\\\\ \u0026=-\\int_{\\partial V}\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_i\\phi)}\\right)n_i\\hat{\\boldsymbol{\\varepsilon}}\\qquad\\textcolor{red}{流形上高斯定理}\\\\ \u0026=0 \\qquad\\textcolor{red}{当V足够大时，“局域性原理”}\\end{aligned}} \\]  所以有结论：场自身得平移不变性，对应，共轭动量守恒。\n2）场自身的旋转不变性 此时 \\(\\delta \\phi=\\epsilon_{\\mu\\upsilon}J^{\\mu\\upsilon}\\phi\\)  ，带入 \\(\\partial_\\mu \\mathcal{J}^\\mu=0\\)  得： \\[ \\partial_\\rho\\left(\\frac{\\partial\\mathscr{L}}{\\partial (\\partial_\\rho\\phi)}\\epsilon_{\\mu\\upsilon}J^{\\mu\\upsilon}\\phi\\right)=0 \\]  量子场论的算符 根据Noether定理，我们知道：\n 动量 \\(\\hat{p}_i\\)  ，对应空间平移生成元 \\(P_i=i\\ \\partial_i\\)  ； 能量 \\(\\hat{E}\\)  ，对应时间平移生成元 \\(P_i=i\\ \\partial_0\\)  ; 位置 \\(\\hat{x}_i\\)  ，没有所谓“位置守恒”的对称性，直接对应 \\(\\hat{x}_i\\to x_i\\)  。  考虑任意一个物理量 \\(\\phi\\)  （省略了标志其性质的指标，比如 \\(\\phi_A,\\phi_{AB}\\)  ），有： \\[ \\begin{aligned}\\ [\\hat{p}_i,\\hat{x}_j]\\phi\u0026=[i\\partial_i,x_j]\\phi\\\\ \u0026=i(\\partial_i x_j-x_j\\partial_i )\\phi\\\\ \u0026=i\\partial_i (x_j\\phi)-ix_j\\partial_i\\\\ \u0026=\\textcolor{blue}{i(\\partial_i x_j)\\phi+\\cancel{ix_j\\partial_i\\phi}}-\\cancel{ix_j\\partial_i\\phi}\\\\ \u0026=i\\delta_{ij}\\phi\\end{aligned} \\]  即： \\[ \\boxed{[\\hat{p}_i,\\hat{x}_j] = i \\delta_{ij}} \\]  根据Noether定理，我们还知道：\n​\n0自旋，Klein-Gordon 方程 1/2自旋，Dirac方程 1自旋，Proca方程"}),a.add({id:86,href:'/notes/tags/%E9%87%8F%E5%AD%90%E5%9C%BA%E8%AE%BA/',title:"量子场论",content:""}),a.add({id:87,href:'/notes/tags/%E5%BA%9E%E5%8A%A0%E8%8E%B1%E7%BE%A4/',title:"庞加莱群",content:""}),a.add({id:88,href:'/notes/docs/theophy/0086/',title:"庞加莱群的单粒子态的表示",content:" 本篇紧接上一篇笔记《半单李代数的Casimir不变算符》。\n分两种情况（有质量、无质量）探讨单粒子的物理态表示。\n本篇及上一篇笔记涉及的代码：https://gitee.com/chaoskey/notes/blob/master/code/0085.ipynb\n 庞加莱群的Casimir不变算符 下面的Julia代码有一个约定（其实以前的笔记涉及Julia代码时也默认用到这个约定）：\n 1）一个矢量（比如：   \\(P\\)  ）默认是逆变矢量；协变矢量则对应记作 \\(Pi\\)  ； 2）逆变矢量的分量在Julia代码中以下标体现（因为上标会被解释成“幂次”）；而协变矢量的分量则可通过度规用逆变矢量的分量表出。  # 紧接上一篇笔记的Julia代码 # 四维evi-Civita记号 ε4= [ Sym((length(Set([i,j,k,l]))==4)* # 存在重复指标，取0 (-1)^(sum([i,j,k,l][σ]\u0026gt;[i,j,k,l][ρ] for σ in 1:4,ρ in 1:4 if σ\u0026lt;ρ) % 2)) # 计算逆序数。偶数取1，奇数取-1 for i in 1:4, j in 1:4, k in 1:4,l in 1:4 ] ; # 闵氏度规 η = sympy.diag(-1,1,1,1); # J: 两上标洛伦兹生成元矩阵 # Ji: 两下标洛伦兹生成元矩阵 J=[Sym(0) for i in 1:4 , j in 1:4]; J[2:4,2:4]=[sum(ε[k,i,j]*E[4+k] for k in 1:3) for i in 1:3,j in 1:3]; J[1,2:4]=-E[8:10]; J[2:4,1]=E[8:10]; Ji=[sum(J[μ,υ]*η[μ,ρ]*η[υ,σ] for μ in 1:4,υ in 1:4) for ρ in 1:4,σ in 1:4]; # P: 逆变平移生成元 # Pi: 协变平移生成元 P=E[1:4]; Pi = [sum(η[υ,σ]*P[σ] for σ in 1:4) for υ in 1:4]; # W: 上标Pauli–Lubanski矢量 # Wi: 下标Pauli–Lubanski矢量 W=Sym(-1//2)*[sum(ε4[μ,υ,ρ,σ]*Ji[υ,ρ]*Pi[σ] for υ in 1:4,ρ in 1:4,σ in 1:4) for μ in 1:4]; Wi=Sym(-1//2)*[sum(ε4[μ,υ,ρ,σ]*J[υ,ρ]*P[σ] for υ in 1:4,ρ in 1:4,σ in 1:4) for μ in 1:4]; # 两个Casimir不变算符 PP = sum(P[μ]*Pi[μ] for μ in 1:4); WW = sum(W[μ]*Wi[μ] for μ in 1:4); [PP,WW] .|\u0026gt; simplify @vars m ω real=true positive=true # 有质量：m \u0026gt; 0 [PP,WW] .|\u0026gt; (expr-\u0026gt;expr(P0=\u0026gt;m,P1=\u0026gt;0,P2=\u0026gt;0,P3=\u0026gt;0)) .|\u0026gt; simplify # 零质量：m = 0 [PP,WW] .|\u0026gt; (expr-\u0026gt;expr(P0=\u0026gt;ω,P1=\u0026gt;0,P2=\u0026gt;0,P3=\u0026gt;ω)) .|\u0026gt; simplify 代码执行结果及说明：\n有质量粒子情况下的表示 考虑惯性标架下，质量 \\(\\textcolor{red}{m}\\)  和自旋 \\(\\textcolor{red}{j}\\)  的自由粒子。我们发现不变量 \\(W_\\mu W^\\mu\\)  实际只和空间转动有关：\n\\[ W_\\mu W^\\mu=-m^2 J^2 \\]  所以这个不变量实际对应李代数 \\(\\textcolor{red}{A_1=\\mathscr{so}(3)=\\mathscr{su}(2)}\\)  ，前面的笔记曾计算过，对应的最高权是：\n\\[ \\boldsymbol{M}=j\\boldsymbol{\\alpha} \\]  有【见上一篇笔记的第一段】：\n\\[ \\boldsymbol{M}\\cdot(\\boldsymbol{M} +2\\boldsymbol{g})=j(j+1)\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}=\\textcolor{red}{j(j+1)} \\]  所以，两个Casimir不变算符的本征值是\n\\[ \\boxed{P_\\mu P^\\mu =-m^2\\qquad W_\\mu W^\\mu=-m^2 j(j+1)}\\\\ m0\\quad j=0,1/2,1,\\dots \\]  以前的笔记还计算过李代数 \\(A_1\\)  对应的维度是 \\(\\textcolor{red}{(2j+1)}\\)  ，所以自旋 \\(\\textcolor{red}{j}\\)  有 \\((2j+1)\\)  个状态:\n\\[ j_z=-j,-j+1,\\dots,0,\\dots,j-1,j \\]  无质量粒子情况下的表示 对零质量的情况，平移生成元的分量可归结为：\n\\[ P^\\mu=(\\omega,0,0,\\omega)\\quad P_\\mu=(-\\omega,0,0,\\omega) \\]  此时\n\\[ W_\\mu W^\\mu=-\\omega^2[(J^1-K^2)^2+(J^2+K^1)^2] \\]  注意，这个不变量只和 \\(x-y\\)  平面有关。不妨选择\n\\[ A=K^1+J^2\\quad B=K^2-J^1 \\]  于是有【根据 \\(\\{J^1,J^2,J^3\\}\\)  的结构常数容易验证】\n\\[ W_\\mu W^\\mu=-\\omega^2(A^2+B^2)\\\\ \\boxed{\\textcolor{red}{[J^3,A]=i B,\\quad [J^3,B]=-i A,\\quad [A,B]=0}} \\]  很明显，这是一个绕z轴旋转的李代数 \\(\\textcolor{red}{\\mathscr{so}(2)=\\mathscr{su}(1)}\\)  。\n由于 \\(A\\)  和 \\(B\\)  是对易的，所以有共同本征矢（本征态）：\n\\[ A|\\boldsymbol{p}:a,b\\rangle=a|\\boldsymbol{p}:a,b\\rangle,\\quad B|\\boldsymbol{p}:a,b\\rangle=b|\\boldsymbol{p}:a,b\\rangle \\]  然而，因为是 \\(a,b\\)  非零的，就得到一个完全连续的谱（连续本征值）!\n先考虑一个带参数 \\(\\theta\\)  的态：\n\\[ |\\boldsymbol{p}:a,b,\\theta\\rangle\\overset{\\Delta}{=}e^{-i\\theta J^3}|\\boldsymbol{p}:a,b,\\theta\\rangle \\]  于是有：\n\\[ \\begin{aligned}\\textcolor{blue}{A|\\boldsymbol{p}:a,b,\\theta\\rangle}\u0026=e^{-i\\theta J^3}\\left(e^{i\\theta J^3}Ae^{-i\\theta J^3}\\right)|\\boldsymbol{p}:a,b\\rangle\\\\ \u0026=e^{-i\\theta J^3}\\left(A\\cos \\theta-B\\sin\\theta\\right)|\\boldsymbol{p}:a,b\\rangle\\\\ \u0026=\\left(A\\cos \\theta-B\\sin\\theta\\right)|\\boldsymbol{p}:a,b,\\theta\\rangle\\\\ \u0026=\\textcolor{blue}{\\left(a\\cos \\theta-b\\sin\\theta\\right)|\\boldsymbol{p}:a,b,\\theta\\rangle}\\end{aligned} \\]  类似有：\n\\[ \\textcolor{blue}{B|\\boldsymbol{p}:a,b,\\theta\\rangle}=\\textcolor{blue}{\\left(a\\sin \\theta+b\\cos\\theta\\right)|\\boldsymbol{p}:a,b,\\theta\\rangle} \\]  这意味着，有一个连续的内部自由度 \\(\\theta\\)  。但是，对关于无质量粒子的观测并没有发现任何像 \\(\\theta\\)  这样的连续自由度，为了避免这些连续谱，我们必须要求 \\(a=b=0\\)  ：\n\\[ A|\\boldsymbol{p}:a,b\\rangle=B|\\boldsymbol{p}:a,b\\rangle=0\\\\ \\boxed{P_\\mu P^\\mu=0,\\quad W_\\mu W^\\mu=0} \\]  所以，这两个不变量的的本征值都不足以标记表示（区分物理态）。我们还注意到：\n\\[ P_\\mu W^\\mu=0 \\]  因为\n根据上面三个等于0的等式， \\(P^\\mu,W^\\mu\\)  必须成比例：\n\\[ \\boxed{W^\\mu=h P^\\mu} \\]  事实上，这个比例系数 \\(h\\)  和角动量在z轴上的投影密切相关：\n即\n\\[ h=\\frac{W^0}{P^0}=\\textcolor{red}{-\\frac{\\boldsymbol{J}\\cdot\\boldsymbol{P}}{P^0}}=-\\boldsymbol{\\hat{P}}\\cdot \\boldsymbol{J}=-J^3 \\]  这意味着：我们只能通过剩下的生成元 \\(J^3\\)  的本征值 \\(\\lambda\\)  来区分物理态\n\\[ J^3|\\boldsymbol{p}:\\lambda\\rangle=\\lambda|\\boldsymbol{p}:\\lambda\\rangle \\]  因为，对于任意一个阿贝尔群， \\(\\mathrm{SO}(2)\\)  的不可约表示是1维的，对应的生成元是在 \\((x,y)\\)  平面旋转的角动量 \\(J^3\\)  。\n注意到，无穷小算符 \\(J^3=\\boldsymbol{\\hat{P}}\\cdot \\boldsymbol{J}\\)  对应有限小转动 \\(\\mathrm{SO}(2)\\)  群 \\(\\exp^{i \\theta \\boldsymbol{\\hat{P}}\\cdot \\boldsymbol{J}}\\)  。因此， \\(\\lambda\\)  给出了 \\(\\mathrm{SO}(2)\\)  的幺正表示 \\(e^{i\\theta\\lambda}\\)  。\n到目前为止，尚没有任何理由阻止本征值 \\(\\lambda\\)  取任意实数，但有一些拓扑的原因使得与有质量粒子的情况一样只能取整数或半整数【我暂时不深究】:\n\\[ \\lambda=0,\\pm\\frac{1}{2},\\pm 1,\\pm\\frac{3}{2},\\dots \\]  作为一个平面上的旋转，只有顺时针/逆时针两种可能，所以可用 \\(j=|\\lambda|\\)  加以标记。\n至此可见，自旋 \\(j\\ne0\\)  的零质量粒子只有两个自旋自由度。对应得物理态可记作：\n\\[ |\\boldsymbol{p}:\\lambda=\\pm j\\rangle \\]  比如：光子( \\(s=1\\)  )态可记作 \\(|\\boldsymbol{p}:\\lambda=\\pm 1\\rangle\\)  ；中微子( \\(s=1/2\\)  )态可记作 \\(|\\boldsymbol{p}:\\lambda=\\pm 1/2\\rangle\\)  ；引力子( \\(s=2\\)  )态可记作 \\(|\\boldsymbol{p}:\\lambda=\\pm 2\\rangle\\)  。\n"}),a.add({id:89,href:'/notes/tags/%E6%9D%8E%E7%BE%A4/',title:"李群",content:""}),a.add({id:90,href:'/notes/docs/diffgeo/0085/',title:"半单李代数的Casimir不变算符",content:" 本篇主题是Casimir算符。\n半单李群李代数的Casimir算符可以完全确定。\n而非半单李群李代数的Casimir算符，只能算出独立Casimir算符的个数，具体形式似乎要靠猜测试探？？？？？\n一旦确定了Casimir算符，可以仿照二次Casimir算符的本征值的计算方法确定对应本征值。\n 二次Casimir算符的本征值 在（外尔-嘉当）标准基   \\(\\{(K_i)^a,(H_\\alpha)^a\\}\\)  下，（二次）Casimir算符可以改写成：\n\\[ \\begin{aligned}C\u0026=\\kappa^{\\mu\\upsilon}E_\\mu E_\\upsilon\\\\\u0026=\\kappa^{ij}K_iK_j+\\sum_\\alpha{H_\\alpha H_{-\\alpha}}\\end{aligned} \\]  考虑某个不可约表示的最高权 \\(\\boldsymbol{M}\\)  ，及其权向量 \\(|u_{\\boldsymbol{M}}\\rangle\\)  。于是有\n\\[ \\begin{aligned}\\textcolor{red}{C}|u_{\\boldsymbol{M}}\\rangle\u0026=\\kappa^{ij}\\textcolor{blue}{M_i M_j}|u_{\\boldsymbol{M}}\\rangle+\\sum_\\alpha{H_\\alpha H_{-\\alpha}|u_{\\boldsymbol{M}}\\rangle}\\quad \\textcolor{red}{权}\\\\ \u0026=\\kappa^{ij}M_i M_j|u_{\\boldsymbol{M}}\\rangle+\\sum_{\\textcolor{blue}{\\alpha\\in\\Sigma^+}}{H_\\alpha H_{-\\alpha}|u_{\\boldsymbol{M}}\\rangle}\\quad \\textcolor{red}{最高权提升得0}\\\\ \u0026=\\kappa^{ij}M_i M_j|u_{\\boldsymbol{M}}\\rangle+\\sum_{\\alpha\\in\\Sigma^+}{\\textcolor{blue}{[H_\\alpha, H_{-\\alpha}]}|u_{\\boldsymbol{M}}\\rangle}\\quad \\textcolor{red}{再次最高权提升得0}\\\\ \u0026=\\kappa^{ij}M_i M_j|u_{\\boldsymbol{M}}\\rangle+\\sum_{\\alpha\\in\\Sigma^+}{\\textcolor{blue}{\\alpha^i K_i}|u_{\\boldsymbol{M}}\\rangle}\\quad \\textcolor{red}{因为是标准形式}\\\\ \u0026=(\\textcolor{blue}{\\boldsymbol{M}\\cdot\\boldsymbol{M}} )|u_{\\boldsymbol{M}}\\rangle+\\sum_{\\alpha\\in\\Sigma^+}{(\\textcolor{blue}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{M}} )|u_{\\boldsymbol{M}}\\rangle}\\quad \\textcolor{red}{改写成内积形式}\\\\ \u0026=(\\boldsymbol{M}\\cdot\\boldsymbol{M} )|u_{\\boldsymbol{M}}\\rangle+\\textcolor{blue}{2(\\boldsymbol{g}\\cdot\\boldsymbol{M} )}|u_{\\boldsymbol{M}}\\rangle\\quad \\textcolor{red}{\\boldsymbol{g}=\\frac{1}{2}\\sum_{\\alpha\\in\\Sigma^+}{\\boldsymbol{\\alpha}}}\\\\ \u0026=\\left\\{\\textcolor{red}{\\boldsymbol{M}\\cdot(\\boldsymbol{M} +2\\boldsymbol{g})}\\right\\}|u_{\\boldsymbol{M}}\\rangle\\end{aligned} \\]  对特定不可约表示而言，上一篇笔记已经详细介绍了最高权的计算。所以，二次Casimir算符的本征值问题，就此解决。\n广义Casimir不变算符 广义Casimir不变算符【以前的笔记涉及过】\n\\[ I_n=C^{\\beta_1}_{\\ \\ \\alpha_1\\beta_2}C^{\\beta_2}_{\\ \\ \\alpha_2\\beta_3}\\dots C^{\\beta_n}_{\\ \\ \\alpha_n\\beta_1}E^{\\alpha_1}E^{\\alpha_2}\\dots E^{\\alpha_n},\\quad n\\ge2 \\\\ E^\\alpha=\\kappa^{\\alpha\\beta}E_\\beta \\]  关键点是：不全是独立的，我们的目标是找出所有独立的Casimir不变算符。\nG. Racah证明了：\n 对 \\(l\\)  秩半单李代数，可构造出 \\(l\\)  个不变算符，而它们的本征值可以完全标记这个半单李代数的不可约表示。\n 特别地，G. Racah还证明了各种情况下的独立Casimir不变算符：\n\\[ \\begin{aligned}A_l:\\qquad \u0026 I_2,I_3,\\dots,I_{l+1}\\\\ B_l:\\qquad \u0026 I_2,I_4,\\dots,I_{2l} \\\\ C_l:\\qquad \u0026 I_2,I_4,\\dots,I_{2l} \\\\ D_l:\\qquad \u0026 I_2,I_4,\\dots,I_{2l-2},\\textcolor{red}{I_l},\\quad \\textcolor{red}{红色标记的部分感觉是错的} \\\\ G_2:\\qquad \u0026 I_2,I_6\\\\ F_4:\\qquad \u0026 I_2,I_6,I_8,I_{12} \\\\ E_6:\\qquad \u0026 I_2,I_5,I_6,I_8,I_9,I_{12} \\\\ E_7:\\qquad \u0026 I_2,I_6,I_8,I_{10},I_{12},I_{14},I_{18}\\\\ E_8:\\qquad \u0026 I_2,I_8,I_{12},I_{14},I_{18},I_{20},I_{24},I_{30} \\end{aligned} \\]  以后，我们只需要查这个表，针对性，直接算出对应的不变算符。就算找到了所有独立的Casimir不变算符。\n非半单李群的不变算符 非半单李群，比如欧几里得群和庞加莱群。一般而言，无法找出嘉当度规，因此无法构造正常意义下的Casimir算符，但不妨碍构造出一种与所有无穷小算符都对易的不变算符。 不妨也称之为Casimir不变算符。\n \\(n\\)  个参数 \\((a_1,\\dots,a_n)\\)  的任意李群的独立Casimir算符的个数\n\\[ l=n-\\mathrm{rank}\\ \\textcolor{red}{C^\\sigma_{\\ \\ \\mu\\upsilon} a_\\sigma},\\quad \\textcolor{red}{标注的部分是n\\times n 矩阵} \\]  根据这个定理，可以算出（十个参数）庞加莱群的独立Casimir算符个数（一共两个）：\nusing SymPy using LinearAlgebra # Levi-Civita记号 ε= [ Sym((length(Set([i,j,k]))==3)* # 存在重复指标，取0 (-1)^(sum([i,j,k][σ]\u0026gt;[i,j,k][ρ] for σ in 1:3,ρ in 1:3 if σ\u0026lt;ρ) % 2)) # 计算逆序数。偶数取1，奇数取-1 for i in 1:3, j in 1:3, k in 1:3 ] ; # 单位矩阵 δ = sympy.diag(1,1,1); # 庞加莱群李代数的结构常数 C=[Sym(0) for i in 1:10 , j in 1:10 , k in 1:10]; C[5:7,5:7,5:7]=IM*ε; C[8:10,8:10,5:7]=-IM*ε; C[2:4,5:7,2:4]=IM*ε; C[5:7,2:4,2:4]=-IM*ε; C[1,8:10,2:4]=IM*δ; C[8:10,1,2:4]=-IM*δ; C[2:4,8:10,1]=IM*δ; C[8:10,2:4,1]=-IM*δ; C[5:7,8:10,8:10]=IM*ε; C[8:10,5:7,8:10]=-IM*ε; # 庞加莱群的十个参数 @vars p0 p1 p2 p3 j1 j2 j3 k1 k2 k3 real=true a=[p0,p1,p2,p3,j1,j2,j3,k1,k2,k3]; # 庞加莱群的十个无穷小生成元 @vars P0 P1 P2 P3 J1 J2 J3 K1 K2 K3 real=true E=[P0,P1,P2,P3,J1,J2,J3,K1,K2,K3]; # 和结构常数对比 [sum(C[i,j,k]*E[k] for k in 1:10) for i in 1:10,j in 1:10] # 计算红色部分的秩 CA = [sum(C[i,j,k]*a[k] for k in 1:10) for i in 1:10,j in 1:10]; CA.rank() 计算结果如图：\n庞加莱群是一个非半单李群，因为对应的Killing型是退化的\n所以，无法按半单李群的Casimir算符的计算公式得到庞加莱群的不变算符。\n我翻了很多书，都没说清楚非半单李群的不变算符如何得到？？？？。 这些书都是直接给出两个不变算符，然后验证的确是不变算符（和其它算符对易），又因为前面的定理（计算）可以保证只有两个独立不变算符，所以完整了。\n\\[ \\boxed{P^2=P_\\mu P^\\mu,\\qquad W^2=W_\\mu W^\\mu}\\\\ W^\\mu=-\\frac{1}{2}\\varepsilon^{\\mu\\upsilon\\rho\\sigma}J_{\\upsilon\\rho}P_\\sigma\\\\ J^{\\upsilon\\rho}=\\begin{pmatrix}0 \u0026 -K^1 \u0026 -K^2 \u0026 -K^3\\\\K^1 \u0026 0 \u0026 J^3 \u0026 -J^2\\\\K^2 \u0026 -J^3 \u0026 0 \u0026 J^1\\\\K^3 \u0026 J^2 \u0026 -J^1 \u0026 0\\end{pmatrix} \\] "}),a.add({id:91,href:'/notes/categories/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/',title:"微分几何",content:""}),a.add({id:92,href:'/notes/tags/%E6%9D%8E%E4%BB%A3%E6%95%B0/',title:"李代数",content:""}),a.add({id:93,href:'/notes/docs/diffgeo/0084/',title:"半单李代数的根系、权系和Dynkin图",content:" Dynkin图，可以完全确定“单根矢量几何”，所有根矢量都可用单根线性表出。\n根系虽然不唯一，但这种不唯一性不会导致“几何”意义上的变化。\n权，就是零根空间（嘉当子代数）所有基底的共同本征矢对应的本征根组成的矢量。而这个共同本征矢被称作权矢量。\n非零根标准基底对应升降算符。正根对应升算符，负根对应降算符。\n权矢量在升降算符的作用后，依然是权矢量，并且对应的权被提高或降低了。\n如果某个权矢量被升算符作用后得零，那么该权矢量是最高权矢量，对应的权是最高权。\n通过Dynkin图可衍生出不可约表示图，利用相关性质容易计算出不可约表示维度。\n 单根系 所谓不可约，就是不存在非平凡理想。所谓平凡，就是空集(0)和自身两种情况。\n所谓完全可约，就是指可表示有限个不可约表示的直和。\n所谓正根，就是在   \\(l\\)  维零根空间中，第一个不为零的坐标为正的根。比如 \\((0,0,\\textcolor{red}{1},-1)\\)  。根据半单李代数的对称性，必有对应的负根。 所有的正根集记作 \\(\\Sigma^+\\)  。\n一个根比另一个根更大 \\(\\boldsymbol{\\alpha}\\boldsymbol{\\beta}\\)  ，指 \\(\\boldsymbol{\\alpha}-\\boldsymbol{\\beta}\\)  是正的。\n所谓单根（又叫素根），也是一个正根，但无法将其分解成其它正根之和。比如：以 \\(B_2\\)  代数为例只有两个单根 \\(\\textcolor{blue}{(0,1)},\\textcolor{blue}{(1,-1)}\\)  ，而 \\((1,0)=\\textcolor{blue}{(1,-1)}+\\textcolor{blue}{(0,1)}\\)  和 \\((1,1)=\\textcolor{blue}{(0,1)}+(1,0)\\)  不是单根。\n关于单根有一个定理：\n  \\(l\\)  秩半单李代数，正好有 \\(l\\)  个单根，记作 \\(\\Pi=\\{\\boldsymbol{\\alpha}_1,\\dots,\\boldsymbol{\\alpha}_1\\}\\subset\\Sigma^+\\)  （约定从小到大排序），被称作单根系或 \\(\\pi\\)  系。有如下性质：\n1）任意两个不同单根的内积非正： \\(\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}\\le 0,\\quad\\boldsymbol{\\alpha}\\ne\\boldsymbol{\\beta}\\quad\\boldsymbol{\\alpha},\\boldsymbol{\\beta}\\in \\Pi \\)  ；\n2）任意根都可写成单根的线性组合： \\(\\boldsymbol{\\alpha}=\\pm\\sum^l_{i=1}{m_i\\boldsymbol{\\alpha}_i},\\quad m_i\\in \\mathbb{Z}^+\\cup\\{0\\},\\quad\\boldsymbol{\\alpha}_i\\in \\Pi,\\quad \\forall \\boldsymbol{\\alpha}\\in\\Sigma\\)   单根之间的关系 沿用上一篇的结论\n\\[ \\cos^2\\varphi=\\frac{1}{4}\\frac{2\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\frac{2\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\beta}\\cdot\\boldsymbol{\\beta}}=0,\\frac{1}{4},\\frac{1}{2},\\frac{3}{4}，1 \\]  对两个单根而言有附加条件\n\\[ \\varphi\\ne 180^\\circ \\Longrightarrow \\boxed{\\cos^2\\varphi\\ne 1}\\\\\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}\\le 0\\Longrightarrow \\boxed{\\cos\\varphi=\\frac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{|\\boldsymbol{\\alpha}||\\boldsymbol{\\beta}|}\\le 0} \\]  所以只有四种情况\n\\[ \\boxed{\\varphi=90^\\circ,120^\\circ,135^\\circ,150^\\circ} \\]  这四种情况的单根矢量关系：\n\\[ \\boxed{\\def\\arraystretch{1.5} \\begin{array}{c:c:c:c} \\varphi=90^\\circ \u0026 \\varphi=120^\\circ \u0026 \\varphi=135^\\circ \u0026 \\varphi=150^\\circ \\\\ \\hline 垂直 \u0026 等长 \u0026 长\\sqrt{2}倍比 \u0026 长\\sqrt{3}倍比 \\\\ \\hdashline \\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}=0 \u0026 |\\boldsymbol{\\alpha}|=|\\boldsymbol{\\beta}| \u0026 \\dfrac{|\\boldsymbol{\\alpha}|}{|\\boldsymbol{\\beta}|}=\\sqrt{2},\\dfrac{1}{\\sqrt{2}} \u0026 \\dfrac{|\\boldsymbol{\\alpha}|}{|\\boldsymbol{\\beta}|}=\\sqrt{3},\\dfrac{1}{\\sqrt{3}}\\end{array}} \\]  Dynkin图（单根角图）  根系图只能绘制秩 \\(l=1,2\\)  的情况； 而单根角图能绘制 \\(l2\\)  的任意情况。\n 绘制约定：\n 1）空圆表示长根，实圆表示短根； 2）相互正交（ \\(90^\\circ\\)  ）不连线； \\(120^\\circ\\)  夹角连一线； \\(135^\\circ\\)  夹角连两线； \\(150^\\circ\\)  夹角连三线。 3）从左到右的单根，按从小到大排列。 4）任意一点不能有三条以上的线相连；必须是树形，不能包含闭环。 5）合法角图中，若将简单链缩为一点，依然是合法角图。 所谓“简单链”，就是单重连线的一个链。【通过缩为一点判断角图的合法性】。 比如下面这个角图是不合法的  对于1和2秩的Dynkin图见下图的蓝色部分：\n以Dynkin图分类根系 下图是单李代数的所有分类。\n关于根系的不唯一性 先回顾“半单李代数标准形式”的本征方程【见上一篇笔记】\n\\[ (\\mathrm{ad}_A)^a_{\\ \\ b}X^b=\\lambda X^a \\]  虽然 \\(A^a\\)  的选取有一定的\u0026quot;自由\u0026quot;，但不完全自由，因为必须要保证本征根的非重根的个数最多。在这种情况下，只有零根可能存在重根。并且所选的 \\(A^a\\)  只能出现在零根空间（嘉当子代数）中，即\n\\[ A^a=\\chi^i(K_i)^a \\]  进而，以作为 \\(\\{\\chi^i\\}\\)  作为“基底”，可将本征根表出【加粗的“矢量”就是根矢量】：\n\\[ \\alpha=\\chi^i\\alpha_i,\\quad \\boldsymbol{\\alpha}\\overset{\\Delta}{=}(\\alpha_1,\\dots,\\alpha_l) \\]  由此可见\n 从实数根的角度看， \\(A^a\\)  在嘉当子代数（零根空间）的不同选择，只会导致所有实数根乘上一个比例系数。【总结： \\(A^a\\)  的选择可能会导致整个“根矢量几何”等比放大或缩小】 从根矢量的角度看，对于同一个实数根， \\(A^a\\)  的选择虽然会改变根矢量的分量。但是不会改变根矢量和实数根的正负对应性，也不会改变任意两个根矢量的“几何”关系。 【总结： \\(A^a\\)  的选择可能会导致整个“根矢量几何”的旋转】  所以，根系的不唯一性，不会导致“几何”意义上的变化。\n权与权空间 考虑 \\(l\\)  秩李代数 \\(\\mathscr{L}\\)  的伴随表示 \\(\\hat{L}\\)  \\[ \\boxed{\\begin{aligned}\\hat{L}:\u0026\\mathscr{L}\\to \\mathscr{GL}(m,\\mathbb{C})\\\\ \u0026A\\mapsto \\hat{L}(A)\\overset{\\Delta}{=}\\textcolor{red}{\\mathrm{ad}_A}\\quad\\qquad\\qquad \\textcolor{blue}{伴随表示习惯写法}\\\\ \u0026\\qquad\\qquad =(\\mathrm{ad}_A)^a_{\\ \\ b}=A^c C^a_{\\ \\ cb}\\quad \\textcolor{blue}{抽象指标写法} \\end{aligned}} \\]  选择标准基 \\(\\{(K_i)^a,(H_\\alpha)^a\\}\\)  ，由于 \\(\\hat{L}(K_i), i=1,\\dots,l\\)  是相互对易的，所以有共同的本征矢 \\(\\textcolor{red}{|u\\rangle\\overset{\\Delta}{=}u^a\\in \\mathscr{L}}\\)  \\[ \\hat{L}(K_i)|u\\rangle=\\Lambda_i |u\\rangle,\\quad i=1,\\dots,l \\]  可以将不妨将 \\(\\boldsymbol{\\Lambda}=(\\Lambda_1,\\dots,\\Lambda_l)\\)  看成一个 \\(l\\)  维矢量，称为权，所以被认为是 \\(l\\)  维权空间 \\(\\Delta_{\\hat{L}}\\)  。\n一般而言，\u0026lsquo;权\u0026rsquo;，是一个\u0026quot;矢量\u0026quot;，但不叫“权矢量”；权矢量，特指权 \\(\\boldsymbol{\\Lambda}\\)  对应的本征矢量 \\(|u_\\boldsymbol{\\Lambda}\\rangle\\)  。\n有时也经常直接用“权”来表示权矢量，比如：权 \\(\\boldsymbol{\\Lambda}=(1,2,3)\\)  ，对应的权矢量也可记作 \\(|u_\\boldsymbol{\\Lambda}\\rangle=|123\\rangle\\)  。此时，“权”就是“权矢量”。\n对于给定权 \\(\\boldsymbol{\\Lambda}\\)  ，可能有多个本征矢（简并的），非简并的权，称作单权。\n所谓正权，在 \\(l\\)  维权空间中，是和“正根”完全对标的类似概念。一个权比另一个权更高 \\(\\boldsymbol{\\Lambda_1}\\boldsymbol{\\Lambda_2}\\)  ，指 \\(\\boldsymbol{\\Lambda_1}-\\boldsymbol{\\Lambda_2}\\)  是正的。\n【注意区分】权 \\(\\boldsymbol{\\Lambda}=(\\Lambda_1,\\dots,\\Lambda_l)\\in\\Delta_{\\hat{L}}\\)  和根矢量 \\(\\boldsymbol{\\alpha}=(\\alpha_1,\\dots,\\alpha_l)\\in\\Sigma\\)   根矢量，粗略来说，就是标准形式下非零根在**零根空间（嘉当子代数）**下分量组成“矢量”，由标准分解唯一确定，进而由李代数 \\(\\mathscr{G}\\)  本身唯一确定。所以非零根矢量空间 \\(\\Sigma\\)  没加下标。 根矢量的概念涉及李代数的结构。 权，伴随表示 \\(\\hat{L}\\)  作用于**零根空间（嘉当子代数）**所有标准基后，共同本征矢各自对应的本征根组成“矢量”。所以，权空间 \\(\\Delta_{\\hat{L}}\\)  有下标，表示依赖李代数 \\(\\mathscr{G}\\)  的一个伴随表示 \\(\\hat{L}\\)  。权的概念涉及李代数的表示。  关于李代数的表示论，有一个重要的定理\n 考虑伴随表示 \\(\\hat{L}\\)  的一个权 \\(\\boldsymbol{\\Lambda}\\)  ，及其对应的本征矢 \\(|u_\\boldsymbol{\\Lambda}\\rangle\\)  ，并设 \\(\\Sigma\\)  是李代数 \\(\\mathscr{L}\\)  的非零根系。 如果 \\(\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\ne 0,\\quad \\boldsymbol{\\alpha}\\in\\Sigma\\)  ，那么 \\(\\boldsymbol{\\Lambda}+\\boldsymbol{\\alpha}\\)  也是表示 \\(\\hat{L}\\)  的一个权，并且对应的本征矢就是 \\(\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\)  。 如果 \\(\\boldsymbol{\\Lambda}+\\boldsymbol{\\alpha}\\)  不是权，那么 \\(\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle=0\\)  。\n 因为【提要】\n\\[ \\begin{aligned}\\quad \u0026\\hat{L}(K_i)\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\\\ =\u0026[\\hat{L}(K_i),\\hat{L}(H_\\alpha)]|u_\\boldsymbol{\\Lambda}\\rangle+\\hat{L}(H_\\alpha)\\hat{L}(K_i)|u_\\boldsymbol{\\Lambda}\\rangle\\\\ =\u0026\\hat{L}([K_i,H_\\alpha])|u_\\boldsymbol{\\Lambda}\\rangle+\\Lambda_i\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\quad \\textcolor{red}{保李括号}\\\\ =\u0026\\hat{L}(\\alpha_i H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle+\\Lambda_i\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\quad \\textcolor{red}{因为标准基}\\\\ =\u0026(\\alpha_i+\\Lambda_i)\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle\\\\ \\Longleftrightarrow \\qquad \u0026 \\boxed{\\hat{L}(K_i)\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle=(\\Lambda_i+\\alpha_i)\\hat{L}(H_\\alpha)|u_\\boldsymbol{\\Lambda}\\rangle} \\end{aligned} \\]  由此可见：【假设 \\(\\alpha\\)  是正根】\n  \\(\\hat{L}(H_\\alpha)\\)  的作用，使本征矢量 \\(|u_\\boldsymbol{\\Lambda}\\rangle\\)  （态）的权 \\(\\boldsymbol{\\Lambda}\\)  升高一个正根 \\(\\boldsymbol{\\alpha}\\)  ，所以 \\(H_\\boldsymbol{\\alpha}\\)  被称作升算符；  \\(\\hat{L}(H_{-\\alpha})\\)  的作用，使 \\(|u_\\boldsymbol{\\Lambda}\\rangle\\)  的权 \\(\\boldsymbol{\\Lambda}\\)  降低一个 \\(\\boldsymbol{\\alpha}\\)  ，所以 \\(H_{-\\boldsymbol{\\alpha}}\\)  被称作降算符。  权系的一些性质 所谓权系和根系有密切关系。\n考虑 \\(\\hat{L}\\)  是半单李代数 \\(\\mathscr{L}\\)  的一个不可约表示， \\(\\boldsymbol{\\Lambda}\\in \\Delta_{\\hat{L}},\\boldsymbol{\\alpha}\\in \\Sigma\\)  ，于是有\n 1） \\(2\\dfrac{\\boldsymbol{\\Lambda}\\cdot\\boldsymbol{\\alpha}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\in \\mathbb{Z}\\)  ，而 \\(\\boldsymbol{\\Lambda}-2\\dfrac{\\boldsymbol{\\Lambda}\\cdot\\boldsymbol{\\alpha}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\boldsymbol{\\alpha}\\in \\Delta_{\\hat{L}}\\)  ，它与 \\(\\boldsymbol{\\Lambda}\\)  被称为等价的权。\n  2）等价的权具有相同的简并度。\n  3）设 \\(\\boldsymbol{\\Lambda}\\)  是单权，若 \\(\\boldsymbol{\\Lambda}+k\\boldsymbol{\\alpha}\\in \\Delta_{\\hat{L}},k\\in \\mathbb{Z}\\)  ，则 \\(k\\)  必有上下限 \\(-p\\le k\\le q,\\quad p,q\\ge 0\\)  ，并且 \\(2\\dfrac{\\boldsymbol{\\Lambda}\\cdot\\boldsymbol{\\alpha}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}=p-q\\)  。\n 最高权(首权) 在有限维表示中，必有一个最高权 \\(\\boldsymbol{M}\\)  ，升算符作用到最高权矢量上得零：\n\\[ \\hat{L}(H_\\alpha)|u_\\boldsymbol{M}\\rangle=0,\\quad \\alpha0 \\]  这也是计算最高权得主要方法。\n关于最高权有两个重要定理：\n 单李代数不可约表示的最高权是单权，两个不可约表示等价的充要条件是它们的最高权相等。\n最高权可表示为单根的线性组合。\n 根据权系性质，一个不可约半单李代数可完全用首权来标记：\n\\[ \\boxed{n_i=\\frac{2\\boldsymbol{M}\\cdot\\boldsymbol{\\alpha}_i}{\\boldsymbol{\\alpha}_i\\cdot\\boldsymbol{\\alpha}_i}\\in \\mathbb{N}\\cup\\{0\\}},\\quad i = 1,\\dots,l,\\quad \\boldsymbol{\\alpha}_i\\in \\Pi \\]  根据这个定理，对于一个李代数，首先画出对应的单根图（Dynkin图），然后再每个单根上方用非负整数 \\(n_i\\)  标记，于是这个图就代表这个李代数的一个特定不可约表示图。一般而言，可用 \\(l\\)  个非负整数 \\(\\textcolor{red}{(n_1,\\dots,n_l)}\\)  来标记一个不可约表示。比如：\n图中所谓“简单线性方程”，实际就是下面方框中的方程： \\[ \\boldsymbol{M} =\\sum^l_{i=k}{\\textcolor{red}{b_k}\\boldsymbol{\\alpha}_k}\\quad \\textcolor{red}{b_k 是待定系数}\\\\ \\frac{2\\boldsymbol{M}\\cdot\\boldsymbol{\\alpha}_i}{\\boldsymbol{\\alpha}_i\\cdot\\boldsymbol{\\alpha}_i}=\\boxed{2\\sum^l_{k=1}{\\left(\\frac{\\boldsymbol{\\alpha}_k\\cdot\\boldsymbol{\\alpha}_i}{\\boldsymbol{\\alpha}_i\\cdot\\boldsymbol{\\alpha}_i}\\right)\\textcolor{red}{b_k}}=n_i} \\]  不可约表示的维数 前面通过不可约表示图可求出首权（最高权），而不可约表示维数的计算与首权有密切的联系。\n 考虑半单李代数 \\(\\mathscr{L}\\)  的一个不可约表示 \\(\\hat{L}\\)  ，其首权为 \\(M\\)  ，那么不可约表示的维数是 \\(\\dim \\hat{L}=\\prod\\limits_{\\boldsymbol{\\alpha}\\in\\Sigma^+}{\\dfrac{(\\boldsymbol{M}+\\boldsymbol{g})\\cdot\\boldsymbol{\\alpha}}{\\boldsymbol{g}\\cdot\\boldsymbol{\\alpha}}},\\quad \\boldsymbol{g}=\\dfrac{1}{2}\\sum\\limits_{\\boldsymbol{\\alpha}\\in \\Sigma^+}{\\boldsymbol{\\alpha}}\\)   经过简单细致计算不难算出， \\(A_2\\)  的不可约表示 \\((n,m)\\)  维数是 \\((3n+1)(3m+1)\\)  。【计算过程和下面例子的完全类似】\n最简单代数 \\(A_1\\)  （对应 \\(\\mathrm{SU}(2)\\)  群）：\n"}),a.add({id:94,href:'/notes/tags/%E6%9D%83%E7%B3%BB/',title:"权系",content:""}),a.add({id:95,href:'/notes/tags/%E6%A0%B9%E7%B3%BB/',title:"根系",content:""}),a.add({id:96,href:'/notes/tags/%E5%85%B8%E5%9E%8B%E7%BE%A4/',title:"典型群",content:""}),a.add({id:97,href:'/notes/docs/diffgeo/0083/',title:"半单李代数的标准形式",content:" 用图示方法梳理典型群。\n一个半单李代数的结构由一组根向量决定。\n所谓根矢量，就是在标准形式下，非零本征根在零根空间中的分量。\n所谓标准形式，选择某个特定基底的李代数表示，这组特定基底满足：具有最多非重根数（实数根）。\n所谓零根空间，就是零本征根（可能有重根）的所有本征矢量张成的空间。\n所谓根系，就是半单李代数标准形式下的所有本征根，有时简称“根”。如果没有加粗，表示实数根   \\(\\alpha\\)  ；如果加粗了，表示根矢量 \\(\\boldsymbol{\\alpha}\\)  。\n嗅到一股量子力学的味道。\n最后是根矢量图示法。\n本篇草稿： https://gitee.com/chaoskey/notes/blob/master/code/0083.ipynb\n 典型群 一些概念的补缺  只补充我以前笔记尚未涉及的、我认为必要的。 用纯语言进行提要。\n 所谓李代数的理想,，就是一个“好的”李子代数。所谓“好的”，这个子代数和整个李代数的李括号封闭到这个子代数自身。所以，这个理想又被称作不变李子代数。\n所谓李代数的中心，就是一个极大可交换理想，即所有的两个元素的李括号等于0.\n关于李代数的伴随表示，上一篇笔记有详细的介绍。\n所谓单李代数，就是指“单纯的”李代数。所谓“单纯的”，就是指不含真理想。\n所谓半单李代数，就是指“半单纯的”李代数。所谓“半单纯的”，就是除 \\(\\{0\\}\\)  外，不含可交换理想（即，阿贝尔理想）。\n单纯李代数必定是半单李代数，反过来不一定正确。 有一个定理如下：\n  \\(\\mathscr{G}\\)  是半单李代数，当且仅当， \\(\\mathscr{G}\\)  可表示为一些理想的直和，并且这些理想都是单李代数。\n 还有一个定理，可更方便判断李代数是否是半单的，上一篇笔记也有涉及。\n 李代数是半单的，当且仅当，对应的Killing型式非退化的，即存在嘉当度规。\n 各种李代数的相互关系  由于我只关心半单李代数，这里只列各种李代数的关系，方便有个整体印象。其它我不关心的李代数，请自行翻书。\n 量子力学与李代数  以量子力学为例，来概要说明李代数的重要性。\n 量子力学的数学结构与泛函分析和李代数理论密切相关，其中所涉及的幺正变换（酉变换）还会涉及李群的表示论\u0026mdash;- 更有趣的式，量子力学中的很多方法和结果都可以在半单李代数理论中找到对应，比如：\n 力学量完全集 \\(\\longleftrightarrow\\)  嘉当子代数的基； \u0026ldquo;好\u0026quot;量子数 \\(\\longleftrightarrow\\)  权和最高权 力学量完全集的共同本征矢量 \\(\\longleftrightarrow\\)  权空间中的元素； 升、降算符 \\(\\longleftrightarrow\\)  根向量；  半单李代数的标准形式 考虑半单李代数 \\(\\mathscr{G}\\)  的一组基底 \\(\\{(E_\\mu)^a\\}\\)  ， \\(\\mathscr{G}\\)  中的任意一个元素 \\(A^a\\)  可表示成\n\\[ A^a=A^\\mu (E_\\mu)^a \\]  考虑另一个元素\n\\[ X^a=X^\\mu (E_\\mu)^a \\]  满足：\n\\[ [A,X]^a=\\lambda X^a \\]  可改写伴随变换(算符) \\(\\mathrm{ad}_A\\)  本征方程的形式\n\\[ \\boxed{(\\mathrm{ad}_A)^a_{\\ \\ b} X^b=\\lambda X^a},\\quad (\\mathrm{ad}_A)^a_{\\ \\ b}=A^c C^a_{\\ \\ cb} \\]  对应的分量形式：【方便具体计算】\n\\[ A^\\mu C^\\rho_{\\ \\ \\mu\\upsilon} X^\\upsilon=\\lambda X^\\rho \\]  注意到：虽然本征方程的本征根和本征矢取决于的 \\(A^a\\)  选择，但如果我们附加一个要求：这个特征方程有最大可能的非重根数（实数根），那么不难想到：可以在某种程度上确定 \\(A^a\\)  及其对应的本征根和本征矢。\n实际上，有一个重要的基本定理\u0026ndash;嘉当定理，描述了这种情况下本征根的性质：\n 设选择一个 \\(A^a\\in \\mathscr{G}\\)  ，使得上面这个本征方程有最大的非重根数(实数根)，那么对半单李代数而言，只有0根可能是重根，其它非零根不可能是重根。\n 求标准形式的一个例子 现在以 \\(\\mathscr{G}=\\mathscr{SO}(3)\\)  为例，求这种情况下的 \\(A^a\\)  及其对应的本征根和本征矢量。【用Julia求解，具体看我的草稿】\n首先，求解一般情况下的本征根（复数域）\n然后，为了确保出现最大可能非重根数（实数根），根号内必取正，于是可选择特定 \\(A^\\mu\\)  ： \\(a_1=0,a_2=0,a_3=i\\ a,\\quad a0\\)  ，进而可算出对应的本征根和本征矢量\n最后，可写出三个本征根及其本征矢量\n\\[ \\begin{aligned}A^a\u0026=i\\ \\alpha (E_3)^a\\\\ \\quad \\\\ (K_1)^a\u0026=(E_3)^a\\qquad \\qquad \\quad [A,K_1]^a=0 \\\\ (H_{\\pm \\alpha})^a\u0026=(E_1)^a\\pm i\\ (E_2)^a\\quad [A,H_{\\pm \\alpha}]^a=\\pm \\alpha (H_{\\pm \\alpha})^a\\end{aligned} \\]  所以， \\(\\mathscr{SO}(3)\\)  标准形式基底为：【随后的段落将解释标准形式的本征矢量为何要用 \\(K,H\\)  两个符号区分】\n\\[ \\{(K_1)^a,(H_{\\pm\\alpha})^a\\} \\]  嘉当李子代数（零根空间）  有了上面这个具体例子提供的感性认识下，我们可以继续讨论。\n 在这个标准形式下，如果0的重根数（简并度）为 \\(l\\)  ，那么称 \\(l\\)  为半单李代数的秩。对应 \\(l\\)  个线性无关的本征矢 \\(\\{(K_i)^a\\}\\)  ，并且可张成李代数 \\(\\mathscr{G}\\)  的一个 \\(l\\)  维零根空间\n\\[ \\boxed{\\mathscr{K}=\\mathrm{span}(\\{(K_i)^a\\})}\\\\ \\quad \\\\ [A,\\mathscr{K}]^a=0\\quad \\boxed{[A,K_i]^a=(\\mathrm{ad}_A)^a_{\\ \\ b}(K_i)^b=0},\\quad i=1,\\dots,l \\]  此外，不难验证，这个零根空间 \\(\\mathscr{K}\\)  满足李括号的雅可比恒等式，进而 \\(\\mathscr{K}\\)  是 \\(\\mathscr{G}\\)  的李子代数，称之为嘉当子代数，这是一个阿贝尔李子代数。\n根据嘉当定理，标准形式下，非0根不可能出现重根，所以 \\(\\alpha\\)  根对应的本征矢不妨记作 \\((H_\\alpha)^a\\)  \\[ \\boxed{[A,H_\\alpha]^a=(\\mathrm{ad}_A)^a_{\\ \\ b}(H_\\alpha)^b=\\alpha (H_\\alpha)^a} \\]  标准形式下的结构常数 因为 \\([A,K_i]^a=0,\\quad i=1,\\dots,l\\)  ，所以在标准形式下，我们选择的特定 \\(A^a\\)  可用零根空间的基底展开\n\\[ \\boxed{A^a=\\chi^i(K_i)^a} \\]  容易推导出：\n\\[ \\boxed{\\begin{aligned}(\\mathrm{ad}_A)^a_{\\ \\ b} [K_i,K_i]^b\u0026=0\\\\(\\mathrm{ad}_A)^a_{\\ \\ b} [K_i,H_\\alpha]^b\u0026= \\alpha [K_i,H_\\alpha]^a\\\\(\\mathrm{ad}_A)^a_{\\ \\ b} [H_\\alpha,H_\\beta]^b\u0026= (\\alpha+\\beta) [H_\\alpha,H_\\beta]^a\\end{aligned}} \\]  这意味着， \\([K_i,K_i]^a,[K_i,H_\\alpha]^a,[H_\\alpha,H_\\beta]^b\\)  ，这三个李括号也都算符 \\(\\mathrm{ad}_A\\)  的本征矢。根据嘉当定理，非零本征根是非简并的，进而\n\\[ [K_i,H_\\alpha]^a\\propto (H_\\alpha)^a\\\\ [H_\\alpha,H_\\beta]^a\\propto (H_{\\alpha+\\beta})^a,\\quad \\alpha+\\beta\\ne0 \\]  于是有（分别选取比例系数 \\(\\alpha_i,h_{\\alpha\\beta}\\)  后）\n\\[ \\begin{aligned}\\ [K_i,K_j]^a\u0026=0\\\\ \\ [K_i,H_\\alpha]^a\u0026= \\alpha_i (H_\\alpha)^a\\\\ \\ [H_\\alpha,H_\\beta]^a\u0026=\\begin{cases} h_{\\alpha\\beta}(H_{\\alpha+\\beta})^a \u0026\\text{if } \\alpha+\\beta \\in \\textcolor{red}{\\Sigma}\\verb|\\| \\{0\\} \\\\ 0 \u0026\\text{if } \\alpha+\\beta \\notin \\textcolor{red}{\\Sigma} \\end{cases} \\\\ \\ [H_\\alpha,H_{-\\alpha}]^a\u0026= C^i_{\\ \\ \\alpha,-\\alpha}(K_i)^a\\end{aligned}\\\\ \\boxed{\\alpha=\\chi^i\\alpha_i} \\]  这样，我们就可以把 \\(\\alpha_i,\\quad i=1,\\dots,l\\)  看作是 \\(l\\)  维零根空间的一个矢量的分量， \\(\\chi^i\\)  则可以看成这个矢量空间的基，这样就把一个作为实数的根看成是一个矢量，称为根矢量。不妨用 \\(\\textcolor{red}{\\Sigma}\\)  表示所有根矢量的集合。\n可完整写出这个标准形式下的李代数结构常数\n\\[ \\boxed{\\begin{aligned}C^\\tau_{\\ \\ ij}\u0026=0\\\\ C^\\tau_{\\ \\ i\\alpha}\u0026=\\alpha_i\\delta^\\tau_{\\ \\ \\alpha}\\\\ \\ C^\\tau_{\\ \\ \\alpha\\beta}\u0026=\\begin{cases} h_{\\alpha\\beta}\\delta^\\tau_{\\ \\ \\alpha+\\beta} \u0026\\text{if } \\alpha+\\beta \\in \\Sigma\\verb|\\| \\{0\\} \\\\ 0 \u0026\\text{if } \\alpha+\\beta \\notin \\Sigma \\end{cases} \\\\ \\ C^\\tau_{\\ \\ \\alpha,-\\alpha}\u0026=待定 \\end{aligned}} \\]  标准形式下本征根的对称性 通过反证法，并利用上面的关系取 \\(\\beta=-\\alpha\\)  ，不难证明下面这个定理\n 一个半单李代数，若 \\(\\alpha\\)  是非零实根，那么 \\((-\\alpha)\\)  也一定是它的根。\n 标准形式的归一化 标准型的所有独立本征基底可记作 \\(\\left\\{(K_i)^a,(H_{\\alpha})^a\\right\\}\\)  ，根据这一基底下的结构常数，可算出半单李代数的嘉当度规分量 \\(\\kappa_{\\mu\\upsilon}\\)  \\[ \\begin{aligned}\\kappa_{\\mu\\upsilon}\u0026=C^\\rho_{\\ \\ \\mu\\sigma}C^\\sigma_{\\ \\ \\upsilon\\rho}\\\\ \u0026= C^i_{\\ \\ \\mu j}C^j_{\\ \\ \\upsilon i}+C^\\alpha_{\\ \\ \\mu j}C^j_{\\ \\ \\upsilon\\alpha}+C^i_{\\ \\ \\mu\\beta}C^\\beta_{\\ \\ \\upsilon i}+C^\\alpha_{\\ \\ \\mu\\beta}C^\\beta_{\\ \\ \\upsilon\\alpha} \\end{aligned} \\]  这里对指标作个约定（前面事实上已经用了这个约定）：用 \\(i,j,k\\)  表示0根基底对应的指标， \\(\\alpha,\\beta,\\gamma\\)  表示非0根，并且用根本身作为基底对应的指标。\n零根空间上的嘉当度规分量\n\\[ \\kappa_{ij}=C^\\alpha_{\\ \\ i\\beta}C^\\beta_{\\ \\ j\\alpha}=\\sum_\\alpha {C^\\alpha_{\\ \\ i\\textcolor{blue}{\\alpha}}C^\\textcolor{blue}{\\alpha}_{\\ \\ j\\alpha}}=\\sum_\\alpha {\\alpha_i\\alpha_j}\\\\ \\textcolor{red}{注意：\\beta改成\\alpha是因为其它可能为0\\quad 改用求和号避免混淆} \\]  零根基底和非零根基底对应的嘉当度规分量\n\\[ \\kappa_{k\\gamma}= C^i_{\\ \\ k\\beta}C^\\beta_{\\ \\ \\gamma i}+C^\\alpha_{\\ \\ k\\beta}C^\\beta_{\\ \\ \\gamma\\alpha}= -\\alpha_i\\alpha_k\\delta^i_{\\ \\ \\gamma}+\\alpha_k h_{\\gamma\\alpha}\\delta^\\alpha_{\\ \\ \\alpha+\\gamma}=0 \\]  非零根基底间的嘉当度规分量\n\\[ \\begin{aligned}\\kappa_{\\gamma\\zeta}\u0026= C^i_{\\ \\ \\gamma j}C^j_{\\ \\ \\zeta i}+C^\\alpha_{\\ \\ \\gamma j}C^j_{\\ \\ \\zeta\\alpha}+C^i_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ \\zeta i}+C^\\alpha_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ \\zeta\\alpha}\\\\ \u0026= C^i_{\\ \\ j\\gamma}C^j_{\\ \\ i\\zeta}-C^\\alpha_{\\ \\ j\\gamma}C^j_{\\ \\ \\zeta\\alpha}-C^i_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ i\\zeta}+C^\\alpha_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ \\zeta\\alpha}\\\\ \u0026= \\alpha_i\\alpha_j\\delta^i_{\\ \\gamma}\\delta^j_{\\ \\zeta}-\\alpha_j h_{\\zeta\\alpha}\\delta^\\alpha_{\\ \\ \\gamma}\\delta^j_{\\ \\ \\alpha+\\zeta}-\\alpha_i h_{\\gamma\\beta}\\delta^\\beta_{\\ \\ \\zeta}\\delta^i_{\\ \\ \\gamma+\\beta}+C^\\alpha_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ \\zeta\\alpha}\\\\ \u0026= C^\\alpha_{\\ \\ \\gamma\\beta}C^\\beta_{\\ \\ \\zeta\\alpha}=h_{\\gamma\\beta}h_{\\zeta\\alpha}\\delta^\\alpha_{\\ \\ \\gamma+\\beta}\\delta^\\beta_{\\ \\ \\zeta+\\alpha}\\\\ \u0026=\\sum_{\\alpha=\\gamma+\\beta,\\quad \\beta=\\zeta+\\alpha}{h_{\\gamma\\beta}h_{\\zeta\\alpha}}=\\sum_{\\alpha=\\gamma+\\beta,\\quad \\zeta=-\\gamma}{ h_{\\gamma\\beta}h_{\\zeta\\alpha}}\\\\ \u0026= \\boxed{\\begin{cases} \\sum\\limits_{\\beta}{ h_{\\gamma\\beta}h_{-\\gamma,(\\gamma+\\beta)}} \u0026\\text{if } \\zeta= -\\gamma \\\\ 0 \u0026\\text{if } \\zeta\\ne -\\gamma \\end{cases}}\\end{aligned} \\]  由此可见，在标准形式下的嘉当度规分量，大部分为0。当然嘉度规分量的大小取决于本征基底 \\(\\left\\{(K_i)^a,(H_{\\alpha})^a\\right\\}\\)  的选择。因此，通过适当选取本征基底的大小，一定可以使嘉当度规所有的非0分量归一。在这种归一化基底下，嘉当度规必定有如下形式。\n\\[ \\kappa_{\\mu\\upsilon}=\\begin{array}{cc} \u0026 \\begin{array}{cc} \u0026 \u0026 \u0026 \\alpha \u0026 -\\alpha \u0026 \u0026 \\dots \u0026 \u0026 \u0026\\beta \u0026 -\\beta \\\\ \u0026 \u0026 \u0026 \\downarrow \u0026 \\downarrow \u0026 \u0026 \\dots \u0026 \u0026 \u0026 \\downarrow \u0026 \\downarrow \\end{array} \\\\ \\begin{array}{cc} \\\\ \\alpha \u0026 \\rightarrow \\\\ -\\alpha \u0026 \\rightarrow \\\\ \\vdots \\\\ \\beta \u0026 \\rightarrow \\\\ -\\beta \u0026 \\rightarrow \\end{array} \u0026 \\left(\\def\\arraystretch{1.5}\\begin{array}{c|c} \\{\\kappa_{ij}\\} \u0026 \\boldsymbol{0} \\\\ \\hline \\boldsymbol{0} \u0026 \\begin{array}{cc}0 \u0026 \\ 1 \\ \u0026 0 \u0026 \\dots \u0026 0 \u0026 0 \u0026 \\ 0 \\ \\\\ 1 \u0026 0 \u0026 0 \u0026 \\dots \u0026 0 \u0026 0 \u0026 0 \\\\ \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \u0026 \\vdots \\\\ 0 \u0026 0 \u0026 0 \u0026 \\dots \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 \\dots \u0026 0 \u0026 1 \u0026 0 \\end{array}\\end{array}\\right) \\end{array} \\]  现在关注零根空间的度规，由于\n\\[ \\det\\{\\kappa_{\\mu\\upsilon}\\}\\ne0 \\Longrightarrow \\det\\{\\kappa_{ij}\\}\\ne0 \\]  所以可以引入零根空间的逆度规 \\(\\{\\kappa^{ij}\\}\\)  ，进而\n\\[ \\begin{aligned}h^i_{\\ \\alpha,-\\alpha}\u0026=C^i_{\\ \\alpha,-\\alpha}=\\kappa^{ik}C_{k,\\alpha,-\\alpha}\\\\\u0026=\\kappa^{ik}C_{-\\alpha,k,\\alpha}=\\kappa^{ik}\\kappa_{\\alpha,-\\beta}C^{\\beta}_{\\ \\ k,\\alpha}\\\\\u0026=\\kappa^{ik}\\kappa_{\\alpha,-\\alpha}C^{\\alpha}_{\\ \\ k,\\alpha}=\\kappa^{ik}C^{\\alpha}_{\\ \\ k,\\alpha}\\quad \\textcolor{red}{因为标准化}\\\\ \u0026= \\kappa^{ik}\\alpha_k= \\alpha^i \\quad \\textcolor{red}{上行两重复指标\\alpha不是求和}\\end{aligned} \\]  这说明\n\\[ [H_\\alpha,H_{-\\alpha}]^a=\\alpha^i(K_i)^a \\]  小结 李代数标准形式的可总结如下：\n\\[ \\boxed{\\begin{aligned}\\ [K_i,K_j]^a\u0026=0\\\\ \\ [K_i,H_\\alpha]^a\u0026= \\alpha_i (H_\\alpha)^a\\\\ \\ [H_\\alpha,H_\\beta]^a\u0026=\\begin{cases} h_{\\alpha\\beta}(H_{\\alpha+\\beta})^a \u0026\\text{if } \\alpha+\\beta \\in \\Sigma\\verb|\\| \\{0\\} \\\\ 0 \u0026\\text{if } \\alpha+\\beta \\notin \\Sigma \\end{cases}\\\\ \\ [H_\\alpha,H_{-\\alpha}]^a\u0026= \\alpha^i(K_i)^a\\end{aligned}} \\]  今后，称这组基为李代数 \\(\\mathscr{G}\\)  的标准基，有时也称为嘉当-外尔基。\n常数 \\(h_{\\alpha\\beta}\\)  可以有一定的选择自由度，一种选择是使基反称\n\\[ \\boxed{h_{\\alpha\\beta}=-h_{\\beta\\alpha}=h_{-\\alpha,-\\beta}=-h_{-\\beta,-\\alpha}} \\]   \\(\\mathrm{span}\\{(K_i)^a\\}\\)  构成了李代数 \\(\\mathscr{G}\\)  的最大阿贝尔子代数。\n一个半单李代数的结构由一组根向量决定。\n根系的一些性质 所谓根系，就是半单李代数标准形式下的所有本征根，有时简称“根”。如果没有加粗，表示实数根 \\(\\alpha\\)  ；如果加粗了，表示根矢量 \\(\\boldsymbol{\\alpha}\\)  。\n 如果 \\(\\boldsymbol{\\alpha}\\)  和 \\(\\boldsymbol{\\beta}\\)  是根，那么 \\(2\\dfrac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\)  必然是一个整数，并且 \\(\\boldsymbol{\\beta}-2\\dfrac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\boldsymbol{\\alpha}\\)  也是一个根。\n  如果 \\(\\boldsymbol{\\alpha}\\)  是根，那么， \\(\\boldsymbol{\\beta}=k \\boldsymbol{\\alpha}\\)  也是根，仅当 \\(k=0,\\pm 1\\)  时。\n  包含 \\(\\boldsymbol{\\beta}\\)  的 \\(\\boldsymbol{\\alpha}\\)  根链： \\(\\dots,\\boldsymbol{\\beta}+2\\boldsymbol{\\alpha},\\boldsymbol{\\beta}+\\boldsymbol{\\alpha},\\boldsymbol{\\beta},\\boldsymbol{\\beta}-\\boldsymbol{\\alpha},\\boldsymbol{\\beta}-2\\boldsymbol{\\alpha},\\dots\\)  ，最多只可能有四个根，即： \\(2\\dfrac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}=0,\\pm 1,\\pm 2,\\pm 3\\)  。\n 根矢量图示法 根系的性质中，其中最让人侧目的是\n\\[ \\boxed{2\\frac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\in \\mathbb{Z}} \\]  若令\n\\[ \\cos\\varphi=\\frac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{|\\boldsymbol{\\alpha}||\\boldsymbol{\\beta}|} \\]  则\n\\[ \\begin{aligned}\\cos^2\\varphi\u0026=\\frac{1}{4}\\left(2\\frac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\alpha}}\\right)\\left(2\\frac{\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}}{\\boldsymbol{\\beta}\\cdot\\boldsymbol{\\beta}}\\right)\\\\ \u0026=\\boxed{0,\\frac{1}{4},\\frac{1}{2},\\frac{3}{4},1}\\end{aligned} \\]  由于“若 \\(\\boldsymbol{\\alpha}\\)  是根矢量，那么 \\(-\\boldsymbol{\\alpha}\\)  也是根矢量”，那么只需考虑5种情况。\n\\[ \\boxed{\\varphi=0^\\circ,30^\\circ,45^\\circ,60^\\circ,90^\\circ} \\]  这5种情况的根矢量关系：\n\\[ \\boxed{\\def\\arraystretch{1.5} \\begin{array}{c:c:c:c:c} \\varphi=0^\\circ \u0026 \\varphi=30^\\circ \u0026 \\varphi=45^\\circ \u0026 \\varphi=60^\\circ \u0026 \\varphi=90^\\circ \\\\ \\hline 全同 \u0026 长\\sqrt{3}倍比 \u0026 长\\sqrt{2}倍比 \u0026 等长 \u0026 垂直 \\\\ \\hdashline \\boldsymbol{\\alpha}=\\boldsymbol{\\beta} \u0026 \\dfrac{|\\boldsymbol{\\alpha}|}{|\\boldsymbol{\\beta}|}=\\sqrt{3},\\dfrac{1}{\\sqrt{3}} \u0026 \\dfrac{|\\boldsymbol{\\alpha}|}{|\\boldsymbol{\\beta}|}=\\sqrt{2},\\dfrac{1}{\\sqrt{2}} \u0026 |\\boldsymbol{\\alpha}|=|\\boldsymbol{\\beta}| \u0026 \\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\beta}=0\\end{array}} \\]  1秩和2秩李代数图示 根据根矢量关系，下面这个根矢量图是很明显的。【Dynkin图见下一篇笔记】\n本篇的主题是半单李代数的标准形式，关于根系的性质点到为止。\n"}),a.add({id:98,href:'/notes/tags/%E5%AF%B9%E7%A7%B0%E6%80%A7/',title:"对称性",content:""}),a.add({id:99,href:'/notes/docs/diffgeo/0082/',title:"李群李代数伴随表示和Killing型、Casimir算符",content:" 同一李群（李代数）有无数表示，本篇侧重伴随表示。\n对半单李代数而言，Killing型就是李代数上的度规，称作嘉当度规。\nCasimir算符，就是和李代数任意元素对易的算符。\n 群的伴随同构 群   \\(G\\)  关于群元 \\(g\\in G\\)  群伴随同构 \\(I_g\\)  \\[ \\boxed{\\begin{aligned}\\textcolor{blue}{I_g}:\u0026G\\overset{\\textcolor{red}{同构}}{\\to} G \\\\ \u0026h \\mapsto \\textcolor{blue}{I_g(h)}\\overset{\\Delta}{=}\\textcolor{red}{ghg^{-1}} \\qquad I_g(e)=e \\end{aligned}} \\]  所以，这是一个单位元不变的群自同构。\n李群的伴随可逆线性变换 特别对李群而言，可在单位元 \\(e\\)  处，通过 \\(I_g\\)  诱导出一个推前映射 \\(\\mathscr{A\\!d}_g\\overset{\\Delta}{=}I_{g*}\\)  \\[ \\boxed{\\begin{aligned}\\textcolor{blue}{\\mathscr{A\\!d}_g}:\u0026\\mathscr{G}\\overset{\\textcolor{red}{线性可逆}}{\\to} \\mathscr{G} \\\\ \u0026A \\mapsto \\textcolor{blue}{\\mathscr{A\\!d}_g(A)}=\\textcolor{red}{\\left.\\frac{d}{dt}\\right|_{t=0}\\left[g\\exp(tA)g^{-1}\\right]}\\end{aligned}} \\]  因为\n\\[ \\begin{aligned}\u0026\\left.\\frac{d}{dt}\\right|_{t=0}\\left[g\\exp(tA)g^{-1}\\right]\\\\ =\u0026\\left.\\frac{d}{dt}\\right|_{t=0}I_g(\\exp(tA))\\qquad \\textcolor{red}{群G的伴随同构}\\\\ =\u0026I_{g*}\\left(\\left.\\frac{d}{dt}\\right|_{t=0}\\exp(tA)\\right)\\qquad \\textcolor{red}{推前映射的性质}\\\\ =\u0026\\mathscr{A\\!d}_g(A)\\qquad \\textcolor{red}{定义及切矢}\\end{aligned} \\]  或者说\n\\[ \\boxed{\\exp(t \\mathscr{A\\!d}_g(A))=g\\exp(t A)g^{-1}} \\]  上面这些关系可图解为\n容易看出：\n1） \\(\\mathscr{A\\!d}_g\\)  是一个线性变换；【因为 \\(I_{g*}\\)  作为推前映射是线性的】\n2） \\(\\mathscr{A\\!d}_g\\)  是一个可逆变换。【因为 \\(I_g\\)  是同构映射，进而 \\(I_{g*}\\)  是可逆的】\n李群的伴随表示 因为 \\(\\mathscr{A\\!d}_g\\)  是可逆线性变换，即 \\(\\mathscr{A\\!d}_g\\in \\mathscr{T}_\\mathscr{G}(1,1)\\)  ，所以 \\(\\mathscr{A\\!d}\\)  也可以看成一个映射\n\\[ \\boxed{\\begin{aligned}\\textcolor{blue}{\\mathscr{A\\!d}}:\u0026G\\overset{\\textcolor{red}{同态}}{\\to} \\mathscr{T}_\\mathscr{G}(1,1)\\cong \\mathrm{GL}(m,\\mathbb{R}) \\\\ \u0026g \\mapsto \\textcolor{blue}{\\mathscr{A\\!d}(g)}\\overset{\\Delta}{=}\\textcolor{red}{\\mathscr{A\\!d}_g}\\end{aligned}} \\]  容易看出：\n1） \\(\\mathscr{A\\!d}\\)  是一个同态映射；【因为推前映射有性质： \\((\\psi\\circ\\phi)_*=\\psi_*\\circ\\phi_*\\)  】\n2）任选可逆 \\(\\mathscr{T}_\\mathscr{G}(1,1)\\)  的一组基底后，同构于 \\(\\mathrm{GL}(m,\\mathbb{R})\\)  。\n所以， \\(\\mathscr{A\\!d}\\)  称为李群 \\(G\\)  的伴随表示。\n李代数的伴随线性变换 利用李代数上的李括号定义一个类似 \\(\\mathscr{A\\!d}_a\\)  的变换 \\(\\mathscr{ad}_A\\)  ：\n\\[ \\boxed{\\begin{aligned}\\textcolor{blue}{\\mathrm{ad}_A}:\u0026\\mathscr{G}\\overset{\\textcolor{red}{线性}}{\\to} \\mathscr{G} \\\\ \u0026B \\mapsto \\textcolor{blue}{\\mathrm{ad}_A(B)}\\overset{\\Delta}{=}\\textcolor{red}{[A,B]}\\end{aligned}} \\]  由李括号的双线性性，容易看出 \\(\\mathrm{ad}_A\\)  是切空间（李代数）上的线性变换，因此可用 \\((1,1)\\)  型张量表示，此外，李代数上的元素自然也是矢量。进而，可用抽象指标重写上面这个映射：\n\\[ (\\mathrm{ad}_A)^c_{\\ \\ b}B^b=[A,B]^c=C^c_{\\ \\ ab}A^a B^b \\]  进而可抛掉被作用对象【其中 \\(\\textcolor{red}{C^c_{\\ \\ ab}}\\)  是李代数 \\(\\mathscr{G}\\)  的结构常数】：\n\\[ \\boxed{(\\textcolor{blue}{\\mathrm{ad}_A})^c_{\\ \\ b}=A^a\\textcolor{red}{C^c_{\\ \\ ab}}} \\]   \\(\\mathscr{A\\!d}_g\\)  和 \\(\\mathrm{ad}_A\\)  有一个重要的关系：\n\\[ \\boxed{\\mathscr{A\\!d}_{\\exp(A)}=\\delta+\\mathrm{ad}_A+\\frac{1}{2!}(\\mathrm{ad}_A)^2+\\frac{1}{3!}(\\mathrm{ad}_A)^3+\\dots} \\]  其中， \\(\\delta\\)  代表恒等映射（ \\(\\delta^a_{\\ \\ b}\\)  ）， \\((\\mathrm{ad}_A)^2\\)  代表恒等映射（ \\((\\mathrm{ad}_A)^a_{\\ \\ c}(\\mathrm{ad}_A)^c_{\\ \\ b}\\)  ），等等。\n因为有这重关系，所以线性变换 \\(\\mathrm{ad}_A\\)  被称作李代数的伴随线性变换。注意，这个线性变换没有可逆的要求。\n李代数的伴随表示 仿照群额伴随表示的分析套路，因为 \\(\\mathrm{Ad}_A\\)  是线性变换（不要求可逆），即 \\(\\mathrm{ad}_A\\in \\mathscr{T}_\\mathscr{G}(1,1)\\)  ，所以 \\(\\mathrm{ad}\\)  也可以看成一个映射\n\\[ \\boxed{\\begin{aligned}\\textcolor{blue}{\\mathrm{ad}}:\u0026\\mathscr{G}\\overset{\\textcolor{red}{线性同态}}{\\to} \\mathscr{T}_\\mathscr{G}(1,1)\\cong \\mathscr{G\\!L}(m,\\mathbb{R}) \\\\ \u0026A \\mapsto \\textcolor{blue}{\\mathrm{ad}(A)}\\overset{\\Delta}{=}\\textcolor{red}{\\mathrm{ad}_A}\\end{aligned}} \\]  注意，这里的 \\(\\mathscr{T}_\\mathscr{G}(1,1)\\)  不要求可逆，所以同构于 \\(\\mathscr{G\\!L}(m,\\mathbb{R}) \\)  。此外还容易看出：\n1） \\(\\mathrm{ad}\\)  是线性映射；【利用李括号的双线性易证】\n2） \\(\\mathrm{ad}\\)  是同态映射。【利用李括号雅可比恒等式易证保李括号】\n所以， \\(\\mathrm{ad}\\)  称为李代数 \\(\\mathscr{G}\\)  的伴随表示。\n至此，我们可发现一个重要而自然的关系：\n\\[ \\boxed{\\mathscr{A\\!d}_*=\\mathrm{ad}} \\]  意思是：李群伴随表示的推前映射就是对应李代数伴随表示。\n各种伴随映射的关系 Killing型 利用李代数的伴随变 \\(\\mathrm{ad}_A\\)  换可以定义Killing型\n\\[ \\begin{aligned}\\kappa:\u0026\\mathscr{G}\\times \\mathscr{G}\\to \\mathbb{R} \\\\ \u0026(A,B)\\mapsto \\kappa(A,B)\\overset{\\Delta}{=}\\mathrm{tr}(\\mathrm{ad}_A\\mathrm{ad}_B)\\\\ \u0026\\qquad \\qquad =(\\mathrm{ad}_A)^a_{\\ \\ b}(\\mathrm{ad}_B)^b_{\\ \\ a}\\end{aligned} \\]  如果如下性质：\n1） \\(\\kappa(A,B)=\\kappa(B,A)\\)  ；【利用两个方阵积的“迹”的可交换性易得】\n2） \\(\\kappa([A,B],C)=\\kappa(A,[B,C])\\)  ；【利用多个方阵乘积的“迹”的可轮换性易证】\n3） \\(\\kappa(A,B)\\)  满足双线性性。【易验证】\n利用李代数结构常数的定义，并在抽象指标表示下，容易推导出：\n\\[ \\boxed{\\kappa_{cd}=C^a_{\\ \\ cb} C^b_{\\ \\ da}} \\]  关于 \\(\\kappa\\)  的非退化性，我们有一个结论【这里我只关心结论不关心证明】：\n  \\(\\kappa\\)  非退化的充要条件 \\(\\mathscr{G}\\)  是为半单李代数。\n 所以，半单李代数 \\(\\mathscr{G}\\)  的Killing型 \\(\\kappa_{ab}\\)  可充当 \\(\\mathscr{G}\\)  的度规，称为嘉当度规。\n需要注意的是， \\(\\kappa_{ab}\\)  的号差因 \\(\\mathscr{G}\\)  而异，但我们关心的物理中遇到的李代数的 \\(\\kappa_{ab}\\)  多半是负定的，因而存在正交归一基底 \\(\\{(E_\\mu)^a\\}\\)  ，使得\n\\[ \\boxed{\\kappa_{\\mu\\upsilon}=\\kappa_{ab}(E_\\mu)^a(E_\\upsilon)^b=-\\delta_{\\mu\\upsilon}} \\]  正如普通的度规，在李代数空间上，嘉当度规 \\(\\kappa_{ab}\\)  也可用来升降指标，比如：\n\\[ C_{\\rho\\mu\\upsilon}=\\kappa_{\\rho\\sigma}C^\\sigma_{\\ \\ \\mu\\upsilon} \\]  进而，关于结构常数，降指标后是全反称额：\n\\[ \\boxed{C_{\\rho\\mu\\upsilon}=C_{[\\rho\\mu\\upsilon]}} \\]  Casimir算符 如果只关心半单李代数（因为存在嘉当度规），可以定义Casimir算符。\n\\[ \\boxed{C=\\kappa^{\\mu\\upsilon}E_\\mu E_\\upsilon} \\]  从矢量角度看，基底可如前面记作 \\((E_\\mu)^a\\)  ，而矢量也可以看成线性映射或算符，所以这里去掉了抽象指标。比如： \\(\\left(\\frac{\\partial}{\\partial t}\\right)^a\\)  实际对应算符 \\(\\frac{\\partial}{\\partial t}\\)  。\n进而，可计算Casimir算符和任意基底 \\(E_\\rho\\)  对易子：\n\\[ \\begin{aligned}\\ [C,E_\\rho]\u0026=\\kappa^{\\mu\\upsilon}[E_\\mu E_\\upsilon,E_\\rho]\\\\ \u0026=\\kappa^{\\mu\\upsilon}E_\\mu [E_\\upsilon , E_\\rho]+\\kappa^{\\mu\\upsilon}[E_\\mu,E_\\rho]E_\\upsilon\\\\ \u0026=\\kappa^{\\mu\\upsilon}C^\\tau_{\\ \\ \\upsilon\\rho}E_\\mu E_\\tau+\\kappa^{\\mu\\upsilon}C^\\tau_{\\ \\ \\mu\\rho}E_\\tau E_\\upsilon \\qquad \\textcolor{red}{结构常数的定义}\\\\ \u0026=\\kappa^{\\mu\\upsilon}C^\\tau_{\\ \\ \\upsilon\\rho}E_\\mu E_\\tau+\\kappa^{\\upsilon\\mu}C^\\tau_{\\ \\ \\upsilon\\rho}E_\\tau E_\\mu\\\\ \u0026=\\kappa^{\\mu\\upsilon}C^\\tau_{\\ \\ \\upsilon\\rho}(E_\\mu E_\\tau+E_\\tau E_\\mu)\\\\ \u0026=2\\kappa^{\\mu\\upsilon}\\kappa^{\\lambda\\tau} C_{\\lambda\\upsilon\\rho}E_{(\\mu} E_{\\tau)} \\qquad \\textcolor{red}{上行括号内是对称的}\\\\ \u0026=2\\kappa^{\\mu\\upsilon}\\kappa^{\\lambda\\tau}E_{(\\mu} E_{\\tau)}C_{[\\lambda\\upsilon\\rho]} \\qquad \\textcolor{red}{下指标结构常数全反称性}\\\\ \u0026=2\\kappa^{(\\mu|\\upsilon}\\kappa^{\\lambda|\\tau)}E_{\\mu} E_{\\tau}C_{[\\lambda\\upsilon\\rho]} \\qquad \\textcolor{red}{括号全缩并时可传染}\\\\ \u0026=2\\kappa^{\\mu(\\upsilon}\\kappa^{\\lambda)\\tau}E_{\\mu} E_{\\tau}C_{[\\lambda\\upsilon\\rho]}=0 \\qquad \\textcolor{red}{异种括号缩并为零} \\end{aligned} \\]  即：\n\\[ \\boxed{[C,E_\\rho]=0} \\]  这说明：\n 半单李代数 \\(\\mathscr{G}\\)  上的Casimir算符与 \\(\\mathscr{G}\\)  的一切基底对易，进而与 \\(\\mathscr{G}\\)  的一切元素对易。\n \\[ \\boxed{[C,\\mathscr{G}]=0} \\]  求SO(3)的李代数的Casimir算符 我们知道李代数 \\(\\mathscr{SO}(3)\\)  的三个基底算符（以前的笔记计算过）：\n\\[ E_1=z\\partial_y-y\\partial_z\\\\ E_2=x\\partial_z-z\\partial_x \\\\ E_3=y\\partial_x-x\\partial_y \\]  对应的结构常数（以前的笔记计算过）：\n\\[ [E_i,E_j]=\\varepsilon^k_{\\ \\ ij}E_k\\\\ C^k_{\\ \\ ij}=\\varepsilon^k_{\\ \\ ij} \\]  进而容易算出嘉当度规：\n\\[ \\kappa_{ij}=-2\\delta_{ij}\\quad \\kappa^{ij}=-\\frac{1}{2}\\delta^{ij} \\]  因为（我直接用julia计算）\nusing SymPy using LinearAlgebra # Levi-Civita记号 ε= [ Sym((i≠j \u0026amp;\u0026amp; i≠k \u0026amp;\u0026amp; j≠k )* # 存在重复指标，取0 (-1)^(sum([i,j,k][σ]\u0026gt;[i,j,k][ρ] for σ in 1:3,ρ in 1:3 if σ\u0026lt;ρ) % 2)) # 计算逆序数。偶数取1，奇数取-1 for i in 1:3, j in 1:3, k in 1:3 ] ; # 计算嘉当度规 κ=[sum(ε[l,i,k]*ε[k,j,l] for k in 1:3, l in 1:3) for i in 1:3, j in 1:3] 进而容易算出Casimir算符\n\\[ C=\\kappa^{ij}E_iE_j=-\\frac{1}{2}\\delta^{ij}E_iE_j=-\\frac{1}{2}((E_1)^2+(E_2)^2+(E_3)^2) \\]  广义Casimir算符 可以定义n阶的广义Casimir算符\n\\[ I_n=C^{\\beta_1}_{\\ \\ \\alpha_1\\beta_2}C^{\\beta_2}_{\\ \\ \\alpha_2\\beta_3}\\dots C^{\\beta_n}_{\\ \\ \\alpha_n\\beta_1}E^{\\alpha_1}E^{\\alpha_2}\\dots E^{\\alpha_n},\\quad n\\ge2 \\\\ E^\\alpha=\\kappa^{\\alpha\\beta}E_\\beta \\]  可以证明与半单李代数中的一切元素对易，但它们并不是独立的。\n首先，二阶Casimir算符，就是普通的Casimir算符\n\\[ I_2=C \\]  更特别地，对 \\(\\mathscr{SO}(3)\\)  李代数而言\n\\[ I_3=-2I_2=-2C \\]   后面这三段我没细研究，先把结论写出来，回头研究。\n 事实上， \\(\\mathscr{SO}(3)\\)  上所有的广义Casimir算符 \\(I_n(n\\ge2)\\)  都正比于 \\(C\\)  ，因此 \\(\\mathscr{SO}(3)\\)  的独立Casimir算符只有一个 \\(C\\)  。\n一般而言，秩为 \\(l\\)  的半单李代数有 \\(l\\)  个独立Casimir算符。\n正如 \\(\\mathscr{SO}(3)\\)  代数中Casimir算符 \\(C(\\sim J^2)\\)  的本征值 \\(j(j+1)\\)  可用来对 \\(\\mathrm{SO}(3)\\)  群的不可约表示进行编号，广义Casimir算符的本征值全体可以用来对不可约表示进行完全编号。因此，Casimir算符的寻找是重要的。\n"}),a.add({id:100,href:'/notes/docs/theophy/0081/',title:"场及其对称性",content:" 场的拉格朗日形式，保持明显的洛伦兹协变性。\n场的哈密顿形式，依赖于时空的1+3分解，因为时间变量在共轭动量密度中扮演了特殊的角色。\n有限维Noether定理，条件更松，每个单参微分同胚群对应一个守恒量。\n场的Noether定理，有更严格的要求，每个单参等度规群对应一个守恒流。\n 场的拉格朗日处理 物理上的场   \\(\\phi\\)  ，是一个时空函数，还可能带有标识其性质的指标。比如：标量场 \\(\\psi\\)  ，矢量场 \\(\\psi^a\\)  ，旋量场 \\(\\psi^A\\)  ，张量场 \\(\\psi^{ab}\\)  \u0026hellip;\u0026hellip;\n正如有限维位形 \\(q^\\mu\\)  的拉格朗日量\n\\[ L=L(q^\\mu,\\dot{q}^\\mu) \\]  （无限维）标量场 \\(\\phi\\)  场的拉格朗日量\n\\[ L=\\int_S{\\mathscr{L}(\\phi,\\nabla_a\\phi)} \\]  其中， \\(\\phi\\)  的定义域是时空流形， \\(\\mathscr{L}\\)  是拉格朗日密度， \\(S\\)  是某时刻三维位形流形，对标量场而言 \\(\\nabla_a\\phi=\\partial_a \\phi\\)  。\n进而可写出作用量\n\\[ S=\\int_{t_0}^{t_1}{L\\ dt}=\\boxed{\\int_D{\\mathscr{L}(\\phi,\\nabla_a\\phi)}}=\\int_D{\\mathscr{L}(\\phi,\\nabla_a\\phi)\\boldsymbol{\\varepsilon}} \\]  其中， \\(D\\)  是四维时空位形（如图），由固定的初始三维空间位形 \\(A\\)  和固定的终了三维空间位形 \\(B\\)  围成， \\(\\boldsymbol{\\varepsilon}\\)  是时空度规适配体元。\n根据最小作用原理，可写出标量场的欧拉-拉格朗日方程（以前的笔记推导过，不再复述）：\n\\[ \\boxed{\\frac{\\partial \\mathscr{L}}{\\partial \\phi}=\\nabla_a\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}} \\]  考虑两个相差一个四维散度的拉格朗日密度\n\\[ \\mathscr{L}'=\\mathscr{L}+\\nabla_a K^a \\]  对应的作用量的变分：\n\\[ \\begin{aligned}\\delta\\int_D{\\mathscr{L}'}=\u0026\\delta\\int_D{\\mathscr{L}}+\\delta\\int_D{\\nabla_a K^a}\\\\ =\u0026 \\delta\\int_D{\\mathscr{L}}+\\delta\\int_D{(\\nabla_a K^a) \\boldsymbol{\\varepsilon}}\\quad \\textcolor{red}{流形上积分定义}\\\\ =\u0026 \\delta\\int_D{\\mathscr{L}}+\\delta\\int_{\\partial D}{K^a n_a \\hat{\\boldsymbol{\\varepsilon}}}\\quad \\textcolor{red}{流形上Gauss定理}\\\\ =\u0026 \\delta\\int_D{\\mathscr{L}}\\quad \\textcolor{red}{固定边界积分的变分为0}\\end{aligned} \\]  这意味着：拉格朗日密度 \\(\\mathscr{L}\\)  相差一个四维散度 等价于 拉格朗日量 \\(L\\)  相差一个全导数。 都对应同一个（场）运动方程。\n场的哈密顿形式 在哈密顿形式中，也有共轭动量密度 \\(\\pi\\)  ：\n\\[ \\pi=\\frac{\\partial\\mathscr{L}}{\\partial \\dot{\\phi}} \\]  注意：前面拉格朗日形式能保持明显的洛伦兹协变性，但哈密顿形式则缺少这种明显性。因为时间变量在共轭动量密度中扮演了特殊的角色。这里已经做了时空的1+3分解：\n\\[ \\boxed{\\nabla_\\mu=(\\nabla_0,\\boldsymbol{\\nabla})=(\\partial/\\partial t,\\boldsymbol{\\nabla})} \\]  于是\n\\[ \\dot{\\phi}=\\nabla_0\\phi=\\frac{\\partial \\phi}{\\partial t} \\]  在此基础上定义哈密顿密度 \\(\\mathscr{H}\\)  \\[ \\mathscr{H}(\\phi,\\pi,\\boldsymbol{\\nabla}\\phi)=\\mathscr{\\pi}\\dot{\\phi}-\\mathscr{L} \\]  注意：这个哈密顿量也体现了1+3分解\n进而作用量的变分为：\n\\[ \\begin{aligned}0=\\delta S\u0026=\\int_D{\\delta \\mathscr{L}}=\\int_D{\\delta (\\pi\\dot{\\phi}-\\mathscr{H})}\\\\ \u0026= \\int_D{\\left(\\textcolor{blue}{\\dot{\\phi}\\delta \\pi+\\pi\\delta \\dot{\\phi}}\\textcolor{green}{-\\frac{\\partial \\mathscr{H}}{\\partial\\phi}\\delta\\phi-\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\delta\\pi-\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\cdot\\delta\\boldsymbol{\\nabla}\\phi}\\right)}\\\\ \u0026= \\int_D{\\left(\\dot{\\phi}\\delta \\pi+\\textcolor{blue}{\\pi\\frac{\\partial}{\\partial t}\\delta \\phi}-\\frac{\\partial \\mathscr{H}}{\\partial\\phi}\\delta\\phi-\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\delta\\pi\\textcolor{green}{-\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\cdot\\boldsymbol{\\nabla}(\\delta\\phi)}\\right)}\\\\ \u0026= \\int_D\\left(\\dot{\\phi}\\delta \\pi+\\textcolor{blue}{\\frac{\\partial}{\\partial t}(\\pi\\delta \\phi)-\\dot{\\pi}\\delta \\phi}-\\frac{\\partial \\mathscr{H}}{\\partial\\phi}\\delta\\phi-\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\delta\\pi \\right. \\\\ \u0026\\qquad \\left.\\textcolor{green}{-\\boldsymbol{\\nabla}\\cdot\\left(\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\delta\\phi\\right) +\\left(\\boldsymbol{\\nabla}\\cdot\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\right)\\delta\\phi}\\right)\\\\ \u0026= \\int_D{\\left\\{\\left(\\dot{\\phi}-\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\right)\\delta\\pi-\\left(\\dot{\\pi}+\\frac{\\partial \\mathscr{H}}{\\partial\\phi}-\\boldsymbol{\\nabla}\\cdot\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\right)\\delta\\phi\\right\\}}\\\\ \u0026\\qquad \\qquad +\\int_D{\\frac{\\partial}{\\partial t}(\\pi\\delta \\phi)}-\\int_D{\\boldsymbol{\\nabla}\\cdot\\left(\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\delta\\phi\\right)}\\quad \\textcolor{red}{边界上变分为0} \\\\ \u0026= \\boxed{\\int_D{\\left\\{\\left(\\dot{\\phi}-\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\right)\\delta\\pi-\\left(\\dot{\\pi}+\\frac{\\partial \\mathscr{H}}{\\partial\\phi}-\\boldsymbol{\\nabla}\\cdot\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\right)\\delta\\phi\\right\\}}} \\end{aligned} \\]  进而有\n\\[ \\begin{aligned}\\dot{\\phi}\u0026=\\frac{\\partial \\mathscr{H}}{\\partial\\pi}\\\\ \\dot{\\pi}\u0026=-\\frac{\\partial \\mathscr{H}}{\\partial\\phi}+\\boldsymbol{\\nabla}\\cdot\\frac{\\partial \\mathscr{H}}{\\partial(\\boldsymbol{\\nabla}\\phi)}\\end{aligned} \\]  场上的Noether定理 (有限维)Noether定理：每一个保持拉格朗日量不变的单参微分同胚群（对称性），必有运动方程组对应的一个首次积分（守恒律）。\n这个定理，在有限维的情况下证明过。 这里要考察无限维的张量场 \\(\\phi\\)  下的情况，命题中的拉格朗日量改成拉格朗日密度，所谓\u0026quot;不变\u0026quot;，可以精确到相差一个四维散度。\n考察一个单参微分同胚 \\(h:\\mathbb{R}\\times D\\to D\\)  ，条件是保证拉格朗日密度 \\(\\mathscr{L}\\)  不变，即：\n\\[ \\mathscr{L}(h^*_s\\phi,h^*_s\\nabla_a\\phi)=\\mathscr{L}(\\phi,\\nabla_a\\phi),\\quad s\\to0,\\quad \\forall s\\in \\mathbb{R} \\]  其中， \\(h_s\\)  对标量场和对偶矢量场的自然诱导映射是拉回映射 \\(h^*_s\\)  ； \\(\\nabla_a\\)  是度规适配导数算符；此外，单参微分同胚群 \\(\\{h_s\\}\\)  ，可由某个矢量场 \\(\\xi^a\\)  生成。\n要注意的是，单参微分同胚不一定保度规，所以变换后度规可能会变，进而其适配导数算符也会变。为了准确描述这个变化，需要将拉格朗日密度改写成：\n\\[ \\mathscr{L}=\\mathscr{L}(\\phi,\\nabla_a\\phi,g_{ab}) \\]  用 \\(h_s\\)  变换后\n\\[ \\mathscr{L}_s=\\mathscr{L}(h^*_s\\phi,h^*_s\\nabla_a\\phi,h^*_s g_{ab})=h^*_s \\mathscr{L}(\\phi,\\nabla_a\\phi,g_{ab}) \\]  进而\n\\[ \\begin{aligned}\\xi^a\\nabla_a\\mathscr{L}\u0026=\\mathcal{L}_\\xi\\mathscr{L}=\\left.\\frac{d\\mathscr{L}_s}{ds}\\right|_{s=0}\\qquad \\textcolor{red}{\\mathcal{L}_\\xi 表示李导数}\\\\\u0026=\\lim_{s\\to 0}\\left(\\frac{1}{s}(\\mathscr{L}(h^*_s\\phi,h^*_s\\nabla_a\\phi,h^*_s g_{ab})-\\mathscr{L}(\\phi,\\nabla_a\\phi,g_{ab}))\\right)\\\\ \u0026=\\frac{\\partial \\mathscr{L}}{\\partial \\phi} \\lim_{s\\to 0}\\left(\\frac{1}{s}(h^*_s\\phi-\\phi)\\right)\\\\ \u0026\\qquad +\\frac{\\partial \\mathscr{L}}{\\partial (\\nabla_a\\phi)} \\lim_{s\\to 0}\\left(\\frac{1}{s}(h^*_s\\nabla_a\\phi-\\nabla_a\\phi)\\right)\\\\ \u0026 \\qquad + \\frac{\\partial \\mathscr{L}}{\\partial (g_{ab})} \\lim_{s\\to 0}\\left(\\frac{1}{s}(h^*_s g_{ab}-g_{ab})\\right)\\\\ \u0026=\\boxed{\\frac{\\partial \\mathscr{L}}{\\partial \\phi}\\mathcal{L}_{\\xi}\\phi +\\frac{\\partial \\mathscr{L}}{\\partial (\\nabla_a\\phi)} \\mathcal{L}_{\\xi}\\nabla_a\\phi + \\frac{\\partial \\mathscr{L}}{\\partial (g_{ab})}\\mathcal{L}_{\\xi}g_{ab}}\\end{aligned} \\]  将拉格朗日方程带入得\n\\[ \\xi^a\\nabla_a\\mathscr{L}=\\left(\\nabla_a\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}\\right)\\mathcal{L}_{\\xi}\\phi +\\frac{\\partial \\mathscr{L}}{\\partial (\\nabla_a\\phi)} \\mathcal{L}_{\\xi}\\nabla_a\\phi + \\frac{\\partial \\mathscr{L}}{\\partial (g_{ab})}\\mathcal{L}_{\\xi}g_{ab} \\]  特别地，如果 \\(h_s\\)  是等度规映射，那么 \\(\\xi^a\\)  必然是Killing矢量场，有:\n\\[ \\mathcal{L}_\\xi g_{ab}=0\\\\ \\nabla_a\\xi^a=g^{ab}\\nabla_a\\xi_b=g^{(ab)}\\nabla_{[a}\\xi_{b]}=0\\\\ \\nabla_a\\mathcal{L}_\\xi\\phi=\\mathcal{L}_\\xi\\nabla_a\\phi \\]  于是有：\n\\[ \\nabla_a\\left(\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}\\mathcal{L}_{\\xi}\\phi-\\xi^a\\mathscr{L}\\right)=0 \\]  可见矢量场\n\\[ \\boxed{J^a=\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}\\mathcal{L}_{\\xi}\\phi-\\xi^a\\mathscr{L}} \\]  满足连续性方程：\n\\[ \\boxed{\\nabla_a J^a=0} \\]  进而 \\(J^a\\)  代表某种守恒流密度。\n(场)Noether定理：每一个保持拉格朗日密度不变的单参等度规群（对称性），必有场方程对应的一个连续性（守恒律）。\n特别地，对闵氏时空而言，存在10个独立Killing矢量场 \\(\\xi^a\\)  ，相应就有10个独立守恒密度流 \\(J^a\\)  。\n比如，考虑时间平移Killing矢量场 \\(\\xi^a=(\\partial/\\partial t)^a\\)  ，有\n\\[ J^a=\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}(\\partial/ \\partial t)^b\\nabla_b\\phi-(\\partial/ \\partial t)^a\\mathscr{L}=\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}\\nabla_0\\phi-(\\partial/\\partial t)^a\\mathscr{L} \\]  因此\n\\[ J^0=\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_0\\phi)}\\nabla_0\\phi-\\mathscr{L}=\\mathscr{\\pi}\\dot{\\phi}-\\mathscr{L}=\\mathscr{H} \\]  此外，还可以定义一个正则能动张量 \\(S^{ab}\\)  ：\n\\[ \\boxed{S^{ab}\\overset{\\Delta}{=}-\\frac{\\partial \\mathscr{L}}{\\partial(\\nabla_a\\phi)}\\nabla^b\\phi+\\mathscr{L}g^{ab}} \\]  则有：\n\\[ \\boxed{S^{ab}\\xi_b=-J^a \\qquad \\nabla_a S^{ab}=0 } \\]  注意： \\(\\xi^a\\)  必须是Killing矢量场，上式才成立。\n"}),a.add({id:101,href:'/notes/tags/%E5%9C%BA%E8%AE%BA/',title:"场论",content:""}),a.add({id:102,href:'/notes/tags/%E6%97%8B%E9%87%8F/',title:"旋量",content:""}),a.add({id:103,href:'/notes/tags/%E6%B5%81%E5%BD%A2/',title:"流形",content:""}),a.add({id:104,href:'/notes/docs/theophy/0080/',title:"闵氏时空对称性的三种观点",content:" 本篇依次从Killing矢量场、张量（矩阵）、旋量三个角度考察闵氏时空的对称性。\n最后，从旋量概念引入自旋概念。\n本篇涉及的草稿：https://gitee.com/chaoskey/notes/blob/master/code/0080.ipynb\n 闵氏时空对称性 闵氏时空，作为一种带度规的时空流形   \\((M,g_{ab})\\)  \\[ g_{ab}=\\eta_{\\mu\\upsilon}g^\\mu_{\\ \\ a}g^\\upsilon_{\\ \\ b}\\quad \\eta_{\\mu\\upsilon}=\\mathrm{diag}(-1,1,1,1) \\]  其对称性表现为保度规，描述此种对称性的李群，就是等度规群。特别地，闵氏时空下的等度规群，就是庞加莱群。\n本篇，从三个角度考察庞加莱群：\n1）Killing矢量场观点【主动观点】；\n2）张量观点【被动观点】\n3）旋量观点\nKilling矢量场观点 作为庞加莱群的子群，单参等度规（局域）群，所对应的矢量场是一个Killing矢量场。很自然，可通过求解Killing方程来确定庞加莱群的李代数。\nusing SymPy using LinearAlgebra # 选择洛伦兹坐标系 @vars t x y z real=true X = [t,x,y,z] # 闵氏度规及逆度规 g = sympy.diag(-1,1,1,1) gi = inv(g) # 待求的Killing矢量场的分量 ξ = SymFunction(\u0026#34;ξ^1,ξ^2,ξ^3,ξ^4\u0026#34;) # 根据度规计算克氏符 Γ = sum([(1//2)*gi[σ,ρ]*(diff(g[μ,ρ],X[υ])+ diff(g[υ,ρ],X[μ])-diff(g[μ,υ],X[ρ])) for μ in 1:4,υ in 1:4 ,σ in 1:4] for ρ in 1:4) # 列出所有独立Killing方程组 eqs = [(0⩵diff(sum(g[υ,ρ]*ξ[ρ](t,x,y,z) for ρ in 1:4),X[μ])+ diff(sum(g[μ,ρ]*ξ[ρ](t,x,y,z) for ρ in 1:3),X[υ])- 2*sum(Γ[μ,υ,σ]*sum(g[σ,ρ]*ξ[ρ](t,x,y,z) for ρ in 1:4) for σ in 1:4)) for μ in 1:4,υ in 1:4 if μ ≤ υ ] 通过分离变量法，逐个获得10个特解【参见我的草稿】，分成三组：\n（一）4个平移：\n\\[ (\\xi_{t_0})^a=\\left(\\frac{\\partial}{\\partial t}\\right)^a,(\\xi_{t_1})^a=\\left(\\frac{\\partial}{\\partial x}\\right)^a,(\\xi_{t_2})^a=\\left(\\frac{\\partial}{\\partial y}\\right)^a,(\\xi_{t_3})^a=\\left(\\frac{\\partial}{\\partial z}\\right)^a \\]  （二）3个空间转动：\n\\[ (\\xi_{r_1})^a=z\\left(\\frac{\\partial}{\\partial y}\\right)^a-y\\left(\\frac{\\partial}{\\partial z}\\right)^a\\\\ (\\xi_{r_2})^a=x\\left(\\frac{\\partial}{\\partial z}\\right)^a-z\\left(\\frac{\\partial}{\\partial x}\\right)^a\\\\ (\\xi_{r_3})^a=y\\left(\\frac{\\partial}{\\partial x}\\right)^a-x\\left(\\frac{\\partial}{\\partial y}\\right)^a \\]  （三）3个伪转动（boost）：\n\\[ (\\xi_{b_1})^a=x\\left(\\frac{\\partial}{\\partial t}\\right)^a+t\\left(\\frac{\\partial}{\\partial x}\\right)^a\\\\ (\\xi_{b_2})^a=y\\left(\\frac{\\partial}{\\partial t}\\right)^a+t\\left(\\frac{\\partial}{\\partial y}\\right)^a\\\\ (\\xi_{b_3})^a=z\\left(\\frac{\\partial}{\\partial t}\\right)^a+t\\left(\\frac{\\partial}{\\partial z}\\right)^a \\]  通过细致的计算【参见我的草稿】，可算出对应李代数的结构常数：\n\\[ \\begin{aligned}\\quad \u0026[\\textcolor{red}{\\xi_{t_i}},\\textcolor{red}{\\xi_{t_j}}]^a=0 \\quad \u0026[\\textcolor{blue}{\\xi_{r_i}},\\textcolor{blue}{\\xi_{r_j}}]^a=\\varepsilon^k_{\\ \\ ij}\\left(\\textcolor{blue}{\\xi_{r_k}}\\right)^a \\\\\u0026 [\\textcolor{green}{\\xi_{b_i}},\\textcolor{green}{\\xi_{b_j}}]^a=-\\varepsilon^k_{\\ \\ ij}\\left(\\textcolor{blue}{\\xi_{r_k}}\\right)^a \\quad \u0026 \\\\\u0026 [\\xi_{t_0},\\textcolor{blue}{\\xi_{r_i}}]^a=0 \\quad \u0026[\\textcolor{red}{\\xi_{t_i}},\\textcolor{blue}{\\xi_{r_j}}]^a=\\varepsilon^k_{\\ \\ ij}\\left(\\textcolor{red}{\\xi_{t_k}}\\right)^a \\\\ \u0026 [\\xi_{t_0},\\textcolor{green}{\\xi_{b_i}}]^a=\\left(\\textcolor{red}{\\xi_{t_i}}\\right)^a \\quad \u0026 [\\textcolor{red}{\\xi_{t_i}},\\textcolor{green}{\\xi_{b_j}}]^a=\\delta_{ij}\\left(\\xi_{t_0}\\right)^a \\quad \\\\ \u0026 [\\textcolor{blue}{\\xi_{r_i}},\\textcolor{green}{\\xi_{b_j}}]^a=\\varepsilon^k_{\\ \\ ij}\\left(\\textcolor{green}{\\xi_{b_k}}\\right)^a \\quad \u0026 \\end{aligned} \\]  进一步引入记号 \\(\\textcolor{red}{l_{\\mu\\upsilon}}=l_{[\\mu\\upsilon]}\\quad \\mu,\\upsilon=0,1,2,3\\)  【注意每一个分量都是一个生成元矢量】：\n\\[ l_{01}=b_1\\quad l_{02}=b_2\\quad l_{03}=b_3\\\\ l_{12}=r_3\\quad l_{23}=r_1\\quad l_{31}=r_2\\\\ \\quad \\\\ \\textcolor{red}{l_{\\mu\\upsilon}}=\\begin{pmatrix}0 \u0026 b_1 \u0026 b_2 \u0026 b_3 \\\\ -b_1 \u0026 0 \u0026 r_3 \u0026 -r_2 \\\\ -b_2 \u0026 -r_3 \u0026 0 \u0026 r_1 \\\\ -b_3 \u0026 r_2 \u0026 -r_1 \u0026 0 \\end{pmatrix} \\]  于是前面堆等式可浓缩为【参见我的草稿】\n\\[ [\\xi_{l_{\\mu\\upsilon}},\\xi_{l_{\\sigma\\rho}}]^a=-\\eta_{\\mu\\rho}(\\xi_{l_{\\upsilon\\sigma}})^a-\\eta_{\\upsilon\\sigma}(\\xi_{l_{\\mu\\rho}})^a+\\eta_{\\mu\\sigma}(\\xi_{l_{\\upsilon\\rho}})^a+\\eta_{\\upsilon\\rho}(\\xi_{l_{\\mu\\sigma}})^a \\\\ [\\xi_{l_{\\mu\\upsilon}},\\xi_{t_\\sigma}]^a=-\\eta_{\\mu\\sigma}(\\xi_{t_\\upsilon})^a+\\eta_{\\upsilon\\sigma}(\\xi_{t_\\mu})^a \\]  对应的分量\n\\[ \\xi_{l_{\\mu\\upsilon}}^{\\ \\ \\beta}\\partial_\\beta\\xi_{l_{\\sigma\\rho}}^{\\ \\ \\alpha}-\\xi_{l_{\\sigma\\rho}}^{\\ \\ \\beta}\\partial_\\beta\\xi_{l_{\\mu\\upsilon}}^{\\ \\ \\alpha}=-\\eta_{\\mu\\rho}\\xi_{l_{\\upsilon\\sigma}}^{\\ \\ \\alpha}-\\eta_{\\upsilon\\sigma}\\xi_{l_{\\mu\\rho}}^{\\ \\ \\alpha}+\\eta_{\\mu\\sigma}\\xi_{l_{\\upsilon\\rho}}^{\\ \\ \\alpha}+\\eta_{\\upsilon\\rho}\\xi_{l_{\\mu\\sigma}}^{\\ \\ \\alpha} \\\\ \\xi_{l_{\\mu\\upsilon}}^{\\ \\ \\beta}\\partial_\\beta\\xi_{t_{\\sigma}}^{\\ \\ \\alpha}-\\xi_{t_{\\sigma}}^{\\ \\ \\beta}\\partial_\\beta\\xi_{l_{\\mu\\upsilon}}^{\\ \\ \\alpha}=\\eta_{\\mu\\sigma}\\xi_{t_\\upsilon}^{\\ \\ \\alpha}-\\eta_{\\upsilon\\sigma}\\xi_{t_\\mu}^{\\ \\ \\alpha} \\]  张量（矩阵）观点 在《常用李群及其李代数》中提及的洛伦兹群，就是从张量角度看的。 本小节不再复述，这里仅仅把 Killing矢量场观点和张量观点联系起来。\n从根上看，两个观点都是基于保度规的，每个Killing矢量场对应一个单参等度规群，而其每个群元作用于流形上，是基于操作的“主动变换”。 换个角度，这种“主动”必然对应“被动”，那就是坐标变换。\n以这个Killing矢量场 \\((\\xi_{r_1})^a\\)  为例\n\\[ (\\xi_{r_1})^a=z\\left(\\frac{\\partial}{\\partial y}\\right)^a-y\\left(\\frac{\\partial}{\\partial z}\\right)^a \\]  假设 \\((\\xi_{r_1})^a\\)  对应的单参等度规群的参数是 \\(\\varphi\\)  ,那么\n\\[ (\\xi_{r_1})^a=\\left(\\frac{\\partial}{\\partial \\varphi}\\right)^a \\]  比较上面两种形式，得到 \\((\\xi_{r_1})^a\\)  积分曲线 \\(C(\\varphi)\\)  的参数方程：\n\\[ \\frac{dy(\\varphi)}{d\\varphi}=z\\quad \\frac{dz(\\varphi)}{d\\varphi}=-y\\\\ p=C(0),\\quad y(0)=y_p,\\quad z(0)=z_p \\]  不难求解出：\n\\[ y(\\varphi)=y_p \\cos\\varphi+z_p\\sin\\varphi\\quad z(\\varphi)=-y_p\\sin\\varphi+z_p\\cos\\varphi \\]  很明显，这就我们熟知的，绕 \\(x\\)  轴旋转的坐标变换形式。不难写出坐标变换所对应的矩阵（由主动到被动反向： \\(\\varphi\\to -\\varphi\\)  ）：\n\\[ Z_x(\\varphi)=\\begin{pmatrix}1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0\\\\ 0 \u0026 0 \u0026 \\cos\\varphi \u0026 -\\sin\\varphi \\\\ 0 \u0026 0 \u0026 \\sin\\varphi \u0026 \\cos \\varphi\\end{pmatrix} \\]  进而可直接求出对应的生成元\n\\[ r_1=\\left.\\frac{d}{d\\varphi}\\right|_{\\varphi\\to 0}Z_x(\\varphi)=\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0\\\\ 0 \u0026 0 \u0026 0 \u0026 -1 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{pmatrix} \\]  类似地，我们可以求出固有洛伦兹群 \\(L^\\uparrow_+\\)  的6个典型单参子群的矩阵：\n\\[ \\begin{pmatrix}1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0\\\\ 0 \u0026 0 \u0026 \\cos\\varphi \u0026 -\\sin\\varphi \\\\ 0 \u0026 0 \u0026 \\sin\\varphi \u0026 \\cos \\varphi\\end{pmatrix}\\begin{pmatrix}1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos\\varphi \u0026 0 \u0026 \\sin\\varphi \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 -\\sin\\varphi \u0026 0 \u0026 \\cos \\varphi\\end{pmatrix}\\begin{pmatrix}1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos\\varphi \u0026 -\\sin\\varphi \u0026 0 \\\\ 0 \u0026 \\sin\\varphi \u0026 \\cos\\varphi \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0\\end{pmatrix}\\\\ \\begin{pmatrix}\\cosh\\varphi \u0026 -\\sinh\\varphi \u0026 0 \u0026 0 \\\\ -\\sinh\\varphi \u0026 \\cosh\\varphi \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1\\end{pmatrix}\\begin{pmatrix}\\cosh\\varphi \u0026 0 \u0026 -\\sinh\\varphi \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ -\\sinh\\varphi \u0026 0\u0026 \\cosh\\varphi \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1\\end{pmatrix}\\begin{pmatrix}\\cosh\\varphi \u0026 0 \u0026 0 \u0026 -\\sinh\\varphi \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ -\\sinh\\varphi \u0026 0\u0026 0 \u0026 \\cosh\\varphi \\end{pmatrix} \\]  对应的生成元 \\(r_1,r_2,r_3,b_1,b_2,b_3\\)  ：\n\\[ \\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0\\\\ 0 \u0026 0 \u0026 0 \u0026 -1 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\end{pmatrix}\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 -1 \u0026 0 \u0026 0 \\end{pmatrix}\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\\\ \\begin{pmatrix} 0 \u0026 -1 \u0026 0 \u0026 0 \\\\ -1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\begin{pmatrix}0 \u0026 0 \u0026 -1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ -1 \u0026 0\u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 -1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \\\\ -1 \u0026 0\u0026 0 \u0026 0 \\end{pmatrix} \\]  实际上，通过比较这些生成元和对应的特解Killing矢量场，我们还能很直观地发现两种观点的同构性：\n\\[ \\boxed{\\xi_{r_i}=-X^T r_i^{\\ \\ T} \\frac{\\partial}{\\partial X}\\quad \\xi_{b_i}=-X^T b_i^{\\ \\ T} \\frac{\\partial}{\\partial X}}\\\\ X\\overset{\\Delta}{=}[t,x,y,z]^T\\quad \\]  此外，需要注意的是：平移没有同维的生成元矩阵形式，但有高一维的生成元矩阵。平移生成元 \\(t_0,t_1,t_2,t_3\\)  :\n\\[ t_0=\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\quad t_1=\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\\\ t_2=\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\end{pmatrix}\\quad t_3=\\begin{pmatrix}0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 1 \\\\ 0 \u0026 0\u0026 0 \u0026 0 \u0026 0 \\end{pmatrix} \\]  进而，不得不将转动和伪转动生成元矩阵都扩张成5维，扩展部分补0。【如果无需和平移混合运算的话，则无需扩展】\n可以验证【参见我的草稿】，也能很直观看出两种观点的同构性：\n\\[ \\begin{aligned}\\quad \u0026[\\textcolor{red}{t_i},\\textcolor{red}{t_j}]=0 \\quad \u0026[\\textcolor{blue}{r_i},\\textcolor{blue}{r_j}]=\\varepsilon^k_{\\ \\ ij}\\textcolor{blue}{r_k} \\\\\u0026 [\\textcolor{green}{b_i},\\textcolor{green}{b_j}]=-\\varepsilon^k_{\\ \\ ij}\\textcolor{blue}{r_k} \\quad \u0026 \\\\\u0026 [t_0,\\textcolor{blue}{r_i}]=0 \\quad \u0026[\\textcolor{red}{t_i},\\textcolor{blue}{r_j}]=\\varepsilon^k_{\\ \\ ij}\\textcolor{red}{t_k} \\\\ \u0026 [t_0,\\textcolor{green}{b_i}]=\\textcolor{red}{t_i} \\quad \u0026 [\\textcolor{red}{t_i},\\textcolor{green}{b_j}]=\\delta_{ij}t_0 \\quad \\\\ \u0026 [\\textcolor{blue}{r_i},\\textcolor{green}{b_j}]=\\varepsilon^k_{\\ \\ ij}\\textcolor{green}{b_k} \\quad \u0026 \\end{aligned} \\]  和前面类似，进一步引入记号 \\(\\textcolor{red}{l_{\\mu\\upsilon}}=l_{[\\mu\\upsilon]}\\quad \\mu,\\upsilon=0,1,2,3\\)  ，每个分量的分配和前面完全一样。根据这种分配，每一个分量都是一个生成元矩阵，有更简洁的表示【参见我的草稿】:\n\\[ \\left(l_{\\mu\\upsilon}\\right)^\\alpha_{\\ \\ \\beta}=-\\delta^\\alpha_{\\ \\ \\mu}\\eta_{\\beta\\upsilon}+\\delta^\\alpha_{\\ \\ \\upsilon}\\eta_{\\beta\\mu} \\]  进而不难验证，上面矩阵形式的结构常数关系可浓缩为【参见我的草稿】：\n\\[ [l_{\\mu\\upsilon},l_{\\sigma\\rho}]=-\\eta_{\\mu\\rho}l_{\\upsilon\\sigma}-\\eta_{\\upsilon\\sigma}l_{\\mu\\rho}+\\eta_{\\mu\\sigma}l_{\\upsilon\\rho}+\\eta_{\\upsilon\\rho}l_{\\mu\\sigma} \\\\ [l_{\\mu\\upsilon},t_\\sigma]=\\eta_{\\mu\\sigma}t_\\upsilon-\\eta_{\\upsilon\\sigma}t_\\mu \\]  庞加莱群的简洁表示 前面无论是Killing矢量场观点，还是张量（矩阵）观点，都有完全一样的形式【同构表示】，\n首先是洛伦兹群，可以用生成元矩阵表示:\n\\[ \\left(l_{\\mu\\upsilon}\\right)^\\alpha_{\\ \\ \\beta}\\cong \\left(\\xi_{l_{\\mu\\upsilon}}\\right)^a \\]  每个生成元 \\(l_{\\mu\\upsilon}=l_{[\\mu\\upsilon]}\\)  都对应一个单参微分同胚群，也可将这些参数组成一个反称张量（矩阵） \\(\\omega_{\\mu\\upsilon}=\\omega_{[\\mu\\upsilon]}\\)  ，进而得到洛伦兹群的一般简洁表示：\n\\[ \\boxed{\\Lambda = \\exp\\left\\{\\frac{1}{2}\\omega_{\\mu\\upsilon}l^{\\mu\\upsilon}\\right\\}=\\exp\\left\\{-\\frac{i}{2}\\omega_{\\mu\\upsilon}J^{\\mu\\upsilon}\\right\\}}\\\\ J^{\\mu\\upsilon}\\overset{\\Delta}{=}i\\ l^{\\mu\\upsilon} \\]  其中， \\(1/2\\)  是由于反称性导致的重复求和； 引入虚数 \\(i\\)  是有意为之，如果将 \\(J^{\\mu\\upsilon}\\)  代替 \\(l^{\\mu\\upsilon}\\)  作为生成元，那么 \\(J^{\\mu\\upsilon}\\)  就是厄米的。\n从 \\(J^{\\mu\\upsilon}\\)  中提取矢量（利用了前面关于 \\(l_{\\mu\\upsilon}\\)  的构造）\n\\[ \\boxed{J^\\alpha\\overset{\\Delta}{=}\\frac{1}{2}\\epsilon^\\alpha_{\\ \\beta\\gamma}J^{\\beta\\gamma}}=ir^\\alpha\\quad \\boxed{K^\\alpha\\overset{\\Delta}{=}J^{\\alpha 0}}=-ib^\\alpha\\quad \\alpha=1,2,3 \\]  从 \\(\\omega^{\\mu\\upsilon}\\)  提取矢量：\n\\[ \\boxed{\\theta^\\alpha\\overset{\\Delta}{=}\\frac{1}{2}\\epsilon^\\alpha_{\\ \\beta\\gamma}\\omega^{\\beta\\gamma}\\quad \\eta^\\alpha\\overset{\\Delta}{=}\\omega^{\\alpha 0}}\\quad \\alpha=1,2,3\\\\ \\omega^{\\alpha0}=-\\omega_{\\alpha0}\\quad \\omega^{\\alpha\\beta}=\\omega_{\\alpha\\beta} \\]  进而\n\\[ \\boxed{\\frac{1}{2}\\omega_{\\mu\\upsilon}J^{\\mu\\upsilon}=\\boldsymbol{\\theta}\\cdot\\boldsymbol{J}-\\boldsymbol{\\eta}\\cdot\\boldsymbol{K}} \\]  其中负号源自 \\(\\omega_{i0}=-\\omega^{i0}=-\\eta^i\\)  。\n于是，洛伦兹群还可以表示为：\n\\[ \\boxed{\\Lambda =\\exp\\left\\{-i\\boldsymbol{\\theta}\\cdot\\boldsymbol{J}+i\\boldsymbol{\\eta}\\cdot\\boldsymbol{K}\\right\\}} \\]  其次是平移群，其生成元矩阵：\n\\[ \\left(t_{\\mu}\\right)^\\alpha_{\\ \\ \\beta}\\cong (\\xi_{t_\\mu})^a \\]  每个生成元 \\(t_{\\mu}\\)  都对应一个单参微分同胚群，此参数数记作 \\(a_{\\mu}\\)  ，进而得到平移群的表示【这里的 \\(t\\)  是\u0026quot;平移\u0026quot;的意思，以后用 \\(P\\)  表示】：\n\\[ \\boxed{\\exp\\left\\{a_\\mu t^\\mu\\right\\}=\\exp\\left\\{-ia_\\mu P^\\mu\\right\\}}\\\\ P^\\mu\\overset{\\Delta}{=}i\\ t^\\mu\\\\ t^0=-t_0\\quad t^i=t_i \\]  庞加莱群是平移群与洛伦兹群的直积。\n最后，李代数的结构常数可改写成：\n\\[ \\boxed{\\begin{aligned}\\quad \u0026[\\textcolor{red}{P^i},\\textcolor{red}{P^j}]=0 \\quad \u0026[\\textcolor{blue}{J^i},\\textcolor{blue}{J^j}]=i \\ \\varepsilon_k^{\\ \\ ij}\\textcolor{blue}{J^k} \\\\\u0026 [\\textcolor{green}{K^i},\\textcolor{green}{K^j}]=-i\\ \\varepsilon_k^{\\ \\ ij}\\textcolor{blue}{J^k} \\quad \u0026 \\\\\u0026 [P^0,\\textcolor{blue}{J^i}]=0 \\quad \u0026[\\textcolor{red}{P^i},\\textcolor{blue}{J^j}]=i\\ \\varepsilon_k^{\\ \\ ij}\\textcolor{red}{P^k} \\\\ \u0026 [P^0,\\textcolor{green}{K^i}]=i\\ \\textcolor{red}{P^i} \\quad \u0026 [\\textcolor{red}{P^i},\\textcolor{green}{K^j}]=i\\ \\delta^{ij}P^0 \\quad \\\\ \u0026 [\\textcolor{blue}{J^i},\\textcolor{green}{K^j}]=i\\ \\varepsilon_k^{\\ \\ ij}\\textcolor{green}{K^k} \\quad \u0026 \\end{aligned}} \\]  旋量观点-三维空间转动群 参考：流形上的旋量和旋量场（初步） ，本段的任务仅仅是将旋量观点和前面的观点建立联系。\n先考察空间转动群 \\(SO(3)\\)  表示\n\\[ \\Lambda =\\exp\\left\\{-i\\boldsymbol{\\theta}\\cdot\\boldsymbol{J}\\right\\} \\]  只需取（ \\(\\boldsymbol{\\sigma}\\)  就是泡利矩阵）\n\\[ \\boldsymbol{J}=\\frac{1}{2}\\boldsymbol{\\sigma} \\]  就能得到 \\(SU(2)\\)  上的表示（自旋矩阵）\n\\[ R =\\exp\\left\\{-\\frac{i}{2}\\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}\\right\\}\\in SU(2) \\]  其作为生成元的泡利矩阵 \\(\\boldsymbol{\\sigma}\\)  的结构常数恰好与 \\(\\boldsymbol{J}\\)  一致：\n\\[ [\\textcolor{blue}{\\sigma^i},\\textcolor{blue}{\\sigma^j}]=2i \\ \\varepsilon_k^{\\ \\ ij}\\textcolor{blue}{\\sigma^k} \\]  这意味着， \\(SO(3)\\)  和 \\(SU(2)\\)  的李代数完全同构\n\\[ \\boxed{\\mathscr{SO}(3)\\cong\\mathscr{SU}(2)} \\]  旋量观点-固有洛伦兹群 然后考察固有洛伦兹群 \\(SO(1,3)\\)  \\[ \\Lambda =\\exp\\left\\{-i\\boldsymbol{\\theta}\\cdot\\boldsymbol{J}+i\\boldsymbol{\\eta}\\cdot\\boldsymbol{K}\\right\\} \\]  在此基础上构造\n\\[ \\boldsymbol{J}^+=\\frac{1}{2}(\\boldsymbol{J}+i\\boldsymbol{K})\\\\ \\boldsymbol{J}^-=\\frac{1}{2}(\\boldsymbol{J}-i\\boldsymbol{K}) \\]  容易验证： \\[ [J^{+i},J^{+j}]=\\frac{i}{2}\\varepsilon_k^{\\ ij}J^{+k}\\quad [J^{-i},J^{-j}]=\\frac{i}{2}\\varepsilon_k^{\\ ij}J^{-k}\\\\ [J^{+i},J^{-j}]=0 \\]  我们发现：\n1）两组生成元都是厄米的，都属于 \\(SU(2)\\)  的李代数的元素\n2）这两组生成元都满足和前面相同的结构常数，精确到相差一个常实系数；\n3）这两组相互独立（对易关系为0）。\n这意味着：\n\\[ \\boxed{\\mathscr{SO}(1,3)\\cong\\mathscr{SU}(2)\\otimes\\mathscr{SU}(2)} \\]  自旋与旋量 在《旋量初步》定义了四种基本旋量，它们分别满足的变换规则： \\[ \\begin{aligned}\\psi^A\\quad \\text{满足}\\quad L^B_{\\ \\ A}=\u0026\\exp\\left\\{(\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\frac{\\boldsymbol{\\sigma}}{2}\\right\\}\\\\ \\psi_A\\quad \\text{满足}\\quad L_A^{\\ \\ B}=\u0026(L^A_{\\ \\ B})^{-1}=\\exp\\left\\{(-\\boldsymbol{\\eta}+i\\ \\boldsymbol{\\theta})\\cdot\\frac{\\boldsymbol{\\sigma}}{2}\\right\\}\\\\ \\psi^{A'}\\quad \\text{满足}\\quad \\bar{L}_{B'}^{\\ \\ A'}=\u0026\\overline{L^A_{\\ \\ B}}=\\exp\\left\\{(\\boldsymbol{\\eta}+i\\ \\boldsymbol{\\theta})\\cdot\\frac{\\boldsymbol{\\sigma}}{2}\\right\\}\\\\ \\psi_{A'}\\quad \\text{满足}\\quad \\bar{L}^{B'}_{\\ \\ A'}=\u0026\\left(\\overline{L^A_{\\ \\ B}}\\right)^{-1}=\\exp\\left\\{(-\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\frac{\\boldsymbol{\\sigma}}{2}\\right\\} \\end{aligned} \\]  在此基础上， \\((k,k';l,l')\\)  型旋量张量 \\[ \\psi^{A_1\\dots A_k A'_1\\dots A'_{k'}}_{\\quad \\qquad \\qquad B_1\\dots B_l B'_1\\dots B'_{l'}} \\]  满足的变换规则： \\[ \\exp\\left\\{\\left[(k+k'-l-l')\\boldsymbol{\\eta}-i\\ (k-k'-l+l')\\boldsymbol{\\theta}\\right]\\cdot\\frac{\\boldsymbol{\\sigma}}{2}\\right\\} \\]  和固有洛伦兹群比较有： \\[ \\boldsymbol{J}=(k-k'-l+l')\\frac{\\boldsymbol{\\sigma}}{2}\\\\ \\boldsymbol{K}=-i\\ (k+k'-l-l')\\frac{\\boldsymbol{\\sigma}}{2} \\]  进而： \\[ \\boldsymbol{J}^{-}=(l'-k')\\frac{\\boldsymbol{\\sigma}}{2}=j_{-}\\ \\boldsymbol{\\sigma}\\quad j_{-}\\overset{\\Delta}{=}\\frac{1}{2}(l'-k')\\\\ \\boldsymbol{J}^{+}=(k-l)\\frac{\\boldsymbol{\\sigma}}{2}=j_{+}\\ \\boldsymbol{\\sigma}\\quad j_{+}\\overset{\\Delta}{=}\\frac{1}{2}(k-l)\\\\ \\quad \\\\ \\boxed{\\boldsymbol{J}=(j_{-}+j_{+})\\boldsymbol{\\sigma}=j\\ \\boldsymbol{\\sigma}} \\quad j\\overset{\\Delta}{=}j_{-}+j_{+} \\]  这说明了：\n1）旋量张量都可以用一对半整数 \\((j_{-},j_{+})\\)  标记；\n2）旋量张量的纯旋转用 \\(j\\)  标记，所以这个旋量张量对应 \\(\\color{red}{\\text{自旋-}j}\\)  。\n3） \\(j_{-},j_{+},j\\)  都有可能取负号。一般我们只关注正数的情况，只要明白取负号的意义，逆变换矩阵，表示对应反向而已。\n \\((j_{-},j_{+})\\)  对应的维度是 \\((2j_{-}+1)(2j_{+}+1)\\)  【我暂时没理解，以后再说】。在量子力学中，所有可能的 \\(\\text{自旋-}j\\)  ，满足： \\[ |j_{+}-j_{-}|\\le j\\le j_{+}+j_{-}\\quad \\textcolor{red}{整数步距} \\]  0自旋 0自旋只有一种可能： \\((0,0)\\)  ，1维的，对应 \\(\\boldsymbol{J}^{\\pm}=0\\)  ，进而 \\(\\boldsymbol{J},\\boldsymbol{K}\\)  都是0 \\[ \\Lambda = I \\]  这种不变的效果，就对应所谓的标量。\n1/2自旋 1/2自旋只有两种可能组合： \\((\\frac{1}{2},0)\\)  和 \\((0,\\frac{1}{2})\\)  ，都是2维的，进而 \\[ \\textcolor{red}{(\\frac{1}{2},0)}\\quad \\boldsymbol{J}=\\frac{1}{2}\\boldsymbol{\\sigma}\\quad \\boldsymbol{K}=\\frac{i}{2}\\boldsymbol{\\sigma}\\\\ \\quad \\textcolor{red}{(0,\\frac{1}{2})}\\quad \\boldsymbol{J}=\\frac{1}{2}\\boldsymbol{\\sigma}\\quad \\boldsymbol{K}=-\\frac{i}{2}\\boldsymbol{\\sigma} \\]  对应的洛伦兹群表示：\n\\[ \\textcolor{red}{(\\frac{1}{2},0)}\\quad \\Lambda_L =\\exp\\left\\{\\frac{1}{2}(-\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}\\\\ \\textcolor{red}{(0,\\frac{1}{2})}\\quad\\Lambda_R =\\exp\\left\\{\\frac{1}{2}(\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}\\\\ \\boxed{(\\Lambda_R)^\\dagger\\Lambda_L=I} \\]  于是：\nA）满足 \\(\\Lambda_R\\)  或 \\(\\textcolor{red}{(0,1/2)}\\)  变换规则的旋量，是 \\((1,0;0,0)\\)  型的逆变旋量 \\(\\textcolor{red}{\\psi_R}=\\psi^A\\)  ；\nB）满足 \\((\\Lambda_R)^{\\dagger}\\)  或 \\(\\textcolor{blue}{(-1/2,0)}\\)  变换规则的旋量，是 \\((0,0;1,0)\\)  型的共轭逆变旋量 \\(\\psi^{A'}\\)  ；\nC）满足 \\((\\Lambda_R)^{-1}\\)  或 \\(\\textcolor{blue}{(0,-1/2)}\\)  变换规则的旋量，是 \\((0,1;0,0)\\)  型的协变旋量 \\(\\psi_A\\)  ；\nD）满足 \\(\\Lambda_L=(\\Lambda_R^{\\ \\ \\dagger})^{-1}\\)  或 \\(\\textcolor{red}{(1/2,0)}\\)  变换规则的旋量，是 \\((0,0;0,1)\\)  型的共轭协变旋量 \\(\\textcolor{red}{\\psi_L}=\\psi_{A'}\\)  。\n在物理上，分别称 \\((\\psi_L)_\\alpha,(\\psi_R)_\\alpha,\\alpha=1,2\\)  ，为左外尔旋量，右外尔旋量。但本笔记系列，更喜欢称之为共轭协变旋量 \\(\\psi_{A'}\\)  ，逆变旋量 \\(\\psi^A\\)  。\n另外两种旋量，实际上代表-1/2自旋，负数代表反向。\n1自旋 1自旋有三种可能： \\((1/2,1/2),(1,0),(0,1)\\)  。\n【第一种情况】： \\((1/2,1/2)\\)  ，对应复4维的，有0自旋和1自旋两种状态。对应的群表示：\n\\[ \\exp\\left\\{-i\\ \\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}\\right\\}=\\textcolor{red}{\\Lambda_L\\Lambda_R} \\]  所以， \\((\\frac{1}{2},\\frac{1}{2})\\)  可写成\n\\[ (\\frac{1}{2},\\frac{1}{2})=(\\frac{1}{2},0)\\otimes(0,\\frac{1}{2})=\\textcolor{blue}{\\boldsymbol{0}}\\oplus\\textcolor{red}{\\boldsymbol{1}} \\]  其中，0自旋对应标量，1自旋对应4维矢量。\n【第二种情况】： \\((1,0)\\)  和 \\((0,1)\\)  ，都对应复3维的，都只有1自旋一种状态。对应的群表示： \\[ \\exp\\left\\{(-\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}=\\Lambda_L\\Lambda_L\\\\ \\exp\\left\\{(\\boldsymbol{\\eta}-i\\ \\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right\\}=\\Lambda_R\\Lambda_R \\]  满足 \\(\\textcolor{red}{(1,0)}\\)  变换规则的旋量张量 \\(\\psi_{A'B'}=\\psi_{(A'B')}\\)  ；满足 \\(\\textcolor{red}{(0,1)}\\)  变换规则的旋量张量 \\(\\psi^{AB}=\\psi^{(AB)}\\)  。 其中的对称性源自3维的约束。\n波函数和自旋张量 一般而言，物理上的波函数常用 \\(n\\)  个指标的全对称旋量张量 \\(\\psi_{AB\\dots F}=\\psi_{(AB\\dots F)}\\)  ，对应 \\(\\color{red}{\\text{自旋-}\\frac{n}{2}}\\)  。全对称旋量张量，又被称作自旋张量。\n在这种情况下，比如\n1） \\(\\color{blue}{\\text{自旋-}0}\\)  对应标量 \\(\\psi\\)  ，比如： \\(\\pi\\)  介子；\n2） \\(\\color{blue}{\\text{自旋-}\\frac{1}{2}}\\)  对应协变旋量 \\(\\psi_A\\)  ，比如：中微子；\n3） \\(\\color{blue}{\\text{自旋-}1}\\)  对应对称旋量张量 \\(\\psi_{AB}=\\psi_{(AB)}\\)  ，比如：光子。\n"}),a.add({id:105,href:'/notes/tags/%E5%AF%BC%E6%95%B0%E7%AE%97%E7%AC%A6/',title:"导数算符",content:""}),a.add({id:106,href:'/notes/tags/%E6%9B%B2%E7%8E%87/',title:"曲率",content:""}),a.add({id:107,href:'/notes/docs/diffgeo/0079/',title:"流形上的旋量和旋量场（自旋系数和克氏符）",content:" 上两篇，引入旋量概念以及旋量代数，以及旋量的一个直观的几何解释。\n自旋系数，是和克氏符对标的概念。\n引入了新的记号，复用度规符号   \\(\\textcolor{red}{g_\\mu^{\\ \\ a}}\\)  来表示矢量基底； \\(\\textcolor{red}{g_\\mu^{\\ \\ AA'}}\\)  表示泡利矩阵，复用旋量度规符号 \\(\\textcolor{red}{\\epsilon_\\Sigma^{\\ \\ A}}\\)  来表示旋量基底;\n张量指标和旋量指标混用。\n本篇虽然看起来公式“巨复杂”，但是掌握了指标的提升、降低、置换、缩并，完全可以无脑写出。\n 度规符号的复用【新记号】 首先，我们引入新记号【旧瓶新装】:\n\\[ \\begin{aligned}\\textcolor{red}{g_{ \\mu}^{\\ \\ a}}=g^a_{\\ \\ \\mu}\\textcolor{blue}{\\overset{\\Delta}{=}}\u0026\\textcolor{red}{(e_\\mu)^a}\\\\ \\textcolor{red}{g^\\mu_{\\ \\ a}}=g_a^{\\ \\ \\mu}=\u0026g^{\\mu\\upsilon}g_{ab}g_{\\upsilon}^{\\ \\ b}=\\textcolor{red}{(e^\\mu)_a}\\end{aligned} \\]  对应 \\(g_{ab}\\)  是度规张量， \\(g_{\\mu\\upsilon}\\)  是度规分量， \\(\\textcolor{red}{g_{ \\mu}^{\\ \\ a}}\\)  就是张量和分量之间建立联系的标架（基底）,比如：\n\\[ \\begin{aligned}\\theta^a=g_\\mu^{\\ \\ a}\\theta^\\mu\\quad \\textcolor{red}{矢量按基底展开} \\\\ \\theta^\\mu=g^\\mu_{\\ \\ a}\\theta^a \\quad \\textcolor{red}{矢量分量的表示}\\end{aligned} \\]  由于可见， \\(\\textcolor{red}{g_{ \\mu}^{\\ \\ a}}\\)  不仅仅表示标架，还可简单理解成抽象指标和具体指标互换的算符。 相对应的有： \\(g^\\mu_{\\ \\ \\upsilon}=g^{\\ \\ \\mu}_{\\upsilon}=\\delta^\\mu_\\upsilon\\)  可将具体指标互换， \\(g^a_{\\ \\ b}=g^{\\ \\ a}_{b}=\\delta^a_b\\)  则可将抽象指标互换。【所以，通过将 \\(g\\)  复用来表示标架（基底）是很合理的】\n这个约定（复用），虽然没有本质上的区别，但是好处是：方便无脑进行指标的提升和下降，再加上水平置换的处理。\n理解克氏符 【注意】当涉及标架的“缩并”时，导数算符和此种“缩并”是不可交换的。 其它情况，导数算符和缩并是可交换的。\n考察 \\(\\textcolor{blue}{\\nabla_a\\theta^b}\\)  的分量 \\(\\boxed{g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ b}(\\textcolor{blue}{\\nabla_a\\theta^b})}\\ne \\nabla_\\mu\\theta^\\upsilon=\\partial_\\mu\\theta^\\upsilon\\)  \\[ \\begin{aligned}g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ b}(\\textcolor{blue}{\\nabla_a\\theta^b})=\u0026g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ b}\\nabla_a(\\theta^\\sigma g_\\sigma^{\\ \\ b}) \\quad \\textcolor{red}{将矢量按基底展开}\\\\ =\u0026g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ b}g_\\sigma^{\\ \\ b}\\nabla_a\\theta^\\sigma +g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ b}\\theta^\\sigma\\nabla_a g_\\sigma^{\\ \\ b}\\quad \\textcolor{red}{莱布尼茨律}\\\\ =\u0026g_\\mu^{\\ \\ a}g^\\upsilon_{\\ \\ \\sigma}\\boxed{\\partial_a\\theta^\\sigma} +\\theta^\\sigma (\\textcolor{green}{g^\\upsilon_{\\ \\ b}\\nabla_\\mu g_\\sigma^{\\ \\ b}})\\quad \\textcolor{red}{缩并,标量场导数算符}\\\\ =\u0026\\boxed{\\partial_\\mu\\theta^\\upsilon +\\theta^\\sigma \\textcolor{green}{\\Gamma^\\upsilon_{\\ \\ \\mu\\sigma}}}\\end{aligned} \\]  其中 \\(\\textcolor{green}{\\Gamma^\\upsilon_{\\ \\ \\mu\\sigma}}\\)  就是克氏符\n\\[ \\boxed{\\Gamma^\\upsilon_{\\ \\ \\mu\\sigma}=g^\\upsilon_{\\ \\ b}\\nabla_\\mu g_\\sigma^{\\ \\ b}=-g_\\sigma^{\\ \\ b}\\nabla_\\mu g^\\upsilon_{\\ \\ b}} \\]  也可改写成：\n\\[ \\boxed{\\nabla_\\mu g_\\sigma^{\\ \\ a}=\\Gamma^\\upsilon_{\\ \\ \\mu\\sigma}g_\\upsilon^{\\ \\ a}\\\\ \\text{或} \\\\ \\nabla_\\mu(e_\\sigma)^a =\\Gamma^\\upsilon_{\\ \\ \\mu\\sigma}(e_\\upsilon)^a} \\]  由此得到，克氏符的理解：克氏符就是导数算符作用于标架场的系数。\n利用标架，可将分量方程写成张量方程\n\\[ \\nabla_a\\theta^b=\\partial_a\\theta^b+\\theta^c \\Gamma^b_{\\ \\ ac} \\]  旋量度规符号的复用【新记号】 和前面类似，不妨复用旋量度规符号 \\(\\epsilon\\)  ，来表示旋量基底\n\\[ \\begin{aligned}\\textcolor{red}{\\epsilon_{ \\Sigma}^{\\ \\ A}}\\textcolor{blue}{\\overset{\\Delta}{=}}\u0026\\textcolor{red}{(\\omicron^A,\\iota^A)}\\\\ \\textcolor{red}{\\epsilon_{ \\Sigma A}}=\u0026\\epsilon_\\Sigma^{\\ \\ B}\\epsilon_{BA}=\\textcolor{red}{(\\omicron_A,\\iota_A)} \\\\ \\textcolor{red}{\\epsilon_A^{\\ \\ \\Sigma}}=\u0026-\\epsilon^{\\Sigma\\Omega}\\epsilon_{\\Omega A}=\\textcolor{red}{(-\\iota_A,\\omicron_A)}\\\\ \\textcolor{red}{\\epsilon^{\\Sigma A}}=\u0026\\epsilon^{\\Sigma\\Omega}\\epsilon_{\\Omega}^{\\ \\ A}=\\textcolor{red}{(\\iota^A,-\\omicron^A)}\\end{aligned} \\]  其次，旋量张量加\u0026quot;撇\u0026quot;（ \\('\\)  ）的映射记号【要和指标加“撇”区别开来】：\n\\[ \\begin{aligned}\u0026\\omicron^A\\mapsto(\\omicron^A)'\\textcolor{blue}{\\overset{\\Delta}{=}}i \\iota^A\\quad \\iota^A\\mapsto(\\iota^A)'=i \\omicron^A\\\\ \u0026\\bar{\\omicron}^{A'}\\mapsto(\\bar{\\omicron}^{A'})'=-i \\bar{\\iota}^{A'}\\quad \\bar{\\iota}^{A'}\\mapsto(\\bar{\\iota}^{A'})'=-i \\bar{\\omicron}^{A}\\end{aligned} \\]  对一个旋量张量进行加\u0026quot;撇\u0026quot;（ \\('\\)  ）映射，就是对其基底表示的所有基底进行加\u0026quot;撇\u0026quot;（ \\('\\)  ）映射的结果。\n自旋系数 有了旋量基底的方便表示，分量可用缩并的方式表示。\n比如，旋量 \\(\\kappa^A\\)  的分量：\n\\[ \\kappa^\\Sigma=\\kappa^A\\epsilon_{A}^{\\ \\ \\Sigma} \\]  比如，导数算符 \\(\\nabla_{AA'}\\)  的分量：\n\\[ \\nabla_{\\Sigma\\Sigma'}=\\epsilon_\\Sigma^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\nabla_{AA'} \\]  要注意，***导数算符作用于旋量张量***的分量 \\(\\Large \\textcolor{red}{不等于}\\)  导数算符分量作用于旋量张量分量。\n比如，导数算符 \\(\\nabla_{AA'}\\)  作用于协变旋量 \\(\\kappa^A\\)  的分量：\n\\[ \\begin{aligned}\\underbrace{\\epsilon_{\\Sigma}^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\epsilon_B^{\\ \\ \\Omega}\\textcolor{blue}{\\nabla_{AA'}\\kappa^B}}_{\\textcolor{#228B22}{先作用后分量}}\u0026=\\epsilon_B^{\\ \\ \\Omega}\\nabla_{\\Sigma\\Sigma'}(\\kappa^\\Lambda\\epsilon_\\Lambda^{\\ \\ B})\\\\ \u0026=\\epsilon_B^{\\ \\ \\Omega}\\epsilon_\\Lambda^{\\ \\ B}\\nabla_{\\Sigma\\Sigma'}\\kappa^\\Lambda+\\kappa^\\Lambda\\epsilon_B^{\\ \\ \\Omega}\\nabla_{\\Sigma\\Sigma'}\\epsilon_\\Lambda^{\\ \\ B}\\\\ \u0026=\\underbrace{\\textcolor{blue}{\\nabla_{\\Sigma\\Sigma'}\\kappa^\\Omega}}_{\\textcolor{#228B22}{先分量后作用}}+\\textcolor{blue}{\\kappa^\\Lambda}\\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Lambda}^{\\ \\ \\quad \\Omega}}\\end{aligned} \\]  其中，红色标记的旋量张量分量，被称作自旋系数：\n\\[ \\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Lambda}^{\\ \\ \\quad \\Omega}}\\overset{\\Lambda}{=}\\epsilon_A^{\\ \\ \\Omega}\\nabla_{\\Sigma\\Sigma'}\\epsilon_\\Lambda^{\\ \\ A}=-\\epsilon_\\Lambda^{\\ \\ A}\\nabla_{\\Sigma\\Sigma'}\\epsilon_A^{\\ \\ \\Omega}\\\\ \\quad \\\\ \\gamma_{\\Sigma\\Sigma'\\Lambda\\Omega}=\\gamma_{\\Sigma\\Sigma'\\Omega\\Lambda} \\]  类似地，导数算符 \\(\\nabla_{AA'}\\)  作用于逆变旋量 \\(\\mu^A\\)  的分量：\n\\[ \\epsilon_\\Sigma^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\epsilon_\\Omega^{\\ \\ B}\\textcolor{blue}{\\nabla_{AA'}\\mu_B}=\\textcolor{blue}{\\nabla_{\\Sigma\\Sigma'}\\mu_\\Omega}-\\textcolor{blue}{\\mu_\\Lambda}\\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Omega}^{\\ \\ \\quad \\Lambda}} \\]  另外两种旋量 \\(\\phi^{A'}\\)  和 \\(\\zeta_{A'}\\)  被作用后的分量：\n\\[ \\epsilon_\\Sigma^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\epsilon_{B'}^{\\ \\ \\Omega'}\\textcolor{blue}{\\nabla_{AA'}\\phi^{B'}}=\\textcolor{blue}{\\nabla_{\\Sigma\\Sigma'}\\phi^{\\Omega'}}+\\textcolor{blue}{\\phi^{\\Lambda'}}\\textcolor{red}{\\bar{\\gamma}_{\\Sigma\\Sigma'\\Lambda'}^{\\ \\ \\ \\quad \\Omega'}}\\\\ \\epsilon_\\Sigma^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\epsilon_{\\Omega'}^{\\ \\ B'}\\textcolor{blue}{\\nabla_{AA'}\\zeta_{B'}}=\\textcolor{blue}{\\nabla_{\\Sigma\\Sigma'}\\zeta_{\\Omega'}}-\\textcolor{blue}{\\zeta_{\\Lambda'}}\\textcolor{red}{\\bar{\\gamma}_{\\Sigma\\Sigma'\\Omega'}^{\\ \\ \\ \\quad \\Lambda'}} \\]  最后，给出任意旋量张量 \\(T^{B_1\\dots B'_{k'}}_{\\quad \\qquad C_1\\dots C'_{l'}}\\)  被 \\(\\nabla_{AA'}\\)  作用后的分量：\n\\[ \\boxed{\\begin{aligned}\u0026\\epsilon_{\\Sigma}^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\epsilon_{B_1}^{\\ \\ \\Lambda_1}\\dots\\bar{\\epsilon}_{B'_{k'}}^{\\ \\ \\Lambda'_{k'}}\\epsilon_{\\Delta_1}^{\\ \\ C_1}\\dots\\bar{\\epsilon}_{\\Delta'_{l'}}^{\\ \\ C'_{l'}}\\textcolor{blue}{\\nabla_{AA'}T^{B_1\\dots B'_{k'}}_{\\quad \\qquad C_1\\dots C'_{l'}}}\\\\ = \u0026 \\textcolor{blue}{\\nabla_{\\Sigma\\Sigma'}T^{\\Lambda_1\\dots \\Lambda'_{k'}}_{\\quad \\qquad \\Delta_1\\dots \\Delta'_{l'}}}\\\\ \\quad \u0026 +\\sum_{i=1}^k{T^{\\Lambda_1\\dots \\Gamma_i \\dots \\Lambda'_{k'}}_{\\qquad \\qquad \\Delta_1\\dots \\Delta'_{l'}}\\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Gamma_i}^{\\qquad \\Lambda_i}}}+\\sum_{i=1}^{k'}{T^{\\Lambda_1\\dots \\Gamma'_i \\dots \\Lambda'_{k'}}_{\\qquad \\qquad \\Delta_1\\dots \\Delta'_{l'}}\\textcolor{red}{\\bar{\\gamma}_{\\Sigma\\Sigma'\\Gamma'_i}^{\\qquad \\Lambda'_i}}} \\\\ \\quad \u0026 -\\sum_{i=1}^l{T^{\\Lambda_1\\dots \\Lambda'_{k'}}_{\\quad \\qquad \\Delta_1\\dots \\Gamma_i \\dots \\Delta'_{l'}}\\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Delta_i}^{\\qquad \\Gamma_i}}}-\\sum_{i=1}^{l'}{T^{\\Lambda_1\\dots \\Lambda'_{k'}}_{\\quad \\qquad \\Delta_1\\dots \\Gamma'_i \\dots \\Delta'_{l'}}\\textcolor{red}{\\bar{\\gamma}_{\\Sigma\\Sigma'\\Delta'_i}^{\\qquad \\Gamma'_i}}} \\end{aligned}} \\]  自旋系数的计算 仔细观察自旋系数的定义【有16个分量】：\n\\[ \\boxed{\\gamma_{\\Sigma\\Sigma'\\Lambda}^{\\ \\ \\quad \\Omega}=\\textcolor{blue}{\\epsilon_A^{\\ \\ \\Omega}}\\textcolor{red}{\\nabla_{\\Sigma\\Sigma'}}\\textcolor{#228B22}{\\epsilon_\\Lambda^{\\ \\ A}}=-\\epsilon_\\Lambda^{\\ \\ A}\\nabla_{\\Sigma\\Sigma'}\\epsilon_A^{\\ \\ \\Omega}}\\\\ \\text{可改写成} \\\\ \\textcolor{red}{\\nabla_{\\Sigma\\Sigma'}}\\epsilon_\\Lambda^{\\ \\ A}=\\textcolor{red}{\\gamma_{\\Sigma\\Sigma'\\Lambda}^{\\ \\ \\quad \\Omega}}\\epsilon_\\Omega^{\\ \\ \\Lambda} \\quad \\textcolor{blue}{对标}\\textcolor{red}{克氏符} \\]  其中， \\(\\textcolor{blue}{\\epsilon_A^{\\ \\ \\Omega}}=(-\\iota_A,\\omicron_A)\\)  是协变旋量基底， \\(\\textcolor{#228B22}{\\epsilon_\\Lambda^{\\ \\ A}}=(\\omicron^A,\\iota^A)\\)  是逆变旋量基底。为 \\(\\textcolor{red}{\\nabla_{\\Sigma\\Sigma'}}\\)  引入如下记号：\n\\[ \\begin{aligned}\\textcolor{red}{D}\\textcolor{blue}{\\overset{\\Delta}{=}}\u0026\\nabla_{00'}=\\omicron^A\\bar{\\omicron}^{A'}\\nabla_{AA'}=-\\textcolor{blue}{l^a}\\nabla_a=\\bar{D} \\\\ \\textcolor{red}{\\delta}\\textcolor{blue}{\\overset{\\Delta}{=}}\u0026\\nabla_{01'}=\\omicron^A\\bar{\\iota}^{A'}\\nabla_{AA'}=-\\textcolor{blue}{m^a}\\nabla_a=\\bar{\\delta}' \\\\ \\textcolor{red}{\\delta'}=\u0026\\nabla_{10'}=\\iota^A\\bar{\\omicron}^{A'}\\nabla_{AA'}=-\\textcolor{blue}{\\bar{m}^a}\\nabla_a=\\bar{\\delta} \\\\ \\textcolor{red}{D'}=\u0026\\nabla_{11'}=\\iota^A\\bar{\\iota}^{A'}\\nabla_{AA'}=-\\textcolor{blue}{n^a}\\nabla_a=\\bar{D}'\\end{aligned} \\]  其中蓝色部分\n\\[ \\textcolor{blue}{l^{AA'}}=\\omicron^A\\bar{\\omicron}^{A'}\\quad \\textcolor{blue}{m^{AA'}}=\\omicron^A\\bar{\\iota}^{A'}\\quad \\textcolor{blue}{n^{AA'}}=\\iota^A\\bar{\\iota}^{A'}\\\\ \\quad \\\\ (l^{AA'})'=n^{AA'}\\quad (m^{AA'})'=\\bar{m}^{AA'}\\quad (\\bar{m}^{AA'})'=m^{AA'}\\quad(n^{AA'})'=l^{AA'} \\]  利用上面的记号，自旋系数可表示成\n\\[ \\gamma_{\\textcolor{red}{\\Sigma\\Sigma'}\\textcolor{blue}{\\Lambda}}^{\\ \\ \\quad \\textcolor{blue}{\\Omega}}=\\textcolor{red}{\\begin{matrix} 00' \\\\ 01' \\\\ 10' \\\\11' \\end{matrix}}\\overbrace{\\begin{pmatrix} \\omicron^A D \\iota_A \u0026 -\\omicron^A D \\omicron_A \u0026 \\iota^A D \\iota_A \u0026 -\\iota^A D \\omicron_A \\\\ \\omicron^A\\delta\\iota_A \u0026 -\\omicron^A \\delta \\omicron_A \u0026 \\iota^A\\delta\\iota_A \u0026 -\\iota^A \\delta \\omicron_A \\\\ \\omicron^A\\delta'\\iota_A \u0026 -\\omicron^A \\delta' \\omicron_A \u0026 \\iota^A\\delta'\\iota_A \u0026 -\\iota^A \\delta' \\omicron_A \\\\ \\omicron^A D' \\iota_A \u0026 -\\omicron^A D'\\omicron_A \u0026 \\iota^A D'\\iota_A \u0026 -\\iota^A D' \\omicron_A \\end{pmatrix}}^{\\textcolor{blue}{\\begin{pmatrix} \u0026 0 \\\\ 0 \u0026 \\end{pmatrix}\\qquad\\begin{pmatrix} \u0026 1 \\\\ 0 \u0026 \\end{pmatrix}\\qquad\\begin{pmatrix} \u0026 0 \\\\ 1 \u0026 \\end{pmatrix}\\qquad\\begin{pmatrix} \u0026 1 \\\\ 1 \u0026 \\end{pmatrix}}} \\]  有了旋量张量加\u0026quot;撇\u0026quot;（ \\('\\)  ）的映射记号，这个自旋系数（16个分量），可以只用8个分量表示：\n\\[ \\gamma_{\\textcolor{red}{\\Sigma\\Sigma'}\\textcolor{blue}{\\Lambda}}^{\\ \\ \\quad \\textcolor{blue}{\\Omega}}=\\textcolor{red}{\\begin{matrix} 00' \\\\ 01' \\\\ 10' \\\\11' \\end{matrix}} \\overbrace{\\begin{pmatrix} \\varepsilon \u0026 -\\kappa \u0026 -\\tau' \u0026 \\gamma' \\\\ \\alpha \u0026 -\\rho \u0026 -\\sigma' \u0026 \\beta' \\\\ \\beta \u0026 -\\sigma \u0026 -\\rho' \u0026 \\alpha' \\\\ \\gamma \u0026 -\\tau \u0026 -\\kappa' \u0026 \\varepsilon' \\end{pmatrix}}^{\\textcolor{blue}{\\begin{pmatrix} \u0026 0 \\\\ 0 \u0026 \\end{pmatrix}\\begin{pmatrix} \u0026 1 \\\\ 0 \u0026 \\end{pmatrix}\\begin{pmatrix} \u0026 0 \\\\ 1 \u0026 \\end{pmatrix}\\begin{pmatrix} \u0026 1 \\\\ 1 \u0026 \\end{pmatrix}}} \\]  其中， \\(\\varepsilon,\\alpha,\\beta,\\gamma,\\kappa,\\rho,\\sigma,\\tau\\)  和前面的系数对应相等，加\u0026quot;撇\u0026quot;（ \\('\\)  ）的是前面定义的映射。\n进而可以写出 \\(\\gamma_{\\textcolor{red}{\\Sigma\\Sigma'}\\textcolor{blue}{\\Lambda\\Omega}}\\)  的分量：\n\\[ \\gamma_{\\textcolor{red}{\\Sigma\\Sigma'}\\textcolor{blue}{\\Lambda\\Omega}}=\\textcolor{red}{\\begin{matrix} 00' \\\\ 01' \\\\ 10' \\\\11' \\end{matrix}} \\overbrace{\\begin{pmatrix} \\kappa \u0026 \\varepsilon \u0026 \\varepsilon \u0026 -\\tau' \\\\ \\rho \u0026 \\alpha \u0026 \\alpha \u0026 -\\sigma' \\\\ \\sigma \u0026 \\beta \u0026 \\beta \u0026 -\\rho' \\\\ \\tau \u0026 \\gamma \u0026 \\gamma \u0026 -\\kappa' \\end{pmatrix}}^{\\textcolor{blue}{00\\qquad 01\\qquad 10 \\qquad 11}} \\]  由于我们选择的都是归一化旋量基底，部分系数之间还有关系：\n\\[ \\boxed{\\begin{aligned}\\alpha=-\\beta'\\quad \\beta=-\\alpha' \\\\ \\varepsilon=-\\gamma'\\quad \\gamma=-\\varepsilon' \\end{aligned}} \\]  旋量指标和张量指标混合 要允许旋量指标和张量指标的混合，就离不开将旋量和张量联系在一起的泡利矩阵【含系数 \\(1/\\sqrt{2}\\)  】：\n\\[ \\sigma_\\mu^{\\ \\ AA'}\\quad \\sigma_a^{\\ \\ AA'}\\\\ \\quad \\\\ \\theta^{AA'}=\\sigma_\\mu^{\\ \\ AA'}\\theta^\\mu \\\\ \\theta^{\\mu}=-\\sigma^\\mu_{\\ \\ AA'}\\theta^{AA'} \\\\ \\quad \\\\ \\sigma^\\mu_{\\ \\ AA'}\\sigma_\\upsilon^{\\ \\ AA'}=-\\delta^\\mu_\\upsilon\\\\ \\sigma^\\mu_{\\ \\ AA'}\\sigma_\\mu^{\\ \\ BB'}=-\\delta^{B}_{A}\\delta^{B'}_{A'} \\]  由此可见，这个泡利矩阵，也完全可以用度规符号 \\(g\\)  代替表示\n\\[ \\boxed{\\begin{aligned}\\textcolor{blue}{g_\\mu^{\\ \\ AA'}}\\overset{\\Delta}{=}\\sigma_\\mu^{\\ \\ AA'} \\quad \\textcolor{blue}{g_a^{\\ \\ AA'}}=\\sigma_a^{\\ \\ AA'} \\\\ \\quad \\\\ \\textcolor{green}{g缩并新规：}\\textcolor{red}{指标对（AA'）缩并加负号}\\end{aligned}} \\]  在前面的一系列约定下，特别式这个缩并新规，我将很容易将张量指标和旋量指标混合在一起。\n首先，导数算符 \\(\\nabla_a\\)  作为一个“协变矢量”，也可用旋量导数算符 \\(\\nabla_{AA'}\\)  表示【按缩并新规也可】：\n\\[ \\nabla_a=-g_a^{\\ \\ AA'}\\nabla_{AA'}\\\\\\nabla_\\mu=-g_\\mu^{\\ \\ AA'}\\nabla_{AA'} \\]  在缩并新规下， \\(\\textcolor{blue}{\\nabla_{AA'}\\kappa^B}\\)  对应的更简单形式 \\(\\textcolor{red}{\\nabla_{a}\\kappa^B}=-g_a^{AA'}\\textcolor{blue}{\\nabla_{AA'}\\kappa^B}\\)  的分量是：\n\\[ g^{\\ \\ a}_{\\mu}\\epsilon_B^{\\ \\ \\Omega}\\textcolor{red}{\\nabla_a\\kappa^B}=\\nabla_\\mu\\kappa^\\Omega+\\kappa^\\Lambda \\textcolor{blue}{\\gamma_{\\mu\\Lambda}^{\\quad \\Omega}} \\]  其中【也符合缩并新规】\n\\[ \\boxed{\\gamma_{\\mu\\Lambda}^{\\quad \\Omega}\\overset{\\Delta}{=}-g_\\mu^{\\ \\ \\Sigma\\Sigma'}\\gamma_{\\Sigma\\Sigma'\\Lambda}^{\\ \\ \\quad \\Omega}}=\\epsilon_A^{\\ \\ \\Omega}\\nabla_\\mu\\epsilon_{\\Lambda}^{\\ \\ A} \\]  类似地，还有：\n\\[ g^{\\ \\ a}_{\\mu}\\epsilon_\\Omega^{\\ \\ B}\\textcolor{red}{\\nabla_a\\omega_B}=\\nabla_\\mu\\omega_\\Omega-\\omega_\\Lambda \\textcolor{blue}{\\gamma_{\\mu\\Omega}^{\\quad \\Lambda}} \\]  最后给一个混合张量导数 \\(\\textcolor{red}{\\nabla_a\\theta_B^{\\ \\ c}}\\)  的情况\n\\[ g_\\mu^{\\ \\ a}\\epsilon_\\Omega^{\\ \\ B}g_c^{\\ \\ \\upsilon}\\textcolor{red}{\\nabla_a\\theta_B^{\\ \\ c}}=\\nabla_\\mu\\theta_{\\textcolor{red}{\\Omega}}^{\\ \\ \\textcolor{blue}{\\upsilon}} -\\theta_\\Lambda^{\\ \\ \\upsilon}\\textcolor{red}{\\gamma_{\\mu\\Omega}^{\\quad \\Lambda}}+\\theta_\\Omega^{\\ \\ \\rho}\\textcolor{blue}{\\Gamma^\\upsilon_{\\ \\ \\mu\\rho}} \\]  红色的指标对应红色的 \\(\\textcolor{red}{自旋系数}\\)  ，蓝色的指标对应蓝色的 \\(\\textcolor{blue}{克氏符}\\)  。\n克氏符的纯旋量表示 将克氏符按旋量表示展开【利用莱布尼茨律，以及升降指标、缩并等一系列操作】\n\\[ \\begin{aligned}\\Gamma^\\sigma_{\\ \\ \\mu\\upsilon}=\u0026g^\\sigma_{\\ \\ b}\\nabla_\\mu g_\\upsilon^{\\ \\ b}=-g^\\sigma_{\\ \\ AA'}\\nabla_\\mu g_\\upsilon^{\\ \\ AA'}\\\\ = \u0026 g^\\sigma_{\\ \\ AA'}\\nabla_\\mu (g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}g_{\\Sigma\\Sigma'}^{\\ \\quad AA'})= -g^\\sigma_{\\ \\ AA'}\\nabla_\\mu (g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}\\epsilon_{\\Sigma}^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'})\\\\ =\u0026-g^\\sigma_{\\ \\ AA'}\\epsilon_{\\Sigma}^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\nabla_\\mu g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}-g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}g^\\sigma_{\\ \\ AA'}\\nabla_\\mu (\\epsilon_{\\Sigma}^{\\ \\ A}\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'})\\\\ =\u0026-g^\\sigma_{\\ \\ \\Sigma\\Sigma'}\\nabla_\\mu g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}-g_\\upsilon^{\\ \\ \\Sigma\\Sigma'}g^\\sigma_{\\ \\ \\Omega\\Omega'}\\epsilon_A^{\\ \\ \\Omega}\\bar{\\epsilon}_{A'}^{\\ \\ \\Omega'}(\\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}\\nabla_\\mu \\epsilon_{\\Sigma}^{\\ \\ A}+\\epsilon_{\\Sigma}^{\\ \\ A}\\nabla_\\mu \\bar{\\epsilon}_{\\Sigma'}^{\\ \\ A'}) \\end{aligned} \\]  进而有：\n\\[ \\begin{aligned}g^\\upsilon_{\\ \\ \\Omega\\Omega'}g_\\sigma^{\\ \\ \\Lambda\\Lambda'}\\Gamma^\\sigma_{\\ \\ \\mu\\upsilon}=\u0026g^\\upsilon_{\\ \\ \\Omega\\Omega'}\\nabla_\\mu g_\\upsilon^{\\ \\ \\Lambda\\Lambda'}-(\\bar{\\epsilon}_{\\Omega'}^{\\ \\ \\Lambda'}\\epsilon_A^{\\ \\ \\Lambda}\\nabla_\\mu \\epsilon_{\\Omega}^{\\ \\ A}+\\epsilon_{\\Omega}^{\\ \\ \\Lambda}\\bar{\\epsilon}_{A'}^{\\ \\ \\Lambda'}\\nabla_\\mu \\bar{\\epsilon}_{\\Omega'}^{\\ \\ A'})\\\\ =\u0026g^\\upsilon_{\\ \\ \\Omega\\Omega'}\\nabla_\\mu g_\\upsilon^{\\ \\ \\Lambda\\Lambda'}-\\bar{\\epsilon}_{\\Omega'}^{\\ \\ \\Lambda'}\\gamma_{\\mu\\Omega}^{\\quad \\Lambda}-\\epsilon_{\\Omega}^{\\ \\ \\Lambda}\\bar{\\gamma}_{\\mu\\Omega'}^{\\quad \\Lambda'}\\end{aligned} \\]  将 \\(\\Lambda'\\)  和 \\(\\Omega'\\)  缩并得 \\[ \\gamma_{\\mu\\Omega}^{\\quad \\Lambda}=-\\frac{1}{2}g^\\upsilon_{\\ \\ \\Omega\\Omega'}g_\\sigma^{\\ \\ \\Lambda\\Omega'}\\Gamma^\\sigma_{\\ \\ \\mu\\upsilon}+\\frac{1}{2}g^\\upsilon_{\\ \\ \\Omega\\Omega'}\\nabla_\\mu g_\\upsilon^{\\ \\ \\Lambda\\Omega'} \\]  指标操作规则梳理  【注意】涉及旋量的规则，依赖度规 (-1，1，1，1) 或 (1，1，1)\n 规则一：【兼容】兼容张量指标操作：指标缩并、指标提升、指标下降、指标替换。\n规则二：【缩并】张量指标要求一上一下即可；旋量指标要求左上右下，否则加负号，比如： \\[ \\theta^a=g^{ab}\\theta_b=g^{ba}\\theta_b\\\\ \\theta^A=\\epsilon^{AB}\\theta_B=-\\epsilon^{BA}\\theta_B \\]  规则三：【张量和分量】张量抽象指标和具体指标替换，比如： \\[ \\begin{aligned}\\theta^a=g_\\mu^{\\ \\ a}\\theta^\\mu\\quad \\textcolor{red}{矢量按基底展开} \\\\ \\theta^\\mu=g^\\mu_{\\ \\ a}\\theta^a \\quad \\textcolor{red}{矢量分量的表示}\\\\ \\quad \\\\ \\theta^A=\\theta^\\Sigma\\epsilon_\\Sigma^{\\ \\ A}\\quad \\textcolor{blue}{旋量按基底展开} \\\\ \\theta^\\Sigma=\\theta^A\\epsilon_A^{\\ \\ \\Sigma}\\quad \\textcolor{blue}{旋量分量的表示}\\end{aligned} \\]  规则四：旋量指标对缩并或拆分加负号。比如 \\[ \\theta^\\mu=-g^\\mu_{\\ \\ AA'}\\theta^{AA'} \\quad \\theta^a\\omega_a=-\\theta^{AA'}\\omega_{AA'}\\\\ g_{AA'BB'}=-\\epsilon_{AB}\\bar{\\epsilon}_{A'B'}\\quad g_{AA'}^{\\quad BB'}=-\\epsilon_A^{\\ \\ B}\\bar{\\epsilon}_{A'}^{\\ \\ B'} \\]  "}),a.add({id:108,href:'/notes/docs/diffgeo/0078/',title:"流形上的旋量和旋量场（导数算符和曲率）",content:" 上两篇，引入旋量概念以及旋量代数，以及旋量的一个直观的几何解释。\n本篇，引入旋量场导数算符和曲率旋量两个概念。\n本篇限定讨论时空流形上的旋量分析，始终选择正交归一标架场（约定   \\((-1,1,1,1)\\)  度规）。特殊情况下，就是闵氏时空。\n 旋量场 考虑一个时空流形 \\((M,g_{ab})\\)  。矢量、张量、旋量，都是某点 \\(p\\in M\\)  切空间 \\(V_p\\)  上的概念。\n对有度规的时空流形而言，我们总能在切空间 \\(V_p\\)  找到一组正交归一的基底，这意味着切空间和平直闵氏时空无数学上的差异【见第一篇】。 所以，当我们谈及闵氏时空时，可以理解成全局平直的闵氏时空， 也可理解成时弯曲时空上某点的局域闵氏时空。\n矢量和张量的概念是不依赖度规的，但旋量是度规依赖的。在前两篇中，我们约定依赖的闵氏度规是 \\((-1,1,1,1)\\)  的。 所以，必须选择正交归一的基底场。\n此外，旋量的分量的表示依赖于一个旋量空间 \\((W,\\epsilon_{AA'})\\)  中选择一组基底 \\((\\omicron^A,\\iota^A)\\)  。\n我们在每一点 \\(p\\in M\\)  都选择一个旋量，要求选择保持光滑连续性，那么就得到一个旋量场。事实上，旋量场就是时空流形 \\(M\\)  到旋量空间 \\(W\\)  的光滑映射。\n旋量场的导数算符 在前面的约定下，存在与度规 \\(g_{ab}\\)  唯一适配的的导数算符 \\(\\nabla_a\\)  。 而 \\(\\nabla_a\\)  很像“协变矢量”，于是可将这个“协变矢量”所关联的“旋量张量” \\(\\nabla_{AA'}\\)  定义为旋量场的导数算符：\n\\[ \\boxed{\\nabla_{AA'}\\overset{\\Delta}{=}\\sigma^a_{\\ \\ AA'}\\nabla_a} \\]  具体而言，比如，当作用于协变矢量 \\(\\omega_b\\)  所关联旋量张量 \\(\\omega_{BB'}\\)  上时\n\\[ \\nabla_{AA'}\\omega_{BB'}=\\sigma^a_{\\ \\ AA'}\\sigma^b_{\\ \\ BB'}\\nabla_a \\omega_{b} \\]  根据这个定义，旋量导数算符 \\(\\nabla_{AA'}\\)  也满足：\n 1）线性的； 2）莱布尼兹律； 3）与缩并可交换； 4）可退化性： \\(v(f)=-v^{AA'}\\nabla_{AA'}f \\)  ； 5）无挠性： \\(\\nabla_{AA'}\\nabla_{BB'}f=\\nabla_{BB'}\\nabla_{AA'}f\\)  。  此外， \\(\\nabla_{AA'}\\)  还满足：\n i）“实数性”： \\(\\overline{\\nabla_{AA'}\\psi^{\\dots}_{\\quad \\dots}}=\\nabla_{AA'}\\bar{\\psi}^{\\dots}_{\\quad \\dots}\\)  ； ii）“自动适配旋量度规”： \\(\\nabla_{AA'}\\epsilon_{BC}=0=\\nabla_{AA'}\\epsilon^{BC}\\)  。  曲率旋量 已知算符 \\([\\nabla_a,\\nabla_b]\\)  是一个线性映射 \\(\\mathscr{T}_p(0,1)\\to\\mathscr{T}_p(0,3)\\)  ，即代表一个张量 \\(R_{abc}^{\\quad d}\\)  ，这就是黎曼曲率张量，改写成其关联的旋量形式\n\\[ (\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\omega_{CC'}=R_{AA'BB'CC'}^{\\qquad \\qquad DD'}\\omega_{DD'} \\]  此外，根据旋量导数算符的定义，对易算符 \\([\\nabla_a,\\nabla_b]\\)  所关联的旋量算符是\n\\[ \\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'}=\\sigma^a_{\\ \\ AA'}\\sigma^b_{\\ \\ BB'}[\\nabla_a,\\nabla_b] \\]  据此可见，由 \\([\\nabla_a,\\nabla_b]\\)  的线性性可诱导出 \\(\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'}\\)  的线性性，即是线性映射 \\(\\mathscr{T}_p(0,1;0,0)\\to \\mathscr{T}_p(0,3;0,2)\\)  ，可用旋量张量 \\(\\chi_{AA'BB'C}^{\\quad \\qquad D}\\)  表示之，称为曲率旋量\n\\[ \\boxed{(\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\omega_C=\\chi_{AA'BB'C}^{\\quad \\qquad D}\\omega_D} \\]  曲率旋量 =》 黎曼曲率张量 将旋量导数算符对易子作用在 \\(\\omega_A\\bar{\\omega}_{A'}\\)  上，利用旋量导数算符的莱布尼茨律及其“实数性”，不难推导出：\n\\[ (\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\ \\omega_C\\bar{\\omega}_{C'}=\\chi_{AA'BB'C}^{\\quad \\qquad D}\\omega_D\\bar{\\omega}_{C'}+ \\bar{\\chi}_{AA'BB'C'}^{\\quad \\qquad D'}\\omega_C\\bar{\\omega}_{D'} \\]  将这个结果和黎曼曲率张量定义进行比较得知：\n\\[ \\boxed{R_{AA'BB'CC'}^{\\qquad \\qquad DD'}= \\chi_{AA'BB'C}^{\\quad \\qquad D}\\bar{\\epsilon}_{C'}^{\\ \\ D'}+ \\bar{\\chi}_{AA'BB'C'}^{\\quad \\qquad D'}\\epsilon_C^{\\ D}} \\]  黎曼曲率张量 =》曲率旋量 由于 \\(R_{abcd}\\)  关于最后两个指标是反称的，依据指标对的反称分解恒等式，有\n\\[ R_{AA'BB'CC'DD'}=\\frac{1}{2}R_{AA'BB'(CD)X'}^{\\quad \\qquad \\qquad X'}\\bar{\\epsilon}_{C'D'}+\\frac{1}{2}R_{AA'BB'(C'D')X}^{\\quad \\qquad \\qquad X}\\epsilon_{CD} \\]  通过比较得知【同时还利用了 \\(R_{abcd}\\)  的\u0026quot;实数性\u0026quot;】：\n\\[ \\boxed{\\chi_{AA'BB'CD}=\\chi_{AA'BB'(CD)}=\\frac{1}{2}R_{AA'BB'(CD)C'}^{\\quad \\qquad \\qquad C'}} \\]  曲率旋量的分解  \\(R_{abcd}\\)  关于头两指标也是反称的，进而 \\(\\chi_{AA'BB'CD}\\)  关于头两组指标也是反称的，再次依据指标对的反称分解恒等式，有：\n\\[ \\boxed{\\chi_{AA'BB'CD}=\\Lambda_{ABCD}\\bar{\\epsilon}_{A'B'}+\\Phi_{A'B'CD}\\epsilon_{AB}}\\\\ \\Lambda_{ABCD}=\\frac{1}{2}\\chi^{\\ \\qquad A'}_{(AB)A'\\ \\ CD}\\\\ \\Phi_{A'B'CD}=\\frac{1}{2}\\chi^{\\ \\ \\qquad A}_{(A'B')A\\ \\ CD} \\]  有性质如下：\n\\[ \\boxed{\\Lambda_{ABCD}=\\Lambda_{(AB)(CD)}\\quad \\Phi_{A'B'CD}=\\Phi_{(A'B')(CD)}} \\]  将前面的结果全部带入，有\n\\[ \\Phi_{A'B'CD}=\\frac{1}{4}\\epsilon^{AB}\\bar{\\epsilon}^{C'D'}R_{(A'B')AB(CD)C'D'} \\\\ \\Lambda_{ABCD}=\\frac{1}{4}\\bar{\\epsilon}^{A'B'}\\bar{\\epsilon}^{C'D'}R_{(AB)A'B'(CD)C'D'} \\]  进而，再根据 \\(R_{abcd}=R_{cdab}\\)  ，有性质如下：\n\\[ \\boxed{\\begin{aligned}\\bar{\\Phi}_{ABC'D'}\u0026=\\Phi_{ABC'D'} \\quad \\text{实数性}\\\\ \\quad \\\\ \\Lambda_{ABCD}\u0026=\\Lambda_{CDAB}\\end{aligned}} \\]  Weyl旋量的构造 易证 \\(\\epsilon^{AC}\\Lambda_{ABCD}\\)  是反称的，必定有一个乘子 \\(\\epsilon_{BD}\\)  。 于是可以定义 \\(\\Psi_{ABCD}\\)  ，我们将会看见，这就是Weyl旋量： \\[ \\boxed{\\Psi_{ABCD}\\overset{\\Delta}{=}\\Lambda_{ABCD}-\\Lambda(\\epsilon_{AC}\\epsilon_{BD}+\\epsilon_{BC}\\epsilon_{AD})}\\\\ \\quad \\Lambda\\overset{\\Delta}{=}\\frac{1}{6}\\epsilon^{AC}\\epsilon^{BD}\\Lambda_{ABCD} \\]  如此构造的 \\(\\Psi_{ABCD}\\)  ，必定满足：【依赖 \\(\\epsilon^{AC}\\Lambda_{ABCD}\\)  的反称性】\n\\[ \\epsilon^{AC}\\Psi_{ABCD}=0 \\]  再与 \\(\\Lambda_{ABCD}\\)  的对称性一起，蕴含着， \\(\\Psi_{ABCD}\\)  是全对称的：【暂时没证出来】\n\\[ \\Psi_{ABCD}=\\Psi_{(ABCD)} \\]  最后，根据 \\(R_{a[bcd]}=0\\)  ，及第一篇末尾的恒等式，可知：【暂时没证出来】\n\\[ \\bar{\\Lambda}=\\Lambda\\quad \\text{实数性} \\]  因此，曲率旋量可以分解成：\n\\[ \\boxed{\\chi_{AA'BB'CD}=\\Psi_{ABCD}\\bar{\\epsilon}_{A'B'}+\\Phi_{A'B'CD}\\epsilon_{AB}+\\Lambda(\\epsilon_{AC}\\epsilon_{BD}+\\epsilon_{BC}\\epsilon_{AD})\\bar{\\epsilon}_{A'B'}} \\]  Weyl张量和Weyl旋量 进而，黎曼曲率张量可分解成：\n\\[ \\boxed{\\begin{aligned}R_{AA'BB'CC'}^{\\qquad \\qquad DD'}=\\Psi_{ABC}^{\\ \\ \\quad D}\\bar{\\epsilon}_{A'B'}\\bar{\\epsilon}_{C'}^{\\ \\ D'}+\\Phi_{A'B'C}^{\\qquad D}\\epsilon_{AB}\\bar{\\epsilon}_{C'}^{\\ \\ D'}\\\\ +\\Lambda(\\epsilon_{AC}\\epsilon_{B}^{\\ \\ D}+\\epsilon_{BC}\\epsilon_{A}^{\\ \\ D})\\bar{\\epsilon}_{A'B'}\\bar{\\epsilon}_{C'}^{\\ \\ D'} + C.C\\end{aligned}} \\]  其中， \\(C.C.\\)  代表前面部分的复共轭。\n里奇张量 \\(R_{ac}\\)  对应的分解： \\[ \\boxed{R_{AA'CC'}=-2\\Phi_{A'C'AC}+6\\Lambda\\epsilon_{AC}\\bar{\\epsilon}_{A'C'}} \\]  进一步缩并有：\n\\[ \\begin{aligned}R\u0026=g^{AA'CC'}R_{AA'CC'}\\\\\u0026=-\\epsilon^{AC}\\bar{\\epsilon}^{AC}(-2\\Phi_{A'C'AC}+6\\Lambda\\epsilon_{AC}\\bar{\\epsilon}_{A'C'})\\\\\u0026=-24\\Lambda\\end{aligned} \\]  所以， \\(\\boxed{R=-24\\Lambda}\\)  ；而 \\(-2\\Phi_{A'C'AC}\\)  对应 \\(R_{ac}-\\dfrac{1}{4}Rg_{ac}\\)  。\n事实上，黎曼曲率张量分解中有一部分，对应Weyl张量 \\(C_{abcd}\\)  ：\n\\[ \\boxed{C_{AA'BB'CC'DD'}=\\Psi_{ABCD}\\bar{\\epsilon}_{A'B'}\\bar{\\epsilon}_{C'D'}+\\bar{\\Psi}_{A'B'C'D'}\\epsilon_{AB}\\epsilon_{CD}} \\]  其中， \\(\\Psi_{ABCD}\\)  称之为Weyl旋量。这就是如此命名的原因。\n旋量导数算符对易子的作用 旋量导数算符对易子对应于曲率旋量。\n我们已知\n\\[ (\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\ T_{CC'}=\\chi_{AA'BB'C}^{\\quad \\qquad D}T_{DC'}+ \\bar{\\chi}_{AA'BB'C'}^{\\quad \\qquad D'}T_{CD'} \\]  利用旋量度规 \\(\\epsilon^{AB}\\)  ，很容易将指标提升【注意有负号】\n\\[ (\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\ T^{CC'}=-\\chi_{AA'BB'D}^{\\quad \\qquad C}T^{DC'}- \\bar{\\chi}_{AA'BB'D'}^{\\quad \\qquad C'}T^{CD'} \\]  更复杂点\n\\[ \\boxed{\\begin{aligned}\u0026(\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\ T^{CC'}_{\\ \\quad DD'}\\\\ =\u0026-\\chi_{AA'BB'E}^{\\ \\quad \\qquad C}\\ T^{EC'}_{\\ \\quad DD'}-\\bar{\\chi}_{AA'BB'E'}^{\\ \\quad \\qquad C'}\\ T^{CE'}_{\\ \\quad DD'}\\\\ \u0026 \\quad +\\chi_{AA'BB'D}^{\\ \\quad \\qquad E}T^{CC'}_{\\ \\quad ED'}+\\bar{\\chi}_{AA'BB'D'}^{\\ \\quad \\qquad E'}\\ T^{CC'}_{\\ \\quad DE'}\\end{aligned}} \\]  更一般地【作用于 \\((k,l;k',l')\\)  型旋量张量上】\n\\[ \\boxed{\\begin{aligned}\u0026(\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'})\\ T^{C_1\\dots C'_{k'}}_{\\ \\ \\qquad D_1\\dots D'_{l'}}\\\\ =\u0026-\\sum_{i=1}^k{\\chi_{AA'BB'E}^{\\ \\quad \\qquad C_i}T^{C_1\\dots E \\dots C'_{k'}}_{\\ \\qquad \\qquad D_1\\dots D'_{l'}}}-\\sum_{i=1}^{k'}{\\bar{\\chi}_{AA'BB'E'}^{\\ \\quad \\qquad C'_i}T^{C_1\\dots E' \\dots C'_{k'}}_{\\ \\qquad \\qquad D_1\\dots D'_{l'}}}\\\\ \u0026 +\\sum_{i=1}^l{\\chi_{AA'BB'D_i}^{\\ \\quad \\qquad E}T_{\\quad \\qquad D_1\\dots E \\dots D'_{l'}}^{C_1\\dots C'_{k'}}}+\\sum_{i=1}^{l'}{\\bar{\\chi}_{AA'BB'D'_i}^{\\ \\quad \\qquad E'}T_{\\quad \\qquad D_1\\dots E' \\dots D'_{l'}}^{C_1\\dots C'_{k'}}}\\end{aligned}} \\]  导数算符对易子的分解 依据指标对的反称分解恒等式，还可直接对旋量场导数算符对易子进行分解：\n\\[ \\boxed{\\nabla_{AA'}\\nabla_{BB'}-\\nabla_{BB'}\\nabla_{AA'}=\\bar{\\epsilon}_{A'B'}\\Delta_{AB}+\\epsilon_{AB}\\Delta_{A'B'}}\\\\ \\Delta_{AB}\\overset{\\Delta}{=}\\nabla_{X'(A}\\nabla_{B)}^{\\quad X'} \\]  导数算符对易子的相关算符 将导数算符对易子分解式，曲率旋量分解式，带入曲率旋量的定义式\n\\[ (\\bar{\\epsilon}_{A'B'}\\Delta_{AB}+\\epsilon_{AB}\\Delta_{A'B'})\\omega_C=(\\Lambda_{ABC}^{\\ \\ \\quad D}\\bar{\\epsilon}_{A'B'}+\\Phi_{A'B'C}^{\\qquad D}\\epsilon_{AB})\\omega_D \\]  上式两边同乘上 \\(\\epsilon^{AB}\\)  或 \\(\\bar{\\epsilon}^{A'B'}\\)  进行缩并得\n\\[ \\boxed{\\begin{aligned}\\nabla_{A(A'}\\nabla_{B')}^{\\quad A}\\omega_C\u0026=\\Phi_{A'B'C}^{\\qquad D}\\omega_D \\\\ \u0026\\quad \\\\ \\nabla_{A'(A}\\nabla_{B)}^{\\quad A'}\\omega_C\u0026=\\Lambda_{ABC}^{\\ \\ \\quad D}\\omega_D\\\\ \u0026=\\Psi_{ABC}^{\\ \\ \\quad D}\\omega_D-2\\Lambda\\epsilon_{C(A}\\omega_{B)}\\end{aligned}} \\]  此外还有【两边同乘 \\(\\epsilon^{AB}\\)  再缩并易证】\n\\[ \\boxed{\\nabla_{A'[A}\\nabla_{B]}^{\\ \\ A'}=\\frac{1}{2}\\epsilon_{AB}\\Box} \\\\ \\Box \\overset{\\Delta}{=}\\nabla_{AA'}\\nabla^{AA'}=-\\nabla_a\\nabla^a \\]  这些算符的作用 作用于 \\((0,n;0,0)\\)  型旋量张量上\n\\[ \\boxed{\\begin{aligned}\u0026\\nabla_{A'(A}\\nabla_{B)}^{\\ \\ A'}\\ \\omega_{C_1\\dots C_n}=\\sum_{i=1}^n{\\Lambda_{ABC_i}^{\\ \\ \\quad D}\\omega_{C_1\\dots D \\dots C_n}}\\\\ = \u0026 \\sum_{i=1}^n\\left\\{\\Psi_{ABC_i}^{\\ \\ \\quad D}\\omega_{C_1\\dots D \\dots C_n}-2\\Lambda\\epsilon_{C_i(A}\\omega_{|C_1\\dots C_{i-1}|B)C_{i+1} \\dots C_n}\\right\\}\\end{aligned}} \\]  作用于 \\((1,1;1,1)\\)  型旋量张量上\n\\[ \\boxed{\\begin{aligned}\u0026\\nabla_{A(A'}\\nabla_{B')}^{\\ \\ A}\\ T^{CC'}_{\\ \\quad DD'}\\\\ =\u0026-\\Phi_{A'B'E}^{\\qquad C}\\ T^{EC'}_{\\ \\quad DD'}-\\bar{\\Lambda}_{A'B'E'}^{\\qquad C'}\\ T^{CE'}_{\\ \\quad DD'}\\\\ \u0026 \\quad +\\Phi_{A'B'D}^{\\qquad E}T^{CC'}_{\\ \\quad ED'}+ \\bar{\\Lambda}_{A'B'D'}^{\\ \\qquad E'}\\ T^{CC'}_{\\ \\quad DE'}\\end{aligned}} \\]  和\n\\[ \\boxed{\\begin{aligned}\u0026\\nabla_{A'(A}\\nabla_{B)}^{\\ \\ A'}\\ T^{CC'}_{\\ \\quad DD'}\\\\ =\u0026-\\Lambda_{ABE}^{\\ \\ \\quad C}\\ T^{EC'}_{\\ \\quad DD'}-\\Phi_{ABE'}^{\\qquad C'}\\ T^{CE'}_{\\ \\quad DD'}\\\\ \u0026 +\\Lambda_{ABD}^{\\ \\ \\quad E}T^{CC'}_{\\ \\quad ED'}+ \\Phi_{ABD'}^{\\qquad E'}\\ T^{CC'}_{\\ \\quad DE'}\\end{aligned}} \\] "}),a.add({id:109,href:'/notes/docs/diffgeo/0077/',title:"流形上的旋量和旋量场（几何解释）",content:" 上一篇，引入旋量概念以及旋量代数。本篇在此基础上给出旋量的一个直观的几何解释。\n本篇限定讨论闵氏时空上的旋量。\n本篇的计算草稿：https://gitee.com/chaoskey/notes/blob/master/code/0077.ipynb\n 旋量的几何解释 一个旋量可以（如图）可解释成：（1）旗杆 “焊接” （2）旗 “加上” （3）旗与它周围事物之间的“指向-缠绕”关系。\n当旗绕旗杆旋转   \\(2\\pi\\)  时，旗可以完全复原【（1）+（2）两部分整体可复原】，但第（3）部分无法复原，旗杆需要再转 \\(2\\pi\\)  才能使（3）复原。也就是说：旗绕旗杆旋转 \\(2\\pi\\)  的任意奇数倍，旋量反向；旋转 \\(2\\pi\\)  的任意偶数倍，旋量复原。\n关于第（3）部分的理解，如下图（杯子(旗子)+环境(妹子)构成“指向-缠绕”）：\n零模矢量（旗杆） 给定一个旋量 \\(\\xi^A\\in W\\)  ，我们可以构造一个作为“旗杆”的实零四维矢量 \\(k^a\\in V_p\\)  ：\n\\[ k^a\\to k^{AA'}=\\xi^A\\bar{\\xi}^{A'} \\]  或写成分量形式【注意，上一篇中约定泡利矩阵前有因子 \\(1/\\sqrt{2}\\)  】：\n\\[ k^\\mu\\sigma_\\mu^{\\ \\ \\Sigma\\Sigma'}=\\xi^\\Sigma\\bar{\\xi}^{\\Sigma'}\\\\ \\quad \\\\ \\frac{1}{\\sqrt{2}}\\begin{pmatrix} k^0+k^3 \u0026 k^1-ik^2 \\\\ k^1+ik^2 \u0026 k^0-k^3 \\end{pmatrix} = \\begin{pmatrix} \\xi^1\\bar{\\xi}^{1'} \u0026 \\xi^1\\bar{\\xi}^{2'} \\\\ \\xi^2\\bar{\\xi}^{1'} \u0026 \\xi^2\\bar{\\xi}^{2'} \\end{pmatrix} \\]  右侧行列式为0，意味着 \\(k^a\\)  的确是零模矢量。此外，也可直接验证之：\n\\[ \\begin{aligned}g_{AA'BB'}k^{AA'}k^{BB'}\u0026=-(\\epsilon_{AB}\\xi^A\\xi^B)(\\bar{\\epsilon}_{A'B'}\\bar{\\xi}^{A'}\\bar{\\xi}^{B'})\\\\ \u0026=-(\\xi_B\\xi^B)(\\bar{\\xi}_{B'}\\bar{\\xi}^{B'})=-|\\xi_B\\xi^B|^2=0\\end{aligned} \\]  因此可将 \\(\\xi^A\\)  看成零模矢量 \\(k^a\\)  的“平方根”。\n对任意两个旋量 \\(\\xi^A\\)  和 \\(\\eta^A\\)  ，我们有：\n\\[ g_{AA'BB'}\\xi^A\\bar{\\xi}^{A'}\\eta^B\\bar{\\eta}^{B'}=-(\\xi_B\\eta^B)(\\bar{\\xi}_{B'}\\bar{\\eta}^{B'})=-|\\xi_B\\eta^B|^2 \\]  因此，任意旋量 \\(\\xi^A\\)  和 \\(\\eta^A\\)  所关联的零模矢量，都有一个非正内积（特指 \\((-1,1,1,1)\\)  对应的度规），这些零模矢量躺在光锥的同一半上（我们通常称之为未来光锥）。所以矢量空间 \\(V_p\\)  有一个自然的时间定向，可用一个实旋量张量表示这个定向： \\[ e_{AA'BB'CC'DD'}=i\\left(\\epsilon_{AB}\\epsilon_{CD}\\bar{\\epsilon}_{A'C'}\\bar{\\epsilon}_{B'D'}-\\bar{\\epsilon}_{A'B'}\\bar{\\epsilon}_{C'D'}\\epsilon_{AC}\\epsilon_{BD}\\right) \\]  容易验证：1） “实数性” 2）“全反称性” 【把 \\(AA'\\)  之类看成一个整体】。 进而对应 \\(e_{abcd}=e_{[abcd]}\\)  ，这说明 \\(e_{abcd}\\)  的确是四维矢量空间 \\(V_p\\)  上的4形式，进而的确构成 \\(V_p\\)  上的定向。\n如果 \\(\\eta^A\\)  和 \\(\\xi^A\\)  相差一个相位因子【旗因子】，比如， \\(\\eta^A=c\\xi^A,\\quad |c|=1，\\quad c=e^{i\\alpha}\\)  ，那么 \\(\\eta^A\\)  和 \\(\\xi^A\\)  关联着同一个零模矢量 \\(k^a\\)  ，所以每个零模矢量都关联着一个单参旋量族。\n二重矢量（旗） 为了进一步揭示“旗因子”的影响，转而研究由同一旋量 \\(\\xi^A\\)  产生的实二重矢量 \\(F^{ab}\\)  ：\n\\[ F^{ab}\\to F^{AA'BB'}=\\xi^A\\xi^B\\bar{\\epsilon}^{A'B'}+\\bar{\\xi}^{A'}\\bar{\\xi}^{B'}\\epsilon^{AB} \\]  这个量只有不多余6个不同分量（ \\(F^{\\mu\\upsilon}=-F^{\\upsilon\\mu}\\)  ）。\n对给定非0旋量 \\(\\xi^A\\)  ，总能找到另一个旋量 \\(\\eta^a\\)  ，满足：\n\\[ \\xi_A\\eta^A=1 \\]  很明显， \\(\\{\\xi^A,\\eta^A\\}\\)  构成一组基旋量，进而：\n\\[ \\epsilon^{AB}=\\xi^A\\eta^B-\\eta^A\\xi^B \\]  于是有：\n\\[ \\begin{aligned}F^{AA'BB'}\u0026=\\xi^A\\xi^B(\\bar{\\xi}^{A'}\\bar{\\eta}^{B'}-\\bar{\\eta}^{A'}\\bar{\\xi}^{B'})+\\bar{\\xi}^{A'}\\bar{\\xi}^{B'}(\\xi^A\\eta^B-\\eta^A\\xi^B)\\\\ \u0026=\\xi^A\\bar{\\xi}^{A'}(\\xi^B\\bar{\\eta}^{B'}+\\eta^B\\bar{\\xi}^{B'})-(\\xi^A\\bar{\\eta}^{A'}+\\eta^A\\bar{\\xi}^{A'})\\xi^B\\bar{\\xi}^{B'}\\\\ \u0026=\\boxed{k^{AA'}l^{BB'}-l^{AA'}k^{BB'}}\\end{aligned} \\]  其中：\n\\[ l^{AA'}\\overset{\\Delta}{=}\\xi^A\\bar{\\eta}^{A'}+\\eta^A\\bar{\\xi}^{A'} \\]  容易验证：\n\\[ \\overline{l^{AA'}}=l^{AA'},\\quad l^{AA'}l_{AA'}=-2,\\quad k^{AA'}l_{AA'}=0 \\]  即【利用矢量的旋量表示】：\n\\[ \\overline{l^{a}}=l^{a},\\quad l^{a}l_{a}=2,\\quad k^{a}l_{a}=0 \\]  这说明， \\(l^a\\)  是类空的，长度为 \\(\\sqrt{2}\\)  的实四维矢量。并且和 \\(k^a\\)  正交。【在第一张图上也标记了对应的矢量】\n在下面的变换下，\n\\[ \\eta^A\\to \\eta^A+c\\xi^A \\]   \\(\\{\\xi^A,\\eta^A\\}\\)  始终能构成同样好基旋量，同时有：【在第一张图上也标记了对应的矢量】\n\\[ l^a\\to l^a+(c+\\bar{c})k^a \\]  因此，由 \\(\\xi^A\\)  构成的旋量张量 \\(F^{AA'BB'}\\)  代表着由两个四维矢量 \\(k^a\\)  和 \\(l^a\\)  构成的一个二重矢量 \\(F^{ab}\\)  ：\n\\[ F^{ab}=k^a l^b- l^a k^b \\]  “指向-缠绕” 考察旋量 \\(\\xi^A\\)  乘上“旗因子” \\(e^{i\\alpha}\\)  变换，则有：\n\\[ \\xi^A_{\\text{旋转}}=e^{i\\alpha}\\xi^A\\quad \\eta^A_{\\text{旋转}}=e^{-i\\alpha}\\eta^A \\]  首先这个变换对矢量 \\(k^a\\)  没有影响，但对矢量 \\(l^a\\)  有影响（绕 \\(k^a\\)  旋转 \\(2\\alpha\\)  ）：\n\\[ \\begin{aligned}l^a_{\\text{旋转}}\\to l^{AA'}_{\\text{旋转}}\u0026=e^{2i\\alpha}\\xi^A\\bar{\\eta}^{A'}+e^{-2i\\alpha}\\eta^A\\bar{\\xi}^{A'}\\\\ \u0026=\\cos 2\\alpha(\\xi^A\\bar{\\eta}^{A'}+\\eta^A\\bar{\\xi}^{A'})+\\sin 2\\alpha(i\\xi^A\\bar{\\eta}^{A'}-i\\eta^A\\bar{\\xi}^{A'})\\\\ \u0026\\to \\boxed{l^a\\cos 2\\alpha+m^a\\sin 2\\alpha}\\end{aligned} \\]  其中\n\\[ m^a\\to m^{AA'}\\overset{\\Delta}{=}i(\\xi^A\\bar{\\eta}^{A'}-\\eta^A\\bar{\\xi}^{A'}) \\]   \\(m^a\\)  共享了矢量 \\(l^a\\)  的下述性质：1）实的；2）类空的；3）长度 \\(\\sqrt{2}\\)  ；4）与旗杆的零模四维矢量 \\(k^a\\)  正交；5）除相差 \\(k^a\\)  实倍数 \\((c+\\bar{c})\\)  外，唯一由起初的旋量 \\(\\xi^A\\)  确定。 此外， \\(m^a\\)  和 \\(l^a\\)  也是正交的。\n因此， \\(\\{l^a,m^a\\}\\)  为某个二维空间提供基矢，“旗的尖端”就是在此二维空间中经历了旋转，并且旋转的角度是 \\(2\\alpha\\)  。\n旋量、旗杆和旗 如果我们将 \\(k^a\\)  这个零模四维矢量想象成从地球某点O照到月球某点P的激光，那么OP在三维空间的表示如图：\n进而四维矢量 \\(k^a\\)  的分量可表示成：\n\\[ (k^\\mu)=\\begin{pmatrix} k^0 \\\\ k^1 \\\\ k^2 \\\\ k^3 \\end{pmatrix}=\\begin{pmatrix} r \\\\ r\\sin \\theta \\cos \\phi \\\\ r\\sin \\theta \\sin \\phi \\\\ r \\cos \\theta \\end{pmatrix} \\]  根据旋量和矢量的关系，可解出对应旋量 \\(\\xi^A\\)  的分量（精确到相差一个不确定“旗因子”）：\n\\[ (\\xi^\\Sigma)=\\begin{pmatrix} \\xi^1 \\\\ \\xi^2 \\end{pmatrix}=\\sqrt[4]{2}\\sqrt{r}\\begin{pmatrix} \\cos\\frac{\\theta}{2}\\ e^{-i(\\phi-\\alpha)/2} \\\\ \\sin\\frac{\\theta}{2}\\ e^{i(\\phi+\\alpha)/2} \\end{pmatrix} \\]  旋量 \\(\\eta^A\\)  可由 \\(\\xi^A\\)  确定（精确到可加一个 \\(\\xi^A\\)  的倍数）：\n\\[ (\\eta^\\Sigma)=\\begin{pmatrix} \\eta^1 \\\\ \\eta^2 \\end{pmatrix}=\\dfrac{1}{\\sqrt[4]{2}\\sqrt{r}}\\begin{pmatrix} -\\sin\\frac{\\theta}{2}\\ e^{-i(\\phi+\\alpha)/2} \\\\ \\cos\\frac{\\theta}{2}\\ e^{i(\\phi-\\alpha)/2} \\end{pmatrix} \\]  利用四维矢量 \\(l^a\\)  和旋量 \\(l^{AA'}\\)  的关系： \\[ l^\\mu\\sigma_\\mu^{\\ \\ AA'}= l^{AA'}=\\xi^A\\bar{\\eta}^{A'}+\\eta^A\\bar{\\xi}^{A'}\\\\ \\text{改写成分量形式}\\\\ \\frac{1}{\\sqrt{2}}\\begin{pmatrix} l^0+l^3 \u0026 l^1-il^2 \\\\ l^1+il^2 \u0026 l^0-l^3 \\end{pmatrix} =\\begin{pmatrix} \\xi^1\\bar{\\eta}^{1'} \u0026 \\xi^1\\bar{\\eta}^{2'} \\\\ \\xi^2\\bar{\\eta}^{1'} \u0026 \\xi^2\\bar{\\eta}^{2'} \\end{pmatrix}+\\begin{pmatrix} \\eta^1\\bar{\\xi}^{1'} \u0026 \\eta^1\\bar{\\xi}^{2'} \\\\ \\eta^2\\bar{\\xi}^{1'} \u0026 \\eta^2\\bar{\\xi}^{2'} \\end{pmatrix} \\]  将旋量分量表达式代入，并解出四维矢量 \\(l^a\\)  的所有分量：\n\\[ (l^\\mu)=\\begin{pmatrix} l^0 \\\\ l^1 \\\\ l^2 \\\\ l^3 \\end{pmatrix}=\\sqrt{2}\\begin{pmatrix} 0 \\\\ \\cos\\theta\\cos\\phi\\cos\\alpha+\\sin\\phi\\sin\\alpha \\\\ \\cos\\theta\\sin\\phi\\cos\\alpha-\\cos\\phi\\sin\\alpha \\\\ -\\sin \\theta \\cos \\alpha \\end{pmatrix} \\]  最后，不难算出二重矢量 \\(F^{ab}\\)  （“旗”）的分量：\n\\[ F^{\\mu\\upsilon}=k^\\mu l^\\upsilon- l^\\mu k^\\upsilon \\] "}),a.add({id:110,href:'/notes/docs/diffgeo/0076/',title:"流形上的旋量和旋量场（初步）",content:" 带度规流形任意点的切空间和平直空间没有数学上的差别，进而平直空间上发展起来的旋量都是可以移到带度规流形上而无需改变。\n旋量概念是度规依赖的，进而可始终在正交归一基底下讨论。\n旋量概念源自   \\(\\mathrm{SU}(2)\\)  对 \\(\\mathrm{SO}(3)\\)  是双重覆盖，将表示空间（或 时空）的旋转“劈”为两半，其中一半就是旋量空间上的逆变旋量，另一半是其共轭空间的共轭逆变旋量。\n一个逆变矢量可以表示成一个逆变旋量与一个共轭逆变旋量的张量积。\n一个协变矢量可以表示成一个协变旋量与一个共轭协变旋量的张量积。\n引入了旋量的抽象指标表示，可以方便无歧义地进行相关的运算。\n关于旋量运算的约定：1）旋量度规按指标左上右下缩并；2）泡利矩阵前加因子 \\(1/\\sqrt{2}\\)  。\n本篇的计算草稿：https://gitee.com/chaoskey/notes/blob/master/code/0076.ipynb\n 三维欧氏空间的旋转 泡利矩阵 引入泡利矩阵 \\(\\sigma_\\mu\\)  (都是厄米矩阵)\n\\[ \\sigma_1=\\begin{pmatrix} 0 \u0026 1 \\\\ 1 \u0026 0 \\end{pmatrix},\\quad \\sigma_2=\\begin{pmatrix} 0 \u0026 -i \\\\ i \u0026 0 \\end{pmatrix},\\quad \\sigma_3=\\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 -1 \\end{pmatrix}\\\\ \\quad \\\\ \\sigma_1^{\\ 2}=\\sigma_2^{\\ 2}=\\sigma_3^{\\ 2}=I\\\\ \\sigma_1\\sigma_2=-\\sigma_2\\sigma_1=i\\sigma_3\\quad \\text{【按1-2-3-1循环置换后也成立】} \\]  自旋矩阵 与任意旋转关联的一个量（以前叫哈密顿的四元数），现在称为自旋矩阵，又被称作旋量变换、旋转算符。绕 \\(\\boldsymbol{n}\\)  轴旋转 \\(\\theta\\)  的自旋矩阵表示 \\(R(\\boldsymbol{\\theta})\\)  ：\n\\[ \\begin{aligned}R(\\boldsymbol{\\theta})\u0026=\\exp\\left(-\\frac{i}{2}\\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}\\right)\\\\\u0026=I\\cos\\frac{\\theta}{2}-i(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})\\sin\\frac{\\theta}{2}\\end{aligned}\\\\ \\quad\\\\ \\boldsymbol{\\theta}=\\theta \\boldsymbol{n}\\quad\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma}=\\sigma_\\mu n^\\mu\\quad |\\boldsymbol{n}|=1 \\]  容易验证，自旋矩阵 \\(R\\)  是特殊酉矩阵 \\(R\\in\\mathrm{SU}(2)\\)  ：\n\\[ RR^\\dagger=I,\\quad \\det R=1 \\]  围绕定轴 \\(\\boldsymbol{n}\\)  转过 \\(\\theta\\)  角，相当于两个平面反射的组合（如图）。这就是半角出现的原因。\n组合旋转 在 \\(R_1\\)  所描述的旋转之后，续之以 \\(R_2\\)  所描述的旋转，给出的净变化由单一旋转 \\(R_3\\)  描绘：\n\\[ R_3=R_2 R_1 \\]  假如 \\(R_1=R(\\boldsymbol{\\theta}),\\quad R_2=R(\\boldsymbol{\\varphi})\\)  ，那么\n\\[ \\begin{aligned}R_3\u0026=\\left(I\\cos\\frac{\\varphi}{2}-i(\\boldsymbol{n}_\\varphi\\cdot\\boldsymbol{\\sigma})\\sin\\frac{\\varphi}{2}\\right)\\left(I\\cos\\frac{\\theta}{2}-i(\\boldsymbol{n}_\\theta\\cdot\\boldsymbol{\\sigma})\\sin\\frac{\\theta}{2}\\right)\\\\ \u0026=I\\left(\\cos\\frac{\\varphi}{2}\\cos\\frac{\\theta}{2}-\\sin\\frac{\\varphi}{2}\\sin\\frac{\\theta}{2}(\\boldsymbol{n}_\\varphi\\cdot\\boldsymbol{n}_\\theta)\\right)\\\\ \u0026\\quad -i\\left(\\boldsymbol{n}_\\varphi\\sin\\frac{\\varphi}{2}\\cos\\frac{\\theta}{2}+\\boldsymbol{n}_\\theta\\cos\\frac{\\varphi}{2}\\sin\\frac{\\theta}{2}+(\\boldsymbol{n}_\\varphi\\times\\boldsymbol{n}_\\theta)\\sin\\frac{\\varphi}{2}\\sin\\frac{\\theta}{2}\\right)\\cdot\\boldsymbol{\\sigma}\\end{aligned} \\]  由此可确定 \\(R_3(\\boldsymbol{\\psi})\\)  。特别地，若 \\(R_1=R(\\frac{\\pi}{2}(0,0,1)),\\quad R_2=R(\\frac{\\pi}{2}(1,0,0))\\)  ，那么\n\\[ \\begin{aligned}R_3\u0026=\\frac{1}{2}I-i\\frac{\\sqrt{3}}{2}(\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}})\\cdot\\boldsymbol{\\sigma}\\\\ \u0026=I\\cos\\frac{\\psi}{2}I-i\\sin\\frac{\\psi}{2}(\\boldsymbol{n}_\\psi\\cdot\\boldsymbol{\\sigma})\\end{aligned}\\\\ \\psi=\\frac{2\\pi}{3},\\quad \\boldsymbol{n}_\\psi=(\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}},\\frac{1}{\\sqrt{3}}) \\]  自旋矩阵的性质 自旋矩阵具有如下性质：\n1） \\((\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})^2=I\\)  2） \\(\\mathrm{tr}(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})=0\\)  3） \\([R, (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})]=R (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})- (\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})R=0\\)  4） \\(\\dfrac{dR}{d\\theta}=-i(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})R\\)  矢量的关联矩阵 矢量 \\(\\boldsymbol{x}\\)  的关联矩阵【是厄米矩阵】：\n\\[ X=\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}=x^\\mu\\sigma_\\mu=\\begin{pmatrix} x^3 \u0026 x^1-ix^2 \\\\ x^1+ix^2 \u0026 -x^3 \\end{pmatrix}\\\\ \\quad \\\\ \\det X=-(x^1)^2-(x^2)^2-(x^3)^2 \\\\ X^2=(\\boldsymbol{x}\\cdot\\boldsymbol{x})I\\quad X^\\dagger=X \\]  旋转效应可总结为：\n\\[ X\\mapsto X'=RXR^\\dagger,\\quad R\\in SU(2) \\]  很明显，无论取 \\(R\\)  还是 \\(-R\\)  ，都不会改变旋转的本质，都对应同一个 \\(\\mathrm{SO}(3)\\)  元素。\n \\(\\mathrm{SO}(3)\\)  和 \\(\\mathrm{SU}(2)\\)  （特殊酉群）是局域同构的。至于为何强调局域，是因为 \\(\\mathrm{SU}(2)\\)  对 \\(\\mathrm{SO}(3)\\)  是双重覆盖，即任意特殊酉矩阵（幺正矩阵）及其负号矩阵代表同一个旋转。\n无穷小旋转 对无穷小旋转动 \\(\\theta\\to 0\\)  而言， \\(R(\\boldsymbol{\\theta})\\)  可写成（忽略高阶无穷小）\n\\[ R=I-\\frac{i}{2}(\\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma}) \\]  进而有矢量 \\(\\boldsymbol{x}\\)  关联矩阵 \\(X=\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}\\)  的无穷小变换：\n\\[ \\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}\\mapsto R(\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})R^\\dagger \\]  即（再次忽略高阶无穷小）\n\\[ \\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}\\mapsto (\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})+\\frac{i}{2}\\left[(\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})(\\boldsymbol{\\theta}\\cdot\\boldsymbol{\\sigma})-(\\boldsymbol{\\theta}\\cdot \\boldsymbol{\\sigma})(\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})\\right] \\]  容易证明【将 \\((\\boldsymbol{a}\\cdot\\boldsymbol{\\sigma})(\\boldsymbol{b}\\cdot\\boldsymbol{\\sigma})=a^\\mu b^\\upsilon \\sigma_\\mu \\sigma_\\upsilon\\)  展开，再合并同类项即得】\n\\[ (\\boldsymbol{a}\\cdot\\boldsymbol{\\sigma})(\\boldsymbol{b}\\cdot\\boldsymbol{\\sigma})=(\\boldsymbol{a}\\cdot\\boldsymbol{b})I+i(\\boldsymbol{a}\\times\\boldsymbol{b})\\cdot\\boldsymbol{\\sigma} \\]  进而有\n\\[ \\boxed{\\begin{aligned}\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}\u0026\\mapsto (\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})+(\\boldsymbol{\\theta}\\times\\boldsymbol{x})\\cdot\\boldsymbol{\\sigma} \\\\ \u0026\\Longleftrightarrow \\\\ \\boldsymbol{x}\u0026\\mapsto [1+\\boldsymbol{\\theta}\\times]\\boldsymbol{x}\\end{aligned}} \\]  四维闵氏时空的旋转 矢量的关联矩阵 在闵氏时空中，矢量 \\(\\boldsymbol{x}\\)  的关联矩阵【注意 \\(\\mu=0,1,2,3\\quad \\sigma_0=I\\)  】：\n\\[ X=tI+\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}=x^\\mu\\sigma_\\mu=\\begin{pmatrix} x^0+x^3 \u0026 x^1-ix^2 \\\\ x^1+ix^2 \u0026 x^0-x^3 \\end{pmatrix}\\\\ \\quad \\\\ \\det X=(x^0)^2-(x^1)^2-(x^2)^2-(x^3)^2,\\quad t=x^0 \\]  洛伦兹变换 四维闵氏时空矢量的关联矩阵和三维欧氏空间矢量的关联矩阵很类似。时空旋转，由空间旋转和洛伦兹旋转组成，一共6个参数：\n\\[ \\begin{aligned}L(\\boldsymbol{\\theta},\\boldsymbol{\\alpha})\u0026=L(\\boldsymbol{\\alpha})R(\\boldsymbol{\\theta})=\\exp\\left(\\frac{1}{2}(\\boldsymbol{\\alpha}-i\\boldsymbol{\\theta})\\cdot\\boldsymbol{\\sigma}\\right)\\\\\u0026=\\left[I\\cosh\\frac{\\alpha}{2}+(\\boldsymbol{n}_\\alpha\\cdot \\boldsymbol{\\sigma})\\sinh\\frac{\\alpha}{2}\\right]\\left[I\\cos\\frac{\\theta}{2}-i(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})\\sin\\frac{\\theta}{2}\\right]\\end{aligned}\\\\\\quad\\\\ \\boldsymbol{\\theta}=\\theta \\boldsymbol{n}\\quad \\boldsymbol{n}\\cdot \\boldsymbol{\\sigma}=\\sigma_i n^i\\quad |\\boldsymbol{n}|=1\\\\ \\boldsymbol{\\alpha}=\\alpha \\boldsymbol{n}_\\alpha\\quad \\boldsymbol{n}_\\alpha\\cdot \\boldsymbol{\\sigma}=\\sigma_i n^i_\\alpha\\quad |\\boldsymbol{n}_\\alpha|=1\\\\ i=1,2,3 \\]  其中 \\(R(\\boldsymbol{\\theta})\\)  仅仅是空间旋转部分，前面研究过了，所以只需要研究洛伦兹旋转部分：\n\\[ \\begin{aligned}L(\\boldsymbol{\\alpha})\u0026=\\exp\\left(\\frac{1}{2}\\boldsymbol{\\alpha}\\cdot\\boldsymbol{\\sigma}\\right)\\\\\u0026=I\\cosh\\frac{\\alpha}{2}+(\\boldsymbol{n}_\\alpha\\cdot \\boldsymbol{\\sigma})\\sinh\\frac{\\alpha}{2}\\end{aligned} \\]  相应的洛伦兹变换：\n\\[ \\begin{aligned}X\u0026\\mapsto LXL^\\dagger\\\\ \u0026\\text{或} \\\\ tI+\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma}\u0026\\mapsto t'I+\\boldsymbol{x'}\\cdot\\boldsymbol{\\sigma}=L(tI+\\boldsymbol{x}\\cdot\\boldsymbol{\\sigma})L^\\dagger\\end{aligned} \\]  进而有【将 \\(L(\\boldsymbol{\\alpha})\\)  代入，强算后，再比较1和 \\(\\boldsymbol{\\sigma}\\)  的系数】\n\\[ \\begin{aligned}t'\u0026=(\\cosh\\alpha)t+(\\sinh\\alpha)(\\boldsymbol{n}_\\alpha\\cdot\\boldsymbol{x})\\\\ \\boldsymbol{x}'\u0026=\\left[(\\sinh\\alpha)t+(\\cosh\\alpha)(\\boldsymbol{n}_\\alpha\\cdot\\boldsymbol{x})\\right]\\boldsymbol{n}_\\alpha\\quad \\text{【与}\\boldsymbol{n}_\\alpha\\text{相平行部分发生变换】}\\\\\u0026\\qquad+\\left[\\boldsymbol{x}-(\\boldsymbol{n}_\\alpha\\cdot\\boldsymbol{x})\\boldsymbol{n}_\\alpha\\right]\\quad \\text{【与}\\boldsymbol{n}_\\alpha\\text{相垂直部分不变】}\\end{aligned} \\]  无穷小变换 同时考虑空间无穷小旋转 \\(\\theta\\to 0\\)  和洛伦兹无穷小旋转 \\(\\alpha\\to 0\\)  ，有\n\\[ L(\\boldsymbol{\\theta},\\boldsymbol{\\alpha})=I-i(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})\\frac{\\theta}{2}+(\\boldsymbol{n}_\\alpha\\cdot \\boldsymbol{\\sigma})\\frac{\\alpha}{2} \\]  进而有\n\\[ \\begin{aligned}t'\u0026=t+\\boldsymbol{x}\\cdot\\boldsymbol{\\alpha}\\\\\\boldsymbol{x}'\u0026= \\boldsymbol{x}+t\\boldsymbol{\\alpha}+\\boldsymbol{\\theta}\\times\\boldsymbol{x}\\end{aligned} \\]  (伪)黎曼流形上对称性 考虑一个给定度规的流形 \\((M,g_{ab})\\)  ，如果要讨论其对称性，首当其冲就是要求保度规，所以可以用其上的等度规李群 \\(G\\)  来刻画对称性。\n此外，由于有度规，在流形每点 \\(p\\)  的切空间 \\(V_p\\)  上都存在正交归一基底 \\(\\{(e_\\mu)^a\\}\\)  。\n由流形 \\((M,g_{ab})\\)  及其上等度规李群 \\(G\\)  生成的李变换群 \\(\\{\\phi:G\\times M\\to M\\}\\)  的每个李变换 \\(\\phi_g:M\\to M\\)  都是等度规变换。也就是说正交归一基底 \\(\\{(e_\\mu)^a\\}\\)  ，在这个变换下， \\(\\{\\phi^*_g(e_\\mu)^a\\}\\)  依然保持正交归一。【保度规 =》保内积】\n上述事实表明，带度规流形任意点的切空间和平直空间没有数学上的差别，进而平直空间上发展起来的旋量都是可以移到带度规流形上而无需改变。 如果每点都指定一个旋量，自然就得到旋量场的概念。\n正交归一坐标基底下 \\(\\{(e_\\mu)^a\\}\\)  ，度规可以表示成：\n\\[ g_{ab}=\\delta_{ab}\\quad \\delta_{\\mu\\upsilon}=\\mathrm{diag}(1,1,1) \\quad \\text{【三维欧氏空间】} \\\\ g_{ab}=\\eta_{ab}\\quad \\eta_{\\mu\\upsilon}=\\mathrm{diag}(-1,1,1,1) \\quad \\text{【四维闵氏时空】} \\]  【注意，我特意保证这两种度规的空间部分一致，方便后面尽可能给出一致的公式】\n基本旋量 逆变旋量 无论是三维欧氏空间，还是四维闵氏空间，都有空间旋转 \\(R(\\boldsymbol{\\theta})\\)  的部分 \\[ R(\\boldsymbol{\\theta})=I\\cos\\frac{\\theta}{2}-i(\\boldsymbol{n}\\cdot\\boldsymbol{\\sigma})\\sin\\frac{\\theta}{2} \\]  很明显\n\\[ R((\\theta+2\\pi)\\boldsymbol{n})=-R(\\theta\\boldsymbol{n}) \\]  这就是前面提到到的： \\(\\mathrm{SU}(2)\\)  对 \\(\\mathrm{SO}(3)\\)  是双重覆盖。为了更显式描绘这个特征，我们抽取出空间（或 时空）旋转变换的一半，用一个二分量向量表示之，称为旋量： \\[ \\xi=\\begin{pmatrix} \\xi^1 \\\\ \\xi^2 \\end{pmatrix} \\]  旋量的变换规律遵循如下规律： \\[ \\xi\\mapsto\\xi'=R\\xi\\quad \\text{【三维欧氏空间】}\\\\ \\xi\\mapsto\\xi'=L\\xi\\quad \\text{【四维闵氏时空】} \\]  这个量由于没有抵消因子，当旋转 \\(2\\pi\\)  时， \\(\\xi\\)  显式出现反向特征。【以后若无特别说明，论述通用于三维欧氏空间和四维闵氏时空】\n类似张量的抽象指标，用大写希腊字母标记旋量的分量： \\[ (\\xi^\\Sigma)=\\begin{pmatrix} \\xi^1 \\\\ \\xi^2 \\end{pmatrix}\\quad \\Sigma=1,2 \\]  将用大写拉丁字母表示旋量本身，与旋量分量 \\(\\xi^\\Sigma\\)  对应的旋量是 \\(\\xi^A\\)  。于是旋量变换可改写成： \\[ \\boxed{\\xi^A\\mapsto\\xi'^A=L^A_{\\ B}\\xi^B} \\]  其中， \\(L^B_{\\ A}\\)  是自旋矩阵 \\(L^\\Omega_{\\ \\Sigma}\\in \\mathrm{SU}(2)\\)  对应的旋量表示。\n很明显，旋量 \\(\\xi^A\\)  属于二维复矢量空间（记作 \\(W\\)  ），称之为逆变旋量。\n协变旋量 进而，可考虑 \\(W\\)  的对偶空间 \\(W^*\\)  ，其元素则对应记作（比如） \\(\\eta_A\\in W^*\\)  ，称之为协变旋量，这是 \\(W\\to \\mathbb{C}\\)  的线性映射。协变旋量变换是： \\[ \\boxed{\\eta_A\\mapsto\\eta'_A=L_A^{\\ \\ B}\\eta_B}\\\\ \\quad \\\\ L_A^{\\ \\ B}\\overset{\\Delta}{=}(L^A_{\\ \\ B})^{-1} \\quad \\text{【逆映射：指标上下交换】} \\]  容易验证，旋量间内积不变： \\[ \\xi'^A\\eta'_A=(L^A_{\\ \\ B}\\xi^B)(L_A^{\\ \\ C}\\xi_C)=\\xi^B\\eta_B \\]  共轭逆变旋量 然后，可以考虑 \\(W\\)  的共轭空间 \\(\\overline{W}\\)  ，其元素记作（比如） \\(\\zeta^{A'}\\in \\overline{W}\\)  ，称之为共轭逆变旋量。共轭逆变旋量变换是： \\[ \\boxed{\\chi^{A'}\\mapsto\\chi'^{A'}=\\chi^{B'}\\bar{L}^{\\ \\ A'}_{B'}}\\\\ \\quad \\\\ \\bar{L}^{\\ \\ A'}_{B'}\\overset{\\Delta}{=}\\overline{L^A_{\\ \\ B}} \\quad \\text{【共轭转置：指标左右交换+共轭】} \\]  共轭协变旋量 最后，有 \\(W\\)  的共轭对偶空间 \\(\\overline{W}^*\\)  ，其元素记作（比如） \\(\\zeta_{A'}\\in \\overline{W}^*\\)  ，称之为共轭协变旋量，这是 \\(W\\to \\mathbb{C}\\)  的反线性映射。共轭协变旋量变换是： \\[ \\boxed{\\zeta_{A'}\\mapsto\\zeta'_{A'}=\\zeta_{B'}\\bar{L}_{\\ \\ A'}^{B'}}\\\\ \\quad \\\\ \\bar{L}_{\\ \\ A'}^{B'}\\overset{\\Delta}{=}\\left(\\overline{L^A_{\\ \\ B}}\\right)^{-1} \\quad \\text{【逆映射与共轭转置的复合】} \\]  根据上面的符号约定，我们有如下关系：\n\\[ \\overline{\\xi^A}=\\overline{\\xi}^{A'},\\quad \\overline{\\eta_A}=\\overline{\\eta}_{A'} \\]  旋量张量 自然也可以在二维复矢量空间 \\(W\\)  上将 \\((k,l;k',l')\\)  型旋量张量 \\(T\\)  也定义成多重线性映射： \\[ T:\\underbrace{W^*\\otimes\\dots\\otimes W^*}_{k}\\otimes \\underbrace{W\\otimes\\dots\\otimes W}_{l}\\otimes \\underbrace{\\overline{W}^*\\otimes\\dots\\otimes \\overline{W}^*}_{k'}\\otimes\\underbrace{\\overline{W}\\otimes\\dots\\otimes \\overline{W}}_{l'} \\to \\mathbb{C} \\]  根据这个定义， \\((2,1;1,0)\\)  型张量的标准记法是 \\(T^{AB\\ \\ D'}_{\\ \\quad C}\\)  。\n \\((k,l;k',l')\\)  型旋张量 \\(T\\)  的共轭 \\(\\overline{T}\\)  是 \\((k',l';k,l)\\)  型旋量张量，比如：\n\\[ \\overline{T^{AB\\ \\ D'}_{\\ \\quad C}}=\\overline{T}^{DA'B'}_{\\qquad C'} \\]  我们可以对不带撇指标进行缩并，也可以对带撇指标进行缩并。但要注意，不能对字母部分相同的带撇和不带撇指标进行缩并。\n最后，旋量张量不妨也可简称为旋量：高阶旋量就是旋量张量的意思。\n旋量空间 旋量度规 类似空间（时空） \\(M\\)  上的度规 \\(g_{ab}\\)  具有提升和下降张量指标的功能，我们自然期待给二维复矢量空间 \\(W\\)  适配一个类似的旋量张量，称之为旋量度规 \\(\\epsilon_{AB}\\)  ，期待也具有提升和下降旋量指标的功能，即【注意：默认左上右下缩并】：\n\\[ \\boxed{\\begin{aligned}\\xi^A=\\epsilon^{AB}\\xi_B \u0026\\quad \\xi_A=\\xi^B\\epsilon_{BA} \\\\ \\bar{\\xi}^{A'}=\\bar{\\epsilon}^{A'B'}\\bar{\\xi}_{B'} \u0026\\quad \\bar{\\xi}_{A'}=\\bar{\\xi}^{B'}\\bar{\\epsilon}_{B'A'}\\end{aligned}} \\]  我们称 \\((W,\\epsilon_{AB})\\)  为旋量空间，其中每个元素成为旋量，其上的张量则是旋量张量（或 高阶旋量）。\n旋量度规反称性 如图考虑两条映射路径：\n紫色所示映射，有两种表示方式：红色复合映射 和 蓝色复合映射。【这个映射图利用了逆变（协变）旋量变换关系和期待中的旋量度规降指标功能】即：\n\\[ \\begin{aligned}\u0026\\xi'_A=\\epsilon_{BA} L^B_{\\ \\ C} \\xi^C=L_A^{\\ \\ B} \\epsilon_{CB} \\xi^C \\\\ \\Rightarrow \u0026 \\epsilon_{BA} L^B_{\\ \\ C} =L_A^{\\ \\ B} \\epsilon_{CB}\\\\ \\Rightarrow \u0026 \\boxed{\\epsilon_{AB} L^A_{\\ \\ C}L^B_{\\ \\ D}= \\epsilon_{CD}}\\end{aligned} \\]  这说明旋量度规 \\(\\epsilon_{AB}\\)  在自旋变换作用下是不变的。结合 \\(L^A_{\\ \\ B}\\in \\mathrm{SU}(2)\\)  的条件约束，在具体指标下，经过强算可以解出 \\(\\epsilon_{\\Sigma\\Omega}\\)  所有分量：\n\\[ \\epsilon_{\\Sigma\\Omega}=\\begin{pmatrix} \\alpha \u0026 \\beta \\\\ \\gamma \u0026 \\delta \\end{pmatrix}=\\begin{pmatrix} 0 \u0026 \\beta \\\\ -\\beta \u0026 0 \\end{pmatrix} \\]  这说明这是一个反称张量，即【类似也可推出另个公式】：\n\\[ \\boxed{\\begin{aligned}\\epsilon_{AB}\u0026=-\\epsilon_{BA}\\\\ \u0026\\quad \\\\ \\bar{\\epsilon}_{A'B'}\u0026=-\\bar{\\epsilon}_{B'A'}\\end{aligned}} \\]  旋量度规的负逆性 根据旋量度规的上升下降指标的约定：\n\\[ \\begin{aligned}\\xi^A\u0026=\\epsilon^{AB}\\xi_B=\\epsilon^{AB}(\\xi^C\\epsilon_{CB})\\\\ \u0026=\\epsilon^{AB}\\epsilon_{CB}\\xi^C=\\boxed{-\\epsilon^{AB}\\epsilon_{BC}\\xi^C}\\end{aligned} \\]  这意味着 \\((-\\epsilon^{AB}\\epsilon_{BC})\\)  是恒等映射，即【类似还可推出另外一个等式】\n\\[ \\boxed{\\begin{aligned}\\epsilon^{AB}\\epsilon_{BC}\u0026=-\\delta^A_C\\\\ \u0026\\quad \\\\ \\bar{\\epsilon}^{A'B'}\\bar{\\epsilon}_{B'C'}\u0026=-\\delta^{A'}_{C'} \\end{aligned}} \\]  为了保持上升下降指标功能一致性，引入定义【保证和前面结论协调的前提下】：\n\\[ \\boxed{\\begin{aligned}\\epsilon^{\\ \\ A}_{B}\u0026=-\\epsilon^{A}_{\\ \\ B}\\overset{\\Delta}{=}\\delta^A_B \\quad \u0026\\bar{\\epsilon}^{\\ \\ A'}_{C'}=-\\bar{\\epsilon}^{A'}_{\\ \\ C'}=\\delta^{A'}_{C'} \\\\ \u0026 \\quad \u0026 \\\\ \\epsilon^{\\ \\ A}_{A}\u0026=2=-\\epsilon^{A}_{\\ \\ A} \u0026\\quad \\bar{\\epsilon}^{\\ \\ A'}_{A'}=2=-\\bar{\\epsilon}^{A'}_{\\ \\ A'}\\end{aligned}} \\]  旋量内积 用旋量度规 \\(\\epsilon_{AB}\\)  提升下降指标的功能，可以定义旋量内积，由反称性还知旋量是零模的：\n\\[ \\boxed{\\begin{aligned}\\xi_A\\phi^A=\\epsilon_{AB}\\xi^A\\phi^B\u0026=-\\xi^A\\phi_A \\\\ \u0026\\quad \\\\ \\xi_A\\xi^A=0\\end{aligned}} \\]  基旋量 在二维复矢量空间 \\(W\\)  中，选择两个线性独立的基底 \\(\\{\\omicron^A，\\iota^A\\}\\)  ，称之为基旋量，满足：\n\\[ \\boxed{\\begin{aligned}\\omicron_A\\iota^A\u0026=\\epsilon_{AB}\\omicron^A\\iota^B=1\\\\ \\bar{\\omicron}_{A'}\\bar{\\iota}^{A'}\u0026=\\bar{\\epsilon}_{A'B'}\\bar{\\omicron}^{A'}\\bar{\\iota}^{B'}=1\\end{aligned}} \\]  旋量度规的基旋量表示 旋量的一般表示（系数待定）\n\\[ \\xi^A = \\xi^1\\omicron^A+\\xi^2\\iota^A \\]  在等式两边同乘某个基旋量：\n\\[ \\xi^1=-\\iota_A\\xi^A \\\\ \\xi^2=\\omicron_A\\xi^A \\]  进而：\n\\[ \\epsilon^{AB}\\xi_B = \\xi^A = -\\iota_B\\xi^B\\omicron^A+\\omicron_B\\xi^B\\iota^A\\\\ = \\iota^B\\xi_B\\omicron^A-\\omicron^B\\xi_B\\iota^A \\\\ = (\\iota^B\\omicron^A-\\omicron^B\\iota^A)\\xi_B \\]  所以【类似还可推出另外三个等式】：\n\\[ \\boxed{\\begin{aligned}\\epsilon^{AB}\u0026=\\omicron^A\\iota^B-\\iota^A\\omicron^B \\\\ \u0026\\quad \\\\ \\epsilon_{AB} \u0026= \\omicron_A\\iota_B-\\iota_A\\omicron_B\\\\ \\bar{\\epsilon}^{A'B'} \u0026= \\bar{\\omicron}^{A'}\\bar{\\iota}^{B'}-\\bar{\\iota}^{A'}\\bar{\\omicron}^{B'}\\\\ \\bar{\\epsilon}_{A'B'} \u0026= \\bar{\\omicron}_{A'}\\bar{\\iota}_{B'}-\\bar{\\iota}_{A'}\\bar{\\omicron}_{B'} \\end{aligned}} \\]  根据这四个关系，容易验证：\n\\[ \\boxed{\\bar{\\epsilon}_{A'B'}=\\overline{\\epsilon_{AB}},\\quad \\bar{\\epsilon}^{A'B'}=\\overline{\\epsilon^{AB}}} \\]  旋量度规的分量 有了基旋量，及旋度度规的基底表示，很自然可以写出基底下的旋量度规的分量：\n\\[ \\boxed{\\begin{aligned}\\epsilon_{\\Sigma\\Omega}=\\begin{pmatrix} 0 \u0026 1 \\\\ -1\u0026 0 \\end{pmatrix}\\quad\\epsilon^{\\Sigma\\Omega}=\\begin{pmatrix} 0 \u0026 1 \\\\ -1\u0026 0 \\end{pmatrix}\\\\ \\bar{\\epsilon}_{\\Sigma'\\Omega'}=\\begin{pmatrix} 0 \u0026 1 \\\\ -1\u0026 0 \\end{pmatrix}\\quad\\bar{\\epsilon}^{\\Sigma'\\Omega'}=\\begin{pmatrix} 0 \u0026 1 \\\\ -1\u0026 0 \\end{pmatrix}\\end{aligned}} \\]  旋量度规恒等式 对任意三个旋量 \\(\\xi^A,\\eta^A,\\zeta^A\\)  ，其分量按如下构造的行列式等式必然成立：\n\\[ \\begin{vmatrix} \\xi^1 \u0026 \\eta^1 \u0026 \\zeta^1 \\\\ \\xi^2 \u0026 \\eta^2 \u0026 \\zeta^2 \\\\ \\xi^\\Sigma \u0026 \\eta^\\Sigma \u0026 \\zeta^\\Sigma \\end{vmatrix}=0,\\quad \\Sigma=1,2 \\]  利用旋量度规，可将上式等价表示为（并由具体指标改为抽象指标）：\n\\[ (\\epsilon_{AB}\\eta^A\\zeta^B)\\xi^C+(\\epsilon_{AB}\\zeta^A\\xi^B)\\eta^C+(\\epsilon_{AB}\\xi^A\\eta^B)\\zeta^C=0\\\\ \\Longleftrightarrow \\\\ \\epsilon_{AB}\\xi^C\\eta^A\\zeta^B+\\epsilon_{AB}\\xi^B\\eta^C\\zeta^A+\\epsilon_{AB}\\xi^A\\eta^B\\zeta^C=0\\\\ \\Longleftrightarrow \\\\ \\epsilon_{BC}\\epsilon_{A}^{\\ \\ D}\\xi^A\\eta^B\\zeta^C+\\epsilon_{CA}\\epsilon_{B}^{\\ \\ D}\\xi^A\\eta^B\\zeta^C+\\epsilon_{AB}\\epsilon_{C}^{\\ \\ D}\\xi^A\\eta^B\\zeta^C=0\\\\ \\Longleftrightarrow \\\\ \\boxed{\\begin{aligned}\\epsilon_{BC}\\epsilon_{A}^{\\ \\ D}+\\epsilon_{CA}\\epsilon_{B}^{\\ \\ D}\u0026+\\epsilon_{AB}\\epsilon_{C}^{\\ \\ D}=0\\\\ \u0026\\Longleftrightarrow \\\\ \\epsilon_{BC}\\epsilon_{AD}+\\epsilon_{CA}\\epsilon_{BD}\u0026+\\epsilon_{AB}\\epsilon_{CD}=0\\end{aligned}} \\]  方括号中的两个恒等式，就是我们要的。\n用旋量度规表示行列式 有了旋量度规的分量容易验证， \\(W\\)  空间上的线性变换的行列式可表示成：\n\\[ \\boxed{\\det(L)=\\frac{1}{2}\\epsilon_{AB}\\epsilon^{CD}L^A_{\\ \\ C}L^B_{\\ \\ D}} \\]  特别地，对自旋变换 \\(L^A_{\\ \\ B}\\)  而言， \\(\\det L=1\\)  ，即有【第二式完全类似】：\n\\[ \\boxed{\\begin{aligned}\\epsilon_{AB}L^A_{\\ \\ C}L^B_{\\ \\ D}\u0026=\\epsilon_{CD}\\\\ \u0026\\quad \\\\ \\bar{\\epsilon}_{A'B'}\\bar{L}^{\\ \\ A'}_{C'}\\bar{L}^{\\ \\ B'}_{D'}\u0026=\\bar{\\epsilon}_{C'D'}\\end{aligned}} \\]  这和前面\u0026quot;旋量度规 \\(\\epsilon_{AB}\\)  在自旋变换作用下是不变的\u0026ldquo;的说法是一致的。\n用基旋量表示泡利矩阵 将泡利矩阵写成具体指标形式【添加额外系数 \\(1/\\sqrt{2}\\)  ，使后续公式更简洁】：\n\\[ \\sigma_0^{\\ \\Sigma\\Sigma'}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix},\\sigma_1^{\\ \\Sigma\\Sigma'}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix} 0 \u0026 1 \\\\ 1 \u0026 0 \\end{pmatrix}\\\\ \\sigma_2^{\\ \\Sigma\\Sigma'}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix} 0 \u0026 -i \\\\ i \u0026 0 \\end{pmatrix},\\quad \\sigma_3^{\\ \\Sigma\\Sigma'}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \u0026 0 \\\\ 0 \u0026 -1 \\end{pmatrix} \\]  然后可写成抽象指标形式（用基旋量表出）：\n\\[ \\sigma_0^{\\ AA'}=\\frac{1}{\\sqrt{2}}(\\omicron^A\\bar{\\omicron}^{A'}+\\iota^A\\bar{\\iota}^{A'})\\\\ \\sigma_1^{\\ AA'}=\\frac{1}{\\sqrt{2}}(\\omicron^A\\bar{\\iota}^{A'}+\\iota^A\\bar{\\omicron}^{A'})\\\\ \\sigma_2^{\\ AA'}=-\\frac{i}{\\sqrt{2}}(\\omicron^A\\bar{\\iota}^{A'}-\\iota^A\\bar{\\omicron}^{A'})\\\\ \\sigma_3^{\\ AA'}=\\frac{1}{\\sqrt{2}}(\\omicron^A\\bar{\\omicron}^{A'}-\\iota^A\\bar{\\iota}^{A'}) \\]  矢量(张量)和旋量的对应关系 矢量的关联矩阵 我们已经知道矢量 \\(x^a\\)  关联矩阵 \\(X^{AA'}\\)  的自旋变换\n\\[ X'^{AA'}= L^A_{\\ \\ B}\\bar{L}^{\\ \\ A'}_{B'}X^{BB'} \\]  自旋变换一半就是旋量变换：\n\\[ \\xi^A=L^A_{\\ \\ B}\\xi^B \\]  若希望恢复完整的自旋变换，则需补上另一半：\n\\[ \\eta^{A'}=\\eta^{B'}\\bar{L}^{\\ \\ A'}_{B'} \\]  于是有：\n\\[ \\xi^A\\eta^{A'}=L^A_{\\ \\ B}\\bar{L}^{\\ \\ A'}_{B'}\\xi^B\\eta^{B'} \\]  由此可见，矢量变换很像二阶旋量变换。可以更明确地用矢量关联(1,1;0,0)型旋量表示：\n\\[ x^{AA'}\\overset{\\Delta}{=}X^{AA'}=x^\\mu\\sigma_\\mu^{\\ \\ AA'} \\]  对三维欧氏空间 \\(\\mu=1,2,3\\)  ；对四维闵氏时空 \\(\\mu=0,1,2,3\\quad x^0=t\\quad \\sigma_0=I\\)  。\n类似，也有也期待有（ \\(\\sigma^\\mu_{\\ \\ AA'}\\)  待定义）：\n\\[ x_{AA'}\\overset{\\Delta}{=}X_{AA'}=x_\\mu\\sigma^\\mu_{\\ \\ AA'} \\]  泡利矩阵的逆 为了确保上式成立， \\(\\sigma^\\mu_{\\ \\ AA'}\\)  只能定义成：\n\\[ \\sigma^\\mu_{\\ \\ AA'}=g^{\\mu\\upsilon}\\sigma_\\upsilon^{\\ \\ BB'}\\epsilon_{BA}\\bar{\\epsilon}_{B'A'} \\]  用基旋量表示之：\n\\[ \\sigma^0_{\\ AA'}=\\frac{1}{\\sqrt{2}}g^{00}(\\omicron_A\\bar{\\omicron}_{A'}+\\iota_A\\bar{\\iota}_{A'})\\\\ \\sigma^1_{\\ AA'}=\\frac{1}{\\sqrt{2}}g^{11}(\\omicron_A\\bar{\\iota}_{A'}+\\iota_A\\bar{\\omicron}_{A'})\\\\ \\sigma^2_{\\ AA'}=-\\frac{i}{\\sqrt{2}}g^{22}(\\omicron_A\\bar{\\iota}_{A'}-\\iota_A\\bar{\\omicron}_{A'})\\\\ \\sigma^3_{\\ AA'}=\\frac{1}{\\sqrt{2}}g^{33}(\\omicron_A\\bar{\\omicron}_{A'}-\\iota_A\\bar{\\iota}_{A'}) \\]  进而可推导出\n\\[ \\sigma_\\mu^{\\ \\ AA'}\\sigma^\\upsilon_{\\ \\ AA'}=-\\delta^\\upsilon_\\mu\\\\ \\sigma_\\mu^{\\ \\ AA'}\\sigma^\\mu_{\\ \\ BB'}=-\\delta^A_B\\delta^{A'}_{B'} \\]  矢量的旋量表示 最后得到矢量的旋量显示表达式： \\[ x^\\mu=-\\sigma^\\mu_{\\ \\ AA'}x^{AA'}\\\\ \\quad \\\\ x_\\mu=-\\sigma_\\mu^{\\ \\ AA'}x_{AA'} \\]  张量的旋量表示 对任意张量，也可以用旋量表示之，比如：\n\\[ T_\\alpha^{\\ \\ \\beta\\gamma}=(-1)^3\\sigma_\\alpha^{\\ \\ AA'}\\sigma^\\beta_{\\ \\ BB'}\\sigma^\\gamma_{\\ \\ CC'}T_{AA'}^{\\quad BB'CC'} \\\\ T_{AA'}^{\\quad BB'CC'}=\\sigma^\\alpha_{\\ \\ AA'}\\sigma_\\beta^{\\ \\ BB'}\\sigma_\\gamma^{\\ \\ CC'} T_\\alpha^{\\ \\ \\beta\\gamma} \\]  进而可推导出：\n\\[ g_{AA'BB'}=-\\epsilon_{AB}\\bar{\\epsilon}_{A'B'}\\\\ \\quad \\\\ g^{AA'BB'}=-\\epsilon^{AB}\\bar{\\epsilon}^{A'B'} \\]  注意：这意味着 \\(g_{AA'BB'},g^{AA'BB'}\\)  可对指标对进行提升和下降操作，但要注意添加一个负号。比如： \\[ g_{AA'BB'}T^{BB'}=-T_{AA'} \\]  关于指标对的反称或对称分解恒等式 考虑任意一个形如 \\(T^{\\dots}_{\\quad \\dots AA'\\dots BB'\\dots }\\)  的旋量张量，为简单起见，用 \\(T_{AA'BB'}\\)  表示之。其中有两组指标对 \\(AA'\\)  和 \\(BB'\\)  ，每一个指标对看成一个整体。本节研究这两组指标对的交换对称性。\n可直接验证一个恒等式【右边展开后合并易得】： \\[ \\frac{1}{2}(T_{AA'BB'}-T_{BB'AA'})=T_{(AB)[A'B']}+T_{[AB](A'B')} \\]  反称部分意味着存在旋量度规因子 \\(\\epsilon_{AB}\\)  或 \\(\\bar{\\epsilon}_{A'B'}\\)  ，对称部分则可分别选择对称旋量张量 \\(\\phi_{AB}\\)  或 \\(\\psi_{A'B'}\\)  代表之： \\[ \\boxed{\\frac{1}{2}(T_{AA'BB'}-T_{BB'AA'})=\\phi_{AB}\\bar{\\epsilon}_{A'B'}+\\epsilon_{AB}\\psi_{A'B'}} \\]  通过对等式两边同乘 \\(\\bar{\\epsilon}^{A'B'}\\)  或 \\(\\epsilon^{AB}\\)  可完全确定 \\(\\phi_{AB}\\)  或 \\(\\psi_{A'B'}\\)  \\[ \\boxed{\\begin{aligned}\\phi_{AB}=\\frac{1}{2}\\bar{\\epsilon}^{A'B'}T_{(AB)A'B'}=\\frac{1}{2}T_{(AB)A'}^{\\ \\qquad A'} \\\\ \\psi_{A'B'}=\\frac{1}{2}\\epsilon^{AB}T_{(A'B')AB}=\\frac{1}{2}T_{(A'B')A}^{\\ \\qquad A}\\end{aligned}} \\]  【结论】：反称张量 \\(T_{ab}=T_{[ab]}\\)  对应的旋量张量（局部反对称也行），可以按上面的方式分解。\n特别地，如果 \\(T_{AA'BB'}\\)  是实数性，易知这两个张量并不独立： \\(\\bar{\\psi}_{AB}=\\phi_{AB}\\)  。进而： \\[ \\boxed{\\frac{1}{2}(T_{AA'BB'}-T_{BB'AA'})=\\phi_{AB}\\bar{\\epsilon}_{A'B'}+\\epsilon_{AB}\\bar{\\phi}_{A'B'}} \\]  类似的，也可直接验证另一个恒等式【右边展开后合并易得】： \\[ \\frac{1}{2}(T_{AA'BB'}+T_{BB'AA'})=T_{(AB)(A'B')}+T_{[AB][A'B']} \\]  其中，第二项两个反称指标分别对应 \\(\\epsilon_{AB}\\)  和 \\(\\bar{\\epsilon}_{A'B'}\\)  两个因子，意味着： \\[ \\boxed{\\begin{aligned}T_{[AB][A'B']}\u0026=\\frac{1}{4}\\epsilon_{AB}\\bar{\\epsilon}_{A'B'}T\\\\ T_{[AB]A'}^{\\qquad A'}\u0026=\\frac{1}{2}\\epsilon_{AB}T \\\\ \u0026\\quad \\\\ T\\overset{\\Delta}{=}T_{AA'}^{\\quad AA'}\u0026=-T_a^{\\ a}\\end{aligned}} \\]  进而 \\[ \\boxed{\\frac{1}{2}(T_{AA'BB'}+T_{BB'AA'})=T_{(AB)(A'B')}+\\frac{1}{4}\\epsilon_{AB}\\bar{\\epsilon}_{A'B'} T} \\]  【结论】：对称张量 \\(T_{ab}=T_{(ab)}\\)  对应的旋量张量（局部对称也行），可以按上面的方式分解。\n 至此，旋量代数的基本工具已经完备了。\n"}),a.add({id:111,href:'/notes/docs/theophy/',title:"理论物理学习笔记",content:"理论物理学习笔记 说明 有空时整理，看我心情。\n前置学习：微分几何笔记\n目录  1. 流形上的拉格朗日力学 2. 流形视角下的牛顿力学 3. 对称性与守恒律（Noether定理） 4. 辛流形上的哈密顿力学    5. 闵氏时空对称性的三种观点 6. 场及其对称性 7. 庞加莱群的单粒子态的表示    参考文献 1）现代物理基础丛书07-微分几何入门与广义相对论(上册.第2版)-梁灿彬＆周彬-科学出版社-2006\n2）现代物理基础丛书25-微分几何入门与广义相对论(中册.第2版)-梁灿彬＆周彬-科学出版社-2009\n3）现代物理基础丛书28-微分几何入门与广义相对论(下册.第2版)-梁灿彬＆周彬-科学出版社-2009\n4）现代物理基础丛书02-物理学家用微分几何(第2版)－侯伯元\u0026amp;侯伯宇-科学出版社-2004\n5）牛津大学研究生教材-量子场论现代导引（英文原版）-[美]加来道雄-OXFORD-2005\n"}),a.add({id:112,href:'/notes/tags/%E5%93%88%E5%AF%86%E9%A1%BF/',title:"哈密顿",content:""}),a.add({id:113,href:'/notes/tags/%E8%BE%9B%E6%B5%81%E5%BD%A2/',title:"辛流形",content:""}),a.add({id:114,href:'/notes/docs/theophy/0075/',title:"辛流形上的哈密顿力学",content:" 有了《辛群及其李代数》和《辛流形》的学习，关于辛流形上的哈密顿力学就水到渠成了。\n首先，借助切丛上的拉格朗日量函数，构造一个特别的切丛到余切丛的同构映射。\n然后，在构造这个同构映射中，对1-形式的动量作外微分，得到一个自然的辛构造，进而余切丛空间（相空间）成为辛流形。\n这个同构映射的构造，实际对应Legendre变换，进而构造出余切丛上的哈密顿函数。\n最后，利用《辛流形》的知识，得到一系列哈密顿力学的结论。\n 相空间(余切丛) 具有约束的力学系的位形空间   \\(M\\)  是一光滑流形，拉格朗日量 \\(L:T\\!M\\to \\mathbb{R}\\)  则是切丛 \\(T\\!M\\)  上的光滑函数。\n很自然，位形空间 \\(M\\)  每个点 \\(q\\)  的切空间 \\(V_q\\)  都有与之同构的对偶空间 \\(V^*_q\\)  ，又叫余切空间。进而可类似切丛概念，定义一个余切丛 \\(T^*\\!M\\)  【也称相空间】：\n\\[ T^*\\!M=\\cup_{q\\in M}V^*_q,\\quad T^*\\!M_q=V^*_q,\\quad \\dim T^*\\!M=2n \\]  相空间上的辛构造 在位形空间 \\(M\\)  选定一个局域坐标系 \\(\\{q^\\mu\\}\\)  ，那么\n\\[ (q,\\dot{q})\\in T\\!M \\]  而切空间 \\(V_q\\)  和余切空间 \\(V^*_q\\)  是同构的，注意这个同构映射并非唯一的，但我们可以根据拉格朗日量 \\(L\\)  构造一个同构映射：\n\\[ \\begin{aligned}\\varphi:\u0026V_q\\to V^*_q\\\\ \u0026 \\dot{q}^a\\mapsto \\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right)_a\\overset{\\Delta}{=}p_a\\end{aligned} \\]  这个 \\(p_a\\in V^*_q\\)  就是 \\(q\\)  点的动量，并且是1-形式：\n\\[ \\boxed{p_a=p_\\mu\\left(dq^\\mu\\right)_a=\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\left(dq^\\mu\\right)_a} \\]  其外微分必然是恰当2-形式：\n\\[ \\boxed{\\boldsymbol{\\omega}\\overset{\\Delta}{=}d_a p_b=(dp_\\mu)_a\\wedge(dq^\\mu)_b} \\]  很明显， \\(\\boldsymbol{\\omega}\\)  是可逆的。所以 \\(\\boldsymbol{\\omega}\\)  将自然的辛构造赋值给了相空间 \\(T^*\\!M\\)  ，进而相空间 \\((T^*\\!M,\\boldsymbol{\\omega})\\)  成为辛流形。\n哈密顿函数 动量 \\(p_a=p_\\mu\\left(dq^\\mu\\right)_a\\)  与速度 \\(\\left(\\dot{q}\\right)^a=\\dot{q}^\\mu\\left(\\dfrac{\\partial}{\\partial q^\\mu}\\right)^a\\)  的缩并是标量场，可以定义一个新标量场 \\(H\\)  ，称之为哈密顿函数：\n\\[ \\boxed{H\\overset{\\Delta}{=}\\dot{q}^\\mu\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\right)_\\mu-L} \\]  Legendre变换 前面这一套流程下，实际上是把切丛变换到余切丛（相空间）上：\n\\[ \\boxed{\\begin{aligned}f:\u0026T\\!M\\to T^*\\!M\\\\ \u0026 \\sigma=(q^\\mu,\\dot{q}^\\mu)\\mapsto f(\\sigma)\\overset{\\Delta}{=}(q^\\mu,p_\\mu)\\\\\u0026 \\qquad\\qquad q^\\mu|_{f(\\sigma)}\\overset{\\Delta}{=}q^\\mu|_\\sigma\\\\\u0026 \\qquad\\qquad p_\\mu|_{f(\\sigma)}\\overset{\\Delta}{=}\\left.\\frac{\\partial L}{\\partial\\dot{q}^\\mu}\\right|_\\sigma\\end{aligned}} \\]  这就是著名的Legendre变换。进而相当于把拉格朗日量 \\(L:T\\!M\\to\\mathbb{R}\\)  变换到余切丛（相空间）上的哈密顿函数 \\(H:T^*\\!M\\to\\mathbb{R}\\)  。\n哈密顿方程 变换后得到的哈密顿函数 \\(H(q^\\mu,p_\\mu)\\)  ，对应的哈密顿矢量场 \\(X^a_H\\)  是:\n\\[ X^a_H=\\frac{\\partial H}{\\partial p_\\mu}\\left(\\frac{\\partial}{\\partial q^\\mu}\\right)^a-\\frac{\\partial H}{\\partial q^\\mu}\\left(\\frac{\\partial}{\\partial p_\\mu}\\right)^a \\]  改写成分量形式就得到哈密顿方程：\n\\[ \\boxed{\\dot{q}^\\mu=\\frac{\\partial H}{\\partial p_\\mu},\\qquad \\dot{p}_\\mu=-\\frac{\\partial H}{\\partial q_\\mu}} \\]  泊松括号 在笔记《辛流形》中，已经定义了括号，这里就不在复述了。\n对任意动力学变量 \\(f(q^\\mu,p_\\mu,t)\\)  ，对时间的作全导数：\n\\[ \\begin{aligned}\\frac{df}{dt}\u0026=\\frac{\\partial f}{\\partial t}+\\frac{\\partial f}{\\partial q^\\mu} \\dot{q}^\\mu+\\frac{\\partial f}{\\partial p_\\mu} \\dot{p}_\\mu\\\\ \u0026=\\frac{\\partial f}{\\partial t}+\\frac{\\partial f}{\\partial q^\\mu}\\frac{\\partial H}{\\partial p_\\mu}-\\frac{\\partial f}{\\partial p_\\mu}\\frac{\\partial H}{\\partial q^\\mu} \\\\ \u0026=\\boxed{\\frac{\\partial f}{\\partial t}+\\{H,f\\}} \\end{aligned} \\]  Liouville定理 由哈密顿矢量场的定义得知:\n\\[ \\mathscr{L}_{X_H}\\boldsymbol{\\omega}=0 \\]  此方程表明，相空间 \\(T^*\\!M\\)  的体积元 \\(\\boldsymbol{\\omega}\\)  沿哈密顿矢量不变。这就是大家熟知的相空间体积不随时间改变的Liouville定理。\n"}),a.add({id:115,href:'/notes/tags/%E6%B3%8A%E6%9D%BE/',title:"泊松",content:""}),a.add({id:116,href:'/notes/docs/diffgeo/0074/',title:"辛流形",content:" 通过类比(维)黎曼流形掌握辛流形的基本概念。\n辛构造，就是闭的反称度规。辛流形，就是配备了辛构造的流形。\n具有相同维度的所有辛流形均局域辛同构（保辛结构的微分同胚映射）。\n辛矢量场是Killing矢量场的类似概念，是无穷小对称生成元。\n如果   \\(X^b\\omega_{ba}\\)  是恰当的，那么对应的辛矢量场 \\(X^a\\)  就是哈密顿矢量场。\n泊松括号， 把哈密顿力学和辛流形联系到一起。\n 辛流形的辛构造 上一节，给出了这是和(对称)度规类似的反称度规的概念，也是一个非奇异2-形式。 在此基础上可以定义辛构造。\n \\(2n\\)  维光滑流形 \\(M\\)  上的2-形式 \\(\\boldsymbol{\\omega}\\in\\Lambda_M(2)\\)  ，若满足以下两个条件：\n 1） \\(\\boldsymbol{\\omega}\\)  是反称度规。【 \\(\\boldsymbol{\\omega}\\)  是非奇异的】 2） \\(\\boldsymbol{\\omega}\\)  是闭的。【 \\(d\\boldsymbol{\\omega}=0\\)  】  则称 \\(\\boldsymbol{\\omega}\\)  为流形 \\(M\\)  上的辛结构。只满足条件1）的，叫近辛结构。只满足条件2）的，则叫予辛结构。\n配有辛结构的光滑流形 \\((M,\\boldsymbol{\\omega})\\)  ，称为辛流形。\n注意：上一节用 \\(s_{ab}\\)  表示反称度规，目的是强调和(对称)度规 \\(g_{ab}\\)  的类比，从本节开始用 \\(\\boldsymbol{\\omega}\\)  表示反称度规，目的是强调这也是一个微分形式。\n辛流形的反称内积 首先， \\(\\boldsymbol{\\omega}\\)  作为反称度规，上一节的相关性质，也是辛流形的性质。\n此外，在流形 \\(M\\)  上每点 \\(p\\)  的切空间 \\(V_p\\)  上，从双线性映射 \\(V_p\\times V_p\\to \\mathbb{R}\\)  的角度看 \\(\\boldsymbol{\\omega}\\)  ，实际上定义了 \\(V_p\\)  上两个矢量的反称内积：\n\\[ \\boldsymbol{\\omega}(u,v)=-\\boldsymbol{\\omega}(v,u),\\quad \\forall u,v\\in V_p \\]   \\(\\boldsymbol{\\omega}\\)  的非奇异性则要求：\n\\[ \\boldsymbol{\\omega}(u,v)=0,\\quad \\forall v\\in V_p \\quad\\Longrightarrow \\quad u=0 \\]  辛流形的正则坐标 上一节已经涉及了正则基底，本节自然也期望存在一个局域坐标系 \\(\\{q^\\mu,p_\\mu\\}\\)  ，使得 \\(\\boldsymbol{\\omega}\\)  也有完全一样的简单形式：\n\\[ \\boldsymbol{\\omega}=(dp_\\mu)_a\\wedge(dq^\\mu)_b \\]  很幸运，Danboux定理保证了这一点。所以这个特殊的局域坐标 \\(\\{q^\\mu,p_\\mu\\}\\)  称作正则坐标，也被称作Danboux坐标。\n此外，这里 \\(p_\\mu\\)  取下标形式的原因：首先，这个特殊坐标下 \\(p_\\mu=\\delta_{\\mu\\upsilon}p^\\upsilon\\backsimeq p^\\mu\\)  ，含义一样；其次，也为了和哈密顿力学中正则坐标保持一致的习惯。\n矢量场到对偶矢量场的自然同构 流形 \\(M\\)  即使没有任何额外结构，矢量场和对偶矢量场也是同构的。但这种同构映射有多种选择，没有谁更特殊。 一旦配置了某种结构，就可能存在一种特别自然的同构映射， 比如，(对称)度规所诱导的同构映射。\n类似的，对辛流形 \\((M,\\boldsymbol{\\omega})\\)  而言， \\(\\boldsymbol{\\omega}\\)  不但可以看成 \\(\\boldsymbol{\\omega}:V_p\\times V_p\\to \\mathbb{R}\\)  的内积映射，作为 \\((0,2)\\)  型张量，也可以看成是映射 \\(\\omega_{ab}:V_p\\to V^*_p\\)  ：\n\\[ \\begin{aligned}\\omega_{ab}:\u0026V_p\\to V^*_p\\\\ \u0026 v^a\\mapsto v_a\\overset{\\Delta}{=}\\omega_{ab}v^b\\end{aligned} \\]  对应也有逆映射 \\(\\omega^{ab}:V^*_p\\to V_p\\)  ：\n\\[ \\begin{aligned}\\omega^{ab}:\u0026V^*_p\\to V_p\\\\ \u0026 v_a\\mapsto v^a=\\omega^{ab}v_b\\end{aligned} \\]  所以，反称度规 \\(\\boldsymbol{\\omega}\\)  是一个非常自然的 \\(V_p\\to V^*_p\\)  的同构映射；进而反称度规场 \\(\\boldsymbol{\\omega}\\)  也是矢量场到对偶矢量场的自然同构 \\(\\omega_{ab}:\\mathscr{F}_M(1,0)\\to\\mathscr{F}_M(0,1)\\)  。\n同时，和度规 \\(g_{ab}\\)  一样， \\(\\boldsymbol{\\omega}=\\omega_{ab}\\)  也具有\u0026quot;提升\u0026quot;和\u0026quot;下降\u0026quot;指标的作用。\n辛构造的特别之处（与对称度规相比） 对(伪)黎曼流形 \\((M,g_{ab})\\)  而言，在每点 \\(p\\in M\\)  的切空间 \\(V_p\\)  上，度规张量的分量矩阵都能通过坐标变换化成对角形式 \\(g_{\\mu\\upsilon}=\\delta_{\\mu\\upsilon}\\)  。 但是，一般不能在 \\(p\\)  点邻域上处处化为对角形（同一套坐标变换下），除非曲率张量系数全为0。\n但辛流形 \\((M,\\boldsymbol{\\omega})\\)  有些不一样，由于辛结构 \\(\\boldsymbol{\\omega}\\)  是局域可积的，可局域辛同胚于标准型，即可在任意点的邻域通过保辛结构的坐标变换化为标准型：\n\\[ (\\omega_{\\mu\\upsilon})=\\begin{pmatrix} 0 \u0026 -I_{n} \\\\ I_{n} \u0026 0 \\end{pmatrix}\\\\ \\quad \\\\ \\boldsymbol{\\omega}=(dp_\\mu)_a\\wedge(dq^\\mu)_b \\]  这是Danboux定理所保证的。这说明：具有相同维度的所有辛流形均局域辛同构（保辛结构的微分同胚映射）。 也就是说辛流形实际上是整体的。\n辛矢量场(和Killing矢量场类比) 辛群 \\(S\\!p(n)\\)  作为辛流形 \\((M,\\boldsymbol{\\omega})\\)  上得变换群，即保辛结构变换的群，其上的李代数 \\(\\mathscr{S\\!p}(n)\\)  的元素 \\(X^a\\in\\mathscr{F}_M(1,0)\\)  就是这个变换群的无穷小生成元。\n如果辛结构沿这个无穷小生成元 \\(X^a\\)  的李导数为0，即满足：\n\\[ \\mathscr{L}_X\\boldsymbol{\\omega}=0 \\]  那么称这个生成元 \\(X^a\\)  就是辛矢量场，也就是无穷小对称生成元。\n辛矢量场的集合记作 \\(\\mathrm{Sym}(M)\\)  。考虑 \\(X,Y\\in \\mathrm{Sym}{M}\\)  ，由于 \\([\\mathscr{L}_X,\\mathscr{L}_Y]=\\mathscr{L}_{[X,Y]}\\)  ，可以证明 \\([X,Y]\\)  也是辛矢量场。这说明 \\(\\mathrm{Sym}(M)\\)  形成 \\(M\\)  上向量场李代数 \\(\\mathscr{X}(M)\\)  的李子代数。\n根据李导数算子 \\(L_X\\)  、外微分算子 \\(d\\)  、缩并算子 \\(i_X\\)  之间的Cartan公式有：\n\\[ \\begin{aligned}\\mathscr{L}_X \\boldsymbol{\\omega}\u0026=(d \\circ i_X+i_X \\circ d)\\boldsymbol{\\omega}, \\quad i_X\\omega_{a_1\\dots a_r}\\overset{\\Delta}{=}X^{a_1}\\omega_{a_1\\dots a_r}\\\\ \u0026=(d \\circ i_X)\\boldsymbol{\\omega},\\qquad d\\boldsymbol{\\omega}=0 \\\\ \u0026=d ( X^b\\omega_{ba})\\end{aligned} \\]  这说明有如下等价说法：\n\\[ \\begin{aligned}\u0026X^a\\in \\mathscr{S\\!p}(n)\\text{是无穷小对称生成元}\\\\ \\quad\\Leftrightarrow\\quad \u0026X^a\\text{是辛矢量场}\\\\ \\quad\\Leftrightarrow\\quad \u0026\\mathscr{L}_X\\boldsymbol{\\omega}=0\\\\ \\quad\\Leftrightarrow\\quad \u0026d ( X^b\\omega_{ba})=0\\qquad X^b\\omega_{ba}\\text{是闭1-形式}\\end{aligned} \\]  而(伪)黎曼流形 \\((M,g_{ab})\\)  对应的无穷小对称生成元，是指满足 \\(\\mathscr{L}_v g_{ab}=0\\)  的矢量场 \\(v^a\\)  ，即Killing矢量场。\n此外，独立Killing矢量场的个数最多是 \\(n(n+1)/2,\\quad n=\\dim M\\)  。但是，独立辛矢量场的个数有无限多个。\n哈密顿矢量场 我们已经知道一个微分形式是恰当的，那必然是闭的。 但如果是闭的，未必是恰当的。\n对辛矢量场 \\(X^a\\in\\mathrm{Sym}(M)\\)  而言， \\(X^b\\omega_{ba}\\)  是闭的。 如果同时是恰当的，即存在标量场 \\(f\\in\\mathscr{F}_M\\)  满足：\n\\[ \\begin{aligned}\u0026X^b\\omega_{ba}=-\\frac{1}{2}df,\\quad \\exist f\\in \\mathscr{F}_M \\\\ \\Longleftrightarrow\\quad \u0026 \\boxed{X^a=\\frac{1}{2}\\omega^{ab}(df)_b=\\frac{1}{2}\\omega^{ab}\\nabla_b f}\\overset{\\Delta}{=}X^a_f\\end{aligned} \\]  此时，我们称是 \\(X^a\\)  是 \\(f\\)  的哈密顿矢量场。哈密顿矢量场的集合记作 \\(\\mathrm{Ham}(M)\\)  ，也构成李代数。\n根据微分形式闭的和恰当的的关系，我们知道哈密顿矢量必定是辛矢量，但反之不一定。 既有如下李代数的包含链：\n\\[ \\mathrm{Ham}(M)\\subset\\mathrm{Sym}(M)\\subset\\mathscr{X}(M) \\]  泊松括号 在辛流形 \\((M,\\boldsymbol{\\omega})\\)  上，可以定义任意两个标量场 \\(f\\)  和 \\(g\\)  的泊松括号：\n\\[ \\begin{aligned}\\{f,g\\}\u0026\\overset{\\Delta}{=}\\frac{1}{2}\\omega^{ab}(df)_a(dg)_b,\\quad \\forall f,g\\in\\mathscr{F}_M \\\\ \u0026=\\frac{1}{2}\\omega^{ab}(\\nabla_a f)(\\nabla_b g) \\\\ \u0026=X^a_g\\nabla_a f=-X^a_f\\nabla_a g\\\\ \u0026=-\\frac{1}{2}\\omega_{ab} X^a_f X^b_g \\end{aligned} \\]  这样定义的泊松括号具有如下性质：\n 1）实双线性： \\(\\{\\alpha f+\\beta g,h\\}=\\alpha\\{f,h\\}+\\beta\\{g,h\\},\\quad \\forall \\alpha,\\beta\\in\\mathbb{R},f,g,h\\in\\mathscr{F}_M\\)   2）反对称： \\(\\{f,g\\}=-\\{g,f\\}\\)   3）雅可比恒等式： \\(\\{f,\\{g,h\\}\\}+\\{g,\\{h,f\\}\\}+\\{h,\\{f,g\\}\\}=0\\)   4）莱布尼茨规则： \\(\\{f,gh\\}=g\\{f,h\\}+\\{f,g\\}h\\)    头三条性质保证了 \\(\\mathscr{F}_M\\)  形成李代数。\n局域正则坐标表示 若在辛流形 \\((M,\\boldsymbol{\\omega})\\)  上选择局域正则坐标，于是有：\n\\[ \\boxed{\\begin{aligned}\\text{辛结构}\\qquad\u0026 \\boldsymbol{\\omega}=\\omega_{ab}=(dp_\\mu)_a\\wedge(dq^\\mu)_b\\\\ \u0026\\omega^{ab}= 2\\left[\\left(\\frac{\\partial}{\\partial q^\\mu}\\right)^a\\left(\\frac{\\partial}{\\partial p_\\mu}\\right)^b-\\left(\\frac{\\partial}{\\partial q^\\mu}\\right)^b\\left(\\frac{\\partial}{\\partial p_\\mu}\\right)^a\\right]\\\\ \\text{哈密顿矢量场}\\qquad\u0026 X^a_f=\\frac{\\partial f}{\\partial p_\\mu}\\left(\\frac{\\partial}{\\partial q^\\mu}\\right)^a-\\frac{\\partial f}{\\partial q^\\mu}\\left(\\frac{\\partial}{\\partial p_\\mu}\\right)^a\\\\ \\text{泊松括号}\\qquad\u0026 \\{f,g\\}=\\frac{\\partial f}{\\partial p_\\mu}\\frac{\\partial g}{\\partial q^\\mu}-\\frac{\\partial f}{\\partial q^\\mu}\\frac{\\partial g}{\\partial p_\\mu} \\end{aligned}} \\] "}),a.add({id:117,href:'/notes/tags/%E5%8F%8D%E7%A7%B0%E5%BA%A6%E8%A7%84/',title:"反称度规",content:""}),a.add({id:118,href:'/notes/tags/%E5%BE%AE%E5%88%86%E5%BD%A2%E5%BC%8F/',title:"微分形式",content:""}),a.add({id:119,href:'/notes/tags/%E6%AD%A3%E5%88%99%E5%8F%98%E6%8D%A2/',title:"正则变换",content:""}),a.add({id:120,href:'/notes/tags/%E8%BE%9B%E7%BE%A4/',title:"辛群",content:""}),a.add({id:121,href:'/notes/docs/diffgeo/0073/',title:"辛群及其李代数",content:" 通过类比正交群掌握辛群的基本概念。\n反称度规   \\(s_{ab}\\)  ，是一个2-形式。只有偶数阶时，才是非奇异的。\n辛群，是保反称度规的线性映射集合，也是李群。\n辛群的元素，作为线性映射而言，就是正则变换。\n辛群的李代数的元素，可以看成 \\(S^{-1}\\)  乘上一个对称矩阵。\n 回顾（对称）度规和正交群 正交群 \\(O(m)\\)  ：正定度规下，全体保度规的线性映射集合。\n这个度规 \\(g_{ab}\\)  ，是矢量空间 \\(V\\)  上非奇异（非退化）的对称 \\((0,2)\\)  型张量，或者看成双线性映射 \\(g:V\\times V\\to\\mathbb{R}\\)  ：\n\\[ g(v,u)=g(u,v),\\quad \\forall v,u\\in V \\]  反称度规（只有偶数阶才是非奇异） 类似的，也可以引入反称度规 \\(s_{ab}\\)  ，但是反称的：\n\\[ s(v,u)=-s(u,v)\\quad \\text{映射形式}\\\\ s_{ab}=-s_{ba}\\quad \\text{张量形式} \\\\ S^T=-S\\quad \\text{矩阵形式} \\]  这个映射可写成：\n\\[ s(v,u)=s_{ab} v^a u^b \\]  由于反称度规 \\(s_{ab}\\)  是非奇异的，必然也有逆 \\(s^{ab}\\)  ，并且满足：\n\\[ s_{ab}s^{bc}=\\delta^c_a=s^{cb}s_{ba} \\]   只有当 \\(m\\)  是偶数时， \\(m\\times m\\)  的反称矩阵 \\(S\\)  才是非奇异的。\n 正则变换和辛群 于是，类似正交群， 辛群的元素 \\(Z\\)  （正则变换）就是保反称度规 \\(s_{ab}\\)  的线性映射：\n\\[ s_{ab}Z^a_{\\ \\ c}Z^b_{\\ \\ d}=s_{cd}\\\\Z^T S\\ Z =S \\]  辛群一般记作 \\(Sp(\\frac{m}{2})\\)  ：\n\\[ Sp(\\frac{m}{2})=\\left\\{Z^a_{\\ \\ b}\\in \\mathscr{T}(1,1)|s_{ab}Z^a_{\\ \\ c}Z^b_{\\ \\ d}=s_{cd}\\right\\} \\]  反称度规的基底表示 实际上，反称度规 \\(s_{ab}\\)  ，作为一个反称张量，其实就2-形式。如果选择一个基底 \\(\\{(e_\\mu)^a\\}\\)  ，相应有对偶基底 \\(\\{(e^\\mu)_a\\}\\)  。 于是反称度规 \\(s_{ab}\\)  ：\n\\[ s_{ab}=s_{[ab]}=\\sum_{(\\mu,\\upsilon)\\in\\chi_2(1\\dots m)}{s_{\\mu\\upsilon}(e^\\mu)_a\\wedge(e^\\upsilon)_b} \\]  其中 \\(\\chi_2(1\\dots m)\\)  代表从 \\(\\{1\\dots m\\}\\)  中取2个数的组合集。\n反称度规分量 \\(s_{\\mu\\upsilon}\\)  则可写成\n\\[ s_{\\mu\\upsilon}=s(e^\\mu,e^\\upsilon)=s_{ab}(e^\\mu)_a(e^\\upsilon)_b \\]  正则基底 给定(对称)度规，则存在特别的正交归一基底，使得度规的分量矩阵成为简单的单位矩阵。\n类似的，给定反称度规，也存在所谓的正则归一基底。使得反称度规分量矩阵有如下简单形式:\n\\[ (s_{\\mu\\upsilon})=\\begin{pmatrix} 0 \u0026 -I_{\\frac{m}{2}} \\\\ I_{\\frac{m}{2}} \u0026 0 \\end{pmatrix} \\]  这里 \\(I_{\\frac{m}{2}}\\)  代表 \\(\\frac{m}{2}\\)  阶单位矩阵。从这个形式，也可看出辛群记作 \\(Sp(\\frac{m}{2})\\)  的原因。\n此时，反称度规可表示成(只能偶数阶)：\n\\[ \\begin{aligned}s_{ab}\u0026=\\sum_{(\\mu,\\upsilon)\\in\\chi_2(1\\dots m)}{s_{\\mu\\upsilon}(e^\\mu)_a\\wedge(e^\\upsilon)_b} \\\\ \u0026=\\sum_{(\\mu,\\upsilon)\\in\\chi_2(1\\dots \\frac{m}{2})}{s_{\\mu\\upsilon}(e^\\mu)_a\\wedge(e^\\upsilon)_b}+\\sum_{\\mu方框中的形式说明：前面最简单的反称度规矩阵，的确对应我们要的最简单2-形式。\n辛群的李代数 辛群 \\(Sp(\\frac{m}{2})\\)  ，也可以写成同构的矩阵形式：\n\\[ Sp(\\frac{m}{2})=\\left\\{Z\\in G\\!L(m)|Z^T S Z=S\\right\\} \\]  考虑辛群 \\(Sp(\\frac{m}{2})\\)  中的一条过恒等元的曲线 \\(Z(t),\\quad Z(0)=I,Z^T(t)\\ S\\ Z(t)=S\\)  。\n于是 \\(\\left.\\dfrac{d Z(t)}{dt}\\right|_{t=0}=A\\)  就是李代数上的元素，于是有：\n\\[ \\begin{aligned}0\u0026=\\left.\\frac{d}{dt}\\left(Z^T(t)\\ S\\ Z(t)\\right)\\right|_{t=0}\\\\ \u0026=\\left.\\frac{d Z^T(t)}{dt}\\right|_{t=0}\\ S\\ Z(0)+Z^T(0)\\ S\\ \\left.\\frac{d Z(t)}{dt}\\right|_{t=0}\\\\ \u0026=A^T\\ S+S\\ A\\\\ \\\\ \\Rightarrow \\quad \u0026S A = (S A)^T\\end{aligned} \\]  所以辛群 \\(S\\!p(\\frac{m}{2})\\)  的李代数可表示成 \\(\\mathscr{S\\!p}(\\frac{m}{2})\\)  ：\n\\[ \\begin{aligned}\\mathscr{S\\!p}(\\frac{m}{2})\u0026=\\left\\{A\\in M(m,\\mathbb{R})|S A = (S A)^T\\right\\}\\\\ \u0026=\\left\\{A=S^{-1}X|X = X^T,X\\in M(m,\\mathbb{R})\\right\\}\\end{aligned} \\]  由此可见，辛群的维度是：\n\\[ \\dim S\\!p(\\frac{m}{2})=\\dim \\mathscr{S\\!p}(\\frac{m}{2})=\\frac{1}{2}m(m+1) \\] "}),a.add({id:122,href:'/notes/tags/noether/',title:"noether",content:""}),a.add({id:123,href:'/notes/tags/%E5%AE%88%E6%81%92%E5%BE%8B/',title:"守恒律",content:""}),a.add({id:124,href:'/notes/docs/theophy/0072/',title:"对称性与守恒律（Noether定理）",content:" 如果知道所有对称性，原则上可以写出具体拉格朗日量。如果只知道部分对称性，也可根据Noether定理得知对称性所关联的守恒律。\nNoether定理：每一个保持拉格朗日量不变的单参微分同胚群（对称性），必有运动方程组对应的一个首次积分（守恒律）。\n套路：研究无穷小变换下的拉格朗日量变换。\n然后，就是三个经典范例。\n Noether定理 令是   \\(M\\)  一光滑流形， \\(L:T\\!M\\to \\mathbb{R}\\)  则是切丛上的光滑函数（拉格朗日量）。\n如果存在一个单参微分同胚 \\(h:\\mathbb{R}\\times M\\to M\\)  ，能够保证拉格朗日量 \\(L\\)  不变，即：\n\\[ L(h_{s*}v)=L(v),\\quad s\\to0,\\quad \\forall s\\in \\mathbb{R},v\\in T\\!M \\]  选择一个局域坐标 \\(\\{q^\\mu\\}\\)  ，于是 \\(v=(q^\\mu,\\dot{q}^\\mu)\\in T\\!M\\)  ，并以下图示意，约定关于变换 \\(h_s\\)  及其推前映射 \\(h_{s*}\\)  的相关符号（推导及图中略去了上标 \\(\\mu\\)  ，事实上存在关于 \\(\\mu\\)  的缩并）：\n在变换 \\(h_s:M\\to M\\)  的作用下，拉格朗日量 \\(L\\)  不变，即\n\\[ \\begin{aligned}\u00260=\\frac{\\partial L(\\Phi,\\dot{\\Phi})}{\\partial s}=\\frac{\\partial L}{\\partial q}\\Phi'+\\frac{\\partial L}{\\partial \\dot{q}}\\dot{\\Phi}'\\\\ \\Rightarrow \\quad \u0026 0=\\left(\\frac{\\partial}{\\partial t}\\frac{\\partial L}{\\partial \\dot{q}}\\right)\\Phi'+\\frac{\\partial L}{\\partial \\dot{q}}\\dot{\\Phi}'\\\\ \\quad \u0026 \\ \\ = \\frac{\\partial}{\\partial t}\\left(\\frac{\\partial L}{\\partial \\dot{q}}\\Phi'\\right)\\\\ \\Rightarrow \\quad \u0026 I= \\frac{\\partial L}{\\partial \\dot{q}}\\Phi'\\end{aligned} \\]  其中， \\(I\\)  就是首次积分常数，可改写成：\n\\[ I(q^\\mu,\\dot{q}^\\mu)=\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\left.\\frac{dh_s(q^\\mu)}{ds}\\right|_{s=0} \\]  着就是著名的Noether定理：\n 每一个保持拉格朗日量不变的单参微分同胚群，必有运动方程组对应的一个首次积分。\n 范例：时间平移不变性对应能量守恒 时间平移无穷小变换： \\(t\\to t+\\varepsilon\\)  。\n在无穷小变换下的拉格朗日量要么不变，要么相差一个关于时间全导数：\n\\[ \\begin{aligned}\u0026L(t+\\varepsilon,q^\\mu,\\dot{q}^\\mu)=L(t,q^\\mu,\\dot{q}^\\mu)+\\frac{d}{dt}f(t,q^\\mu)\\\\ \\Rightarrow \\quad \u0026 \\frac{\\partial L}{\\partial t}\\varepsilon=\\frac{d}{dt}f(t,q^\\mu)\\\\ \\Rightarrow \\quad \u0026 \\frac{\\partial L}{\\partial t}=0\\quad \\text{【时间平移不变说明拉氏量不含时间】}\\\\ \\Rightarrow \\quad \u0026 \\frac{d L}{d t}=\\frac{\\partial L}{\\partial q^\\mu}\\dot{q}^\\mu+\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\ddot{q}^\\mu\\\\ \u0026 \\quad \\ \\ =\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\right)\\dot{q}^\\mu+\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\ddot{q}^\\mu\\quad \\text{【带入拉氏方程】}\\\\ \u0026 \\quad \\ \\ =\\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\dot{q}^\\mu\\right)\\\\ \\Rightarrow \\quad \u0026 \\frac{d}{dt}\\left(\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\dot{q}^\\mu-L\\right)=0\\\\ \\Rightarrow \\quad \u0026 \\boxed{E=\\frac{\\partial L}{\\partial \\dot{q}^\\mu}\\dot{q}^\\mu-L}\\end{aligned} \\]  方框中的积分常数 \\(E\\)  ，就是系统能量。\n范例：空间平移不变性对应动量守恒 空间平移无穷小变换： \\(x^\\mu\\to x^\\mu+\\varepsilon^\\mu\\)  。\n于是所有质点同时无穷小平移： \\(\\vec{r}_i\\to \\vec{r}_i+\\vec{\\varepsilon},\\quad i=1,2,\\dots\\)  继续类似的套路\n\\[ \\begin{aligned}\u0026L(\\vec{r}_i+\\vec{\\varepsilon},\\vec{v}_i)=L(\\vec{r}_i,\\vec{v}_i)+\\frac{d}{dt}f(t,\\vec{r}_i)\\\\ \\Rightarrow \\quad \u0026 \\vec{\\varepsilon}\\cdot \\sum_i{\\frac{\\partial L}{\\partial \\vec{r}_i}}=\\frac{d}{dt}f(t,\\vec{r}_i)\\quad \\text{【三个相互独立的无穷小变量】}\\\\ \\Rightarrow \\quad \u0026 \\sum_i{\\frac{\\partial L}{\\partial \\vec{r}_i}}=0\\\\ \\Rightarrow \\quad \u0026 \\frac{d}{dt}\\sum_i{\\frac{\\partial L}{\\partial \\vec{v}_i}}=0\\quad \\text{【根据拉氏方程】}\\\\ \\Rightarrow \\quad \u0026 \\boxed{\\vec{P}=\\sum_i{\\frac{\\partial L}{\\partial \\vec{v}_i}}=\\sum_i{p_i}}\\end{aligned} \\]  方框中的积分常数 \\(\\vec{P}\\)  ，就是封闭系统总动量。 \\(p_i\\)  则是单个质点的动量。\n范例：空间旋转不变性对应角动量守恒 空间旋转无穷小变换： \\(x^\\mu\\to x^\\mu+\\xi^\\mu_{\\ \\ \\upsilon} \\varepsilon^\\upsilon\\)  。\n于是所有质点同时无穷小旋转：\n\\[ \\vec{r}_i\\to \\vec{r}_i+\\Xi_i\\ \\vec{\\varepsilon},\\quad\\vec{v}_i\\to \\vec{v}_i+\\dot{\\Xi}_i\\ \\vec{\\varepsilon},\\quad i=1,2,\\dots \\]  其中， \\(\\Xi_i\\)  是上一节Killing矢量场三个旋转基底组成的矩阵，每列对应一个基底：\n\\[ \\Xi_i=\\begin{bmatrix}0 \u0026 -z_i \u0026 y_i \\\\ z_i \u0026 0 \u0026 -x_i \\\\ -y_i \u0026 x_i \u0026 0 \\end{bmatrix} \\]  于是：\n\\[ \\begin{aligned}\u0026L(\\vec{r}_i+\\Xi_i\\ \\vec{\\varepsilon},\\vec{v}_i+\\dot{\\Xi}_i\\ \\vec{\\varepsilon})=L(\\vec{r}_i,\\vec{v}_i)+\\frac{d}{dt}f(t,\\vec{r}_i)\\\\ \\Rightarrow \\quad \u0026 \\sum_i{\\left(\\frac{\\partial L}{\\partial \\vec{r}_i}\\Xi_i+\\frac{\\partial L}{\\partial \\vec{v}_i}\\dot{\\Xi}_i\\right)} \\vec{\\varepsilon}=\\frac{d}{dt}f(t,\\vec{r}_i)\\quad \\text{【三个相互独立的无穷小变量】}\\\\ \\Rightarrow \\quad \u0026\\sum_i{\\left(\\frac{d }{d t}\\left(\\frac{\\partial L}{\\partial \\vec{v}_i}\\right)\\Xi_i+\\frac{\\partial L}{\\partial \\vec{v}_i}\\dot{\\Xi}_i\\right)}\\vec{\\varepsilon}=\\frac{d}{dt}f(t,\\vec{r}_i)\\quad \\text{【根据拉氏方程】}\\\\ \\Rightarrow \\quad \u0026 \\frac{d }{d t}\\left(\\sum_i{\\frac{\\partial L}{\\partial \\vec{v}_i}\\Xi_i}\\right)\\vec{\\varepsilon}=\\frac{d}{dt}f(t,\\vec{r}_i)\\\\ \\Rightarrow \\quad \u0026 \\frac{d }{d t}\\left(\\sum_i{\\frac{\\partial L}{\\partial \\vec{v}_i}\\Xi_i}\\right)=0\\\\ \\Rightarrow \\quad \u0026 \\boxed{\\vec{M}=\\sum_i{\\frac{\\partial L}{\\partial \\vec{v}_i}\\Xi_i}=\\sum_i{\\vec{r}_i\\times\\vec{p}_i}}\\end{aligned} \\]  其中：\n\\[ \\begin{aligned}\\frac{\\partial L}{\\partial \\vec{v}}\\Xi=\\left[p_x\\quad p_y\\quad p_z\\right]\\begin{bmatrix}0 \u0026 -z \u0026 y \\\\ z \u0026 0 \u0026 -x \\\\ -y \u0026 x \u0026 0 \\end{bmatrix}=\\vec{r}\\times\\vec{p}\\\\\\end{aligned} \\]  方框中的积分常数 \\(\\vec{M}\\)  ，就是封闭系统总角动量。\n"}),a.add({id:125,href:'/notes/tags/killing/',title:"killing",content:""}),a.add({id:126,href:'/notes/tags/%E4%BC%BD%E5%88%A9%E7%95%A5/',title:"伽利略",content:""}),a.add({id:127,href:'/notes/docs/theophy/0071/',title:"流形视角下的牛顿力学(杀鸡用牛刀)",content:" 本文真是杀鸡用牛刀，但好处是彻底厘清了如何用对称性构造拉格朗日量的一般套路。\n本文通过强算Killing方程的笨方法，来确定伽利略时空，特别是欧氏空间的完整对称性，进而得到无穷小生成元（变换），最后用这组无穷小变换在拉格朗日量上的不变性来确定拉格朗日量。\n 伽利略时空 伽利略时空流形   \\(M\\)  的时间和空间是绝对分离的： \\(M=\\mathbb{R}^3\\times \\mathbb{R}\\)  。\n伽利略时空李群(10维)： \\(G=\\mathrm{SO}(3)\\times T(3)\\times T(4)\\)   空间平移群 \\(T(3)\\)  ： \\(x^\\mu\\to x^\\mu+b^\\mu\\)   空间旋转群 \\(\\mathrm{SO}(3)\\)  ： \\(x^\\mu \\to A^\\mu_{\\ \\ \\upsilon} x^\\upsilon,\\quad A^TA=I\\)   时间平移群 \\(\\mathbb{R}\\)  ： \\(t\\to t+c\\)   伽利略惯性平移群 \\(\\mathbb{R}^3\\)  ： \\(x^\\mu \\to x^\\mu +v^\\mu t\\)     \\(M\\)  的空间部分（欧氏空间） \\(\\mathbb{R}^3\\)  的度规（线元表示）\n\\[ ds^2=(dx)^2+(dy)^2+(dz)^2 \\]  伽利略时空 \\(M\\)  在李群 \\(G\\)  的作用下是欧氏等度规李变换，即欧氏线元是不变量。\n欧氏空间的Killing矢量场 由于伽利略时空的时间和空间是绝对分离的，同时与时间相关的对称性都是平移，所以，有必要先单独分析三维欧氏空间的对称性。\n可通过求解Killing方程确定欧氏空间的平移群 \\(T(3)\\)  和转动群 \\(\\mathrm{SO}(3)\\)  。合起来对应Killing矢量的6个基底所张成的空间。 下面给出Julia代码：\nusing SymPy # 选择欧氏坐标系 @vars x y z real=true X = [x,y,z] # 待求的Killing矢量场的分量 ξ = SymFunction(\u0026#34;ξ^1,ξ^2,ξ^3\u0026#34;) # 欧氏度规及逆度规 g = sympy.eye(3) .* [1,1,1] gi = inv(g) # 根据度规计算克氏符 Γ = sum([(1//2)*gi[σ,ρ]*(diff(g[μ,ρ],X[υ])+ diff(g[υ,ρ],X[μ])-diff(g[μ,υ],X[ρ])) for μ in 1:3,υ in 1:3 ,σ in 1:3] for ρ in 1:3) # 列出所有独立Killing方程组 eqs = [(0⩵diff(sum(g[υ,ρ]*ξ[ρ](x,y,z) for ρ in 1:3),X[μ])+ diff(sum(g[μ,ρ]*ξ[ρ](x,y,z) for ρ in 1:3),X[υ])- 2*sum(Γ[μ,υ,σ]*sum(g[σ,ρ]*ξ[ρ](x,y,z) for ρ in 1:3) for σ in 1:3)) for μ in 1:3,υ in 1:3 if μ ≤ υ ] 根据方程1、3、6，可设：\n\\[ \\begin{aligned}\\xi(x,y,z)\u0026=\\Big(\\xi^1(x,y,z),\\xi^2(x,y,z),\\xi^3(x,y,z)\\Big)^T\\\\\u0026=\\Big(f(y,z),g(x,z),h(x,y)\\Big)^T\\end{aligned} \\]  带入方程2、4、5，并分离变量得：\n\\[ \\frac{\\partial f(y,z)}{\\partial y}=-\\frac{\\partial g(x,z)}{\\partial x}=C_1(z)\\\\ \\frac{\\partial f(y,z)}{\\partial z}=-\\frac{\\partial h(x,y)}{\\partial x}=C_2(y)\\\\ \\frac{\\partial g(x,z)}{\\partial z}=-\\frac{\\partial h(x,y)}{\\partial y}=C_3(x) \\]  当 \\(C_1(z)=C_2(y)=C_3(x)=0\\)  时，有三个平移特解：\n\\[ \\boxed{\\begin{aligned}(\\xi_4)^a=\\left(\\frac{\\partial}{\\partial x}\\right)^a \\overset{\\Delta}{=}(e_1)^a\\quad \\xi_4=(1,0,0)^T\\\\ (\\xi_5)^a=\\left(\\frac{\\partial}{\\partial y}\\right)^a\\overset{\\Delta}{=}(e_2)^a \\quad \\xi_5=(0,1,0)^T\\\\ (\\xi_6)^a=\\left(\\frac{\\partial}{\\partial z}\\right)^a\\overset{\\Delta}{=}(e_3)^a\\quad \\xi_6=(0,0,1)^T\\end{aligned}} \\]  当 \\(C_1(z)=C_2(y)=0,C_3(x)\\ne0\\)  时，有一个沿 \\(x\\)  轴平移特解（前面已有），一个绕 \\(x\\)  轴转动特解（新解）：\n\\[ \\boxed{(\\xi_1)^a=z\\left(\\frac{\\partial}{\\partial y}\\right)^a-y\\left(\\frac{\\partial}{\\partial z}\\right)^a\\quad \\xi_1=(0,z,-y)^T} \\]  当 \\(C_1(z)=0,C_2(y)\\ne 0,C_3(x)=0\\)  时，有一个沿 \\(y\\)  轴平移特解（前面已有），一个绕 \\(y\\)  轴转动特解（新解）：\n\\[ \\boxed{(\\xi_2)^a=-z\\left(\\frac{\\partial}{\\partial x}\\right)^a+x\\left(\\frac{\\partial}{\\partial z}\\right)^a\\quad \\xi_2=(-z,0,x)^T} \\]  当 \\(C_1(z)=0,C_2(y)\\ne 0,C_3(x)\\ne 0\\)  时，一个绕 \\(y\\)  轴转动特解（前面已有），一个绕 \\(x\\)  轴转动特解（前面已有）。\n当 \\(C_1(z)\\ne 0,C_2(y)= 0,C_3(x)=0\\)  时，一个沿 \\(z\\)  轴平移特解（前面已有），一个绕 \\(z\\)  轴转动特解（新解）：\n\\[ \\boxed{(\\xi_3)^a=y\\left(\\frac{\\partial}{\\partial x}\\right)^a-x\\left(\\frac{\\partial}{\\partial y}\\right)^a\\quad \\xi_3=(y,-x,0)^T} \\]   \\(C_1(z),C_2(y),C_3(x)\\)  还剩下三种组合，但相关得特解都和前面重复了。\n所以，三维欧氏空间的6维Killing矢量场，由三个平移 \\(\\{(e_1)^a,(e_2)^a,(e_3)^a\\}\\)  和三个转动 \\(\\{(\\xi_1)^a,(\\xi_2)^a,(\\xi_3)^a\\}\\)  ，一共6个特解张成。\n这三个转动基底（特解） \\(\\{(\\xi_1)^a,(\\xi_2)^a,(\\xi_3)^a\\}\\)  ，构成一个反对称矩阵，这就是 \\(\\mathrm{SO}(3)\\)  的三个生成元，每列代表一个生成元（也是李代数 \\(\\mathscr{S\\!O}(3)\\)  上的三个基底）：\n\\[ \\{\\xi^\\mu_{\\ \\ \\upsilon}\\}=\\begin{bmatrix}0 \u0026 -z \u0026 y \\\\ z \u0026 0 \u0026 -x \\\\ -y \u0026 x \u0026 0 \\end{bmatrix} \\]  于是，空间旋转群可改写成参数形式(利用了李代数到李群的指数映射)：\n\\[ \\boxed{x^\\mu\\to \\exp\\left[\\varepsilon \\xi^\\mu_{\\ \\ \\upsilon}\\right] x^\\upsilon=x^\\mu+\\varepsilon \\xi^\\mu_{\\ \\ \\upsilon} x^\\upsilon=x^\\mu+\\xi^\\mu_{\\ \\ \\upsilon} \\varepsilon^\\upsilon} \\]  其中， \\(\\varepsilon\\)  是无穷小参数， \\(\\varepsilon^\\upsilon=\\varepsilon x^\\mu\\)  则是 \\(\\varepsilon\\)  诱导的三个无穷小量，对应 \\(\\mathrm{SO}(3)\\)  的三个参数。\n由伽利略时空对称性确定自由粒子的拉格朗日量 首先，在空间、时间的无穷小平移变换下，必须保持拉格朗量不变，这意味着拉格朗日量不显含位置和时间，即：\n\\[ L(\\dot{x}^\\mu) \\]  然后，在无穷小空间转动变换下，也必须保持拉格朗量不变（优先保证相等，其次也可精确到相差一个全微分），即：\n\\[ \\begin{aligned}\u0026L(\\dot{x}^\\mu+\\dot{\\xi}^\\mu_{\\ \\ \\upsilon} \\varepsilon^\\upsilon)=L(\\dot{x}^\\mu)+\\frac{d}{dt}f(t,x^\\mu) \\quad \\text{【代入无穷小转动】} \\\\ \\Rightarrow \\quad \u0026 \\begin{cases}\\dfrac{\\partial L}{\\partial \\dot{x}^\\mu} \\dot{\\xi}^\\mu_{\\ \\ 1} \\varepsilon^1=\\dfrac{d}{dt}f_1(t,x^\\mu)\\\\ \\dfrac{\\partial L}{\\partial \\dot{x}^\\mu} \\dot{\\xi}^\\mu_{\\ \\ 2} \\varepsilon^2=\\dfrac{d}{dt}f_2(t,x^\\mu)\\\\ \\dfrac{\\partial L}{\\partial \\dot{x}^\\mu} \\dot{\\xi}^\\mu_{\\ \\ 3} \\varepsilon^3=\\dfrac{d}{dt}f_3(t,x^\\mu)\\end{cases} \\quad \\text{【保留一阶项】}\\\\ \\Rightarrow \\quad \u0026 \\begin{cases}\\dfrac{d}{dt}f_1(t,x,y,z)=\\varepsilon^1 (\\dot{z}\\dfrac{\\partial L}{\\partial \\dot{y}}-\\dot{y}\\dfrac{\\partial L}{\\partial \\dot{z}})\\\\ \\dfrac{d}{dt}f_2(t,x,y,z)=\\varepsilon^2 (-\\dot{z}\\dfrac{\\partial L}{\\partial \\dot{x}}+\\dot{x}\\dfrac{\\partial L}{\\partial \\dot{z}})\\\\ \\dfrac{d}{dt}f_3(t,x,y,z)=\\varepsilon^3 (\\dot{y}\\dfrac{\\partial L}{\\partial \\dot{x}}-\\dot{x}\\dfrac{\\partial L}{\\partial \\dot{y}})\\end{cases} \\quad \\text{【将Killing矢量转动基底代入】}\\\\ \\Rightarrow \\quad \u0026 \\begin{cases}\\dot{z}\\dfrac{\\partial L}{\\partial \\dot{y}}-\\dot{y}\\dfrac{\\partial L}{\\partial \\dot{z}}=0\\\\ -\\dot{z}\\dfrac{\\partial L}{\\partial \\dot{x}}+\\dot{x}\\dfrac{\\partial L}{\\partial \\dot{z}}=0\\\\ \\dot{y}\\dfrac{\\partial L}{\\partial \\dot{x}}-\\dot{x}\\dfrac{\\partial L}{\\partial \\dot{y}}=0\\end{cases} \\quad \\text{【确保变换后拉格朗日量不变】}\\\\ \\Rightarrow \\quad \u0026 \\dfrac{\\partial L}{\\partial \\dot{x}}/\\dot{x}=\\dfrac{\\partial L}{\\partial \\dot{y}}/\\dot{y}=\\dfrac{\\partial L}{\\partial \\dot{z}}/\\dot{z}\\\\ \\Rightarrow \\quad \u0026 \\boxed{L=L(\\dot{x}^2+\\dot{y}^2+\\dot{z}^2)=L(v^2)} \\end{aligned} \\]  最后，在无穷小伽利略惯性平移变换下(变换的相对速度 \\(\\vec{\\varepsilon}\\to 0\\)  )，也必须保持拉格朗量不变（优先保证相等，其次也可精确到相差一个全微分），即：\n\\[ \\begin{aligned}\u0026L(\\left|\\vec{v}+\\vec{\\varepsilon}\\right|^2)=L(v^2)+\\frac{d}{dt}f(t,\\vec{r})\\\\ \\Rightarrow \\quad \u0026 L(v^2+2\\vec{v}\\cdot \\vec{\\varepsilon}+\\varepsilon^2)=L(v^2)+\\frac{d}{dt}f(t,\\vec{r})\\\\ \\Rightarrow \\quad \u0026 2\\vec{v}\\cdot \\vec{\\varepsilon}\\frac{\\partial L}{\\partial v^2}=\\frac{d}{dt}f(t,\\vec{r})\\end{aligned} \\]  我们注意到最后一个等式左边无法取0（因为 \\(L\\)  取常数无意义），那么只能保证是时间的全导数。进而只能取 \\(\\dfrac{\\partial L}{\\partial v^2}\\)  为常数，即：\n\\[ L=\\frac{m}{2}v^2 \\]  其中， \\(m\\)  成为质点的质量。\n质点系的拉格朗日量 根据，各自完全独立系统的总拉格朗量等于部分拉格朗量之和，然后再补上表示各质点间相互作用的某个函数 \\(-U\\)  ，则有封闭质点系拉格朗日量的一般形式:\n\\[ \\boxed{L=\\sum_\\alpha{\\frac{1}{2}m_\\alpha v_\\alpha^2}-U(\\vec{r}_1,\\vec{r}_2,\\dots)} \\]  其中， \\(T=\\sum_\\alpha{\\frac{1}{2}m_\\alpha v_\\alpha^2}\\)  称为系统动能， \\(U\\)  则成为系统势能。\n"}),a.add({id:128,href:'/notes/tags/%E7%89%9B%E9%A1%BF%E5%8A%9B%E5%AD%A6/',title:"牛顿力学",content:""}),a.add({id:129,href:'/notes/tags/%E5%85%8B%E6%B0%8F%E7%AC%A6/',title:"克氏符",content:""}),a.add({id:130,href:'/notes/tags/%E5%BC%A0%E9%87%8F/',title:"张量",content:""}),a.add({id:131,href:'/notes/docs/diffgeo/0070/',title:"微分几何中的计算（Julia版 计划长期维护）",content:" Julia，对数学符号真太友好了。\n前面的笔记中，我曾穿插了些相关的符号计算，本文作为一个汇总，并且未来的一些有特点的代码，我也将汇总于此，用作备忘。\n用Julia进行张量符号计算的关键：1）先要写出（多重）数组友好的公式，然后用Julia实现之； 2）使用了SymPy，外加Julia本身的语法优势。\n我曾想过将代码封装成函数，但发现直接用代码似乎更好。首先代码不复杂，其次， 暴露代码细节还能和数学公式相互对照，不容易出错。 有种“所见即所得”的感觉。\n 张量变换 首先将张量变换关系写成具体指标，并调整成矩阵友好的形式:\n  \\[ \\eta'_{\\mu\\upsilon}=\\frac{dx^\\alpha}{dx'^\\mu}\\frac{dx^\\beta}{dx'^\\upsilon}\\eta_{\\alpha\\beta}=\\frac{dx^\\alpha}{dx'^\\mu}\\eta_{\\alpha\\beta}\\frac{dx^\\beta}{dx'^\\upsilon} \\]  1） 同维变换 比如，坐标变换引起的张量变换 以笛卡尔坐标到球坐标的变换为例求球坐标下的度规，用Julia实现之：\nusing SymPy @vars r θ φ real=true # 笛卡尔坐标到球坐标的变换 X = [r*sin(θ)*cos(φ), r*sin(θ)*sin(φ), r*cos(θ)] Q = [r, θ, φ] # 欧氏度规及逆度规 g = sympy.eye(3) .* [1, 1, 1] gi = inv(g) # 文中公式最后一项的最后一个因子 M=[diff(x, q) for x in X, q in Q] # 球坐标下的度规 看文中改写的公式 h = simplify.(sympy.Matrix(M\u0026#39;*g*M)) h 2）降维变换 比如，求子流形的诱导度规 上面类似的方法也用来计算球面上的诱导度规，用Julia实现之（只有注释对应的代码和前面不一样）：\n# # 除了注释部分，其它和前一段代码完全一样 # using SymPy @vars r, θ φ real=true X = [r*sin(θ)*cos(φ), r*sin(θ)*sin(φ), r*cos(θ)] # 球面只有两个参数， r是常量，所以不在坐标列表中 Q = [θ, φ] g = sympy.eye(3) .* [1, 1, 1] gi = inv(g) M=[diff(x, q) for x in X, q in Q] h = simplify.(sympy.Matrix(M\u0026#39;*g*M)) h 克氏符 克氏符的分量（具体指标）表达式：\n\\[ \\Gamma^\\sigma_{\\ \\ \\mu \\upsilon}=\\frac{1}{2}g^{\\sigma \\rho}[g_{\\upsilon \\rho,\\mu}+g_{\\mu \\rho,\\upsilon}-g_{\\mu \\upsilon,\\rho}] \\]  显然，这个计算要用到三重数组。我们约定表示克氏符数组的头两个位置分配给下指标，最后一个位置分配给上指标，即用 \\(\\Gamma[\\mu,\\upsilon,\\sigma]\\)  代表 \\(\\Gamma^\\sigma_{\\ \\ \\mu \\upsilon}\\)  。\n此外， \\(g_{\\upsilon \\rho,\\mu}=\\partial_\\mu g_{\\upsilon \\rho}\\)  ， 而 \\(\\{g^{\\sigma\\rho}\\}\\)  是 \\(\\{g_{\\sigma\\rho}\\}\\)  的逆矩阵，在数组中分别表示为 \\(\\mathrm{gi}[\\sigma,\\rho]\\)  和 \\(g[\\sigma,\\rho]\\)  。\n【范例】 求度规 \\(ds^2=z^{-1/2}(-dt^2+dz^2)+z(dx^2+dy^2)\\)  的克氏符在 \\(\\{t,x,y,z\\}\\)  系的全部分量。\n有了这些约定，很容易用Julia计算之：\nusing SymPy @vars t x y z real=true # 坐标变量 X = [t,x,y,z] # 度规张量及其逆 g = sympy.eye(4) .* [-z^(-1//2),z,z,z^(-1//2)] gi = inv(g); # 根据度规计算克氏符 Γ = sum([(1//2)*gi[σ,ρ]*(diff(g[υ,ρ],X[μ])+ diff(g[μ,ρ],X[υ])-diff(g[μ,υ],X[ρ])) # 公式部分 for μ in 1:4, υ in 1:4, σ in 1:4] # 三重数组生成指标 for ρ in 1:4) # 缩并求和指标 # 显示所有分量（剔除了０分量和对称分量） [symbols(\u0026#34;Γ^{$σ}_{$μ$υ}\u0026#34;)⩵Γ[μ,υ,σ] for μ in 1:4,υ in 1:4 ,σ in 1:4 if Γ[μ,υ,σ]!=0 \u0026amp;\u0026amp; μ\u0026lt;=υ].T 黎曼曲率张量 黎曼曲率张量分量：\n\\[ R^{\\ \\quad \\rho}_{\\mu \\upsilon \\sigma}=\\Gamma^\\rho_{\\ \\ \\mu \\sigma,\\upsilon}-\\Gamma^\\rho_{\\ \\ \\upsilon \\sigma,\\mu}+\\Gamma^\\lambda_{\\ \\ \\sigma\\mu}\\Gamma^\\rho_{\\ \\ \\upsilon \\lambda}-\\Gamma^\\lambda_{\\ \\ \\sigma\\upsilon }\\Gamma^\\rho_{\\ \\ \\mu \\lambda} \\\\ R_{\\mu \\sigma}=R^{\\ \\quad \\upsilon}_{\\mu \\upsilon \\sigma} \\]  黎曼曲率张量涉及四重数组，约定表示黎曼曲率张量数组的头三个位置分配给下指标，最后一个位置分配给上指标，即用 \\(R[\\mu,\\upsilon,\\sigma,\\rho]\\)  代表 \\(R^{\\ \\quad \\rho}_{\\mu \\upsilon \\sigma}\\)  。\n继续沿用克氏符的范例，用Julia计算之：\n#　根据克氏符计算黎曼曲率张量 R=[diff(Γ[μ,σ,ρ],X[υ])-diff(Γ[υ,σ,ρ],X[μ])+ sum(Γ[μ,σ,λ]*Γ[υ,λ,ρ]-Γ[υ,σ,λ]*Γ[μ,λ,ρ] # 公式部分 for λ in 1:4) # 第3、4项的缩并求和指标 for μ in 1:4,υ in 1:4 ,σ in 1:4,ρ in 1:4] # 四重数组生成指标 # 显示所有分量（剔除了０分量和反对称分量） reshape([symbols(\u0026#34;R_{$μ$υ$σ}^{$ρ}\u0026#34;)⩵R[μ,υ,σ,ρ] for μ in 1:4,υ in 1:4 ,σ in 1:4,ρ in 1:4 if R[μ,υ,σ,ρ]!=0 \u0026amp;\u0026amp; μ\u0026lt;=υ],(3,4)) 继续计算里奇张量：\n# 根据黎曼曲率张量计算里奇张量 RR=[sum(R[μ,υ,σ,υ] for υ in 1:4) # 缩并求和指标 for μ in 1:4,σ in 1:4] # 矩阵生成指标 Killing方程 Killing方程的分量形式，并改写成数组友好的形式：\n\\[ \\begin{aligned}\u0026\\nabla_\\mu\\xi_\\upsilon+\\nabla_\\upsilon\\xi_\\mu=0\\\\ \\Leftrightarrow \\quad \u0026 \\partial_\\mu\\xi_\\upsilon+\\partial_\\upsilon\\xi_\\mu-2\\Gamma^\\sigma_{\\ \\ \\mu\\upsilon}\\xi_\\sigma=0\\\\ \\Leftrightarrow \\quad \u0026 \\boxed{\\partial_\\mu (g_{\\upsilon\\rho}\\xi^\\rho)+\\partial_\\upsilon(g_{\\mu\\rho}\\xi^\\rho)-2\\Gamma^\\sigma_{\\ \\ \\mu\\upsilon}g_{\\sigma\\rho}\\xi^\\rho=0}\\end{aligned} \\]  【范例】3维欧氏空间 \\((\\mathbb{R}^3,\\delta_{ab})\\)  中的2维球面 \\((S^2,h_{ab})\\)  。根据方框中的公式用Julia很容易列出所有Killing方程\nusing SymPy @vars θ φ real=true # 待求的Killing矢量场的分量 ξ = SymFunction(\u0026#34;ξ^1,ξ^2\u0026#34;) # 坐标变换 X=[sin(θ)*cos(φ),sin(θ)*sin(φ),cos(θ)] Q=[θ,φ] # 三维欧氏度规矩阵 g = sympy.eye(3) .* [1,1,1] # 计算二维球面上的诱导度规矩阵h，及其逆hi M=[diff(x,q) for x in X, q in Q] h= simplify.(sympy.Matrix(M\u0026#39;*g*M)) hi = inv(h) # 根据度规计算克氏符 Γ = sum([(1//2)*hi[σ,ρ]*(diff(h[υ,ρ],Q[μ])+ diff(h[μ,ρ],Q[υ])-diff(h[μ,υ],Q[ρ])) for μ in 1:2,υ in 1:2 ,σ in 1:2] for ρ in 1:2) # 列出所有独立Killing方程 eqs = [(0⩵diff(sum(h[υ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2),Q[μ])+ diff(sum(h[μ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2),Q[υ])- 2*sum(Γ[μ,υ,σ]*sum(h[σ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2) for σ in 1:2)) for μ in 1:2,υ in 1:2 if μ ≤ υ ] 至于，这个方程组通解的求解，还是要靠手工进行。【参见：李变换群 的末尾部分】\nLevi-Civita记号  20200425 追加\n 以三指标Levi-Civita记号 \\(\\varepsilon_{ijk}\\)  为例。下面这个段代码关键点：1）重复指标取0；2）求逆序数。\n# 三指标Levi-Civita记号 ε= [ Sym((length(Set([i,j,k]))==3)* # 存在重复指标，取0 (-1)^(sum([i,j,k][σ]\u0026gt;[i,j,k][ρ] for σ in 1:3,ρ in 1:3 if σ\u0026lt;ρ) % 2)) # 计算逆序数。偶数取1，奇数取-1 for i in 1:3, j in 1:3, k in 1:3 ] ; # 四维evi-Civita记号 ε4= [ Sym((length(Set([i,j,k,l]))==4)* # 存在重复指标，取0 (-1)^(sum([i,j,k,l][σ]\u0026gt;[i,j,k,l][ρ] for σ in 1:4,ρ in 1:4 if σ\u0026lt;ρ) % 2)) # 计算逆序数。偶数取1，奇数取-1 for i in 1:4, j in 1:4, k in 1:4,l in 1:4 ] ; 对于更多指标的情况，只需要将这段代码多加一个指标，然后3改成4即可。\n关于逆变指标和协变指标  20200514追加\n 首先，作为符号而言 \\(\\textcolor{red}{A_1^2}\\)  ，在julia中会解释成 \\(A_1\\)  的2次幂。所以为了能在julia中有进行相关的计算，必须作些约定：\n 1）julia中的指标统统表示逆变指标【以逆变指标作为默认】，比如对应记作 \\(\\textcolor{red}{A}\\)  ； 2）假设存在度规； 3）所有协变指标的分量通过度规用逆变指标表出，对应记作 \\(\\textcolor{red}{Ai}\\)  。  举个例子【对应的julia代码见后，其中有详细注释】：\n\\[ \\boxed{P^2=P_\\mu P^\\mu,\\qquad W^2=W_\\mu W^\\mu}\\\\ W^\\mu=-\\frac{1}{2}\\varepsilon^{\\mu\\upsilon\\rho\\sigma}J_{\\upsilon\\rho}P_\\sigma\\quad W_\\mu=-\\frac{1}{2}\\varepsilon_{\\mu\\upsilon\\rho\\sigma}J^{\\upsilon\\rho}P^\\sigma\\\\ J^{\\upsilon\\rho}=\\begin{pmatrix}0 \u0026 -K^1 \u0026 -K^2 \u0026 -K^3\\\\K^1 \u0026 0 \u0026 J^3 \u0026 -J^2\\\\K^2 \u0026 -J^3 \u0026 0 \u0026 J^1\\\\K^3 \u0026 J^2 \u0026 -J^1 \u0026 0\\end{pmatrix}\\\\\\quad \\\\ \\textcolor{red}{计算：}{W_\\mu W^\\mu=????} \\]  using SymPy using LinearAlgebra # 三指标Levi-Civita记号 ε= [ Sym((length(Set([i,j,k]))==3)* (-1)^(sum([i,j,k][σ]\u0026gt;[i,j,k][ρ] for σ in 1:3,ρ in 1:3 if σ\u0026lt;ρ) % 2)) for i in 1:3, j in 1:3, k in 1:3 ] ; # 四指标evi-Civita记号 ε4= [ Sym((length(Set([i,j,k,l]))==4)* (-1)^(sum([i,j,k,l][σ]\u0026gt;[i,j,k,l][ρ] for σ in 1:4,ρ in 1:4 if σ\u0026lt;ρ) % 2)) for i in 1:4, j in 1:4, k in 1:4,l in 1:4 ] ; # 闵氏度规 η = sympy.diag(-1,1,1,1); # 庞加莱群的十个无穷小生成元 # E[1:4] 对应4个平移生成元 # E[5:7] 对应3个转动生成元 # E[8:10]对应3个伪转动生成元 @vars P0 P1 P2 P3 J1 J2 J3 K1 K2 K3 real=true E=[P0,P1,P2,P3,J1,J2,J3,K1,K2,K3]; # J: 两上标洛伦兹生成元矩阵 # Ji: 两下标洛伦兹生成元矩阵 J=[Sym(0) for i in 1:4 , j in 1:4]; J[2:4,2:4]=[sum(ε[k,i,j]*E[4+k] for k in 1:3) for i in 1:3,j in 1:3]; J[1,2:4]=-E[8:10]; J[2:4,1]=E[8:10]; Ji=[sum(J[μ,υ]*η[μ,ρ]*η[υ,σ] for μ in 1:4,υ in 1:4) for ρ in 1:4,σ in 1:4]; # P: 逆变平移生成元 # Pi: 协变平移生成元 P=E[1:4]; Pi = [sum(η[υ,σ]*P[σ] for σ in 1:4) for υ in 1:4]; # W: 上标Pauli–Lubanski矢量 # Wi: 下标Pauli–Lubanski矢量 W=Sym(-1//2)*[sum(ε4[μ,υ,ρ,σ]*Ji[υ,ρ]*Pi[σ] for υ in 1:4,ρ in 1:4,σ in 1:4) for μ in 1:4]; Wi=Sym(-1//2)*[sum(ε4[μ,υ,ρ,σ]*J[υ,ρ]*P[σ] for υ in 1:4,ρ in 1:4,σ in 1:4) for μ in 1:4]; # 两个Casimir不变算符 PP = sum(P[μ]*Pi[μ] for μ in 1:4); WW = sum(W[μ]*Wi[μ] for μ in 1:4); [PP,WW] .|\u0026gt; simplify @vars m ω real=true positive=true # 有质量：m \u0026gt; 0 [PP,WW] .|\u0026gt; (expr-\u0026gt;expr(P0=\u0026gt;m,P1=\u0026gt;0,P2=\u0026gt;0,P3=\u0026gt;0)) .|\u0026gt; simplify # 零质量：m = 0 [PP,WW] .|\u0026gt; (expr-\u0026gt;expr(P0=\u0026gt;ω,P1=\u0026gt;0,P2=\u0026gt;0,P3=\u0026gt;ω)) .|\u0026gt; simplify "}),a.add({id:132,href:'/notes/tags/%E9%BB%8E%E6%9B%BC%E6%9B%B2%E7%8E%87/',title:"黎曼曲率",content:""}),a.add({id:133,href:'/notes/tags/%E5%8F%98%E6%8D%A2%E7%BE%A4/',title:"变换群",content:""}),a.add({id:134,href:'/notes/docs/diffgeo/0069/',title:"李变换群",content:" 李变换群，就是李群作用于流形，这种“作用”其实就是变换，这种变换的集合构成的群。 就是李群的实现，或 李群的表示。\n 李变换群 前面已经接触过了单参微分同胚群   \\(\\phi:\\mathbb{R}\\times M \\to M\\)  。只需要把 \\(\\mathbb{R}\\)  换成李群 \\(G\\)  就得到了李变换群。\n考虑李群 \\(G\\)  和流形 \\(M\\)  ， \\(C^\\infty\\)  映射 \\(\\sigma:G\\times M\\to M\\)  成为上的一个李变换群，若\n 1） \\(\\forall g\\in G,\\quad \\sigma_g:M\\to M\\)  是微分同胚； 2） \\(\\sigma_{gh}=\\sigma_g \\circ \\sigma_h,\\quad \\forall g,h\\in G\\)  。   \\(\\sigma\\)  可诱导出另外两个映射(方框中)：\n\\[ \\sigma(g,p)=\\boxed{\\sigma_g(p)=\\sigma_p(g)},\\quad \\forall g\\in G, p\\in M \\]  条件2）保证了，从李群 \\(G=\\{g\\}\\)  到李变换群 \\(\\{\\sigma_g:M\\to M|g\\in G\\}\\)  的自然映射 \\(g\\mapsto\\sigma_g\\)  是一个同态映射。这个同态映射成为 \\(G\\)  的一个实现，则称 \\(M\\)  为实现空间。 如果这个同态是同构，则称 \\(G\\)  为忠实实现。\n可以说，李群 \\(G\\)  决定了流形 \\(M\\)  上的一个李变换群。\n单参微分同胚群 特别地，李群 \\(G\\)  的每个单参子群决定了流形 \\(M\\)  上的一个单参微分同胚群。\n如图，李群 \\(G\\)  的李代数 \\(\\mathscr{G}\\)  的一个元素 \\(A_e\\)  唯一确定一个单参数子群 \\(\\gamma(t)\\)  。在流形 \\(M\\)  上任意选一点 \\(p\\)  ，在单参子群 \\(\\gamma\\in G\\)  的作用下，得到流形 \\(M\\)  上的一个单参微分同胚群 \\((\\sigma_p\\circ\\gamma) (t)\\)  。 进而在流形 \\(M\\)  的 \\(p\\)  点确定唯一的矢量 \\(\\xi_p\\)  ： \\[ \\xi_p=\\left.\\frac{d}{dt}\\right|_{t=0}\\sigma_p(\\gamma(t))=\\sigma_{p*}\\left.\\frac{d}{dt}\\right|_{t=0}\\gamma(t)=\\sigma_{p*}A_e \\]  由此可见：\n 对于给定的李变换群 \\(\\sigma:G\\times M\\to M\\)  ，李群 \\(G\\)  的李代数 \\(\\mathscr{G}\\)  的每个元素 \\(A_e\\)  对应流形 \\(M\\)  上的一个 \\(C^\\infty\\)  矢量场 \\(\\xi\\)  。 故有映射 \\(\\chi:\\mathscr{G}\\to \\{\\xi\\}\\)   Killing矢量场 进一步考虑一个特殊情况：带度规流形 \\((M,g_{ab})\\)  ，而李群 \\(G\\)  是 \\(M\\)  的等度规群，即李变换群 \\(\\sigma:G\\times M\\to M\\)  的每个 \\(\\sigma_g:M\\to M\\)  都是等度规映射。\n这时，李群 \\(G\\)  的每个单参子群 \\(\\gamma(t)\\)  产生的单参微分同胚群 \\(\\{\\sigma_{\\gamma(t)}|t\\in \\mathbb{R}\\}\\)  升格为单参等度规群。其轨道切矢 \\(\\xi\\)  就是 \\((M,g_{ab})\\)  上的Killing矢量场。即，\n\\[ \\chi:\\mathscr{G}\\to \\mathscr{K} \\]  Killing矢量场，在对易子为李括号下，也成为李代数。 事实上，映射 \\(\\chi:\\mathscr{G}\\to \\mathscr{K}\\)  对李括号保到只相差一个符号的程度：\n\\[ \\chi([A_e,B_e])=-[\\chi(A_e),\\chi(B_e)],\\quad \\forall A_e,B_e\\in \\mathscr{G} \\]  于是有必要映入新的映射 \\(\\psi:\\mathscr{G}\\to \\mathscr{K}\\)  ，能够保李括号：\n\\[ \\psi(A_e)=-\\chi(A_e),\\quad A_e\\in \\mathscr{G}\\\\ \\psi[A_e,B_e]=[\\psi(A_e),\\psi(B_e)],\\quad \\forall A_e,B_e\\in \\mathscr{G} \\]  进而保证了，映射 \\(\\psi:\\mathscr{G}\\to \\mathscr{K}\\)  是李代数同态映射。\n 如果的每个Killing矢量场都是完备矢量场，则每个都能产生单参等度规群，进而等度规群 \\(G\\)  （因而其李代数 \\(\\mathscr{G}\\)  ）与 \\(\\mathscr{K}\\)  的维度相同，于是 \\(\\psi:\\mathscr{G}\\to \\mathscr{K}\\)  就是李代数同构。\n \u0026ldquo;另类\u0026quot;Killing矢量场 前面谈的是基于等度规映射Killing矢量场。并且在此基础上有三条性质：\n 1） \\(\\mathscr{K}=\\{\\xi\\}\\)  是矢量空间； 2）矢量场对易子作为李括号使得 \\(\\mathscr{K}\\)  成为李代数； 3）映射 \\(\\chi:\\mathscr{G}\\to \\mathscr{K}\\)  在相差一个负号的意义下“保李括号”。  但我们发现，即使不要求等度规，矢量场集合 \\(\\{\\xi\\}\\)  也能满足这三条。所以不妨也可直接将 \\(\\{\\xi\\}\\)  定义称Killing矢量场，称之为流形 \\(M\\)  上关于李群 \\(G\\)  的Killing矢量场。\n以后说到“Killing矢量场”，如果没有加定语说明，表示原生意义上的Killing矢量场；如果加了如上定语约束，则是这里的“另类”Killing矢量场。\n当然，如果对映射 \\(\\sigma:G\\times M\\to M\\)  不加要求， \\(\\dim \\mathscr{K}\\)  可能小于 \\(\\dim \\mathscr{G}\\)  。\n但是，如果映射 \\(\\sigma:G\\times M\\to M\\)  是有效的，即\n\\[ \\sigma_g(p)=p \\quad \\Rightarrow \\quad g=e,\\quad \\forall p \\in M \\]  (这个条件等价于 \\(g\\mapsto \\sigma_g\\)  是一一映射， 还等价于 \\(G\\)  在 \\(M\\)  上的实现是忠实的)， 那么 \\(\\chi:\\mathscr{G}\\to \\mathscr{K}\\)  是同构映射，进而 \\(\\psi:\\mathscr{G}\\to \\mathscr{K}\\)  是李代数同构。\n计算李代数结构常数 利用基于等度规映射的Killing矢量场计算等度规群的李代数的结构常数。\n这里部分步骤，我可以用Julia来计算， 以后有类似的更复杂的，可以复制这段代码，作点修改就可以计算了。\n【范例目标】：3维欧氏空间 \\((\\mathbb{R}^3,\\delta_{ab})\\)  中的2维球面 \\((S^2,h_{ab})\\)  。\n首先，这个球面的等度规群是三维空间转动群 \\(G=\\mathrm{SO}(3)\\)  。\n其次，计算这个球面的诱导度规 \\(h_{ab}\\)  :\nusing SymPy @vars θ φ real=true # 坐标变换 X=[sin(θ)*cos(φ),sin(θ)*sin(φ),cos(θ)] Q=[θ,φ] # 三维欧氏度规矩阵g g = sympy.eye(3) .* [1,1,1] # 计算二维球面上的诱导度规矩阵h，及其逆hi M=[diff(x,q) for x in X, q in Q] h= simplify.(sympy.Matrix(M\u0026#39;*g*M)) hi = inv(h) h 计算结果： \\(\\begin{bmatrix}1 \u0026 0 \\\\ 0 \u0026 \\sin^{2} θ\\end{bmatrix}\\)  第三步：根据度规计算克氏符，然后列出所有Killing方程：\n# 待求的Killing矢量场的分量 ξ = SymFunction(\u0026#34;ξ^1,ξ^2\u0026#34;) # 根据度规计算克氏符 Γ = sum([(1//2)*hi[σ,ρ]*(diff(h[μ,ρ],Q[υ])+ diff(h[υ,ρ],Q[μ])-diff(h[μ,υ],Q[ρ])) for μ in 1:2,υ in 1:2 ,σ in 1:2] for ρ in 1:2) # 列出所有独立Killing方程组 eqs = [(0⩵diff(sum(h[υ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2),Q[μ])+ diff(sum(h[μ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2),Q[υ])- 2*sum(Γ[μ,υ,σ]*sum(h[σ,ρ]*ξ[ρ](θ,φ) for ρ in 1:2) for σ in 1:2)) for μ in 1:2,υ in 1:2 if μ ≤ υ ] 结果是： \\(\\begin{bmatrix}0 = 2 \\frac{\\partial}{\\partial θ} \\operatorname{ξ^{1}}{\\left (θ,φ \\right )}\\\\0 = \\sin^{2}{\\left (θ \\right )} \\frac{\\partial}{\\partial θ} \\operatorname{ξ^{2}}{\\left (θ,φ \\right )} + \\frac{\\partial}{\\partial φ} \\operatorname{ξ^{1}}{\\left (θ,φ \\right )}\\\\0 = 2 \\operatorname{ξ^{1}}{\\left (θ,φ \\right )} \\sin{\\left (θ \\right )} \\cos{\\left (θ \\right )} + 2 \\sin^{2}{\\left (θ \\right )} \\frac{\\partial}{\\partial φ} \\operatorname{ξ^{2}}{\\left (θ,φ \\right )}\\end{bmatrix}\\)  第四步，求解这组方程的通解。\n首先通过观察，很容易得到第一组特解：\n\\[ (\\xi_3)^a=-\\left(\\frac{\\partial}{\\partial \\varphi}\\right)^a, \\quad \\xi_3=(0,-1) \\]  然后，由方程１和３有 \\(\\xi^1(\\theta,\\varphi)=f(\\varphi),\\quad \\xi^2(\\theta,\\varphi)=g(\\theta)h(\\varphi)\\)  ，回代方程3，并分离变量得：\n\\[ -\\frac{f(\\varphi)}{h'(\\varphi)}=\\frac{g(\\theta)}{\\cot(\\theta)}=C \\]  当 \\(C=0\\)  ，只有全0平凡解。所以必须 \\(C\\ne0\\)  ，于是有：\n\\[ f(\\varphi)=-C \\ h'(\\varphi),\\quad g(\\theta)=C \\cot(\\theta) \\]  回代方程2得：\n\\[ h''(\\varphi)+h(\\varphi)=0 \\]  得到 \\(h(\\varphi)\\)  得两个特解: \\(\\sin(\\varphi),\\quad \\cos(\\varphi)\\)  。\n最后，回代并整理得到剩余两个特解：\n\\[ (\\xi_2)^a=-\\cos\\theta \\left(\\frac{\\partial}{\\partial \\theta}\\right)^a+\\cot\\theta \\sin\\theta\\left(\\frac{\\partial}{\\partial \\varphi}\\right)^a, \\quad \\xi_2=(-\\cos\\theta,\\cot\\theta\\sin\\theta)\\\\ (\\xi_1)^a=\\sin\\theta \\left(\\frac{\\partial}{\\partial \\theta}\\right)^a+\\cot\\theta \\cos\\theta\\left(\\frac{\\partial}{\\partial \\varphi}\\right)^a, \\quad \\xi_1=(\\sin\\theta,\\cot\\theta\\cos\\theta) \\]  这三个特解，可选作Killing矢量场得一组基矢。\n第五步，获得李代数得结构常数表达式 （只要写出，上面这三个基矢量的三组对易子即可）\n\\[ [\\xi_1,\\xi_2]^a=(\\xi_3)^a,\\quad [\\xi_2,\\xi_3]^a=(\\xi_1)^a,\\quad [\\xi_3,\\xi_1]^a=(\\xi_2)^a \\] "}),a.add({id:135,href:'/notes/docs/diffgeo/0068/',title:"常用李群及其李代数",content:" 一般线性群   \\(GL(m)\\)  ，全体可逆线性映射的集合。\n正交群 \\(O(m)\\)  ，正定度规下，全体保度规线性映射的集合。【正定度规下，保度规 \\(\\Longrightarrow\\)  保内积。】\n洛伦兹群 \\(O(1,3)\\)  ，正交归一基底下度规矩阵是 \\(\\mathrm{diag}(-1,1,1,1)\\)  时，全体保度规线性映射的集合。\n酉群 \\(U(m)\\)  ，就是复数域中的全体保内积线性算符（即酉算符）的集合。\n 一般线性群 考虑 \\(m\\)  维矢量空间 \\(V\\)  ， \\(\\mathrm{GL}(m)\\)  代表 \\(V\\to V\\)  的全体可逆线性映射的集合，以映射复合作为群乘法，恒等映射即为恒等元，易见 \\(\\mathrm{GL}(m)\\)  构成李群。\n因为 \\(V\\to V\\)  的线性映射就是 \\(V\\)  上的 \\((1,1)\\)  型张量，所以\n\\[ \\mathrm{GL}(m)=\\{T\\in \\mathscr{T}_V(1,1)\\} \\]  为 \\(V\\)  取定一个基底（及其对偶基底），得到群元张量 \\(T\\)  的分量，即可逆矩阵（ \\(m^2\\)  个分量），此时单位矩阵为恒等元。于是得到与上面表示相互同构的另一个表示：\n\\[ \\mathrm{GL}(m)=\\{A\\in M(m,\\mathbb{R})| \\det A\\ne 0\\} \\]  其中， \\(M(m,\\mathbb{R})\\)  代表 \\(m\\times m\\)  实矩阵。\n注意， \\(\\mathrm{GL}(m,\\mathbb{R})\\)  是非紧且非连通李群，取其包含恒等元的一个连通李子群，记作：\n\\[ \\mathrm{GL}^+(m)=\\{A\\in M(m,\\mathbb{R})| \\det A \\gt 0\\} \\]   \\(\\mathrm{GL}(m)\\)  的李代数 \\(\\mathscr{G\\!L}(m)\\)  ，与全体实矩阵构成的矢量空间同构，即：\n\\[ \\mathscr{G\\!L}(m)=M(m,\\mathbb{R}) \\]  在这里，指数数映射具有显式的展开形式:\n\\[ \\exp(A)=I+A+\\frac{1}{2!}A^2+\\frac{1}{3!}A^3+\\dots,\\quad \\forall A\\in \\mathscr{G\\!L}(m) \\]  正交群 如果考虑带正定度规的矢量空间 \\((V,g_{ab})\\)  ，可以在 \\(\\mathrm{GL}(m)\\)  的基础上提出保度规的要求，即要求线性映射 \\(Z:V\\to V\\)  保度规(方框中的要求)： \\[ \\begin{aligned}\u0026\\boxed{g_{ab}(Z^a_{\\ \\ c}v^c)(Z^b_{\\ \\ d}u^d)=g_{cd}v^c u^d,\\quad \\forall v,u\\in V} \\\\ \\Longleftrightarrow \u0026 g_{ab}Z^a_{\\ \\ c}Z^b_{\\ \\ d}=g_{cd}\\quad \\text{【因为}v,u\\text{选择的任意性】} \\end{aligned} \\]  这类线性映射的集合构成的李群，称之为正交群 \\(O(m)\\)  ：\n\\[ O(m)=\\{Z^a_{\\ \\ b}\\in \\mathscr{T}_V(1,1)| g_{ab}Z^a_{\\ \\ c}Z^b_{\\ \\ d}=g_{cd}\\} \\]  为 \\((V,g_{ab})\\)  取定一个正交归一基底（及其对偶基底），于是：\n\\[ \\begin{aligned}\u0026g_{ab}Z^a_{\\ \\ c}Z^b_{\\ \\ d}=g_{cd}\\\\ \\Longrightarrow \u0026 \\delta_{\\sigma\\rho}=\\delta_{\\mu\\upsilon}Z^\\mu_{\\ \\ \\sigma}Z^\\upsilon_{\\ \\ \\rho}=(Z^T)^{\\ \\ \\mu}_\\sigma\\delta_{\\mu\\upsilon}Z^\\upsilon_{\\ \\ \\rho}\\quad \\text{【因为正交归一基底】}\\\\ \\Longleftrightarrow \u0026 I=Z^T I Z = Z^T Z \\quad \\text{【写成矩阵形式】} \\end{aligned} \\]  于是， \\(O(m)\\)  可写成同构的形式：\n\\[ O(m)=\\{Z\\in \\mathrm{GL}(m)| Z^T Z = I\\} \\]  其中， \\(I\\)  是单位矩阵， \\(Z\\)  则是正交矩阵。 \\(O(m)\\)  是 \\(\\mathrm{GL}(m)\\)  的最大紧致李子群。\n特别地有： \\[ O(1)=\\{1\\}\\cup\\{-1\\} \\]  \\[ O(2)=\\left\\{\\begin{bmatrix} \\cos\\alpha \u0026 -\\sin\\alpha \\\\ \\sin\\alpha \u0026 \\cos\\alpha \\end{bmatrix}|\\alpha\\in \\mathbb{R}\\right\\}\\cup\\left\\{\\begin{bmatrix} \\cos\\alpha \u0026 \\sin\\alpha \\\\ \\sin\\alpha \u0026 -\\cos\\alpha \\end{bmatrix}|\\alpha\\in \\mathbb{R}\\right\\} \\]  由于 \\(\\det Z=\\pm1\\)  ， \\(O(m)\\)  注定也是非连通的。 把包含恒等元的分支记作 \\(\\mathrm{SO}(m)\\)  ：\n\\[ \\mathrm{SO}(m)=\\{Z\\in O(m)| \\det A=1 \\} \\]  称为特殊正交群。 最常用的是三维空间转动群 \\(SO(3)\\)  。\n正交群 \\(O(m)\\)  和其李子群 \\(\\mathrm{SO}(m)\\)  的有相同的李代数 \\(\\mathscr{O}(m)\\)  ：\n\\[ \\mathscr{O}(m)=\\{A\\in M(m,\\mathbb{R})| A^T = -A \\}\\\\ \\dim O(m)= \\dim \\mathscr{O}(m)=\\frac{1}{2}m(m-1) \\]  洛伦兹群 和正交群 \\(O(3)\\)  的差别：不再要求是正定度规，但要求度规 \\(g_{ab}\\)  在正交归一基底下的度规矩阵是 \\(\\mathrm{diag}(-1,1,1,1)\\)  。\n类似 \\(O(3)\\)  可写出 \\(O(1,3)\\)  ：\n1） 线性映射集合视角\n\\[ O(1,3)=\\{\\Lambda^a_{\\ \\ b}\\in \\mathscr{T}_V(1,1)| g_{ab}\\Lambda^a_{\\ \\ c}\\Lambda^b_{\\ \\ d}=g_{cd}\\} \\]  2）正交归一基底下矩阵集合视角\n\\[ O(1,3)=\\{\\Lambda\\in \\mathrm{GL}(m+1)| \\Lambda^T \\eta \\Lambda = \\eta\\},\\quad \\eta\\overset{\\Delta}{=}\\mathrm{diag}(-1,1,1,1) \\]  先看更简单的情况 \\(O(1,1)\\)  ：\n\\[ \\begin{aligned}O(1,1)\u0026=O^\\uarr_+(1,1)\\cup O^\\uarr_-(1,1)\\cup O^\\darr_-(1,1)\\cup O^\\darr_+(1,1)\\\\ O^\\uarr_+(1,1)\u0026= \\left\\{\\begin{bmatrix} \\mathrm{ch} \\lambda \u0026 -\\mathrm{sh}\\lambda \\\\ -\\mathrm{sh}\\lambda \u0026 \\mathrm{ch} \\lambda \\end{bmatrix}|\\lambda\\in \\mathbb{R}\\right\\},\\quad \\det \\Lambda=1,\\Lambda^0_{\\ \\ 0}\\ge 1\\\\ O^\\uarr_-(1,1)\u0026=\\left\\{\\begin{bmatrix} \\mathrm{ch}\\lambda \u0026 -\\mathrm{sh}\\lambda \\\\ \\mathrm{sh}\\lambda \u0026 -\\mathrm{ch}\\lambda \\end{bmatrix}|\\lambda\\in \\mathbb{R}\\right\\},\\quad \\det \\Lambda=-1,\\Lambda^0_{\\ \\ 0}\\ge 1\\\\ O^\\darr_-(1,1)\u0026=\\left\\{\\begin{bmatrix} -\\mathrm{ch}\\lambda \u0026 \\mathrm{sh}\\lambda \\\\ -\\mathrm{sh}\\lambda \u0026 \\mathrm{ch}\\lambda \\end{bmatrix}|\\lambda\\in \\mathbb{R}\\right\\},\\quad \\det \\Lambda=-1,\\Lambda^0_{\\ \\ 0}\\le -1\\\\ O^\\darr_+(1,1)\u0026=\\left\\{\\begin{bmatrix} -\\mathrm{ch}\\lambda \u0026 \\mathrm{sh}\\lambda \\\\ \\mathrm{sh}\\lambda \u0026 -\\mathrm{ch}\\lambda \\end{bmatrix}|\\lambda\\in \\mathbb{R}\\right\\},\\quad \\det \\Lambda=1,\\Lambda^0_{\\ \\ 0}\\le -1\\end{aligned} \\]  注意: 其中只有 \\(O^\\uarr_+(1,1)\\)  是李群 \\(O(1,1)\\)  的李子群。\n类似地，洛伦兹群 \\(L=O(1,3)\\)  ，也类似存在4个连通分支，每个分支各存在一个特殊元素：\n\\[ \\begin{aligned}\u0026 L\\text{的恒等元} \u0026I\u0026=\\mathrm{diag}(1,1,1,1)\u0026\\in\u0026 L^\\uarr_+\\\\ \u0026 L\\text{的空间反射元} \u0026r_s\u0026=\\mathrm{diag}(1,-1,-1,-1)\u0026\\in\u0026 L^\\uarr_- = r_sL^\\uarr_+ \\\\ \u0026 L\\text{的时间反射元} \u0026r_t\u0026=\\mathrm{diag}(-1,1,1,1)\u0026\\in\u0026 L^\\darr_- = r_tL^\\uarr_+ \\\\ \u0026 L\\text{的时空反演元}\u0026 i_{ts}\u0026=r_t r_s=-I\u0026\\in\u0026 L^\\darr_+ = i_{ts}L^\\uarr_+\\end{aligned} \\]  其中只有包含恒等元的分支 \\(L^\\uarr_+\\)  构成李群，是 \\(L\\)  的李子群，称为固有洛伦兹群，是6维连通流形，流形结构为 \\(\\mathbb{R}^3\\times SO(3)\\)  。\n同 \\(O(3)\\)  类似，洛伦兹群 \\(L=O(1,3)\\)  及其李子群 \\(L^\\uarr_+\\)  有相同的李代数 \\(\\mathscr{O}(1,3)\\)  :：\n\\[ \\mathscr{O}(1,3)=\\{A\\in M(4,\\mathbb{R})| A^T \\eta A = \\eta \\}\\\\ \\dim O(1,3) = \\dim \\mathscr{O}(1,3) = \\dim \\mathscr{O}(4)=6 \\]  酉群 如果把实矢量空间扩展称复矢量空间，那么 \\(\\mathrm{GL}(m)\\)  对应 \\(\\mathrm{GL}(m,\\mathbb{C})\\)  ，这个新群是连通李群（不存在多分支）。\n我们知道正交群 \\(O(m)\\)  ，有保度规的要求，进而必然保内积。而酉群 \\(U(m)\\)  ，就是这种要求保内积的 \\(\\mathrm{GL}(m,\\mathbb{C})\\)  子群。但是复矢量空间的内积只对第二个矢量是线性的，对第一个矢量则为共轭线性。即：\n\\[ (g,f)=\\overline{(f,g)},\\quad \\forall f,g\\in V \\]  很明显，当复矢量空间 \\(V\\)  退化成实矢量空间时，内积对所作用的两个矢量都是线性的。\n类似实矢量空间，线性映射 \\(\\eta:V\\to \\mathbb{C}\\)  就是复矢量空间 \\(V\\)  对应的一个对偶矢量，所有对偶矢量的集合就是 \\(V\\)  的对偶矢量空间 \\(V^*\\)  。据此 \\(V\\)  上的每个线性映射（算符） \\(A:V\\to V\\)  可以诱导出 \\(V^*\\)  上的一个线性映射（算符） \\(A^*:V^*\\to V^*\\)  ：\n\\[ \\begin{aligned}A^*:\u0026V^*\\to V^* \\\\ \u0026\\eta \\mapsto A^*\\eta \\\\ \u0026 (A^*\\eta)(f)\\overset{\\Delta}{=}\\eta(A f),\\quad \\forall f\\in V \\end{aligned} \\]   \\(A^*\\)  称之为 \\(A\\)  的对偶算符。这是一个线性算符，并且 \\(A^*\\)  和 \\(A\\)  的对应关系也是线性的。\n此外，我们还知道有限维矢量空间 \\(V\\)  和其对偶矢量空间 \\(V^*\\)  是相互同构的，记作 \\(\\phi:V\\to V^*\\)  ，这是一个反线性映射。 进而 \\(V\\)  上线性算符 \\(A\\)  的对偶算符 \\(A^*\\)  又可自然诱导出 \\(V\\)  上的一个线性算符 \\(A^\\dagger:V \\to V\\)  ，如图：\n \\(A^\\dagger\\)  称之为 \\(A\\)  的伴随算符。这是一个线性算符，并且 \\(A^\\dagger\\)  和 \\(A\\)  的对应关系则是反线性的(共轭线性)。\n最后，借助对偶矢量作用于矢量得实数得特点，将内积定义为：\n\\[ (f,g)\\overset{\\Delta}{=}\\eta_f g,\\quad \\quad \\forall f,g\\in V \\]  进而有 \\(\\boxed{(f,Ag)=(A^\\dagger f,g)}\\)  ，因为：\n\\[ \\begin{aligned}(f,Ag)\u0026=n_f(Ag)\\quad \\text{【内积定义】}\\\\ \u0026=(A^*\\eta_f)(g)\\quad \\text{【对偶算符定义】}\\\\ \u0026=\\eta_h(g)=(h,g)\\quad \\text{【见上图标注,及内积定义】}\\\\ \u0026=(A^\\dagger f,g)\\quad \\text{【见上图标注】}\\end{aligned} \\]  此外， \\(\\boxed{(f,Ag)=(Bf,g)\\quad \\Rightarrow \\quad B=A^\\dagger}\\)  ，因为：\n\\[ \\begin{aligned}\u00260=(Bf,g)-(A^\\dagger f,g)=(Bf-A^\\dagger f,g),\\quad \\forall f,g\\in V\\\\ \\Longrightarrow \u0026 0=(Bf-A^\\dagger f,Bf-A^\\dagger f)\\quad \\text{因为}g\\text{可任意选择}\\\\ \\Longrightarrow \u00260=Bf-A^\\dagger f\\quad \\text{相同矢量内积为0的充要条件}\\\\ \\Longrightarrow \u0026B=A^\\dagger \\quad \\text{因为}f\\text{可任意选择}\\end{aligned} \\]  有上面的准备，下面就容易了。现在可以谈保内积的线性算符 \\(U\\)  ，称之为酉算符（或 幺正算符）：\n\\[ (Uf,Ug)=(f,g),\\quad \\forall f,g\\in V \\]  算符 \\(U\\)  为酉算符的充要条件是： \\(U^\\dagger U=\\delta\\)  。其中， \\(\\delta\\)  是恒等算符。\n为 \\(V\\)  选择一个正交归一基底 \\(\\{e_i\\}\\)  ， \\(V\\)  上任意算符 \\(A\\)  可用矩阵表示:\n\\[ A_{ij}=(e_i,A e_j)=(A^\\dagger e_i,e_j)=\\overline{(e_j,A^\\dagger e_i)}=\\overline{(A^\\dagger)_{ji}} \\]  即：\n\\[ A^\\dagger = \\overline{A^T} \\]  进而，算符 \\(U\\)  为酉算符的充要条件的矩阵形式： \\(U^{-1}=U^\\dagger=\\overline{U^T}\\)  。 对应的矩阵 \\(U\\)  称为酉矩阵（或 幺正矩阵）。\n如果 \\(U\\)  为酉矩阵，那么：\n\\[ \\det U=e^{i\\varphi},\\quad \\varphi\\in \\mathbb{R},\\quad \\text{即} \\left|\\det U\\right|=1 \\]  所以，酉群 \\(U(m)\\)  可定义为：\n\\[ U(m)\\overset{\\Delta}{=}\\{U\\in \\mathrm{GL}(m,\\mathbb{C})| U^\\dagger U = I\\} \\]  酉群 \\(U(m)\\)  是紧致的连通流形。\n \\(A\\)  是厄米矩阵，若 \\(A^\\dagger = A\\)  ； \\(A\\)  是反厄米矩阵，若 \\(A^\\dagger = -A\\)  ；\n酉群 \\(U(m)\\)  的李代数 \\(\\mathscr{U}(m)\\)  ：\n\\[ \\mathscr{U}(m)=\\{A\\in\\mathscr{G\\!L}(m,\\mathbb{C})|A^\\dagger=-A\\}\\\\ \\dim U(m)=\\dim \\mathscr{U}(m)=m^2 \\]  特殊酉群 \\(\\mathrm{SU}(m)\\)  可定义为：\n\\[ \\mathrm{SU}(m)\\overset{\\Delta}{=}\\{U\\in U(m)| \\det U=1 \\} \\]  特殊酉群 \\(\\mathrm{SU}(m)\\)  的李代数 \\(\\mathscr{S\\!U}(m)\\)  ：\n\\[ \\mathscr{S\\!U}(m)=\\{A\\in\\mathscr{U}(m)|\\mathrm{tr} A=0\\}\\\\ \\dim \\mathrm{SU}(m)=\\dim \\mathscr{S\\!U}(m)=m^2-1 \\] "}),a.add({id:136,href:'/notes/tags/%E6%AD%A3%E4%BA%A4%E7%BE%A4/',title:"正交群",content:""}),a.add({id:137,href:'/notes/tags/%E6%B4%9B%E4%BC%A6%E5%85%B9%E7%BE%A4/',title:"洛伦兹群",content:""}),a.add({id:138,href:'/notes/tags/%E9%85%89%E7%BE%A4/',title:"酉群",content:""}),a.add({id:139,href:'/notes/tags/%E6%8C%87%E6%95%B0%E6%98%A0%E5%B0%84/',title:"指数映射",content:""}),a.add({id:140,href:'/notes/tags/%E6%9D%8E%E6%8B%AC%E5%8F%B7/',title:"李括号",content:""}),a.add({id:141,href:'/notes/docs/diffgeo/0016/',title:"李群李代数",content:" 李群是分析流形对称性的重要工具。\n从李群   \\(G\\)  自身来看，李群 \\(G\\)  也是一个流形。\n李群 \\(G\\)  作为流形在恒等元 \\(e\\)  有切空间 \\(V_e\\)  ，在这切空间上定义双线性映射的李括号，以此作为切空间上的乘法，进而定义了李代数。\n通过指数映射，可以在李群的李代数和李群自身之间建立关系。\n李代数的结构张量，则是李括号双线性特征的显式表现。\n符号说明：由于本节讨论的矢量场，并不涉及具体指标。所以简单用 \\(A\\)  代表矢量场 \\(A^a\\)  ，用 \\(A_g\\)  代表点 \\(g\\)  的矢量。\n 李群 李群，既是群也是流形。\n 从群的角度看，李群必须满足群乘法封闭性、群乘法结合律、存在恒等元 \\(e\\)  、存在逆元。 李群 \\(G\\)  的李子群 \\(H\\)  ，不仅仅是 \\(G\\)  的子群，还必须同时是 \\(G\\)  的子流形。 李群同态 \\(\\rho:G\\to G'\\)  ，和群同态一致，即 \\(\\rho(a b)=\\rho(a)\\rho(b),\\quad \\forall a,b\\in G\\)  。 李群同构 \\(\\rho:G \\overset{\\mathrm{diff.}}{\\longleftrightarrow} G'\\)  ，和群同构一致，即一一到上的李群同态。考虑李群连续性，这个映射实际上也是微分同胚。  左平移 李群的特定元素 \\(g\\in G\\)  给出的左平移 \\(L_g\\)  ，\n\\[ \\boxed{\\begin{aligned}L_g:\u0026G\\to G\\\\ \u0026h\\mapsto L_g(h)\\overset{\\Delta}{=}gh\\end{aligned}} \\]   左平移是一个微分同胚映射，也是李群 \\(G\\)  上的一个自同构；  \\(L_{gh}=L_g\\circ L_h\\)  。  左平移 \\(L_g\\)  可以把曲线映射到曲线（如图），进而诱导出对矢量场 \\(A\\)  的推前映射 \\(L_{g*}\\)  ，比如： \\(L_{g*}A_e=A_g\\)  。这个推前映射 \\(L_{g*}\\)  也看成对矢量场左平移。\n特别地，称矢量场 \\(A\\)  是左不变的，若 \\(L_{g*}A=A,\\quad \\forall g\\in G\\)  。\n 左不变矢量场必然是 \\(C^\\infty\\)  矢量场。 定义等价于： \\(\\boxed{(L_{g*}A)_{gh}=L_{g*}A_h}=A_{gh},\\quad \\forall g,h \\in G\\)  。【结合上图示意：方框中等式左边（图中紫色）的意思是对矢量场 \\(A\\)  进行左平移映射（红虚线）后再 \\(gh\\)  处取值；方框中等式右边（图中蓝色）则是直接对矢量 \\(A_h\\)  进行左平移映射；这两者意思是一样的。方框外面的等号则源自左不变的定义】   李群 \\(G\\)  上全体左不变矢量场的集合 \\(\\mathscr{L}\\)  构成矢量空间，并且与 \\(G\\)  在恒等元 \\(e\\)  的切空间 \\(V_e\\)  同构。\n  因为左不变的要求，本质就是把一个左不变矢量场，\u0026ldquo;压缩认同\u0026quot;为一个矢量，具体选择哪个矢量随意，所以不妨选恒等元处的矢量。 若把所有左不变矢量场都在恒等元处选一个代表之，于是上面的结论。  李代数 李括号，矢量空间 \\(V\\)  上的双线性映射 \\([,]:V\\times V\\to V\\)  ：，满足\n 反称性： \\([A,B]=-[B,A],\\quad \\forall A,B\\in V\\)  ； 雅可比恒等式： \\([A,[B,C]]+[C,[A,B]]+[B,[C,A]]=0,\\quad \\forall A,B,C\\in V\\)    李代数，就是定义了李括号的矢量空间。\n 李代数同态，自然是要保李括号的。 李代数同构，就是一一到上的李代数同态。 阿贝尔李代数，李括号始终为0的李代数。 李代数 \\(\\mathscr{G}\\)  的李子代数 \\(\\mathscr{H}\\)  ，就是满足李括号封闭性子空间 \\(\\mathscr{H}\\subset \\mathscr{G}\\)  。  根据 \\(\\phi_*[u,v]^a=[\\phi_*u,\\phi_*v]^a\\)  和左不变定义易知：两个左不变矢量场组成的李括号依然是左不变矢量场。 所以有：\n 李群 \\(G\\)  上全体左不变矢量场的集合 \\(\\mathscr{L}\\)  是李代数（以矢量场对易子为李括号）。\n 有了矢量场对易子定义的矢量场李括号, 那么可在恒等元 \\(e\\in G\\)  切空间 \\(V_e\\)  上定义矢量李括号： \\[ [A_e,B_e]\\overset{\\Delta}{=}[A,B]_e,\\quad \\forall A_e,B_e\\in V_e \\]  有了恒等元切空间上的矢量李括号，可以证明 \\(V_e\\)  成为李代数，称为李群 \\(G\\)  的李代数，记作 \\(\\mathscr{G}\\)  。\n 李群 \\(G\\)  和 \\(G'\\)  的李代数分别是 \\(\\mathscr{G}\\)  和 \\(\\mathscr{G}'\\)  ，那么李群同态 \\(\\rho:G\\to G'\\)  ，在恒等元 \\(e\\in G\\)  所诱导的前推映射 \\(\\rho_*:\\mathscr{G}\\to \\mathscr{G}'\\)  是李代数同态。\n如果 \\(H\\)  是 \\(G\\)  的李子群，那么 \\(\\mathscr{H}\\)  必然是 \\(\\mathscr{G}\\)  李子代数。\n 单参子群 李群 \\(G\\)  上的一条曲线 \\(\\gamma\\)  ，如果 \\(\\gamma(s+t)=\\gamma(s)\\gamma(t),\\forall s,t\\in\\mathbb{R}\\)  ，那么 \\(\\gamma\\)  是 \\(G\\)  的单参子群。\n 单参子群 \\(\\gamma:\\mathbb{R}\\to G\\)  是从 \\(\\mathbb{R}\\)  到 \\(G\\)  的李群同态映射； 李群 \\(G\\)  的单参子群 \\(\\gamma\\)  必过恒等元 \\(e\\)  ； 不变矢量场的每条不可延积分曲线的参数取遍算 \\(\\mathbb{R}\\)  ； 单参数子群是左不变矢量场经过 \\(e\\)  的不可延积分曲线，反之亦然。  最后一条结论表明：左不变矢量场 与 单参子群 有一一对应的关系。【因为：首先，李群 \\(G\\)  恒等元处切空间 \\(V_e\\)  和 左不变矢量场集合 \\(\\mathscr{L}\\)  是一一对应的；其次，李群 \\(G\\)  的李代数 \\(\\mathscr{G}\\)  （= \\(V_e\\)  ）的每个元素 \\(A_e\\in \\mathscr{G}\\)  ​可生成一个单参数子群 \\(\\gamma(t)\\)  。】于是， \\(\\mathscr{G}\\)  的每个元素称为一个（无限小）生成元。\n指数映射 如图，利用“ \\(e\\)  点的一个矢量 \\(A_e\\)  决定唯一的单参子群”这一事实，可以定义指数映射。【注意：上图虚线连接的两个 \\(e\\)  点是重合的】\n李群 \\(G\\)  的李代数 \\(\\mathscr{G}\\)  到 \\(G\\)  指数映射是： \\[ \\boxed{\\begin{aligned}\\exp: \\mathscr{G} \u0026\\to G \\\\ A_e \u0026\\mapsto \\exp(A_e)\\overset{\\Delta}{=}\\gamma(1) \\\\ \\\\ \u0026 其中\\gamma\\text{是与}A_e\\text{对应的单参子群} \\end{aligned}} \\]  可以证明：\n\\[ \\boxed{\\exp(s A_e)=\\gamma(s)},\\quad \\forall s\\in\\mathbb{R},A_e\\in\\mathscr{G} \\]  这意味着，由 \\(A_e\\in\\mathscr{G}\\)  决定的单参子群，可以表示成 \\(\\exp(t A_e)\\)  。\n进一步，由 \\(A_e\\in\\mathscr{G}\\)  对应的左不变矢量场 \\(A\\)  产生的单参微分同胚群 \\(\\phi:\\mathbb{R}\\times G\\to G\\)  ，则可以表示成：\n\\[ \\boxed{\\phi_t(g)=g \\exp(t A_e)},\\quad \\forall g\\in G,t\\in \\mathbb{R} \\]  下面几条性质，说明指数映射是名副其实的：\n  \\(\\exp(s A_e)\\exp(t A_e)=\\exp((s+t)A_e),\\quad \\forall s,t \\in \\mathbb{R}\\)  ；  \\(\\exp(-t A_e)=\\exp(t A_e)^{-1},\\quad \\forall t \\in \\mathbb{R}\\)  ； 如果李群 \\(G\\)  是可交换的，则： \\((\\exp A_e)(\\exp B_e)=\\exp(A_e+B_e)\\)  。  如果 \\(\\phi:H\\to G\\)  是一个李群同态，那么基于下图映射路径的复合是可交换的：\n此可交换性，按图可写成： \\[ \\boxed{\\phi(\\exp A_e)=\\exp(\\phi_*A_e)},\\quad \\forall A_e \\in \\mathscr{H} \\]  正则坐标系 由群乘映射和求逆映射的光滑性出发，加上微分方程解对其初值的光滑依赖性，可知 \\(\\exp:\\mathscr{G}\\to G\\)  是 \\(C^\\infty\\)  映射。 由反函数定理可知， \\(\\mathscr{G}\\)  中存在包含恒等元 \\(e\\)  的开子集 \\(\\mathscr{U}\\)  ，并且 \\(G\\)  中也存在包含 \\(e\\)  的开子集 \\(U\\)  ，使得 \\(\\exp:\\mathscr{U}\\to U\\)  为微分同胚。\n利用这个性质，并考虑 \\(\\mathscr{G}(=V_e)\\)  是一个矢量空间，完全可在其上可给 \\(G\\)  定义局域坐标系，其坐标成为李群 \\(G\\)  的正则坐标。\n李代数的结构（常数）张量 注意，这一小段恢复使用抽象指标。\n结构张量 考虑一个李代数 \\(\\mathscr{V}\\)  ，对应的李括号 \\([,]:\\mathscr{V}\\times\\mathscr{V}\\to \\mathscr{V}\\)  是双线性映射。这意味着也可把李括号看成一个 \\((1,2)\\)  型张量，记作 \\(C^c_{\\ \\ ab}\\)  。即： \\[ \\boxed{[v,u]^a=C^c_{\\ \\ ab}v^au^b},\\quad \\forall v,u\\in \\mathscr{V} \\]  我们将这个张量 \\(C^c_{\\ \\ ab}\\)  ，称作李代数的结构张量。\n结构张量基本性质 李代数结构张量 \\(C^c_{\\ \\ ab}\\)  的基本性质:\n 下标反称： \\(C^c_{\\ \\ ab}=-C^c_{\\ \\ ab}\\)    \\(C^c_{\\ \\ a[b}C^a_{\\ \\ de]}=0\\)  【利用李括号的雅可比恒等式易证】  结构常数 特别地，为 \\(\\mathscr{V}\\)  选择一个基底 \\(\\{(e_\\mu)^a\\}\\)  ，于是有： \\[ [e_\\mu,e_\\upsilon]^c=C^c_{\\ \\ ab}(e_\\mu)^a(e_\\upsilon)^b=C^\\sigma_{\\ \\ \\mu\\upsilon}(e_\\sigma)^c \\]  其中， \\(C^\\sigma_{\\ \\ \\mu\\upsilon}\\)  称作李代数的结构常数，也是结构张量的分量。\n李氏第三基本定理 给定一组满足以下两条件的常数 \\(C^\\sigma_{\\ \\ \\mu\\upsilon}\\)  ：1） \\(C^\\sigma_{\\ \\ \\mu\\upsilon}=-C^\\sigma_{\\ \\ \\upsilon\\mu}\\)  ；2） \\(C^\\sigma_{\\ \\ \\mu[\\upsilon}C^\\mu_{\\ \\ \\rho\\tau]}=0\\)  ，必存在李群，其李代数以 \\(C^\\sigma_{\\ \\ \\mu\\upsilon}\\)  为结构常数。\n"}),a.add({id:142,href:'/notes/tags/%E6%AD%A3%E5%88%99%E5%9D%90%E6%A0%87/',title:"正则坐标",content:""}),a.add({id:143,href:'/notes/tags/%E7%BE%A4/',title:"群",content:""}),a.add({id:144,href:'/notes/tags/%E5%8A%9B%E5%AD%A6/',title:"力学",content:""}),a.add({id:145,href:'/notes/tags/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5/',title:"拉格朗日",content:""}),a.add({id:146,href:'/notes/docs/theophy/0015/',title:"流形上的拉格朗日力学",content:" 一个具有约束的力学系的位形空间是一个微分流形。\n拉格朗日力学其实就是个理论框架。\n有限自由度系统可直接拉格朗日量描述。\n场论（无限自由度系统）则可用拉格朗日密度描述。\n 拉格朗日量 一个具有约束的力学系的位形空间是一个微分流形   \\(M,\\quad \\dim{M}=n\\)  。无论何时，该力学系的状态由位形 \\(q\\in M\\)  和切矢 \\(\\dot{q}\\in V_q\\)  唯一确定。所以， \\(\\{(q,\\dot{q})\\}\\)  构成所谓的状态空间，称之为切丛 \\(TM\\)  \\[ TM=\\cup_{q\\in M}{V_q},\\quad TM_q=V_q,\\quad \\dim{TM}=2n \\]  基于最小作用原理的信仰，我们相信必然存在切丛 \\(TM\\)  上的某种标量场，能够描述这个这个力学系的演化规律，不妨称之为拉格朗日量 \\(\\mathrm{L}:TM \\to \\mathbb{R},\\quad \\mathrm{L}\\in \\mathscr{F}_{TM}\\)  ，对应演化路径作用量 \\(\\mathrm{S}\\)  就是: \\[ \\boxed{\\mathrm{S}\\overset{\\Delta}{=}\\int^{t_1}_{t_0}{\\mathrm{L}(q(t),\\dot{q}(t))dt}}\\quad (q,\\dot{q})\\in TM,\\quad q\\in M,\\quad \\dot{q}\\in V_q=TM_q \\]  其中， \\(\\left.q(t)\\right|_{t_0\\to t_1}\\)  就是目前未知但客观上确定的演化路径 ，这个作用量就是关于演化路径泛函。\n最小作用原理：作用量 \\(\\mathrm{S}\\)  最小的演化路径就是真实演化路径。\n欧拉-拉格朗日方程 不同演化路径的比较，自然是通过每个时刻的差异进行“纵向”比较，在这种比较中，时间只是一个固定的参数而已。基于这种思路，可以“微分”的方法求作用量的的变分： \\[ \\begin{aligned}\\delta\\mathrm{S}\u0026=\\int^{t_1}_{t_0}{\\delta\\mathrm{L}dt}\\\\ \u0026=\\int^{t_1}_{t_0}{(\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}\\delta q^\\mu+\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\delta \\dot{q}^\\mu)dt}\\quad \\text{仿照微分}\\\\ \u0026=\\int^{t_1}_{t_0}{\\left[\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}\\delta q^\\mu+\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\frac{d}{dt}(\\delta q^\\mu)\\right]dt}\\quad \\text{微分变分视角切换}\\\\ \u0026=\\int^{t_1}_{t_0}{\\left[\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}\\delta q^\\mu+\\frac{d}{dt}\\left(\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\delta q^\\mu\\right)-\\frac{d}{dt}\\left(\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\right)\\delta q^\\mu\\right]dt}\\\\ \u0026=\\int^{t_1}_{t_0}{\\left[\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}-\\frac{d}{dt}\\left(\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\right)\\right]\\delta q^\\mu dt}+\\left.\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\delta q^\\mu\\right|^{t_1}_{t_0} \\\\ \u0026=\\int^{t_1}_{t_0}{\\left[\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}-\\frac{d}{dt}\\left(\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}\\right)\\right]\\delta q^\\mu dt}\\quad \\text{固定边界} \\end{aligned} \\]  根据最小作用原理，真实演化路径必须满足 \\(\\delta \\mathrm{S}=0\\)  ，考虑到路径变分任意性，可写出真实演化路径的方程，称之为欧拉-拉格朗日方程： \\[ \\boxed{\\frac{d}{dt}\\frac{\\partial \\mathrm{L}}{\\partial \\dot{q}^\\mu}=\\frac{\\partial \\mathrm{L}}{\\partial q^\\mu}} \\quad \\mu=1\\dots n \\]  拉格朗日量的形式 只要知道系统的拉格朗日量，就能够写出演化方程。\n但系统的拉格朗日量的具体形式是什么？ 这就需要具体相关领域的知识，特别是系统拥有的对称性。\n后面将会陆续展开讨论：如何通过系统对称性写出拉格朗日量。\n所以，拉格朗日力学其实就是个理论框架。\n拉格朗日场论 前面的拉格朗日力学所对应拉格朗日量，只适用于有限自由度的力学系。\n以标量场为例，考察场的状态描述方法。标量场首先是关于流形上点的函数，其次还要考察标量场的演化，必然还和时间有关，所以标量场可写成 \\(\\phi(q,t)\\)  。\n注意， \\(\\phi(q,t)\\)  其实是和前面拉格朗日力学种的位形变量 \\(q(t)\\)  相对应的，进而有如下对应：\n\\[ \\boxed{\\begin{aligned}q(t) \u0026\\longleftrightarrow \\phi(q,t) \\\\ \\dot{q}(t) \u0026\\longleftrightarrow (\\frac{\\partial \\phi(q,t)}{\\partial t},\\frac{\\partial \\phi(q,t)}{\\partial q^\\mu})\\overset{\\Delta}{=}(\\dot{\\phi}(q,t),\\partial_\\mu \\phi(q,t))\\end{aligned}} \\]  由于标量场\u0026quot;弥散\u0026quot;在整个流形 \\(M\\)  上，所以需要将空间每个部分“拉格朗日量”加起来得到整个系统的拉格朗日量，一个自然的想法就是引入拉格朗日密度(单位体积的拉格朗日量)： \\[ \\mathscr{L}(\\phi(x,t),\\dot{\\phi}(x,t),\\partial_\\mu\\phi(x,t)) \\]  如果把\u0026quot;时空\u0026quot;看成一个整体，那么拉格朗日密度可改写成： \\[ \\boxed{\\mathscr{L}(\\phi,\\partial_a\\phi)} \\]  那么整个系统的拉格朗日量可写成流形上的积分： \\[ \\boxed{\\mathrm{L}=\\int_M{\\mathscr{L}(\\phi,\\partial_a \\phi)}} \\]  最后可以写出作用量： \\[ \\boxed{\\mathrm{S}=\\int^{t_1}_{t_0}{\\mathrm{L}dt}=\\int_U{\\mathscr{L}(\\phi,\\partial_a \\phi)}}\\quad U=[t_0,t_1]\\times M \\]  在时空整体化后，有必要引入一个参数 \\(\\lambda\\)  来替代 \\(t\\)  （当然在特别情况下 \\(\\lambda=t\\)  ）。于是可对作用量进行变分：\n\\[ \\begin{aligned}\\delta S \u0026 = \\int_U{\\delta \\mathscr{L}(\\phi,\\partial_a \\phi)} \\\\ \u0026 = \\int_U{\\left(\\frac{\\partial \\mathscr{L}}{\\partial \\phi}\\delta \\phi+\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\delta (\\partial_a \\phi)\\right)}\\\\ \u0026 = \\int_U{\\left(\\frac{\\partial \\mathscr{L}}{\\partial \\phi}\\delta \\phi+\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\partial_a(\\delta\\phi)\\right)}\\\\ \u0026 = \\int_U{\\left(\\frac{\\partial \\mathscr{L}}{\\partial \\phi}\\delta \\phi+\\partial_a\\left(\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\delta\\phi\\right)-\\partial_a\\left(\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\right)\\delta\\phi\\right)}\\\\ \u0026 = \\int_U{\\left[\\frac{\\partial \\mathscr{L}}{\\partial \\phi}-\\partial_a\\left(\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\right)\\right]\\delta\\phi}+\\left.\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\delta\\phi\\right|^{\\lambda_1}_{\\lambda_0}\\\\ \u0026 = \\int_U{\\left[\\frac{\\partial \\mathscr{L}}{\\partial \\phi}-\\partial_a\\left(\\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}\\right)\\right]\\delta\\phi}\\end{aligned} \\]  最后得到标量场的欧拉-拉格朗日方程： \\[ \\boxed{\\frac{\\partial \\mathscr{L}}{\\partial \\phi}=\\partial_a \\frac{\\partial \\mathscr{L}}{\\partial (\\partial_a \\phi)}} \\]  上面仅仅是以标量场为例，对应更复杂“场”，拉格朗日量密度可能形如: \\[ \\boxed{\\mathscr{L}(\\Psi,\\nabla_a\\Psi,\\nabla^2\\Psi,\\dots, \\nabla^k\\Psi)} \\]  其中， \\(\\Psi\\)  代表一个或一组张量场， \\(\\nabla^k \\Psi\\overset{\\Delta}{=}\\nabla_{a_1}\\dots\\nabla_{a_k}\\Psi\\)  。\n所以对复杂的情况，需要直接通过 \\(\\delta \\mathrm{S}=0\\)  推导出对应的演化方程。\n"}),a.add({id:147,href:'/notes/docs/diffgeo/',title:"微分几何笔记",content:"微分几何笔记 基础概念提要 本系列直接跳过了 拓扑、流形、张量等基础概念。为此，我特意先用纯文字按我的理解对一些基础概念进行提要（可能不严谨，着重提要而已）。\n所谓拓扑，就是开集族。 用集合的语言，通过三条公理严格定义开集。这三条公理就是：1）两个平凡开集；2）有限个开集交的封闭性；3）无限个开集并的封闭性。\n所谓拓扑空间，就是定义了拓扑的集合。\n所谓拓扑空间之间连续映射，就是指开集逆像必为开的映射。\n所谓同胚映射，就是一一到上且正反都连续的映射。就纯拓扑空间而言，表示“像的不能再像”。\n所谓闭集，就是补集为开的子集。\n所谓拓扑空间连通性，就是指即开又闭的集合只有两个平凡开集(闭集)。\n所谓微分流形，就是能被一组开集覆盖，每个开集同胚于一个欧氏空间，任意两个这种同胚映射的复合都是光滑的。\n所谓切矢量（简称矢量），就流形上过某点的某条曲线的切矢。也可以看成是把函数变成实数并满足莱布尼兹律的线性映射。 如果为流形上每点都指定一个切矢量，就构成一个矢量场。\n至于对偶矢量，首先矢量也可以看成是把函数变成实数的线性映射，其次对偶矢量可看成把矢量变成实数线性映射。 同时，矢量和对偶矢量还可以相互作用得实数，这个特点就是对偶。并且还可利用这个特点证明矢量空间和对偶矢量空间相互同构。\n所谓张量，就是利用矢量和对偶矢量都是线性映射的特点，经过\u0026quot;多重组合\u0026quot;得到的多重线性映射。\n所谓度规张量，就是对称非退化的(0,2)型张量。任何带度规的矢量空间都有正交归一基底。\n目录  1. 基于抽象指标的张量分析 2. 流形上的导数算符 3. 流形上的平移 4. 黎曼曲率张量 5. 流形间的映射 6. 流形上的李导数 7. Killing矢量场 8. 子流形和超曲面 9. 流形上的微分形式及其对偶 10. 流形上的微积分 11. 李群李代数 12. 常用李群及其李代数 13. 李变换群 14. 微分几何中的计算（Julia版）    15. 辛群及其李代数 16. 辛流形 17. 流形上的旋量和旋量场（初步） 18. 流形上的旋量和旋量场（几何解释） 19. 流形上的旋量和旋量场（导数算符和曲率) 20. 流形上的旋量和旋量场（自旋系数和克氏符） 21. 李群李代数伴随表示和Killing型、Casimir算符 22. 半单李代数的标准形式 23. 半单李代数的根系、权系和Dynkin图 24. 半单李代数的Casimir不变算符    参考文献 1）现代物理基础丛书07-微分几何入门与广义相对论(上册.第2版)-梁灿彬＆周彬-科学出版社-2006\n2）现代物理基础丛书25-微分几何入门与广义相对论(中册.第2版)-梁灿彬＆周彬-科学出版社-2009\n3）现代物理基础丛书28-微分几何入门与广义相对论(下册.第2版)-梁灿彬＆周彬-科学出版社-2009\n4）现代物理基础丛书02-物理学家用微分几何(第2版)－侯伯元\u0026amp;侯伯宇-科学出版社-2004\n5）General Relativity（广义相对论）, Robert M.Wald, Chicago, 1984\n6）通向实在之路：宇宙法则的完全指南-[英]罗杰·彭罗斯-王文浩(译)-湖南科学技术出版社-6月, 2008\n7）Gravitation（引力论·大黑书）, Misner Thorne Wheeler , W.H.Freeman, 1973\n8）Spinors and Space-Time Vol.1：Two-spinor calculus and relativistic fields（旋量与时空 卷1：两旋量微积分与相对论场），R.Penrose W.Rindler，Cambridge，1984\n9）The Theory of Spinors（旋量理论），Elie.Cartan ，Dover，1981\n10）数学物理学百科全书(英文版.全5卷)-[法]费朗克斯-Elsevier出版-2007\n11）Lie 代数理论及其在物理学中的应用(共127)-周彬-北京师范大学\n12）典型群及其在物理学上的应用-[新西兰]B·G·怀邦-冯承天(译)-科学出版社-1982\n13）物理学中的群论（上下合卷）-陶瑞宝-上海科学技术出版社-1986\n14）李代数及其表示理论导引-[美]J.E.汉弗莱斯-陈志杰(译)-上海科学技术出版社-1981\n"}),a.add({id:148,href:'/notes/tags/Gauss%E5%AE%9A%E7%90%86/',title:"Gauss定理",content:""}),a.add({id:149,href:'/notes/tags/Stokes%E5%AE%9A%E7%90%86/',title:"Stokes定理",content:""}),a.add({id:150,href:'/notes/tags/%E4%BD%93%E5%85%83/',title:"体元",content:""}),a.add({id:151,href:'/notes/tags/%E5%A4%96%E5%BE%AE%E5%88%86/',title:"外微分",content:""}),a.add({id:152,href:'/notes/tags/%E5%BE%AE%E7%A7%AF%E5%88%86/',title:"微积分",content:""}),a.add({id:153,href:'/notes/docs/diffgeo/0014/',title:"流形上的微积分",content:" 流形上微积分的作用对象是微分形式。\n普通微分对应微分形式的外微分，普通积分则对应微分形式在流形上的积分。\n微积分基本定理对应流形上的Stokes定理。\n流形上的Gauss定理则成为Stokes定理特例。\n 流形上的微分、外微分算符 流形   \\(M\\)  上的外微分算符 \\(d\\)  是一个映射：\n\\[ \\boxed{\\begin{aligned}d:\u0026\\Lambda_M(l)\u0026\\to\u0026 \u0026 \u0026\\Lambda_M(l+1)\\\\ \u0026\\omega_{a_1\\dots a_l}\u0026\\mapsto\u0026 \u0026 \u0026 (d\\omega)_{b a_1\\dots a_l} \\overset{\\Delta}{=}(l+1)\\nabla_{[b}\\omega_{a_1 \\dots a_l]}\\end{aligned}} \\]  特别地， \\((df)_a=\\nabla_b f\\)  ，意味着标量场的外微分就是导数算符对标量场的作用。\n1. 定义中的导数算符可任意选择 此外，在坐标基矢下，根据定义全反称性和克氏符的下标对称性(因为括号内加异种括号为０)，上面的定义式可改写成：\n\\[ (d\\omega)_{b a_1\\dots a_l}=(l+1)\\partial_{[b}\\omega_{a_1 \\dots a_l]} \\]  同样道理，前面的外微分的定义和导数算符选择无关，都有相同的结果。\n2.坐标基矢下的外微分作用后的展开式 在坐标基矢下，外微分算符对微分形式作用后的展开式：\n\\[ \\boxed{(d\\omega)_{b a_1\\dots a_l}=\\sum_C{(d\\omega_{\\mu_1\\dots \\mu_l})_b\\wedge(dx^{\\mu_1})_{a_1}\\wedge\\dots\\wedge(dx^{\\mu_l})_{a_l}}} \\]  这里根据定义的全反称性能产生 \\((l+1)\\)  个重复项进而可被定义吸收掉，最后就必然得到上式。\n3. 连续两次外微分作用得０ 连续求两次外微分的结果得０，即 \\(\\boxed{d\\circ d=0}\\)  。因为 \\[ \\begin{aligned}[d(d\\omega)]_{c b a_1\\dots a_l}=\u0026(l+2)(l+1)\\partial_{[c}\\partial_{[b}\\omega_{a_1 \\dots a_l]]}\\quad \\text{根据定义嵌套}\\\\ =\u0026(l+2)(l+1)\\partial_{[c}\\partial_b\\omega_{a_1 \\dots a_l]}\\quad \\text{扩号内同种括号可删除}\\\\ =\u0026(l+2)(l+1)\\partial_{[(c}\\partial_{b)}\\omega_{a_1 \\dots a_l]}\\quad \\text{普通导数可交换}\\\\=\u00260\\quad \\text{异种括号得０}\\end{aligned} \\]  4. 闭的、恰当的微分形式 微分形式场 \\(\\boldsymbol{\\omega}\\in \\Lambda_M(l)\\)  被称作闭的，若 \\(d \\boldsymbol{\\omega}=0\\)  。\n微分形式场 \\(\\boldsymbol{\\omega}\\in \\Lambda_M(l)\\)  被称恰当的，若 \\( \\boldsymbol{\\omega}=d \\boldsymbol{\\mu},\\quad \\exists \\boldsymbol{\\mu}\\in \\Lambda_M(l-1)\\)  。\n结论１：若 \\(\\boldsymbol{\\omega}\\)  是恰当的，那必然也是闭的。因为连续两次外微分得０。\n结论2：若 \\(\\boldsymbol{\\omega}\\)  是闭的，那么至少也是局域恰当的。\n5. Cartan公式 由于对微分形式计算其李导数比较麻烦，不妨先引入一个缩并算子：\n\\[ i_X\\omega_{a_1\\dots a_r}\\overset{\\Delta}{=}X^{a_1}\\omega_{a_1\\dots a_r} \\]  于是，李导数算子 \\(\\mathscr{L}_X\\)  、外微分算子 \\(d\\)  、缩并算子 \\(i_X\\)  之间有一个Cartan公式的关系：\n\\[ \\boxed{\\mathscr{L}_X=d \\circ i_X+i_X \\circ d} \\]  也可以写成抽象指标形式：\n\\[ \\mathscr{L}_X \\omega_{a_1\\dots a_r}=d_{a_1}(X^c\\omega_{c a_2\\dots a_r})+X^c(d\\omega)_{c a_1\\dots a_r} \\]  流形上的积分 1. 流形上的局域积分 设 \\((O,\\psi)\\)  是 \\(n\\)  维定向流形 \\(M\\)  上的右手坐标系， \\(\\boldsymbol{\\omega}\\)  是开子集 \\(G\\subset O\\)  上的连续 \\(n\\)  形式场，那么 \\(\\boldsymbol{\\omega}\\)  在上 \\(G\\)  的积分定义成： \\[ \\boxed{\\int_G{\\boldsymbol{\\omega}} \\overset{\\Delta}{=} \\int_{\\psi[G]}{\\omega_{1\\dots n}dx^1\\dots dx^n}} \\]  这个定义和右手坐标系的选择是无关的。因为，可另选新的右手坐标系 \\((O',\\psi'),\\quad G\\subset O\\cap O'\\)  ，那么 \\[ \\begin{aligned}\\int_{\\psi'[G]}{\\omega'_{1\\dots n}dx'^1\\dots dx'^n}=\u0026 \\int_{\\psi'[G]}{\\frac{\\partial x^{\\mu_1}}{\\partial x'^1}\\dots\\frac{\\partial x^{\\mu_n}}{\\partial x'^n}\\omega_{\\mu_1\\dots\\mu_n}dx'^1\\dots dx'^n}\\quad \\text{坐标变换}\\\\ =\u0026 \\int_{\\psi'[G]}{\\omega_{1\\dots n}\\det\\left(\\frac{\\partial x^\\mu}{\\partial x'^\\upsilon}\\right)dx'^1\\dots dx'^n}\\quad \\text{写成雅可比行列式}\\\\ =\u0026 \\int_{\\psi[G]}{\\omega_{1\\dots n}dx^1\\dots dx^n}\\quad \\text{变量替换}\\end{aligned} \\]  2. 流形上的大范围积分 考虑流形 \\(M\\)  上的有限坐标图册 \\(\\{(O_\\alpha,\\varphi_\\alpha)\\}\\)  ，根据“单位分解定理”，必然存在这组开覆盖所对应的一组单位分解 \\(\\{\\pi_\\alpha\\}\\)  ，即满足： \\[ \\sum_\\alpha{\\pi_\\alpha(p)}=1,\\quad 0\\le \\pi_\\alpha(p)\\le 1,\\quad \\mathrm{supp}(\\pi_\\alpha)\\subset O_\\alpha,\\quad \\forall p\\in M \\]  然后将 \\(\\{\\pi_\\alpha\\}\\)  定义域全部限制在区域 \\(D\\subset M\\)  ，不在此区域的全部取０，那么可对大范围进行积分： \\[ \\boxed{\\int_D{\\boldsymbol{\\omega}}=(\\sum_\\alpha{\\pi_\\alpha})\\int_D{\\boldsymbol{\\omega}}=\\sum_\\alpha{\\int_{D\\cap O_\\alpha}{\\pi_\\alpha\\boldsymbol{\\omega}}}\\overset{\\Delta}{=}\\sum_\\alpha{\\int_{D\\cap O_\\alpha}{\\boldsymbol{\\omega}}_\\alpha}} \\]  3. 子流形上的积分 考虑 \\(n\\)  维流形 \\(M\\)  的 \\(l(\\lt n)\\)  维嵌入子流形 \\(\\phi[S]\\)  ， \\(\\phi:S\\to M\\)  是对应的嵌入。 从流形 \\(M\\)  角度看的 \\(l\\)  形式场 \\(\\boldsymbol{\\mu}=\\mu_{a_1\\dots a_l}\\in \\Lambda_M(l)\\)  ，但从子流形 \\(\\phi[S]\\)  角度只能看见 \\(\\boldsymbol{\\mu}\\)  在 \\(\\Lambda_{\\phi[S]}(l)\\)  上的“投影” \\(\\tilde{\\boldsymbol{\\mu}}=\\tilde{\\mu}_{a_1\\dots a_l}\\in \\Lambda_{\\phi[S]}(l)\\)  ，称为 \\(\\boldsymbol{\\mu}\\)  在 \\(\\phi[S]\\)  上的限制，若\n\\[ \\left.\\tilde{\\mu}_{a_1\\dots a_l}\\right|_q(w_1)^{a_1}\\dots(w_l)^{a_l}=\\left.\\mu_{a_1\\dots a_l}\\right|_q(w_1)^{a_1}\\dots(w_l)^{a_l}\\\\ \\forall q\\in\\phi[S],(w_1)^{a_1},\\dots,(w_l)^{a_l}\\in W_q \\]  所以子流形上的积分可理解为： \\[ \\boxed{\\int_{\\phi[S]}{\\boldsymbol{\\mu}}\\overset{\\Delta}{=}\\int_{\\phi[S]}{\\tilde{\\boldsymbol{\\mu}}}} \\]  Stokes定理　流形上微积分基本定理 1. 局域上的Stokes定理 \\[ \\int_{A}{d\\boldsymbol{\\omega}}=\\int_{\\partial A}{\\boldsymbol{\\omega}}, \\quad \\boldsymbol{\\omega}\\in \\Lambda_M(n-1)\\quad \\exists \\alpha \\ A\\subset O_\\alpha \\]  下面是非严格的证明过程示意（带帽^的项代表不存在的项）: \\[ \\begin{aligned}\\boldsymbol{\\omega}=\u0026 \\sum_C{\\omega_{\\mu_1\\dots \\mu_{n-1}}(dx^{\\mu_1})_{a_1}\\wedge\\dots\\wedge(dx^{\\mu_{n-1}})_{a_{n-1}}}\\\\ =\u0026 \\sum_{i=1}^n{\\omega_i(dx^1)_{a_1}\\wedge\\dots\\wedge(d \\hat{x}^i)_{a_i}\\wedge\\dots\\wedge(dx^n)_{a_n}} \\\\ d\\boldsymbol{\\omega}_\\alpha=\u0026 \\sum_{i=1}^n{(d\\omega_i)_{a_i}\\wedge(dx^1)_{a_1}\\wedge\\dots\\wedge(d \\hat{x}^i)_{a_i}\\wedge\\dots\\wedge(dx^n)_{a_n}}\\\\ =\u0026 \\sum_{i=1}^n{\\left[\\sum_s{\\frac{\\partial \\omega_i}{\\partial x^s}(dx^s)_{a_i}}\\right]\\wedge(dx^1)_{a_1}\\wedge\\dots\\wedge(d \\hat{x}^i)_{a_i}\\wedge\\dots\\wedge(dx^n)_{a_n}}\\\\=\u0026 \\sum_{i=1}^n{\\frac{\\partial \\omega_i}{\\partial x^i}(dx^i)_{a_i}\\wedge(dx^1)_{a_1}\\wedge\\dots\\wedge(d \\hat{x}^i)_{a_i}\\wedge\\dots\\wedge(dx^n)_{a_n}} \\\\ \\int_A{d\\boldsymbol{\\omega}}_\\alpha=\u0026 \\int_{\\varphi[A]}{\\sum_{i=1}^n{\\frac{\\partial \\omega_i}{\\partial x^i}dx^i dx^1 \\dots d \\hat{x}^i \\dots dx^n} }\\\\ =\u0026 \\sum_{i=1}^n{\\int_{\\varphi[A]\\overset{\\Delta}{=}I_n}{\\frac{\\partial \\omega_i}{\\partial x^i}dx^i dx^1 \\dots d \\hat{x}^i \\dots dx^n} } \\\\ =\u0026 \\sum_{i=1}^n{\\int_{I_{n-1}}{\\left[\\int_{I_1}{\\frac{\\partial \\omega_i}{\\partial x^i}dx^i}\\right] dx^1 \\dots d \\hat{x}^i \\dots dx^n} }\\\\ =\u0026 \\sum_{i=1}^n{\\int_{\\partial A\\overset{\\Delta}{=}I_{n-1}}{\\omega_i dx^1 \\dots d \\hat{x}^i \\dots dx^n} }\\\\ =\u0026 \\int_{\\partial A}{\\sum_{i=1}^n{\\omega_i dx^1 \\dots d \\hat{x}^i \\dots dx^n} }\\\\ =\u0026 \\int_{\\partial A}{\\boldsymbol{\\omega}}\\end{aligned} \\]  2. 大范围上的Stokes定理 \\[ \\boxed{\\int_{D}{d\\boldsymbol{\\omega}}=\\int_{\\partial D}{\\boldsymbol{\\omega}}, \\quad \\boldsymbol{\\omega}\\in \\Lambda_M(n-1)\\quad D\\subset M} \\]  因为(利用了单位分解) \\[ \\int_D{d\\boldsymbol{\\omega}}=\\sum_\\alpha{\\int_{D\\cap O_\\alpha}{d\\boldsymbol{\\omega}}_\\alpha}=\\sum_\\alpha{\\int_{\\partial D\\cap O_\\alpha}{\\boldsymbol{\\omega}}_\\alpha}=\\int_{\\partial D}{\\boldsymbol{\\omega}} \\]  Gauss定理 1. 函数在流形上的积分 考虑流形 \\((M,g_{ab})\\)  ，有对应度规适配体元 \\(\\boldsymbol{\\varepsilon}\\)  ，还有标量场(流形上的函数) \\(f\\in \\mathscr{F}_M\\)  ,那么 \\(f\\)  在 \\(M\\)  上的积分定义为 \\(n\\)  形式场 \\(f\\boldsymbol{\\varepsilon}\\)  在 \\(M\\)  上的积分，即\n\\[ \\boxed{\\int_M{f}\\overset{\\Delta}{=}\\int_M{^*f}=\\int_M{f\\boldsymbol{\\varepsilon}}} \\]  其中用到了霍奇星算子 \\(^*\\)  。\n2. Gauss定理雏形 考虑定向流形 \\((M,g_{ab})\\)  ， \\(\\boldsymbol{\\varepsilon}\\)  和 \\(\\nabla_a\\)  分别时适配体元和适配导数算符， \\(v^a\\in \\mathscr{F}_M(1,0)\\)  ，取 \\((n-1)\\)  形式场 \\[ \\boldsymbol{\\omega}=v^b \\varepsilon_{b a_1\\dots a_{n-1}}\\in \\Lambda_M(n-1) \\]  那么求外微分后时 \\(n\\)  形式场( \\(h\\)  待定) \\[ d\\boldsymbol{\\omega}=n\\nabla_{[c}v^b\\varepsilon_{|b| a_1 \\dots a_{n-1}]}\\overset{\\Delta}{=}h \\varepsilon_{c a_1\\dots a_{n-1}} \\in \\Lambda_M(n) \\]  进而可以求出 \\(h\\)  (两边与 \\(\\varepsilon^{c a_1\\dots a_{n-1}}\\)  缩并)\n\\[ h \\varepsilon^{c a_1\\dots a_{n-1}}\\varepsilon_{c a_1\\dots a_{n-1}}= n \\varepsilon^{c a_1\\dots a_{n-1}} \\nabla_{[c}v^b\\varepsilon_{|b| a_1 \\dots a_{n-1}]} \\\\ \\quad \\\\ \\Longrightarrow \\begin{aligned}\u0026 (-1)^s n! h \u0026=\u0026 n\\varepsilon^{[c a_1\\dots a_{n-1}]} \\nabla_{c}v^b\\varepsilon_{b a_1 \\dots a_{n-1}}\\\\ \u0026 \u0026=\u0026 n\\varepsilon^{c a_1\\dots a_{n-1}} \\varepsilon_{b a_1 \\dots a_{n-1}}(\\nabla_{c}v^b) \\\\ \u0026 \u0026=\u0026 n(-1)^s(n-1)!1!\\delta^c_{\\ b}(\\nabla_{c}v^b) \\\\ \u0026 \u0026=\u0026 (-1)^s n! (\\nabla_{b}v^b) \\end{aligned} \\]  这意味着 \\[ h = \\nabla_{b}v^b \\Longrightarrow d\\boldsymbol{\\omega} =(\\nabla_{b}v^b) \\varepsilon_{c a_1\\dots a_{n-1}} \\]  带入Stokes定理得到Gauss定理雏形 \\[ \\boxed{\\int_{D}{(\\nabla_{b}v^b) \\boldsymbol{\\varepsilon}}=\\int_{\\partial D}{v^b \\varepsilon_{b a_1\\dots a_{n-1}}}} \\]  3. 诱导适配体元  \\(\\partial D\\)  超曲面(不考虑类光超曲面的情况)，可谈归一化法矢 \\(n^a,\\quad n^a n_b=\\pm 1\\)  ，并有 \\(\\partial D\\)  上的诱导度规 \\(h_{ab}=g_{ab}\\mp n_a n_b\\)  。那么 \\(h_{ab}\\)  的适配体元 \\(\\hat{\\varepsilon}_{a_1\\dots a_{n-1}}\\)  必须满足：（1）与 \\(\\partial D\\)  的诱导定向相容；（2）与度规 \\(h_{ab}\\)  相适配，即 \\[ \\boxed{\\hat{\\varepsilon}^{a_1\\dots a_{n-1}}\\hat{\\varepsilon}_{a_1\\dots a_{n-1}}=(-1)^{\\hat{s}}(n-1)!} \\]  考虑正交归一基底 \\(\\{(e_\\mu)^a\\},\\quad (e_1)^a=n^a\\)  ，那么 \\[ \\varepsilon_{a_1\\dots a_n}=(e^1\\wedge\\dots \\wedge e^n)_{a_1\\dots a_n}=\\pm n_{a_1}\\wedge(e^2\\wedge\\dots\\wedge e^n)_{a_2\\dots a_n} \\]  由诱导定向的相容性要求： \\[ \\boxed{\\hat{\\varepsilon}_{a_2\\dots a_n}=K (e^2\\wedge\\dots\\wedge e^n)_{a_2\\dots a_n},\\quad K0} \\]  于是 \\[ \\begin{aligned}\u0026 K \\varepsilon_{a_1\\dots a_{n-1}}=\\pm n_{b}\\wedge \\hat{\\varepsilon}_{a_1\\dots a_{n-1}}\\\\ \\Rightarrow \\quad \u0026 K n^b\\varepsilon_{b a_1\\dots a_{n-1}}=\\pm n^b (n_b\\wedge\\hat{\\varepsilon}_{a_1\\dots a_{n-1}})= \\hat{\\varepsilon}_{a_1\\dots a_{n-1}}\\\\ \\Rightarrow \\quad \u0026 \\hat{\\varepsilon}_{a_1\\dots a_{n-1}}=K n^b\\varepsilon_{b a_1\\dots a_{n-1}} \\quad K0\\end{aligned} \\]  由诱导度规适配性要求：\n \\[ \\begin{aligned}(-1)^{\\hat{s}}(n-1)!\u0026=K^2 n_b\\varepsilon^{b a_1\\dots a_{n-1}} n^c\\varepsilon_{c a_1\\dots a_{n-1}}\\\\ \u0026= K^2 (n_b n^c)((-1)^s(n-1)!1!\\delta^b_{\\ c})\\\\ \u0026= (-1)^s (n-1)! n_b n^b K^2\\\\ \\Rightarrow \\quad \u0026K=1 \\end{aligned} \\]  即，诱导适配体元是法矢与适配体元的缩并： \\[ \\boxed{\\hat{\\varepsilon}_{a_1\\dots a_{n-1}}=n^b\\varepsilon_{b a_1\\dots a_{n-1}}} \\]  4. Gauss定理 前面Gauss定理雏形右边被积分的部分 \\(v^b \\varepsilon_{b a_1\\dots a_{n-1}}\\)  ，而积分区域是在 \\(\\partial D\\)  超曲面上，所以一个很自然的想法就是写成标量场（流形函数）与 \\(\\partial D\\)  上诱导适配体元的乘积，即 \\[ \\begin{aligned}\u0026 \\boxed{v^b \\varepsilon_{b a_1\\dots a_{n-1}}=K \\hat{\\varepsilon}_{a_1\\dots a_{n-1}}} \\\\ \\Rightarrow \\quad \u0026v^b \\varepsilon_{b a_1\\dots a_{n-1}}=K n^b\\varepsilon_{b a_1\\dots a_{n-1}}\\\\ \\Rightarrow \\quad \u0026v^b \\varepsilon^{c a_1\\dots a_{n-1}} \\varepsilon_{b a_1\\dots a_{n-1}}=K n^b \\varepsilon^{c a_1\\dots a_{n-1}} \\varepsilon_{b a_1\\dots a_{n-1}}\\\\ \\Rightarrow \\quad \u0026v^b=K n^b\\\\ \\Rightarrow \\quad \u0026K n^b n_b = v^b n_b\\\\ \\Rightarrow \\quad \u0026K = \\pm v^b n_b \\quad \\text{符号}n^a n_a\\text{和一致} \\end{aligned} \\]  最后得到标准的Gauss定理： \\[ \\boxed{\\int_D{(\\nabla_a v^a)\\boldsymbol{\\varepsilon}}=\\int_{\\partial D}{v^a n_a \\hat{\\boldsymbol{\\varepsilon}}}} \\]  三维欧氏空间矢量算子的外微分表示 梯度、旋度、散度可用外微分表示： \\[ \\begin{aligned}\\mathrm{grad}\\ f \u0026= df\\\\ \\mathrm{curl} \\ \\vec{A}\u0026= ^*d \\boldsymbol{A}\\\\ \\mathrm{div} \\ \\vec{A}\u0026= ^*d (^*\\boldsymbol{A})\\end{aligned} \\]  欧氏空间这个种平凡流形，必然是恰当的，所以有:\n  无旋矢量场必可表示为梯度 \\( \\mathrm{curl}\\ \\vec{E}=0 \\Longrightarrow \\exists \\phi, \\ \\ \\vec{E}=\\mathrm{grad}\\ \\phi \\)    无散矢量场必可表示为旋度 \\( \\mathrm{div}\\ \\vec{B}=0 \\Longrightarrow \\exists \\vec{A}, \\ \\ \\vec{B}=\\mathrm{curl} \\ \\vec{A} \\)   "}),a.add({id:154,href:'/notes/tags/%E5%AE%9A%E5%90%91/',title:"定向",content:""}),a.add({id:155,href:'/notes/tags/%E6%A5%94%E7%A7%AF/',title:"楔积",content:""}),a.add({id:156,href:'/notes/docs/diffgeo/0013/',title:"流形上的微分形式及其对偶",content:" 微分形式就是全反称全下指标张量，是流形上微积分的作用对象。\n对偶矢量基底的楔积构成微分形式的基底。由于全反称性，这个基底张成的线性空间维度是一个组合数。\n为流形上每个点选一个微分形式，就得到微分形式场。\n流形的定向，由处处连续非零的   \\(n\\)  形式场（体元场）确定。\n度规适配体元，就是正交归一基底下的分量为 \\(\\pm 1\\)  的体元。右手系取1，左手系取-1。\n利用适配体元引入霍奇星算子（求微分形式的对偶）。\n用普通导数算符和抽象指标可简化欧氏空间上矢量代数公式的推导。\n 矢量空间上的微分形式  \\(\\omega_{a_1\\dots a_l}\\in\\mathscr{T}_V(0,l)\\)  叫 \\(V\\)  上的 \\(l\\)  次形式( \\(l\\)  形式)，若\n\\[ \\omega_{a_1\\dots a_l}=\\omega_{[a_1\\dots a_l]} \\quad \\text{or} \\quad \\omega_{(a_1\\dots a_l)}=0 \\]  也就是说： \\(l\\)  形式，就是全反称 \\((0,l)\\)  型张量。有时为简洁会记做 \\(\\boldsymbol{\\omega}\\)  。　\\(V\\)  上的全体 \\(l\\)  形式的集合记作 \\(\\Lambda(l)\\subset\\mathscr{T}_V(0,l)\\)  。　1形式就是 \\(V\\)  上的对偶矢量，即 \\(\\Lambda(1)=V^*\\)  。约定实数可看成上的0形式，即 \\(\\Lambda(0)=\\mathbb{R}\\)  。\n\u0026ldquo;全反称\u0026quot;具有的基本性质就是就是微分形式该具有的性质。\n在流形 \\(M\\)  上点 \\(p\\)  的切空间 \\(V_p\\)  上自然也有微分形式 \\(\\omega_{a_1\\dots a_l}\\in \\Lambda_p(l)\\)  。\n微分形式构成线性空间  \\(\\Lambda(l)\\)  是 \\(\\mathscr{T}_V(0,l)\\)  的线性子空间，并且 \\(\\dim \\Lambda(l)=\\dfrac{n!}{l!(n-l)!},\\quad l\\le n\\)  。　这个维度就是反称性导致形如 \\(\\{e^{\\mu_1}\\wedge \\dots \\wedge e^{\\mu_l}\\}\\)  的独立基底数就是组合总数 \\(C^l_n\\)  。\n微分形式的楔积 微分形式的楔积定义： \\[ (\\omega\\wedge\\mu)_{a_1\\dots a_l b_1\\dots b_m}=\\frac{(l+m)!}{l! m!}\\omega_{[a_1\\dots a_l}\\mu_{b_1\\dots b_m]} \\]  楔积的性质：\n  结合律： \\(\\boldsymbol{\\omega}\\wedge(\\boldsymbol{\\mu}\\wedge\\boldsymbol{\\upsilon})=(\\boldsymbol{\\omega}\\wedge\\boldsymbol{\\mu})\\wedge\\boldsymbol{\\upsilon}=\\boldsymbol{\\omega}\\wedge\\boldsymbol{\\mu}\\wedge\\boldsymbol{\\upsilon}\\)  ；\n  分配律： \\(\\boldsymbol{\\omega}\\wedge(\\boldsymbol{\\mu}+\\boldsymbol{\\upsilon})=\\boldsymbol{\\omega}\\wedge\\boldsymbol{\\mu}+\\boldsymbol{\\omega}\\wedge\\boldsymbol{\\upsilon}\\)  ；\n  交换律一般不成立，但有： \\( \\boldsymbol{\\omega}\\wedge\\boldsymbol{\\mu}=(-1)^{lm}\\boldsymbol{\\mu}\\wedge\\boldsymbol{\\omega}\\quad \\boldsymbol{\\omega}\\in\\Lambda(l),\\boldsymbol{\\mu}\\in\\Lambda(m) \\)    微分形式的基底展开和分量 正如前面关于维度的提示，很容易写出微分形式的基底展开和分量表达式： \\[ \\omega_{a_1\\dots a_l}=\\sum_C{\\omega_{\\mu_1\\dots\\mu_l}(e^{\\mu_1})_{a_1}\\wedge\\dots\\wedge (e^{\\mu_l})_{a_l}}=\\frac{1}{l!}\\omega_{\\mu_1\\dots\\mu_l}(e^{\\mu_1})_{a_1}\\wedge\\dots\\wedge (e^{\\mu_l})_{a_l}\\\\ \\\\ \\omega_{\\mu_1\\dots\\mu_l}=\\omega_{a_1\\dots a_l}(e_{\\mu_1})^{a_1}\\dots (e_{\\mu_l})^{a_l} \\]  其中， \\(C\\)  表示对偶基底的某种组合。没求和符则默认相同上下指标缩并。\n特别地， \\(\\boldsymbol{\\omega}\\overset{\\Delta}{=}\\omega_{a_1\\dots a_n}\\in \\Lambda_M(n)\\)  的展开只有一项（第二式是简写）： \\[ \\omega_{a_1\\dots a_n}=\\omega_{1\\dots n} (e^1)_{a_1}\\wedge\\dots\\wedge (e^n)_{a_n} \\\\ \\\\ \\boldsymbol{\\omega}=\\omega_{1\\dots n} e^1\\wedge\\dots\\wedge e^n \\]  流形上的微分形式场 对流形 \\(M\\)  的每个点 \\(p\\)  都指定 \\(V_p\\)  上的一个 \\(l\\)  形式，就得到 \\(M\\)  上的一个 \\(l\\)  形式场。 用 \\(\\Lambda_M(l)\\)  代表 \\(M\\)  上全体形式场的集合。\n流形上的定向 根据 \\(n\\)  维流形上的 \\(n\\)  形式场展开式只有唯一项的事实，知道任意两个 \\(n\\)  形式场只相差一个标量场因子： \\[ \\boldsymbol{\\omega}_1=h \\boldsymbol{\\omega}_2,\\quad \\forall \\boldsymbol{\\omega}_1,\\boldsymbol{\\omega}_2 \\in \\Lambda_M(n),h\\in \\mathscr{F}_M \\]  我们知道，如果连续标量场(流形上的连续函数) \\(h\\)  处处非零，那么 \\(h\\)  要么处处为正，要么处处为为负。　于是连续的 \\(n\\)  形式场处处非零，那么该微分形式场也要么处处为正，要么处处为为负。　据此可引入流形的可定向概念。\n \\(n\\)  维流形 \\(M\\)  称为可定向的，若其上存在 \\(C^0\\)  且处处非零的 \\(n\\)  形式场 \\(\\boldsymbol{\\varepsilon}\\)  。 如果两个 \\(n\\)  形式场处处同号（相差的标量场因子始终为正），则称是同一个定向。\n比如： \\(\\mathbb{R}^3\\)  就是可定向流形，因为其上存在 \\(C^\\infty\\)  的3形式场 \\(\\boldsymbol{\\varepsilon}=dx\\wedge dy\\wedge dz\\)  。\n右手系、左手系 一旦选定了流形 \\(M\\)  的定向(如果可定向的话)，所谓右手基底场，就是保证 \\(n\\)  形式场的分量场（标量场）始终为正的基底场；始终为负的情况，就是左手基底场。\n如果选择的是坐标系的话，就分别对应右手系和左手系。\n体元、度规适配体元 1. 体元 前面所提及的，可定向 \\(n\\)  维流形 \\(M\\)  所存在的处处连续非零的 \\(n\\)  形式场 \\(\\boldsymbol{\\varepsilon}\\)  ，就是一个体元。 并知道体元不是唯一的，但最多相差一个标量场因子。\n如果流形上给定了度规 \\(g_{ab}\\)  ，那么 \\[ \\begin{aligned}\\varepsilon^{a_1\\dots a_n}\\varepsilon_{a_1\\dots a_n}=\u0026\\varepsilon^{\\mu_1\\dots \\mu_n}\\varepsilon_{\\mu_1\\dots \\mu_n}=g^{\\mu_1\\upsilon_1}\\dots g^{\\mu_n\\upsilon_n}\\varepsilon_{\\mu_1\\dots \\mu_n}\\varepsilon_{\\upsilon_1\\dots \\upsilon_n}\\\\ = \u0026 \\sum_{\\mu_1\\dots\\mu_n}{\\sum_{\\upsilon_1\\dots\\upsilon_n}{g^{\\mu_1\\upsilon_1}\\dots g^{\\mu_n\\upsilon_n}\\varepsilon_{\\mu_1\\dots \\mu_n}\\varepsilon_{\\upsilon_1\\dots \\upsilon_n}}}\\\\ = \u0026 \\sum_{\\mu_1\\dots\\mu_n}{(-1)^{\\pi(\\mu_1\\dots \\mu_n)}\\sum_{\\upsilon_1\\dots\\upsilon_n}{(-1)^{\\pi(\\upsilon_1\\dots \\upsilon_n)}g^{\\mu_1\\upsilon_1}\\dots g^{\\mu_n\\upsilon_n}}}(\\varepsilon_{1\\dots n})^2\\\\ = \u0026 n! \\sum_{\\upsilon_1\\dots\\upsilon_n}{(-1)^{\\pi(\\upsilon_1\\dots \\upsilon_n)}g^{1\\upsilon_1}\\dots g^{n\\upsilon_n}}(\\varepsilon_{1\\dots n})^2\\\\ = \u0026 n! \\det\\left(g^{\\mu\\upsilon}\\right)(\\varepsilon_{1\\dots n})^2\\end{aligned} \\]  其中： \\(\\pi(\\mu_1\\dots\\mu_n)\\)  表示全排列的逆序数。倒数第二个等号是因为内层求和具有行列式的特征，外层求和的 \\((-1)^{\\pi(\\mu_1\\dots\\mu_n)}\\)  表示对内层行列式进行 \\(\\pi(\\mu_1\\dots\\mu_n)\\)  次行交换，就能把 \\((\\mu_1\\dots\\mu_n)\\)  变成 \\((1\\dots n)\\)  ，而全排列项数是 \\(n!\\)  。最后用行列式符号表示。\n如果选择正交归一基底，那么度规矩阵可以写成对角元素为 \\(\\pm 1\\)  的对角矩阵，进而 \\[ \\varepsilon^{a_1\\dots a_n}\\varepsilon_{a_1\\dots a_n}=(-1)^s n!(\\varepsilon_{1\\dots n})^2 \\]  其中， \\(s\\)  是度规对角元素是 \\(-1\\)  的个数。\n2. 度规适配体元 进一步要求（右手系取正，左手系取负） \\[ \\varepsilon_{1\\dots n}=\\pm 1 \\]  于是有 \\[ \\varepsilon^{a_1\\dots a_n}\\varepsilon_{a_1\\dots a_n}=(-1)^s n! \\]  称此时的 \\(\\varepsilon_{a_1\\dots a_n}\\)  为与度规 \\(g_{ab}\\)  相适配的体元。\n适配体元对应的 \\(\\varepsilon^{a_1\\dots a_n}\\varepsilon_{a_1\\dots a_n}\\)  作为绝对量，和基底的选择无关，所以对任意基底 \\(\\{(e_\\mu)^a\\}\\quad \\{(e^\\mu)_a\\}\\)  ，下式成立: \\[ \\begin{aligned}\u0026n! \\det\\left(g^{\\mu\\upsilon}\\right)(\\varepsilon_{1\\dots n})^2=(-1)^s n!\\\\ \\Rightarrow \u0026 (\\varepsilon_{1\\dots n})^2=(-1)^s \\det\\left(g_{\\mu\\upsilon}\\right)\\overset{\\Delta}{=}(-1)^s g\\\\ \\Rightarrow \u0026 \\varepsilon_{1\\dots n}=\\pm \\sqrt{|g|} \\quad \\text{右手系取正，左手系取负}\\end{aligned} \\]  所以度规 \\(g_{ab}\\)  适配体元 \\(\\varepsilon_{a_1\\dots a_n}\\)  可写成（右手系取正，左手系取负）： \\[ \\varepsilon_{a_1\\dots a_n}=\\pm \\sqrt{|g|}(e^1)_{a_1}\\wedge\\dots\\wedge(e^n)_{a_n},\\quad g=\\det(g_{\\mu\\upsilon}) \\]  特别地，对正交归一基底， \\(|g|=1\\)  。\n3. 度规适配体元性质   度规适配导数算符作用于度规适配体元得0，即 \\( \\nabla_b \\varepsilon_{a_1\\dots a_n}=0 \\)    两个有用的关系： \\( \\varepsilon^{a_1\\dots a_n}\\varepsilon_{b_1\\dots b_n}=(-1)^s n!\\delta^{[a_1}_{\\ \\ b_1}\\dots\\delta^{a_n]}_{\\ \\ b_n} \\\\ \\quad \\\\ \\varepsilon^{a_1\\dots a_j a_{j+1} \\dots a_n}\\varepsilon_{a_1\\dots a_j b_{j+1} \\dots b_n}=(-1)^s (n-j)!j!\\delta^{[a_{j+1}}_{\\ \\ \\quad b_{j+1}}\\dots\\delta^{a_n]}_{\\ \\ b_n} \\)    对偶微分形式 注意到 \\(l\\)  形式和 \\((n-l)\\)  形式具有相同的维度 \\[ \\dim \\Lambda_p(l)=\\frac{n!}{l!(n-l)!}=\\dim \\Lambda_p(n-1) \\]  考虑定向流形 \\((M,g_{ab})\\)  ， \\(\\boldsymbol{\\varepsilon}\\)  是度规适配体元，于是可以定义一个同构映射\n\\[ \\begin{aligned}^*:\u0026\\Lambda_M(l) \u0026\\to\u0026 \\Lambda_M(n-l)\\\\ \u0026 \\omega_{a_1\\dots a_n} \u0026\\mapsto\u0026 *\\omega_{a_1\\dots a_n}\\overset{\\Delta}{=}\\frac{1}{l!}\\omega^{b_1\\dots b_l}\\varepsilon_{b_1\\dots b_l a_1\\dots a_{n-l}}\\end{aligned} \\]   \\(^*\\)  称作霍奇星算子（Hodge star）， \\(^*\\boldsymbol{\\omega}\\)  称作 \\(\\boldsymbol{\\omega}\\)  的对偶微分形式。\n特别地\n\\[ \\begin{aligned}(^*f)_{a_1\\dots a_n}=\\frac{1}{0!}f \\varepsilon_{a_1\\dots a_n}=f \\varepsilon_{a_1\\dots a_n}\\\\ ^*(^*f)=^*(f\\boldsymbol{\\varepsilon})=\\frac{1}{n!}f \\varepsilon_{a_1\\dots a_n}=(-1)^sf\\end{aligned} \\]  一般地 \\[ ^*{^*\\boldsymbol{\\omega}}=(-1)^{s+l(n-l)}\\boldsymbol{\\omega} \\]  三维欧氏空间的矢量代数 1. 符号解释 \\[ \\vec{A}\\overset{\\Delta}{=}A^a \\quad \\boldsymbol{A}\\overset{\\Delta}{=}A_a=\\delta_{ab}A^b\\\\ \\vec{A}\\cdot\\vec{B}\\overset{\\Delta}{=}A_a B^a \\\\ \\vec{A}\\times\\vec{B}\\overset{\\Delta}{=}{^*(\\boldsymbol{A}\\wedge\\boldsymbol{B})}=\\varepsilon_{abc}A^aB^b \\]  2. 导数算符 \\[ \\vec{\\nabla}\\overset{\\Delta}{=}\\nabla_a=\\partial_a \\\\ \\vec{\\nabla}f=\\partial_a f\\quad \\vec{\\nabla}\\cdot\\vec{A}=\\partial_a A^a \\quad \\vec{\\nabla}\\times\\vec{A}=\\varepsilon^{abc}\\partial_a A^b \\\\ \\vec{\\nabla}\\cdot(\\vec{A}\\vec{B})=\\partial_a(A^a B^b) \\\\ \\vec{\\nabla}\\vec{A}=\\partial^a A^b \\quad \\nabla^2 f=\\partial_a\\partial^a f\\quad \\nabla^2 \\vec{A}=\\partial_a\\partial^a A^b \\]  3. 常用公式（可用普通导数算符和抽象指标简化推导） \\[ \\vec{\\nabla}\\cdot(\\vec{A}\\times\\vec{B})=\\vec{B}\\cdot(\\vec{\\nabla}\\times\\vec{A}) - \\vec{A}\\cdot(\\vec{\\nabla}\\times\\vec{B})\\\\ \\quad \\\\ \\vec{\\nabla}(\\vec{A}\\cdot\\vec{B})=(\\vec{A}\\cdot\\vec{\\nabla})\\vec{B}+(\\vec{B}\\cdot\\vec{\\nabla})\\vec{A}+\\vec{A}\\times(\\vec{\\nabla}\\times\\vec{B})+\\vec{B}\\times(\\vec{\\nabla}\\times\\vec{A}) \\] "}),a.add({id:157,href:'/notes/tags/%E5%AD%90%E6%B5%81%E5%BD%A2/',title:"子流形",content:""}),a.add({id:158,href:'/notes/docs/diffgeo/0012/',title:"子流形和超曲面",content:" 嵌入，就是\u0026quot;足够像\u0026quot;地映射到更高维流形“内部”。这种“内部”区域就是子流形。\n超曲面，就是低一维的子流形。\n法余矢，就是能够和超曲面矢量基底一起张成\u0026quot;母\u0026quot;流形的一个矢量基底所对应的对偶矢量基底。\n法矢，就是存在度规情况下，用度规将法余矢的指标\u0026quot;提升\u0026quot;得到矢量。\n诱导度规，就是和\u0026quot;母\u0026quot;流形度规保持\u0026quot;自然一致\u0026quot;的子流形度规。\n投影映射，就是诱导度规\u0026ldquo;下降\u0026quot;一个指标，也是将\u0026quot;母\u0026quot;流形任意矢量投影到子流形切空间的映射。\n 嵌入映射与嵌入子流形 映射   \\(\\phi:S\\to M,\\quad \\dim S \\le \\dim M=n\\)  称为嵌入，如果：\n  \\(\\phi:S\\to \\phi[S](\\subset M)\\)  是同胚映射；  \\(\\phi_*V_p \\to V_{\\phi(p)},\\quad \\forall p\\in S\\)  是非退化的，即 \\(\\phi_* v^a \\Rightarrow v^a=0\\)  。  利用嵌入映射 \\(\\phi\\)  ,可以称 \\(S\\)  或 \\(\\phi[S]\\)  是 \\(M\\)  (嵌入)子流形。\n特别地，如果 \\(\\dim S=n-1\\)  ，那么称 \\(S\\)  或 \\(\\phi[S]\\)  是 \\(M\\)  的一张超曲面。\n超曲面得切平面、法余矢、法矢 设 \\(\\phi[S]\\)  是 \\(M\\)  的超曲面及上的点 \\(q\\in\\phi[S]\\subset M\\)  。\n从 \\(M\\)  角度来看，有 \\(q\\)  点的 \\(n\\)  维切空间 \\(V_q\\)  。　从 \\(\\phi[S]\\)  角度来看，也有 \\(q\\)  点的 \\((n-1)\\)  维切空间 \\(W_q\\)  。 任意 \\(w^a\\in W_q\\)  都是沿 \\(\\phi[S]\\)  上的某曲线的切矢，这条曲线同时也是 \\(M\\)  上的曲线，所以 \\(w^a\\in V_q\\)  ，即 \\(W_q \\subset V_q\\)  。\n非零对偶矢量 \\(n_a\\in V^*_q\\)  称为超曲面 \\(\\phi[S]\\)  在 \\(q\\)  点法余矢，若 \\(n_a w^a=0,\\quad \\forall w^a\\in W_q\\)  。\n如果 \\(M\\)  上有度规 \\(g_{ab}\\)  ，那么 \\(n^a\\overset{\\Delta}{=}g^{ab}n_a\\in V_q\\)  与 \\(\\phi[S]\\)  的所有矢量正交。因为, \\[ g_{ab}n^a w^a=n_a w^a=0,\\quad \\forall w^a\\in W_q \\]  所以可称 \\(n^a\\)  为超曲面 \\(\\phi[S]\\)  在 \\(p\\)  点的法矢。\n超曲面单位法余矢的唯一性 我们知道 \\(W_q\\)  可由最大线性无关基底 \\(\\{(e_2)^a,\\dots,(e_n)^a\\}\\)  张成，自然也可选作 \\(V_q\\)  的 \\((n-1)\\)  个线性无关基底，必然可从 \\(V_q\\)  选出与这 \\((n-1)\\)  都线性无关的元素，记做 \\((e_1)^a\\)  。于是 \\(V_q\\)  可由最大线性无关基底 \\(\\{(e_\\mu)^a|\\mu=1,\\dots,n\\}\\)  张成，进而有一组对偶基底 \\(\\{(e^\\mu)_a\\}\\)  。 可取 \\(n_a=(e^1)_a\\)  ，有 \\(n_a(e_\\tau)^a=\\delta^1_{\\ \\tau}=0,\\quad \\tau=2,\\dots,n\\)  ，因此这个 \\(n_a\\)  就是法余矢。若 \\(m_a\\ne n_a\\)  也是法余矢，那么 \\(m_\\tau =m_a(e_\\tau)^a=0(\\tau=2,\\dots)\\)  ，进而 \\(m_a=m_1(e^1)_a=m_1 n_a\\)  。\n所以，超曲面 \\(\\phi[S]\\)  上任意点 \\(q\\)  必有法余矢，唯一到相差常数因子。　但对一般的嵌入子流形(比如三维流形中的曲线)的法余矢没有这样的唯一性。\n标量场梯度是对应等值超曲面的法余矢 考虑 \\(\\phi[S]\\)  是由 \\(f=const. \\quad f\\in \\mathscr{F}_M\\)  给出的超平面。对任意 \\(w^a\\in V_q\\)  ， \\(w^a\\)  总切于超曲面 \\(\\phi[S]\\)  上的某条曲线 \\(C(t)\\)  ，于是： \\[ w^a (\\nabla_a f)=w^a \\partial_a f=0 \\]  着意味着 \\(\\nabla_a f\\)  的确是 \\(\\phi[S]\\)  的法余矢。\n超曲面的分类 对黎曼流形而言，给定的度规是正定的，必然有 \\(n^a n_b=g_{ab}n^a n^b  0\\)  。但对非正定度规的伪黎曼流形而言， \\(n^a n_b\\)  正负零都可能。\n法矢处处类时（ \\(n^a n_b）的超曲面是类空的；法矢处处类空（ \\(n^a n_b0\\)  ）的超曲面是类时的；法矢处处类光（ \\(n^a n_b=0\\)  ）的超曲面也是类光的。\n所以黎曼流形中的超平面都是类时的，对应的法矢是类空的。\n类光超曲面的法矢就躺在超曲面切空间上，即 \\(n^a\\in W_q \\Leftrightarrow n^a n_b=0\\)  。\n对类空和类时的超平面的而言，今后谈法矢时都特指归一化法矢,即 \\(n^a n_a=\\pm 1\\)  。\n子流形诱导度规、投影映射 所谓 \\(\\phi[S]\\subset M\\)  诱导度规 \\(h_{ab}\\)  就是将 \\(M\\)  上的度规 \\(g_{ab}\\)  作用对象限制在 \\(\\phi[S]\\)  的切平面 \\(W_q\\)  上的结果。　也就是说： \\[ h_{ab} u^a w^a=g_{ab}u^a w^a,\\quad \\forall u^a,w^a\\in W_q \\]  注意 \\(n_a n_b u^a w^a=(n_a u^a)(n_b w^a)=0\\)  ，所以一个合理猜测，并做变换： \\[ \\begin{aligned}\u0026h_{ab}=g_{ab}-\\lambda n_a n_b\\\\ \\Leftrightarrow \\quad \u0026 h^a_{\\ b}=g^{ac}h_{cb}=\\delta^a_{\\ b}-\\lambda n^a n_b\\\\ \\Leftrightarrow \\quad \u0026 h^a_{\\ b}v^b=v^a-\\lambda n^a (n_b v^b)\\quad \\forall v^a\\in V_q\\\\ \\Leftrightarrow \\quad \u0026 v^a=h^a_{\\ b}v^b+n^a (\\lambda n_b v^b)\\end{aligned} \\]  很明显，最后一个式子似乎代表矢量 \\(v^a\\in V_q\\)  的某种分解。我们更希望这是一种正交分解，就是希望： \\[ \\begin{aligned}0=\u0026 n_a(h^a_{\\ b}v^b)\\\\ =\u0026 n_a(\\delta^a_{\\ b}-\\lambda n^a n_b)v^b\\\\ =\u0026 n_b v^b-\\lambda n^a n_a n_b v^b\\\\ =\u0026 (1-\\lambda n^a n_a )n_b v^b \\quad \\forall v^b\\in V_q\\end{aligned} \\]  考虑到 \\(v^b\\)  选择的任意性以及 \\(n^a\\)  默认是归一化法矢，于是有 \\(\\lambda=\\pm1\\)  。根据上述分析，可直接写出下面的两个结论：\n 诱导度规可表示成： \\[ h_{ab}=g_{ab}\\mp n_a n_b,\\quad \\text{加减号与}n^a n_a\\text{的符号相反} \\]   任意矢量 \\(v^a\\in V_q\\)  可进行正交分解： \\[ v^a=h^a_{\\ b}v^b\\pm n^a (n_b v^b),\\quad \\text{加减号与}n^a n_a\\text{的符号一致} \\]  其中， \\(v^a_{\\parallel}\\overset{\\Delta}{=}h^a_{\\ b} v^b\\in W_q\\)  称为 \\(v^a\\)  在 \\(\\phi[S]\\)  切向分量， \\(h^a_{\\ b}:V_q\\to W_q\\)  则是投影映射。 \\(v^a_{\\perp}\\overset{\\Delta}{=}\\pm n^a(n_b v^b)\\)  是与法矢 \\(n^a\\)  平行的法向分量。 "}),a.add({id:159,href:'/notes/tags/%E5%B5%8C%E5%85%A5/',title:"嵌入",content:""}),a.add({id:160,href:'/notes/tags/%E6%8A%95%E5%BD%B1%E6%98%A0%E5%B0%84/',title:"投影映射",content:""}),a.add({id:161,href:'/notes/tags/%E6%B3%95%E4%BD%99%E7%9F%A2/',title:"法余矢",content:""}),a.add({id:162,href:'/notes/tags/%E6%B3%95%E7%9F%A2/',title:"法矢",content:""}),a.add({id:163,href:'/notes/tags/%E8%AF%B1%E5%AF%BC%E5%BA%A6%E8%A7%84/',title:"诱导度规",content:""}),a.add({id:164,href:'/notes/tags/%E8%B6%85%E6%9B%B2%E9%9D%A2/',title:"超曲面",content:""}),a.add({id:165,href:'/notes/docs/diffgeo/0011/',title:"Killing矢量场",content:" Killing矢量场描述了(伪)黎曼流形的对称性，每一种对称性都与一个Killing矢量场相关联。\n 等度规映射 给定度规的流形   \\((M,g_{ab})\\)  ，不但可以谈微分同胚映射，还可进一步谈等度规映射: \\[ \\phi:M\\to M, \\quad \\phi^*g_{ab}=g_{ab} \\]  Killing矢量场及数学形式 很自然也可谈单参等度规群。能给出了单参等度规(局域)群的矢量场 \\(\\xi^a\\)  被称作Killing矢量场，等价于 \\(\\mathscr{L}_{\\xi} g_{ab}=0\\)  。因为： \\[ \\mathscr{L}_{\\xi} g_{ab}=\\lim_{t\\to 0}{\\frac{1}{t}(\\phi^*_t g_{ab}-g_{ab})}=0 \\]  Killing方程 进而等价于Killing方程  \\(\\nabla_{(a} \\xi_{b)}=0\\)  。因为： \\[ \\begin{aligned}0\u0026=\\mathscr{L}_{\\xi} g_{ab}\\\\ \u0026=\\xi^c \\nabla_c g_{ab} + g_{ca} \\nabla_b \\xi^c+ g_{cb} \\nabla_a \\xi^c\\\\ \u0026=\\nabla_b \\xi_a + \\nabla_a \\xi_b\\quad\\text{度规适配导数算符，并降指标}\\\\ \u0026=2 \\nabla_{(a} \\xi_{b)}\\end{aligned} \\]  Killing矢量场适配坐标系 Killing矢量场 \\(\\xi^a\\)  在其适配坐标系 \\(\\{x^\\mu\\},\\quad \\xi^a=(\\partial/\\partial x^1)^a\\)  中满足 \\(\\partial g_{\\mu\\upsilon}/\\partial x^1=0\\)  ，反之依然。因为： \\[ 0=(\\mathscr{L}_\\xi g)_{\\mu\\upsilon}=\\frac{\\partial g_{\\mu\\upsilon}}{\\partial x^1} \\]  Killing矢量场与测地线 测地线切矢 \\(T^a\\)  与Killing矢量场 \\(\\xi^a\\)  沿测地线“内积”不变： \\(T^a\\nabla_a(T^b\\xi_b)=0\\)  。因为: \\[ \\begin{aligned}T^a\\nabla_a(T^b\\xi_b)=\u0026 \\xi_bT^a\\nabla_aT^b+T^aT^b\\nabla_a\\xi_b\\\\ =\u0026 T^aT^b\\nabla_a\\xi_b\\quad \\text{用到测地线定义}\\\\ =\u0026 T^{(a}T^{b)}\\nabla_{[a}\\xi_{b]}=0\\quad \\text{用到Killing方程，并异种括号缩并为０}\\end{aligned} \\]  Killing矢量场基本性质  线性性：Killing矢量场的集合也构成矢量空间 \\(\\mathscr{K}_M\\)  ； 对易子封闭性： \\([u,v]^a\\in\\mathscr{K}_M,\\quad \\forall u^a,v^a \\in \\mathscr{K}_M\\)  ； 自由度： \\(\\dim \\mathscr{K}_M \\le n(n+1)/2, \\quad n=\\dim M\\)  。  称 \\((M,g_{ab})\\)  是最高对称性空间，如果 \\(\\dim \\mathscr{K}_M = n(n+1)/2\\)  。\n寻找全体Killing矢量场 一般方法是求解Killing方程通解，但对简单的情况可以采用猜解再验证的方法。\n猜解验证法 以二维欧氏空间 \\((\\mathbb{R}^2,\\delta_{ab})\\)  为例，相信此空间具有最高对称性，应该有 \\(n(n+1)/2=3\\)  个独立Killing矢量场。\n很自然想到：两个方向平移和一个转动。\n如果选择笛卡尔坐标系 \\(\\{x,y\\}\\)  ，线元 \\(ds^2=dx^2+dy^2\\)  ，欧氏度规 \\(\\delta_{ab}\\)  在此系中分量都是常数，所以 \\((\\partial/\\partial x)^a\\)  和 \\((\\partial/\\partial y)^a\\)  都为Killing矢量场，并且相互独立。\n再选择极坐标系 \\(\\{r,\\varphi\\}\\)  ，线元 \\(ds^2=dr^2+r^2d\\varphi^2\\)  ，欧氏度规 \\(\\delta_{ab}\\)  在此系中分量都与 \\(\\varphi\\)  无关，所以只有 \\((\\partial/\\partial \\varphi)^a\\)  是Killing矢量。 用笛卡尔坐标基底展开： \\[ \\begin{aligned}\\left(\\frac{\\partial}{\\partial\\varphi}\\right)^a=\u0026\\frac{\\partial x}{\\partial \\varphi} \\left(\\frac{\\partial}{\\partial x}\\right)^a +\\frac{\\partial y}{\\partial \\varphi}\\left(\\frac{\\partial}{\\partial y}\\right)^a\\\\ =\u0026 -r\\sin\\varphi \\left(\\frac{\\partial}{\\partial x}\\right)^a +r\\cos\\varphi\\left(\\frac{\\partial}{\\partial y}\\right)^a\\\\ =\u0026 -y \\left(\\frac{\\partial}{\\partial x}\\right)^a +x\\left(\\frac{\\partial}{\\partial y}\\right)^a\\end{aligned} \\]  Killing方程通解法 以二维闵氏空间 \\((\\mathbb{R}^2,\\eta_{ab})\\)  为例，选择洛伦兹坐标系 \\(\\{t,x\\}\\)  ，线元 \\(ds^2=-dt^2+dx^2\\)  。\n用julia列出所有独立的Killing方程：\nusing SymPy # 选择洛伦兹坐标系 @vars t x real=true X = [t,x] # 待求的Killing矢量场的分量 ξ = SymFunction(\u0026#34;ξ^1,ξ^2\u0026#34;) # 闵氏度规及逆度规 g = sympy.eye(2) .* [-1,1] gi = inv(g) # 根据度规计算克氏符 Γ = sum([(1//2)*gi[σ,ρ]*(diff(g[μ,ρ],X[υ])+ diff(g[υ,ρ],X[μ])-diff(g[μ,υ],X[ρ])) for μ in 1:2,υ in 1:2 ,σ in 1:2] for ρ in 1:2) # 列出所有独立Killing方程组 eqs = [(0⩵diff(sum(g[υ,ρ]*ξ[ρ](t,x) for ρ in 1:2),X[μ])+ diff(sum(g[μ,ρ]*ξ[ρ](t,x) for ρ in 1:2),X[υ])- 2*sum(Γ[μ,υ,σ]*sum(g[σ,ρ]*ξ[ρ](t,x) for ρ in 1:2) for σ in 1:2)) for μ in 1:2,υ in 1:2 if μ ≤ υ ] 执行的结果： \\[ \\left[ \\begin{array}{r}0 = - 2 \\frac{\\partial}{\\partial t} \\operatorname{ξ^{1}}{\\left (t,x \\right )}\\\\0 = - \\frac{\\partial}{\\partial x} \\operatorname{ξ^{1}}{\\left (t,x \\right )} + \\frac{\\partial}{\\partial t} \\operatorname{ξ^{2}}{\\left (t,x \\right )}\\\\0 = 2 \\frac{\\partial}{\\partial x} \\operatorname{ξ^{2}}{\\left (t,x \\right )}\\end{array} \\right] \\]  由方程１和３有 \\(\\xi^1(t,x)=h(x),\\xi^2(t,x)=g(t)\\)  ，代入方程２得： \\[ \\frac{\\partial h(x)}{\\partial x}=\\frac{\\partial g(t)}{\\partial t}=C \\]  当 \\(C=0\\)  时，有 \\(\\xi^1(t,x)=h(x)=c_1, \\xi^2(t,x)=g(t)=c_2\\)  , 即有两个独立特解： \\[ \\xi^a=(\\frac{\\partial}{\\partial t})^a,\\quad \\xi=(1,0)\\\\ \\xi^a=(\\frac{\\partial}{\\partial x})^a,\\quad \\xi=(0,1) \\]  当 \\(C\\neq0\\)  时，有 \\(\\xi^1(t,x)=h(x)=C x, \\xi^2(t,x)=g(t)=C t\\)  ，由此到一个独立特解： \\[ \\xi^a=x(\\frac{\\partial}{\\partial t})^a+t(\\frac{\\partial}{\\partial x})^a,\\quad \\xi=(x,t) \\]  "}),a.add({id:166,href:'/notes/tags/%E6%B5%8B%E5%9C%B0%E7%BA%BF/',title:"测地线",content:""}),a.add({id:167,href:'/notes/tags/%E7%9F%A2%E9%87%8F%E5%9C%BA/',title:"矢量场",content:""}),a.add({id:168,href:'/notes/tags/%E7%AD%89%E5%BA%A6%E8%A7%84%E6%98%A0%E5%B0%84/',title:"等度规映射",content:""}),a.add({id:169,href:'/notes/tags/%E5%BB%B6%E6%8B%93/',title:"延拓",content:""}),a.add({id:170,href:'/notes/tags/%E5%BE%AE%E5%88%86%E5%90%8C%E8%83%9A/',title:"微分同胚",content:""}),a.add({id:171,href:'/notes/tags/%E6%8B%89%E5%9B%9E%E6%98%A0%E5%B0%84/',title:"拉回映射",content:""}),a.add({id:172,href:'/notes/tags/%E6%8E%A8%E5%89%8D%E6%98%A0%E5%B0%84/',title:"推前映射",content:""}),a.add({id:173,href:'/notes/tags/%E6%96%B9%E5%90%91%E5%AF%BC%E6%95%B0/',title:"方向导数",content:""}),a.add({id:174,href:'/notes/tags/%E6%9D%8E%E5%AF%BC%E6%95%B0/',title:"李导数",content:""}),a.add({id:175,href:'/notes/docs/diffgeo/0010/',title:"流形上的李导数",content:" 李导数是沿矢量场对张量场的导数，也是沿矢量场坐标线对张量分量的普通导数。\n为了清晰定义李导数，引入了单参数微分同胚群   \\(\\phi:\\mathbb{R}\\times M\\to M\\)  ，然后利用拉回映射及其逆映射 \\(\\phi_t^*=(\\phi^{-1}_t)_*=(\\phi_{-t})_*\\)  将同一轨道上的 \\(q=\\phi(p)\\)  点上的张量拉回成点 \\(p\\)  的张量，于是可以进行相加减，进而可以合理定义极限。\n引入矢量场的适配坐标系，得到李导数在适配坐标系中的分量表达式。\n然后，有李导数作用到任意张量的一般表达式。\n最后，分析了李导数和方向导数的关系\n 单参微分同胚群 可以考虑流形 \\(M\\)  到其自身的微分同胚映射 \\(\\phi:M\\to M\\)  ，这个映射可以有两种理解：１）主动观点，此时流形 \\(M\\)  \u0026quot;不动\u0026quot;，只是将内部一个点变换到另一个点，这是点变换，；２）被动观点，由于第二个 \\(M\\)  相对第一个 \\(M\\)  发生了某种意义上的\u0026quot;转动\u0026quot;，导致固定在第二个 \\(M\\)  上点的局域坐标系相对第一个 \\(M\\)  上的局域坐标系发生了变换，这是坐标变换。\n如果我们只关注被动观点的“转动”（虽然它导致了坐标变换），这里打引号，只是借用“圆球转动”形象说明而已。为了更准确描述这个\u0026quot;转动\u0026quot;过程，需要引入一个参数 \\(t\\in\\mathbb{R}\\)  ，进而引入单参数微分同胚群 \\(\\phi:\\mathbb{R}\\times M \\to M\\)  ，满足：\n  \\(\\phi_t\\)  是微分同胚映射： \\(\\phi_t:M\\to M, \\quad \\forall t\\in \\mathbb{R}\\)  ； 单参\u0026quot;转动\u0026quot;抽象化： \\(\\phi_t\\circ\\phi_s=\\phi_{t+s},\\quad \\forall t,s\\in \\mathbb{R}\\)  。  同时注意集合 \\(\\{\\phi_t|t\\in \\mathbb{R}\\}\\)  是以复合映射为乘法的群，所以命名为\u0026quot;单参微分同胚群”。\n对任意一点 \\(p\\in M\\)  ，在 \\(\\phi\\)  的作用下(满足 \\(\\phi_p(0)=\\phi_0|_p=p\\)  ), \\(\\phi_p(t),\\forall t\\in \\mathbb{R}\\)  构成一个过 \\(p\\)  点的光滑曲线，称之为 \\(\\phi\\)  过 \\(p\\)  点的轨道。 这个轨道在点 \\(\\phi_p(0)\\)  必然有切矢 \\(v^a|_p\\)  ，于是得到上的一个光滑矢量场 \\(v^a\\in\\mathscr{F}_M(1,0)\\)  。这意味着：M上的一个单参数微分同胚群给出了M上的一个光滑矢量场。\n另一方面，如果给定一个光滑矢量场 \\(v^a\\in\\mathscr{F}_M(1,0)\\)  ，对任意一个点 \\(p\\in M\\)  ，我们都可以得到过 \\(p\\)  的积分曲线 \\(C(t),C(0)=p\\)  ，进而可以定义 \\(\\phi_p(t)=C(t),\\forall t\\in\\mathbb{R},p\\in M\\)  ，这就是一个单参数微分同胚局域群（考虑到微分的局域性，所以加入\u0026quot;局域\u0026quot;限定）。　所以有结论：M上的一个光滑矢量场给出了M上的一个单参数微分同胚局域群。\n李导数 对于 \\(M\\)  上给定的一个单参微分同胚群 \\(\\phi\\)  中的群元 \\(\\phi_t:M\\to M\\)  ，可看成流形间的映射，再考虑微分同胚性，那么可以对流形上的任意张量场 \\(T\\)  进行拉回 \\(\\phi_t^*T\\)  和推前 \\(\\phi_{t*}T\\)  的操作。\n考虑矢量场 \\(v^a\\in \\mathscr{F}_M(1,0)\\)  是由单参数微分同胚群 \\(\\phi:\\mathbb{R}\\times M \\to M\\)  确定的，一般而言，我们无法对 \\(\\phi_t(T)\\)  和 \\(T=\\phi_0(T)\\)  进行比较，因为这两个张量场的每对张量都对应不同点 \\(p\\)  和 \\(\\phi_t(p)\\)  ，即 \\(\\left.\\phi_t(T)\\right|_{\\phi_t(p)}\\)  和 \\(T|_p\\)  。但可利用 \\(\\phi_t^*\\)  把 \\(\\left.\\phi_t(T)\\right|_{\\phi_t(p)}\\)  拉回成 \\(p\\)  点的张量 \\(\\left.\\phi_t^*(T)\\right|_p\\overset{\\Delta}{=}\\left.\\phi^*[\\phi_t(T)]\\right|_p,\\quad \\forall p\\in M\\)  。于是可以定义某种导数： \\[ \\mathscr{L}_v T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots a_l}\\overset{\\Delta}{=}\\lim_{t\\to 0}{\\left[\\frac{1}{t}\\left(\\phi_t^* T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots a_l}-T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots a_l}\\right)\\right]} \\]  称之为 \\(T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots a_l}\\)  沿矢量场 \\(v^a\\)  的李导数。\n李导数在适配坐标系分量 由于李导数 \\(\\mathscr{L}_v\\)  是沿矢量场 \\(v^a\\)  定义的，我们就选 \\(v^a\\)  对应的积分曲线为 \\(x^1\\)  坐标线, 其它坐标线需要保持沿 \\(x^1\\)  平移即可，就得到一个矢量场 \\(v^a\\)  的适配坐标系，在这种坐标系中 \\(v^a=(\\partial/\\partial x^1)^a\\)  。\n根据微分同胚映射的主被动观点的等价性，可写出： \\[ \\left.(\\phi^* T)^{\\mu}_{\\ \\upsilon}\\right|_p=\\left.(\\phi_{-t*}T)^{\\mu}_{\\ \\upsilon}\\right|_{\\phi_{-t}(q)}=\\left.T'^{\\mu}_{\\ \\ \\upsilon}\\right|_q=\\left[\\frac{\\partial x'^\\mu}{\\partial x^\\rho}\\frac{\\partial x^\\sigma}{\\partial x'^\\upsilon}T^\\rho_{\\ \\ \\sigma}\\right]_q,\\quad q=\\phi(p) \\]  由于选择了 \\(v^a\\)  适配坐标系，那么坐标系的变换只涉及 \\(x^1\\)  坐标线，那么必然有： \\[ \\frac{\\partial x'^\\mu}{\\partial x^\\rho}=\\delta^\\mu_{\\ \\ \\rho}\\quad \\frac{\\partial x^\\sigma}{\\partial x'^\\upsilon}=\\delta^\\sigma_{\\ \\ \\upsilon} \\]  于是： \\[ \\left.(\\phi^* T)^{\\mu}_{\\ \\upsilon}\\right|_p=\\left.T^\\mu_{\\ \\ \\upsilon}\\right|_q,\\quad q=\\phi(p) \\]  最后有：\n\\[ \\begin{aligned}\\left.(\\mathscr{L}_v T)^{\\mu}_{\\ \\ \\upsilon}\\right|_p\u0026=\u0026 \u0026\\lim_{t\\to 0}{\\left[\\frac{1}{t}\\left(\\left.(\\phi^* T)^{\\mu}_{\\ \\upsilon}\\right|_p-\\left.T^{\\mu}_{\\ \\ \\upsilon}\\right|_p\\right)\\right]} \\\\ \u0026=\u0026 \u0026\\lim_{t\\to 0}{\\left[\\frac{1}{t}\\left(\\left.T^\\mu_{\\ \\ \\upsilon}\\right|_q-\\left.T^{\\mu}_{\\ \\ \\upsilon}\\right|_p\\right)\\right]} \\\\ \u0026=\u0026 \u0026\\frac{\\partial}{\\partial x^1}{T^{\\mu}_{\\ \\ \\upsilon}}\\end{aligned} \\]  所以，一般而言， \\(T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots a_l}\\)  沿矢量场 \\(v^a\\)  的李导数在 \\(v^a\\)  适配坐标系中的分量可写成： \\[ (\\mathscr{L}_v T)^{\\mu_1\\dots \\mu_k}_{\\ \\qquad \\upsilon_1\\dots \\upsilon_l}=\\frac{\\partial}{\\partial x^1}{T^{\\mu_1\\dots \\mu_k}_{\\ \\qquad \\upsilon_1\\dots \\upsilon_l}} \\]  李导数的表达式   李导数是线性映射： \\(\\mathscr{L}_v:\\mathscr{F}_M(k,l)\\to\\mathscr{F}_M(k,l)\\)  ；\n  李导数同缩并可交换次序；\n   \\(\\mathscr{L}_v f=v(f), \\quad \\forall f\\in \\mathscr{F}_M\\)  ；\n   \\(\\mathscr{L}_v u^a=[v,u]^a=v^b\\nabla_b u^a-u^b\\nabla_b v^a,\\quad \\forall u^a,v^a\\in \\mathscr{F}_M(1,0)\\)  ；\n   \\(\\mathscr{L}_v \\omega_a=v^b\\nabla_b\\omega_a+\\omega_b\\nabla_a v^b,\\quad \\forall v^a\\in \\mathscr{F}_M(1,0),\\omega_a\\in \\mathscr{F}_M(0,1)\\)  ；\n  更一般有： \\( \\mathscr{L}_v T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots b_l}=v^c \\nabla_c T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots b_l}-\\sum_{i=1}^k{T^{a_1\\dots c \\dots a_k}_{\\ \\ \\quad \\qquad b_1\\dots b_l}\\nabla_c v^{a_i}}\\\\ +\\sum_{j=1}^l{T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots c \\dots b_l}\\nabla_{b_j} v^c}\\\\,\\quad \\forall v^a\\in \\mathscr{F}_M(1,0),T\\in \\mathscr{F}_M(k,l) \\)    李导数和方向导数的关系 方向导数是对矢量场 \\(u^a\\)  沿曲线 \\(C(t)\\)  的导数，求导变量则是曲线参数 \\(t\\)  。对应则是李导数对矢量场 \\(u^a\\)  沿矢量场 \\(v^a\\)  的的导数，求导变量则是矢量场 \\(v^a\\)  诱导出的单参微分同胚群 \\(\\phi(t)\\)  的参数 \\(t\\)  ，随着 \\(t\\)  的变化得到一族积分曲线。\n为了能和方向导数比较，可考察特定点 \\(p\\in M\\)  上矢量场 \\(u^a\\)  沿矢量场 \\(v^a\\)  的导数，这样点 \\(p\\)  配合矢量场 \\(v^a\\)  ，可唯一确定局域积分曲线 \\(C(t)\\)  ，此时 \\(v^a\\)  就是这条曲线的切矢。　如果我们选择一个 \\(v^a\\)  适配的坐标系 \\(\\{x^\\mu\\}\\)  ，有 \\(v^a=(\\partial/\\partial x^1)^a=T^a\\)  。那么： \\[ \\begin{aligned}\u0026\\mathscr{L}_v u^a \u0026=\u0026T^b\\nabla_b u^a－u^b\\nabla_b \\left(\\frac{\\partial}{\\partial x^1}\\right)^a　\\quad \\text{第一项就方向导数}\\\\ \u0026 \u0026=\u0026\\frac{D u^a}{dt}－u^b\\partial_b \\left(\\frac{\\partial}{\\partial x^1}\\right)^a-\\Gamma^a_{\\ \\ bc}T^b u^c　\\quad \\text{第二项展开} \\\\\u0026 \u0026=\u0026\\frac{D u^a}{dt}-\\Gamma^a_{\\ \\ bc}T^b u^c　\\quad \\text{普通导数算符作用于坐标基矢为０}\\\\\u0026 \u0026=\u0026\\frac{d u^a}{dt} \\quad \\forall u^a \\in\\mathscr{F}_M(1,0)\\end{aligned} \\]  所以：作用于 \\(u^a\\)  李导数看成矢量场 \\(v^a\\)  适配坐标系下沿坐标线的普通方向导数 \\(du^a/dt\\)  。，而非正真意义上的方向导数 \\(Du^a/dt\\)  。\n"}),a.add({id:176,href:'/notes/docs/diffgeo/0009/',title:"流形间的映射",content:" 流形间的点映射   \\(\\phi\\)  ，可以看作对点的推前映射 \\(\\phi=\\phi_*\\)  ；对张量(场) \\(T\\)  的拉回映射 \\(\\phi^*\\)  ，可看成该张量(场) \\(T\\)  与某种推前映射 \\(\\phi_*\\)  的复合映射 \\(\\phi^*T=T\\circ\\phi_*\\)  ；对张量(场) \\(T\\)  的推前映射 \\(\\phi_*\\)  ，可看成该张量(场) \\(T\\)  与某种拉回映射 \\(\\phi^*\\)  的复合映射 \\(\\phi_*T=T\\circ\\phi^*\\)  。\n 考虑两个流形 \\(M,N\\)  间的一个光滑映射 \\(\\phi:M \\to N\\)  。一旦有了流形之间的映射，就可以探讨流形间张量(场)之间的映射。\n自然诱导映射的构造套路 这里，我们用构造性的方法来引入 \\(\\phi\\)  的自然诱导映射，其中 \\(T\\)  代表张量场或张量。\n \\(\\phi\\)  的所有自然诱导映射，组成集合 \\(\\mathbb{F}_{\\phi}\\)  ，其元素满足：\n 平凡元素： \\(\\phi \\in \\mathbb{F}_{\\phi}\\)  ； 构造规则：如果存在 \\(\\varphi\\in \\mathbb{F}_{\\phi}\\)  ，使得 \\(T\\)  与 \\(T\\circ\\varphi\\)  是同型张量(场)。据此可定义新的映射 \\(\\theta:T\\mapsto \\theta(T)\\overset{\\Delta}{=} T\\circ\\varphi\\)  ，那么 \\(\\theta \\in \\mathbb{F}_\\phi\\)  ； 同一认定：如果 \\(\\theta\\in \\mathbb{F}_\\phi\\)  是 \\(\\varphi\\in \\mathbb{F}_\\phi\\)  的延拓，那么认定 \\(\\theta=\\varphi\\in \\mathbb{F}_\\phi\\)  。  流形间标量场映射，拉回映射 目前已知： \\(\\phi\\in\\mathbb{F}_\\phi\\)  ， \\(\\phi\\)  是点到点的流形映射。\n为了能将标量场 \\(f\\)  和 \\(\\phi : M \\to N\\)  构造出复合映射，只能选择 \\(f:N \\to \\mathbb{R}\\)  ，进而对应复合映射 \\(f\\circ\\phi:M \\to \\mathbb{R}\\)  。因为 \\(f\\in\\mathscr{F}_N,f\\circ\\phi\\in\\mathscr{F}_M\\)  ，所以得到 \\(\\phi^*\\in\\mathbb{F}_\\phi\\)  ：\n\\[ \\begin{aligned} \u0026\\phi^* :\u0026 \\mathscr{F}_N \u0026\\to \\mathscr{F}_M \\\\ \u0026\\quad\u0026 f \u0026\\mapsto f\\circ\\phi\\\\ \u0026 \u0026 \u0026 (\\phi^* f)|_p \\overset{\\Delta}{=} f|_{\\phi(p)} \\quad \\forall p \\in M \\end{aligned} \\]  这个映射是 \\(\\mathscr{F}_N \\to \\mathscr{F}_M\\)  ，和 \\(\\phi\\)  的映射 \\(M\\to N\\)  方向相反，所以称 \\(\\phi^*\\)  为拉回映射。\n基本性质   \\(\\phi^* : \\mathscr{F}_N \\to \\mathscr{F}_M\\)  是线性映射。  \\(\\phi^*(f g)=\\phi^*(f)\\phi^*(g),\\quad \\forall f,g \\in \\mathscr{F}_N\\)  。  流形间矢量映射，推前映射，切映射 目前已知： \\(\\phi,\\phi^*\\in\\mathbb{F}_\\phi\\)  ， \\(\\phi\\)  是点到点的流形映射， \\(\\phi^*\\)  则是标量场到标量场的拉回映射。\n1 流形间矢量场映射？ 因为矢量场 \\(v^a\\)  是标量场到实数的映射，只能与 \\(\\phi^* : \\mathscr{F}_N \\to \\mathscr{F}_M\\)  才可能构成复合映射，并且只能选择 \\(v^a:\\mathscr{F}_M\\to\\mathbb{R}\\)  ，进而对应复合映射 \\(v^a\\circ\\phi^*:\\mathscr{F}_N \\to \\mathbb{R}\\)  。因为 \\(v^a\\in\\mathscr{F}_M(1,0),v^a\\circ\\phi^*\\in\\mathscr{F}_N(1,0)\\)  ，所以得到一个可能的自然诱导映射 \\(\\theta\\)  ：\n\\[ \\begin{aligned} \u0026\\theta :\u0026 \\mathscr{F}_M(1,0) \u0026\\to \\mathscr{F}_N(1,0) \\\\ \u0026\\quad\u0026 v^a \u0026\\mapsto v^a\\circ\\phi^*\\\\ \u0026 \u0026 \u0026 (\\theta v)|_q(f) \\overset{\\Delta}{=} v|_{\\phi^{-1}(q)}(\\phi^*f) \\quad \\forall q \\in N, f \\in \\mathscr{F}_N \\end{aligned} \\]  最后一个式子要求流形映射 \\(\\phi\\)  是可逆的。但关于 \\(\\phi\\)  的约定，这逆像未必存在，所以无法定义关于矢量场的自然诱导映射。\n2 矢量的自然诱导映射 退而求其次，选择两个点 \\(p\\in M,\\phi(p)\\in N\\)  ，研究切空间 \\(V_p\\)  和 \\(V_{\\phi(p)}\\)  之间的映射：\n\\[ \\begin{aligned} \u0026\\phi_* :\u0026 V_p \u0026\\to V_{\\phi(p)} \\\\ \u0026\\quad\u0026 v^a \u0026\\mapsto v^a\\circ\\phi^*\\\\ \u0026 \u0026 \u0026 (\\phi_* v)(f) \\overset{\\Delta}{=} v(\\phi^*f) \\quad \\forall f \\in \\mathscr{F}_N \\end{aligned} \\]  注意：这个映射是将 \\(V_p\\)  映射倒 \\(V_{\\phi(p)}\\)  ，这和 \\(\\phi\\)  的映射方向一致，所以称 \\(\\phi_*\\)  为推前映射。此外，这个映射是把切空间的点映射到切空间，所以又称 \\(\\phi_*\\)  为切映射。\n3 基本性质   \\(\\phi_*:V_p\\to V_{\\phi(p)}\\)  是线性映射； 曲线 \\(C(t)\\)  在 \\(C(t_0)\\)  点切矢 \\(T^a\\)  的像 \\(\\phi_*T^a\\)  是曲线像 \\(\\phi(C(t))\\)  在 \\(\\phi(C(t_0))\\)  点的切矢。  流形间对偶矢量场映射 目前已知： \\(\\phi,\\phi^*,\\phi_*\\in\\mathbb{F}_\\phi\\)  ， \\(\\phi\\)  是点到点的流形映射， \\(\\phi^*\\)  是标量场到标量场的拉回映射， \\(\\phi_*\\)  则是切空间到切空间的推前映射。\n由于对偶矢量场 \\(\\omega_a\\)  是矢量场到实数的映射， \\(\\phi,\\phi^*,\\phi_*\\)  都无法和其复合。但对指定 \\(p\\in M\\)  的情况下，是可能与 \\(\\phi_*:V_p\\to V_{\\phi(p)}\\)  进行复合的，此时只能选择 \\(\\omega_a|_{\\phi(p)}:V_{\\phi(p)\\to\\mathbb{R}}\\)  ，构成复合映射 \\(\\omega_a|_p\\circ\\phi_*:V_p\\to\\mathbb{R}\\)  。\n由此可见，对偶矢量场映射具有“拉回”的特点，但毕竟对偶矢量场 \\(\\omega_a\\)  与 \\(\\phi_*\\)  无法直接复合。所以对 \\(\\phi^*\\)  的定义进行延拓，确保对偶矢量场的“拉回”：\n \\[ \\begin{aligned} \u0026\\phi^* :\u0026 \\mathscr{F}_N(0,1) \u0026\\to \\mathscr{F}_M(0,1) \\\\ \u0026\\quad\u0026 \\omega_a \u0026\\mapsto \\omega_a\\circ\\phi_*\\\\ \u0026 \u0026 \u0026 (\\phi^* \\omega)|_p \\overset{\\Delta}{=} \\omega_a|_{\\phi(p)} \\quad \\forall p \\in M\\\\ \u0026 \u0026 \u0026 (\\phi^* \\omega)|_p v^a \\overset{\\Delta}{=} \\omega_a|_{\\phi(p)} (\\phi_*v)^a \\quad \\forall p \\in M, v^a\\in V_p \\end{aligned} \\]  注意：\n  \\(\\phi\\)  本身就可以看成是对流形点的推前映射： \\(\\phi_*(p)=\\phi(p)\\)  。这也符合前面将 \\(\\phi\\)  看出自身的自然诱导映射的要求。 最后一个式子是定义的细化。  拉回映射和推前映射定义的延拓 根据前面矢量推前映射和对偶矢量场拉回映射的定义，可以进行更一般的定义延拓。\n拉回映射的延拓 \\[ \\begin{aligned} \u0026\\phi^* : \u0026\\mathscr{F}_N(0,l) \u0026\\to \\mathscr{F}_M(0,l) \\\\ \u0026\\quad\u0026 T_{a_1\\dots a_l} \u0026\\mapsto T_{a_1\\dots a_l}\\circ\\phi_*\\\\ \u0026 \u0026 \u0026 (\\phi^* T)_{a_1\\dots a_l}|_p \\overset{\\Delta}{=} T_{a_1\\dots a_l}|_{\\phi(p)} \\quad \\forall p \\in M\\\\ \u0026 \u0026 \u0026 (\\phi^* T)_{a_1\\dots a_l}|_p (v_1)^{a_1}\\dots(v_l)^{a_l} \\overset{\\Delta}{=} T_{a_1\\dots a_l}|_{\\phi(p)} (\\phi_*v_1)^{a_1}\\dots(\\phi_*v_l)^{a_l} \\\\ \u0026 \u0026 \u0026 \\quad \\forall p \\in M, (v_1)^{a_1},\\dots, (v_l)^{a_l}\\in V_p \\end{aligned} \\]  推前映射的延拓 为了方便延拓，先把矢量推前映射，改写成等价形式：\n\\[ \\begin{aligned} \u0026\\phi_* :\u0026 V_p \u0026\\to V_{\\phi(p)} \\\\ \u0026\\quad\u0026 v^a \u0026\\mapsto v^a\\circ\\phi^*\\\\ \u0026 \u0026 \u0026 (\\phi_* v)^a\\omega_a \\overset{\\Delta}{=} v^a(\\phi^*\\omega)_a \\quad \\forall \\omega \\in \\mathscr{F}_N(0,1) \\end{aligned} \\]  因为 \\(\\forall\\omega_a\\in \\mathscr{F}_M(0,1),\\exists f\\in\\mathscr{F}_M,(df)_a=\\omega_a\\)  ，所以 \\(v(f)=(df)_av^a=v^a\\omega_a\\)  。也就是说：矢量既可以看成是标量场到实数的映射，也可以看成是对偶矢量到实数的映射。\n于是有推前映射的延拓定义：\n\\[ \\begin{aligned} \u0026\\phi_* :\u0026 \\mathscr{T}_{V_p}(k,0) \u0026\\to \\mathscr{T}_{V_{\\phi(p)}}(k,0),\\quad p\\in M \\\\ \u0026\\quad\u0026 T^{a_1\\dots a_k} \u0026\\mapsto T^{a_1\\dots a_k}\\circ\\phi^*\\\\ \u0026 \u0026 \u0026 (\\phi_* T)^{a_1\\dots a_k}(\\omega^1)_{a_1}\\dots(\\omega^k)_{a_k} \\overset{\\Delta}{=} T^{a_1\\dots a_k}(\\phi^*\\omega^1)_{a_1}\\dots(\\phi^*\\omega^k)_{a_k}\\\\ \u0026 \u0026 \u0026 \\quad \\forall \\omega^1\\dots \\omega^k \\in V^*_{\\phi(p)} \\end{aligned} \\]  微分同胚下的拉回和推前映射 如果 \\(\\phi:M\\to N\\)  是微分同胚映射，那么推前映射 \\(\\phi_*\\)  也可以把 \\((k,0)\\)  张量场推前为 \\((k,0)\\)  张量场： \\[ \\phi_*:\\mathscr{F}_M(k,0)\\to\\mathscr{F}_N(k,0) \\]  此外，由于 \\(\\phi^{-1}\\)  存在且光滑，那么也可以对 \\((0,l)\\)  型张量场进行推前映射： \\[ \\phi_*=(\\phi^{-1})^*:\\mathscr{F}_M(0,l)\\to \\mathscr{F}_N(0,l) \\]  进一步，可以对 \\((k,l)\\)  型张量场进行推前映射： \\[ \\phi_*:\\mathscr{F}_M(k,l)\\to \\mathscr{F}_N(k,l) \\]  比如， \\((\\phi_*T)^a_{\\ \\ b}|_q\\omega_a v^b\\overset{\\Delta}{=}T^a_{\\ \\ b}|_{\\phi^{-1}(q)}(\\phi^*\\omega)_a(\\phi^*v)^b,\\quad \\forall q\\in N,\\omega_a\\in V^*_q,v^b\\in V_q\\)  同理，拉回映射也可以推广到 \\((k,l)\\)  型张量场： \\[ \\phi^*:\\mathscr{F}_N(k,l)\\to \\mathscr{F}_M(k,l) \\]  比如， \\((\\phi^*T)^a_{\\ \\ b}|_p\\omega_a v^b\\overset{\\Delta}{=}T^a_{\\ \\ b}|_{\\phi(p)}(\\phi_*\\omega)_a(\\phi_*v)^b,\\quad \\forall p\\in M,\\omega_a\\in V^*_p,v^b\\in V_p\\)  微分同胚映射的主动和被动观点 当初给微分流形下定义时，就是借助微分同胚映射定义的，区别是当初是用局域微分同胚 \\(O\\to V,\\quad O\\subset M, V\\subset\\mathbb{R}^n\\)  的概念，而我们这里是全局微分同胚 \\(M\\to N\\)  。\n当初借助两个局域微分同胚定义两个坐标系，进而之间存在坐标变换。现在，也能引入两个微分同胚映射：第一个借用 \\(\\mathbb{R}^n\\)  ： \\(O_1\\to V,\\quad O_1\\subset M, V\\subset\\mathbb{R}^n\\)  ，第二个则直接借用 \\(N\\)  ：是 \\(\\phi^{-1}[O_2]\\to O_2,\\quad \\phi^{-1}[O_2]\\subset M,O_2\\subset N\\)  。 这就引入了下面提及的被动观点。\n微分同胚映射的主动观点，自然就是点到点的变换 \\(p\\mapsto \\phi(p)\\)  及其导致的张量变换 \\(T\\mapsto \\phi_*T\\)  。\n微分同胚映射的被动观点，就是将映射 \\(\\phi:M\\to N\\)  看成一个新的局域坐标系，进而和局域老坐标系存在变换关系，完全可以套用当初普通坐标变换的做法。\n将 \\(O_1\\subset M\\)  对应的\u0026quot;老\u0026quot;坐标系记作 \\(\\{x^\\mu\\}\\)  ，将 \\(O_2\\subset N\\)  对应的坐标系记作 \\(\\{y^\\mu\\}\\)  ，进而可将 \\(\\phi^{-1}[O_2] \\subset M\\)  对应的新坐标记作 \\(\\{x'^\\mu\\}，x'^\\mu(q)\\overset{\\Delta}{=}y^\\mu(\\phi(q))\\quad \\forall q\\in \\phi^{-1}[O_2]\\)  。\n微分同胚映射的主动观点和被动观点的等价性，体现在下面的关系： \\[ \\left.(\\phi_*T)^{\\mu_1\\dots\\mu_k}_{\\ \\qquad \\upsilon_1\\dots\\upsilon_l}\\right|_{\\phi(p)}=\\left.T'^{\\mu_1\\dots\\mu_k}_{\\ \\qquad \\upsilon_1\\dots\\upsilon_l}\\right|_p,\\quad \\forall T\\in \\mathscr{F}_M(k,l) \\]  几个有用的性质 如果 \\(\\phi:M\\to N\\)  是光滑映射，那么： \\[ \\phi^*(T_{a_1\\dots a_l}S_{b_1\\dots b_{l'}})=\\phi^*(T_{a_1\\dots a_l})\\phi^*(S_{b_1\\dots b_{l'}})\\\\ \\phi_*(T^{a_1\\dots a_k}S^{b_1\\dots b_{k'}})=\\phi_*(T^{a_1\\dots a_k})\\phi_*(S^{b_1\\dots b_{k'}}) \\]  如果 \\(\\phi:M\\to N\\)  是同胚映射，那么： \\[ \\phi_*(T^{a_1\\dots a_k}_{\\ \\qquad b_1\\dots b_l}S^{c_1\\dots c_{k'}}_{\\ \\qquad d_1\\dots d_{l'}})=\\phi_*(T^{a_1\\dots a_l}_{\\ \\qquad b_1\\dots b_l})\\phi_*(S^{c_1\\dots c_{k'}}_{\\ \\qquad d_1\\dots d_{l'}}) \\]  如果 \\(\\phi:M\\to N\\)  是同胚映射，那么 \\(\\phi_*\\)  ( \\(\\phi^*\\)  )与缩并可交换次序。\n"}),a.add({id:177,href:'/notes/tags/%E9%80%82%E9%85%8D%E5%9D%90%E6%A0%87%E7%B3%BB/',title:"适配坐标系",content:""}),a.add({id:178,href:'/notes/tags/%E5%AF%B9%E6%98%93%E5%AD%90/',title:"对易子",content:""}),a.add({id:179,href:'/notes/docs/diffgeo/0008/',title:"黎曼曲率张量",content:"曲率概念的意义 导数算符对易子   \\([\\nabla_a,\\nabla_b]=\\nabla_a\\nabla_b-\\nabla_b\\nabla_a\\)  ：对标量场的作用结果为０(无挠性决定的)，但对一般张量场未必为０。\n黎曼曲率张量就是这种非对易性的表现。\n探究导数算符对易子 先把目标集中在 \\((\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)\\)  作用在对偶矢量 \\(\\omega_c\\)  上的情况上。\n首先，下式左边展开后相减，再根据无挠性，得到： \\[ (\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)(f \\omega_c)=f (\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)\\omega_c,\\quad \\forall f\\in\\mathscr{F}_M,\\omega_c\\in\\mathscr{F}_M(0,1) \\]  选择在 \\(p\\)  点相等的对偶矢量 \\(\\omega_b,\\omega'_b,\\left. \\omega_b\\right|_p=\\left.\\omega'_b\\right|_p\\)  ，于是 \\(\\Omega_b\\overset{\\Delta}{=}\\omega'_b-\\omega_b, \\quad \\left.\\Omega_b\\right|_p=0\\)  ，引入坐标系 \\({x^\\mu}\\)  并使坐标域含 \\(p\\)  ，于是有： \\[ \\begin{aligned}\\left[(\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)\\Omega_c\\right]_p \u0026=\\left[(\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)[\\Omega_\\mu(dx^\\mu)_c]\\right]_p \u0026\\text{张量展开}\\\\ \u0026=\\left.\\Omega_\\mu\\right|_p(\\nabla_a\\nabla_b-\\nabla_b\\nabla_a)(dx^\\mu)_c \u0026\\text{利用上式}\\\\ \u0026=0 \u0026\\text{根据约定}\\end{aligned} \\]  这说明，对流形 \\(M\\)  上的任意一点 \\(p\\)  而言， \\(\\left.[\\nabla_a,\\nabla_b]\\omega_c\\right|_p\\)  只依赖于 \\(\\omega_c\\)  在 \\(p\\)  点的值，而与 \\(\\omega_c\\)  其它部分无关。\n引入曲率张量概念 上一段的结论说明 \\([\\nabla_a,\\nabla_b]\\)  是一个线性算符(映射)： \\[ \\begin{aligned} [\\nabla_a,\\nabla_b]\u0026:\u0026\\mathscr{T}_p(0,1)\u0026\\to\u0026 \u0026\\mathscr{T}_p(0,3) \\\\ \u0026 \u0026\\left.\\omega_c\\right|_p\u0026\\mapsto\u0026 \u0026\\left.[\\nabla_a,\\nabla_b]\\omega_c\\right|_p\\end{aligned} \\]  可以将这个线性映射用张量表示，也就是说 \\([\\nabla_a,\\nabla_b]\\)  对应一个张量 \\(R^{\\quad d}_{abc}\\)  ，满足： \\[ \\left.[\\nabla_a,\\nabla_b]\\omega_c\\right|_p=\\left.R^{\\quad d}_{abc}\\omega_d\\right|_p \\]  考虑到 \\(p\\)  点选择的任意性，于是有： \\[ [\\nabla_a,\\nabla_b]\\omega_c=R^{\\quad d}_{abc}\\omega_d,\\quad \\forall \\omega_c\\in\\mathscr{F}_M(0,1) \\]  我们称 \\(R^{\\quad d}_{abc}\\)  为黎曼曲率张量。\n只要选定了导数算符，就可以谈黎曼曲率张量。\n如果有度规张量场 \\(g_{ab}\\)  ，那么导数算符 \\(\\nabla_a\\)  就是与 \\(g_{ab}\\)  适配的，进而有唯一确定的黎曼曲率张量场。\n黎曼曲率张量场为０的度规，称之为平直度规。欧氏度规和闵氏度规都是平直度规。\n导数算符作用张量场的非对易性 根据矢量场与对偶矢量场相互作用的结果是标量场的事实，可推出导数算符 \\(\\nabla_a\\)  作用于矢量场 \\(v^a\\)  的非对易性： \\[ [\\nabla_a,\\nabla_b]v^c=-R^{\\quad c}_{abd}v^d,\\quad \\forall v^c\\in\\mathscr{F}_M(1,0) \\]  进而有： \\[ [\\nabla_a,\\nabla_b]T^{c_1 \\dots c_k}_{\\ \\qquad d_1 \\dots c_l}=-\\sum_{i=1}^k{R^{\\quad c_i}_{abe}T^{c_1 \\dots e \\dots c_k}_{\\ \\qquad \\quad d_1 \\dots d_l}}+\\sum_{j=1}^l{R^{\\quad e}_{abd_j}T^{c_1 \\dots c_k}_{\\ \\qquad d_1 \\dots e \\dots d_l}} \\]  黎曼曲率张量的性质   \\(R^{\\quad d}_{abc}=-R^{\\quad d}_{bac} , \\quad R^{\\ \\ \\quad d}_{(ab)c}=0\\)   循环恒等式： \\( R^{\\ \\ \\quad d}_{[abc]}=0\\)   比安基恒等式： \\( \\nabla_{[a} R^{\\ \\quad e}_{bc]d}=0\\)    \\(R_{abcd}=-R_{abdc},\\quad R_{ab(cd)}=0\\)    \\(R_{abcd}=-R_{cdab}\\)    注意：最后两个性质，引入度规 \\(g_{ab}\\)  ， \\(R_{abcd}\\overset{\\Delta}{=}g_{de}R^{\\quad e}_{abc}\\)  黎曼曲率张量的迹 我们知道：相似矩阵有相同的迹，所有相似矩阵都对应同一个线性变换，进而对应同一个张量。所以这迹也就是张量的迹,其值为： \\(T^a_{\\ \\ a}=g^{ac}T_{ac}\\)  ，是张量 \\(T^a_b\\)  的迹，也是张量 \\(T_{ab}\\)  的迹。\n类似地，也可以对 \\(R_{abcd}\\)  进行求\u0026quot;迹\u0026quot;，根据黎曼张量的性质和度规的对称性，对６个可能分别计算：\n\\[ \\begin{aligned}g^{ab}R_{abcd}\u0026=g^{(ab)}R_{[ab]cd}=0\\\\ g^{ac}R_{abcd}\u0026=-g^{ac}R_{bacd}=g^{ac}R_{badc}=R^{\\ \\quad a}_{bad}\\\\ g^{ad}R_{abcd}\u0026=-g^{ad}R_{bacd}=-R^{\\ \\quad a}_{bac}\\\\ g^{bc}R_{abcd}\u0026=-g^{bc}R_{abdc}=-R^{\\ \\quad b}_{abd} \\\\ g^{bd}R_{abcd}\u0026=R^{\\ \\quad b}_{abc} \\\\ g^{cd}R_{abcd}\u0026=g^{cd}R_{cdab}=g^{(cd)}R_{[cd]ab}=0\\end{aligned} \\]  由此可见，这６个\u0026quot;迹\u0026quot;，只有一个是独立的，选择其中一个定义为里奇张量： \\[ R_{ac}\\overset{\\Delta}{=}g^{bd}R_{abcd}=R^{\\ \\quad b}_{abc} \\]  于是有： \\[ \\begin{aligned}g^{ab}R_{abcd}\u0026=0,\\quad g^{cd}R_{abcd}=0\\\\ g^{ac}R_{abcd}\u0026=R_{bd}, \\quad g^{bd}R_{abcd}=R_{ac} \\\\ g^{ad}R_{abcd}\u0026=-R_{bc},\\quad g^{bc}R_{abcd}=-R_{ad} \\end{aligned} \\]  对里奇张量 \\(R_{ac}\\)  进一步缩并，得到标量曲率 \\(R\\overset{\\Delta}{=}g^{ac}R_{ac}\\)  。　此外，里奇张量也是对称的： \\[ R_{ac}=R_{ca}, \\quad R_{[ac]}=0 \\]  黎曼曲率张量 \\(R^{\\quad d}_{abc}\\)  的无迹部分，叫做外尔张量 \\(C_{abcd}\\)  ： \\[ C_{abcd}\\overset{\\Delta}{=}R_{abcd}-\\frac{2}{n-2}(g_{a[c} R_{d]b}-g_{b[c} R_{d]a})+\\frac{2}{(n-1)(n-2)}R g_{a[c} g_{d]b}, \\quad \\dim(M)\\ge 3 \\]  外尔张量有如下性质：\n  \\(C_{abcd}=-C_{bacd}=-C_{abdc}=C_{cdab},\\quad C_{[abc]d}=0\\)    \\(C_{abcd}\\)  的各种迹都为０.  由度规计算黎曼曲率 首先计算，用双重导数算符作用于对偶矢量场，再取反称部分，计算结果： \\[ \\begin{aligned}\\nabla_{[a}\\nabla_{b]}\\omega_c\u0026=\\partial_{[a}\\nabla_{b]}\\omega_c-\\Gamma^{d}_{\\ \\ [ab]}\\nabla_d\\omega_c-\\Gamma^{d}_{\\ \\ [a|c|}\\nabla_{b]}\\omega_d \\\\ \u0026=\\partial_{[a}\\nabla_{b]}\\omega_c-\\Gamma^{d}_{\\ \\ c[a}\\nabla_{b]}\\omega_d \\\\ \u0026=\\partial_{[a}\\partial_{b]}\\omega_c-\\omega_d\\partial_{[a}\\Gamma^d_{\\ \\ b]c}-\\Gamma^d_{\\ \\ c[b}\\partial_{a]}\\omega_d-\\Gamma^{d}_{\\ \\ c[a}\\partial_{b]}\\omega_d+\\Gamma^{e}_{\\ \\ c[a}\\Gamma^{d}_{\\ \\ b]e}\\omega_d \\\\ \u0026=-\\omega_d\\partial_{[a}\\Gamma^d_{\\ \\ b]c}-2\\Gamma^{d}_{\\ \\ c([a}\\partial_{b])}\\omega_d+\\Gamma^{e}_{\\ \\ c[a}\\Gamma^{d}_{\\ \\ b]e}\\omega_d \\\\ \u0026=-\\omega_d\\partial_{[a}\\Gamma^d_{\\ \\ b]c}+\\Gamma^{e}_{\\ \\ c[a}\\Gamma^{d}_{\\ \\ b]e}\\omega_d \\\\ \u0026=(-\\partial_{[a}\\Gamma^d_{\\ \\ b]c}+\\Gamma^{e}_{\\ \\ c[a}\\Gamma^{d}_{\\ \\ b]e})\\omega_d \\end{aligned} \\]  而根据黎曼张量的定义有： \\[ R^{\\quad d}_{abc}\\omega_d=2\\nabla_{[a}\\nabla_{b]}\\omega_c \\]  进而有黎曼曲率张量的表达式(考虑到对偶矢量 \\(\\omega_d\\)  是任意选择的)： \\[ R^{\\quad d}_{abc}=-2\\partial_{[a}\\Gamma^d_{\\ \\ b]c}+2\\Gamma^{e}_{\\ \\ c[a}\\Gamma^{d}_{\\ \\ b]e} \\]  对应的黎曼曲率张量分量是(将反称部分展开)： \\[ R^{\\ \\quad \\rho}_{\\mu \\upsilon \\sigma}=\\Gamma^\\rho_{\\ \\ \\mu \\sigma,\\upsilon}-\\Gamma^\\rho_{\\ \\ \\upsilon \\sigma,\\mu}+\\Gamma^\\lambda_{\\ \\ \\sigma\\mu}\\Gamma^\\rho_{\\ \\ \\upsilon \\lambda}-\\Gamma^\\lambda_{\\ \\ \\sigma\\upsilon }\\Gamma^\\rho_{\\ \\ \\mu \\lambda} \\]  最后，得到里奇张量的分量表达式： \\[ R_{\\mu \\sigma}=R^{\\ \\quad \\upsilon}_{\\mu \\upsilon \\sigma}=\\Gamma^\\upsilon_{\\ \\ \\mu \\sigma,\\upsilon}-\\Gamma^\\upsilon_{\\ \\ \\upsilon \\sigma,\\mu}+\\Gamma^\\lambda_{\\ \\ \\sigma\\mu}\\Gamma^\\upsilon_{\\ \\ \\upsilon \\lambda}-\\Gamma^\\lambda_{\\ \\ \\sigma\\upsilon }\\Gamma^\\upsilon_{\\ \\ \\mu \\lambda} \\]  范例 求度规 \\(ds^2=z^{-1/2}(-dt^2+dz^2)+z(dx^2+dy^2)\\)  的黎曼张量在 \\(\\{t,x,y,z\\}\\)  系的全部分量。\n用julia解决这个问题。首先设置变量，设置度规张量，并计算逆度规：\nusing SymPy @vars t x y z real=true xv = [t,x,y,z] # 度规张量及其逆 g = sympy.eye(4) .* [-z^(-1//2),z,z,z^(-1//2)] gi = inv(g); 根据度规计算克氏符:\n# 根据度规计算克氏符 Γ = sum([(1//2)*gi[σ,ρ]*(diff(g[μ,ρ],xv[υ])+ diff(g[υ,ρ],xv[μ])-diff(g[μ,υ],xv[ρ])) for μ in 1:4,υ in 1:4 ,σ in 1:4] for ρ in 1:4) # 显示所有分量（剔除了０分量和对称分量） [symbols(\u0026#34;Γ^{$σ}_{$μ$υ}\u0026#34;)⩵Γ[μ,υ,σ] for μ in 1:4,υ in 1:4 ,σ in 1:4 if Γ[μ,υ,σ]!=0 \u0026amp;\u0026amp; μ\u0026lt;=υ].T 根据克氏符计算黎曼曲率张量:\n#　根据克氏符计算黎曼曲率张量 R=[diff(Γ[μ,σ,ρ],xv[υ])-diff(Γ[υ,σ,ρ],xv[μ])+ sum(Γ[μ,σ,λ]*Γ[υ,λ,ρ]-Γ[υ,σ,λ]*Γ[μ,λ,ρ] for λ in 1:4) for μ in 1:4,υ in 1:4 ,σ in 1:4,ρ in 1:4] # 显示所有分量（剔除了０分量和反对称分量） reshape([symbols(\u0026#34;R_{$μ$υ$σ}^{$ρ}\u0026#34;)⩵R[μ,υ,σ,ρ] for μ in 1:4,υ in 1:4 ,σ in 1:4,ρ in 1:4 if R[μ,υ,σ,ρ]!=0 \u0026amp;\u0026amp; μ\u0026lt;=υ],(3,4)) 根据黎曼曲率张量计算里奇张量:\n# 根据黎曼曲率张量计算里奇张量 RR=[sum(R[μ,υ,σ,υ] for υ in 1:4) for μ in 1:4,σ in 1:4] "}),a.add({id:180,href:'/notes/tags/%E5%B9%B3%E7%A7%BB/',title:"平移",content:""}),a.add({id:181,href:'/notes/docs/diffgeo/0007/',title:"流形上的平移",content:"平移是路径无关的吗？ 我们知道，欧氏空间的平移是路径无关的，任意两个位置，平移的结果是唯一的。\n那么在流形上呢？结论是：流形上的平移是路径依赖的。只需要一个例子就足以说明，如图：\n我们选择b为起点a为终点，路径１：   \\(b\\to c\\to a, u^a\\to w^a \\to v'^a\\)  ，路径２： \\(b\\to a, u^a\\to v^a\\)  。很明显不一样的路径，平移后的结果不一样。　所以，我们只能谈论沿曲线的平移。\n矢量场沿曲线的平移 1. 平移概念 所谓平移，就是矢量移动后不变，所谓沿线平移,就是矢量 \\(v^a\\)  沿曲线 \\(C(t)\\)  移动后不变，所谓不变，数学含义就是（对欧氏空间而言）： \\[ \\frac{d v^a}{d t}=0 \\]  而曲线 \\(C(t)\\)  的切矢是 \\(T^a\\overset{\\Delta}{=}\\left(\\dfrac{d}{d t}\\right)^a=\\dfrac{d x^\\mu}{dt}\\left(\\dfrac{\\partial}{\\partial x^\\mu}\\right)^a=T^\\mu\\left(\\dfrac{\\partial}{\\partial x^\\mu}\\right)^a\\)  ，于是我们可以推导：\n\\[ \\begin{aligned}\\frac{d v^a}{d t} \u0026=\\frac{d x^\\mu}{d t}\\frac{\\partial v^a}{\\partial x^\\mu} \u0026 \\text{普通的矢量微分} \\\\ \u0026=T^\\mu \\frac{\\partial }{\\partial x^\\mu} v^a=T^\\mu \\partial_\\mu v^a\u0026 \\text{利用上面的切矢记号} \\\\ \u0026=T^b \\partial_b v^a \u0026 \\text{重复抽象上下指标对应缩并} \\end{aligned} \\]  由此可见，对欧氏空间而言， \\(T^b\\partial_b v^a\\)  可解释成矢量场 \\(v^a\\)  沿曲线 \\(C(t)\\)  的导数，或沿 \\(T^b\\)  的导数。 这就是欧氏空间中的方向导数。\n对一般流形而言，平移概念很自然推广成：设 \\(v^a\\)  是沿曲线 \\(C(t)\\)  的矢量场， \\(v^a\\)  称为沿 \\(C(t)\\)  平移的，若 \\(\\dfrac{D v^a}{dt}\\overset{\\Delta}{=}T^b\\nabla_b v^a=0\\)  。其中 \\(\\dfrac{D v^a}{dt}\\)  用来表示流形中沿曲线的方向导数。\n2. 方向导数导数在局域坐标中的表达式 如果引入局域坐标系 \\(\\{x^\\mu\\}\\)  ，利用导数算符的结论和张量展式，可将 \\(T^b\\nabla_b v^a\\)  表示为： \\[ T^b\\nabla_b v^a=\\left(\\frac{\\partial}{\\partial x^\\mu}\\right)^a\\left[\\frac{d v^\\mu}{dt}+\\Gamma^\\mu_{\\ \\ \\upsilon\\sigma}T^\\upsilon v^\\sigma\\right] \\]  3. 沿曲线平移矢量场的唯一性 根据一阶常微分方程给定初值的解的唯一性，我们有结论：\n曲线上一点 \\(C(t_0)\\)  及该点的一个矢量决定一个唯一的沿曲线平移的矢量场.\n4. 联络 对流形中的任何两个点 \\(p,q\\)  ，一般而言， \\(V_p,V_q\\)  是两个不同的矢量空间，他们的元素是无法比较的。现在由于有了导数算符 \\(\\nabla_a\\)  ，于是可用一条曲线 \\(C(t)\\)  连接两点 \\(p,q\\)  ，又由沿曲线平移矢量的唯一性，我们可以在 \\(V_p,V_q\\)  间定义一个映射 \\(\\varphi\\)  ： \\[ \\begin{aligned} \\varphi\u0026:\u0026V_p\u0026\\to V_q \\\\ \u0026 \u0026 v^a \u0026\\mapsto v^a 沿曲线 C(t) 平移到 q 点 \\end{aligned} \\]  通过这个映射 \\(\\varphi\\)  （曲线依赖的）,原来毫无联系的 \\(V_p,V_q\\)  发生了某种联系，因此也把 \\(\\nabla_a\\)  称为联络。\n与度规适配的导数算符 在流形 \\(M\\)  上有导数算符（或联络） \\(\\nabla_a\\)  可以谈平移，如果还指定了度规 \\(g_{ab}\\)  就可以谈内积了。为了和欧氏空间的平移一致，谈平移还需要补充一个条件：平移时内积不变： \\[ 0=\\frac{d}{dt}(g_{ab}u^a v^b)=T^c \\nabla_c(g_{ab}u^a v^b)=u^a v^b T^c \\nabla_c g_{ab} \\]  由于这个条件对任意曲线和沿它平移的任意两个矢量 \\(u^a,v^b\\)  都成立，于是有： \\[ \\nabla_c g_{ab}=0 \\]  我们称满足这个条件的导数算符 \\(\\nabla_a\\)  是度规适配的导数算符。\n现在任意选择一个导数算符 \\(\\tilde{\\nabla}_a\\)  (不要求度规适配)，有： \\[ 0=\\nabla_a g_{bc}=\\tilde{\\nabla}_a g_{bc}-C^d_{\\ \\ ab} g_{dc}-C^d_{\\ \\ ac} g_{bd}=\\tilde{\\nabla}_a g_{bc}-C_{cab}-C_{bac} \\]  即： \\[ \\tilde{\\nabla}_a g_{bc}=C_{cab}+C_{bac} \\]  轮换指标得另外两式： \\[ \\tilde{\\nabla}_b g_{ca}=C_{abc}+C_{cba} \\\\ \\tilde{\\nabla}_c g_{ab}=C_{bca}+C_{acb} \\]  第１式+第２式-第３式，再利用 \\(C_{cab}=C_{cba}\\)  得：\n\\[ \\tilde{\\nabla}_a g_{bc}+\\tilde{\\nabla}_b g_{ac}-\\tilde{\\nabla}_c g_{ab}=2 C_{cab} \\]  最后有： \\[ C^c_{\\ \\ ab}=\\frac{1}{2}g^{cd}[\\tilde{\\nabla}_a g_{bd}+\\tilde{\\nabla}_b g_{ad}-\\tilde{\\nabla}_d g_{ab}] \\]  根据这个式子，我们可以认定：度规适配的导数算符是唯一的。否则必然存在另一个不同的度规适配的导数算符 \\(\\tilde{\\nabla}_a\\)  也满足 \\(\\tilde{\\nabla}_c g_{ab}=0\\)  ，代入上式会导致 \\(C^c_{\\ \\ ab}=0\\)  ，这说明 \\(\\nabla_a=\\tilde{\\nabla}_a\\)  ，矛盾。\n由于度规适配导数算符的唯一性，以后有度规时，我们谈导数算符都默认是指度规适配的。\n有度规流形中的克氏符 在流形 \\((M,g_{ab})\\)  上，有唯一的适配导数算符 \\(\\nabla_a\\)  ，选择一个局域坐标系 \\(\\{x^\\mu\\}\\)  ，根据上一小段的结论，克氏符克写成： \\[ \\Gamma^c_{\\ \\ ab}=\\frac{1}{2}g^{cd}[\\partial_a g_{bd}+\\partial_b g_{ad}-\\partial_d g_{ab}] \\]  进而克氏符克分量可写成： \\[ \\Gamma^\\sigma_{\\ \\ \\mu \\upsilon}=\\frac{1}{2}g^{\\sigma \\rho}[g_{\\upsilon \\rho,\\mu}+g_{\\mu \\rho,\\upsilon}-g_{\\mu \\upsilon,\\rho}] \\]  测地线 在 \\((M,\\nabla_a)\\)  中，有了矢量平移的概念，就很容易定义测地线:　就是满足切矢沿线平移的特殊曲线。\n如果有度规场，那么 \\((M,g_{ab})\\)  的测地线是指 \\((M,\\nabla_a)\\)  上的测地线，其中 \\(\\nabla_a\\)  是与 \\(g_{ab}\\)  适配的。\n利用前面的结论可很容易写出测地线方程： \\[ \\frac{d^2 x^\\mu}{dt^2}+\\Gamma^\\mu_{\\ \\ \\upsilon\\sigma}\\frac{d x^\\upsilon}{dt} \\frac{d x^\\sigma}{dt} = 0, \\quad \\mu=1,\\dots \\]  "}),a.add({id:182,href:'/notes/tags/%E8%81%94%E7%BB%9C/',title:"联络",content:""}),a.add({id:183,href:'/notes/docs/diffgeo/0006/',title:"流形上的导数算符",content:"定义 导数算符，就是欧氏空间我们所熟悉的   \\(\\vec\\nabla\\)  ，作用于标量场 \\(f\\)  就是梯度 \\(\\vec\\nabla f\\)  ，作用于矢量场 \\(\\vec v\\)  再缩并就是散度 \\(\\vec\\nabla \\cdot \\vec v\\)  。欧氏空间是有度规的，我们知道在有度规的情况下，度规可对张量指标进行“上升下降操作”，所以任何矢量都存在其自然对应的对偶矢量。如果要推广到任意流形，就必须分清楚矢量和对偶矢量（因为没有度规了）。\n我们发现 \\(\\vec\\nabla\\)  更像对偶矢量，所以我们将 \\(\\vec\\nabla\\)  记作 \\(\\nabla_a\\)  。所谓“更像”，指的是作用于函数 \\(f\\)  的结果是一个对偶矢量 \\(\\nabla_a f\\)  ，而 \\(\\nabla_a\\)  本身仅仅是一个算符，为了指标平衡而做的记号而已。\n流形 \\(M\\)  上全体型 \\(C^\\infty\\)  的 \\((k,l)\\)  型张量场的集合，记作 \\(\\mathscr{F}_M(k,l)\\)  （特别地，标量场 \\(\\mathscr{F}_M\\overset{\\Delta}{=}\\mathscr{F}_M(0,0)\\)  ）。映射 \\(\\nabla:\\mathscr{F}_M(k,l)\\to\\mathscr{F}_M(k,l+1)\\)  称为 \\(M\\)  上的（无绕）导数算符，如果满足下列条件：\n  线性性质： \\( \\nabla_a(\\alpha T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}+\\beta S^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l})=\\alpha \\nabla_a T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_k}+\\beta \\nabla_a S^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l} \\\\ \\forall \\ T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l},S^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}\\in\\mathscr{F}_M(k,l),\\alpha,\\beta\\in\\mathbb{R} \\)    满足莱布尼茨律： \\( \\nabla_a(T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}S^{d_1,\\dots,d_{k'}}_{\\ \\ \\qquad e_1,\\dots,e_{l'}})=S^{d_1,\\dots,d_{k'}}_{\\ \\ \\qquad e_1,\\dots,e_{l'}} \\nabla_a T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}+T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}\\nabla_a S^{d_1,\\dots,d_{k'}}_{\\ \\ \\qquad e_1,\\dots,e_{l'}} \\\\ \\forall \\ T^{b_1,\\dots,b_k}_{\\ \\ \\qquad c_1,\\dots,c_l}\\in\\mathscr{F}_M(k,l),S^{d_1,\\dots,d_{k'}}_{\\ \\ \\qquad e_1,\\dots,e_{l'}}\\in\\mathscr{F}_M(k',l') \\)    与缩并可交换： \\(\\nabla \\circ C = C \\circ \\nabla\\)  ，其中 \\(C\\)  代表缩并。\n  可退化性： \\(v(f)=v^a\\nabla_a f,\\quad \\forall f\\in\\mathscr{F}_M,v\\in\\mathscr{F}_M(1,0)\\)    无挠性： \\(\\nabla_a\\nabla_b f=\\nabla_b\\nabla_a f, \\quad \\forall f\\in\\mathscr{F}_M\\)    其中第４条形式，本质反应了此定义的可退化性，因为根据这条性质容易证明： \\[ \\nabla_a f=(df)_a, \\quad \\forall f\\in\\mathscr{F}_M \\]  这就是所谓的梯度，也就是函数 \\(f\\)  生成的对偶矢量场 \\(df\\)  的抽象指标表示，同时也表明算符 \\(\\vec\\nabla\\)  \u0026quot;更像\u0026quot;对偶矢量。\n默认情况下，导数算符，我们都特指无挠导数算符。\n任意两个导数算符的差异性 上面这形如公理化的定义，直观上看，是无法保证定义的唯一性。　为此我们必须研究任意两个不同的导数算符之间的关系。\n根据定义的可退化性，知道导数算符作用到标量场 \\(f\\)  时，定义是唯一的： \\[ \\nabla_a f=\\tilde{\\nabla}_a f=(df)_a, \\quad \\forall f\\in\\mathscr{F}_M \\]  所以他们的不同只能表现在更高阶张量场上。\n先把目标集中在 \\((\\tilde{\\nabla}_a-\\nabla_a)\\)  作用在对偶矢量 \\(\\omega_b\\)  上的情况上。我们发现，对流形 \\(M\\)  上的任意一点 \\(p\\)  而言， \\(\\left[(\\tilde{\\nabla}_a-\\nabla_a)\\omega_b\\right]_p\\)  只依赖于 \\(\\omega_b\\)  在 \\(p\\)  点的值，而与 \\(\\omega_b\\)  其它部分无关。\n取两个满足条件的对偶矢量 \\(\\omega_b,\\omega'_b,\\left. \\omega_b\\right|_p=\\left.\\omega'_b\\right|_p\\)  ，于是 \\(\\Omega_b\\overset{\\Delta}{=}\\omega'_b-\\omega_b, \\quad \\left.\\Omega_b\\right|_p=0\\)  ，引入坐标系 \\({x^\\mu}\\)  并使坐标域含 \\(p\\)  ，于是有：\n\\[ \\begin{aligned} \\left[\\nabla_a \\Omega_b \\right]_p \u0026= \\left\\{ \\nabla_a [\\Omega_\\mu(dx^\\mu)_b] \\right\\}_p \\\\ \u0026=\\left[(dx^\\mu)_b \\nabla_a\\Omega_\\mu\\right]_p+\\Omega_\\mu(p)\\left[\\nabla_a(dx^\\mu)_b\\right]_p \\\\ \u0026=\\left[(dx^\\mu)_b \\nabla_a\\Omega_\\mu\\right]_p\\end{aligned} \\]  同样有： \\[ \\left[ \\tilde{\\nabla}_a \\Omega_b \\right]_p =\\left[(dx^\\mu)_b \\tilde{\\nabla}_a\\Omega_\\mu\\right]_p \\]  注意到含具体指标的 \\(\\Omega_\\mu\\)  本质上一个标量场，所以：\n\\[ \\nabla_a\\Omega_\\mu= \\tilde{\\nabla}_a\\Omega_\\mu \\Rightarrow \\left[(\\tilde{\\nabla}_a-\\nabla_a) \\Omega_b \\right]_p=0 \\]  这个结论说明 \\((\\tilde{\\nabla}_a-\\nabla_a)\\)  是一个线性算符(映射)： \\[ \\begin{aligned} (\\tilde{\\nabla}_a-\\nabla_a)\u0026:\u0026\\mathscr{T}_p(0,1)\u0026\\to\u0026 \u0026\\mathscr{T}_p(0,2) \\\\ \u0026 \u0026\\left.\\omega_b\\right|_p\u0026\\mapsto\u0026 \u0026\\left[(\\tilde{\\nabla}_a-\\nabla_a) \\omega_b \\right]_p\\end{aligned} \\]  恰好张量就能看成一个线性映射，也就是说 \\((\\tilde{\\nabla}_a-\\nabla_a)\\)  对应一个张量 \\(C^c_{\\ \\ ab}\\)  ，满足： \\[ \\left[(\\tilde{\\nabla}_a-\\nabla_a) \\omega_b \\right]_p=\\left[C^c_{\\ \\ ab}\\omega_c\\right]_p \\]  考虑到 \\(p\\)  点选择的任意性，所以流形 \\(M\\)  上的两个导数算符 \\(\\tilde{\\nabla}_a\\)  和 \\(\\nabla_a\\)  在对 \\(\\omega_b\\)  的作用上的差别体现为 \\(M\\)  上的一个 \\((1,2)\\)  型张量场 \\(C^c_{\\ \\ ab}\\)  ，即： \\[ \\nabla_a\\omega_b =\\tilde{\\nabla}_a\\omega_b-C^c_{\\ \\ ab}\\omega_c,\\quad \\forall \\omega_b\\in\\mathscr{F}_M(0,1) \\]  注意：无挠性保证了 \\(C^c_{\\ \\ ab}\\)  的对称性： \\(C^c_{\\ \\ ab}=C^c_{\\ \\ ba}\\)  。\n根据矢量场与对偶矢量相互作用的结果是标量场的事实，容易推出导数算符 \\(\\nabla_a\\)  作用于矢量场 \\(v^b\\)  的结论： \\[ \\nabla_a v^b=\\tilde{\\nabla}_a v^b+C^b_{\\ \\ ac} v^c \\]  进一步可构造出作用于张量 \\(T^b_{\\ \\ c}\\)  的结论： \\[ \\nabla_a T^b_{\\ \\ c}=\\tilde{\\nabla}_a T^b_{\\ \\ c}+C^{b}_{\\ \\ ad}T^d_{\\ \\ c}-C^{d}_{\\ \\ ab}T^b_{\\ \\ d} \\]  更一般的结论： \\[ \\nabla_a T^{b_1\\dots b_k}_{\\ \\ \\qquad c_1\\dots c_l}=\\tilde{\\nabla}_a T^{b_1\\dots b_k}_{\\ \\ \\qquad c_1\\dots c_l}+\\sum_j{C^{b_i}_{\\ \\ ad}T^{b_1\\dots d\\dots b_k}_{\\ \\ \\qquad c_1\\dots c_l}}\\\\-\\sum_j{C^{d}_{\\ \\ ac_i}T^{b_1\\dots b_k}_{\\ \\ \\qquad c_1\\dots d\\dots c_l}},\\quad \\forall T\\in\\mathscr{F}_M(k,l) \\]  克氏符（Christoffel symbol） 导数算符，虽然不是唯一的，但也不是任意的。因为，一旦选定某个导数算符，随之而确定。 在选定一个局域坐标系 \\(\\{x^\\mu\\}\\)  的情况下，一个自然的选择就是偏导数 \\(\\partial_\\mu\\overset{\\Delta}{=}\\partial/\\partial x^\\mu\\)  所对应的抽象指标形式 \\(\\partial_a\\)  ，我们称之为该坐标系的普通导数算符，比如： \\[ \\partial_a T^b_{\\ \\ c}=(dx^\\mu)_a(\\partial/\\partial x^\\upsilon)^b(dx^\\sigma)_c\\partial_\\mu T^\\upsilon_{\\ \\ \\sigma} \\]  普通导数算符有一些导数算符一般不具备的性质：\n  普通导数算符作用于自身所依赖的坐标系的坐标基矢和对偶坐标基矢的结果都为０： \\( \\partial_a(\\partial/\\partial x^v)^b=0,\\quad\\partial_a(d x^v)_b=0 \\)    普通导数算符对任意型张量都是可交换的： \\( \\partial_a\\partial_b T=\\partial_b\\partial_a T \\quad\\Leftrightarrow\\quad \\partial_{[a}\\partial_{b]}T=0 \\)    设 \\(\\partial_a\\)  是 \\((M,\\nabla_a)\\)  上给定坐标系的普通导数算符，体现 \\(\\nabla_a\\)  和 \\(\\partial_a\\)  差别的张量场 \\(C^c_{\\ \\ ab}\\)  被称为 \\(\\nabla_a\\)  在该坐标系的克氏符，记做 \\(\\Gamma^c_{\\ \\ ab}\\)  。此时， \\(\\nabla_a\\)  称作协变导数算符。\n为协变导数算符和普通导数算符作用张量后的坐标分量分别引入新的记号： \\[ T^\\upsilon_{\\ \\ \\sigma;\\mu}\\overset{\\Delta}{=}\\nabla_\\mu T^\\upsilon_{\\ \\ \\sigma} \\\\ T^\\upsilon_{\\ \\ \\sigma,\\mu}\\overset{\\Delta}{=}\\partial_\\mu T^\\upsilon_{\\ \\ \\sigma} \\]  于是协变导数和普通导数的分量关系式： \\[ T^\\upsilon_{\\ \\ \\sigma;\\mu}=T^\\upsilon_{\\ \\ \\sigma,\\mu}+\\Gamma^{\\upsilon}_{\\ \\ \\mu\\alpha}T^\\alpha_{\\ \\ \\sigma}-\\Gamma^{\\alpha}_{\\ \\ \\mu\\sigma}T^\\upsilon_{\\ \\ \\alpha} \\]  导数算符的两个性质 由导数算符与缩并的可交换性，可等价推导出： \\[ \\nabla_a \\delta^b_{\\ \\ c}=0 \\]  利用导数算符可写出矢量场对易子的显式表达式： \\[ \\left[u,v\\right]^a=u^b\\nabla_b v^a-v^b\\nabla_b u^a \\]  "}),a.add({id:184,href:'/notes/tags/%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2/',title:"坐标变换",content:""}),a.add({id:185,href:'/notes/docs/diffgeo/0005/',title:"基于抽象指标的张量分析",content:"简介 抽象指标记号（英语：abstract index notation）是由罗杰·彭罗斯发明的一种用来表示张量与旋量的数学记号。与不带指标的字母（如T）表示张量相比，这种表示法能够显示张量的类型，同时可清楚地表明缩并等运算。而与用分量（张量在某一特定基底下的分量）表示张量不同，该表示法与特定的基底无关，可以表示出张量等式。\n抽象指标的直观意义(通过比较自己感受)   \\[ \\begin{aligned} \u0026 \\text{抽象指标} \u0026\\qquad\u0026 \\text{具体指标} \u0026\\qquad\u0026 \\text{张量表示} \\\\\u0026\\vec v \u0026\\qquad\u0026 v_i \u0026\\qquad\u0026 \\vec v=v_1 \\vec{e}_1+v_2\\vec{e}_2+v_3\\vec{e}_3 \\\\ \u0026v^a \u0026\\qquad\u0026 v^\\mu \u0026\\qquad\u0026 v^a=v^\\mu (e_\\mu)^a\\\\ \u0026\\omega_b \u0026\\qquad\u0026 \\omega_\\upsilon \u0026\\qquad\u0026 \\omega_b=\\omega_\\upsilon (e^\\upsilon)_b \\\\ \u0026T^a_{\\ \\ b} \u0026\\qquad\u0026 T^\\mu_{\\ \\ \\upsilon} \u0026\\qquad\u0026 T^a_{\\ \\ b}=T^\\mu_{\\ \\ \\upsilon} (e_\\mu)^a(e^\\upsilon)_b \\end{aligned} \\]  在纯矢量分析中，我们已经很自然用了 \\(\\vec{v}\\)  这个抽象指标的原型，但为何到高阶张量反而不用？　在不用抽象指标的情况下，我只能复用 \\(T^\\mu_{\\ \\ \\upsilon}\\)  ，它即表示张量，也表示张量分量，　更严格或许会指着 \\(T\\)  说，这是一个 \\((1,1)\\)  型张量。　如果引入了抽象指标，不但形式上能和 \\(\\vec{v}\\)  一致，而且同 \\(\\vec{v}\\)  一样，是坐标无关的。\n抽象指标的要点  用拉丁字母 \\(a,b,c,\\dots\\)  作为上下标的抽象指标。比如，矢量 \\(\\vec v\\)  可写成 \\(v^a\\)  ，注意 \\(a\\)  在这里仅仅代表这个矢量箭头，不代表 \\(1,2,3,\\dots\\)  。　类似地，对偶矢量可表示成 \\(\\omega_a\\)  。 进而， (2,1)型张量可写成 \\(T^{ab}_{\\ \\ \\ c}\\)  。　 由于是抽象指标， \\(\\upsilon^a\\)  和 \\(\\upsilon^b\\)  独立而言代表相同的矢量，但如果在一个等式中必须注意指标平衡。 比如： \\(\\alpha u^a+v^a=w^a\\)  和 \\(\\alpha u^b+v^b=w^b\\)  代表同一个等式，但写成 \\(\\alpha u^a+v^b=w^a\\)  就不对了。也就是说等号两边不但张量型必须一致，抽象指标也必须一致。 具体指标用小写希腊字母 \\(\\mu,\\upsilon,\\alpha,\\beta,\\dots\\)  表示，对具体指标（比如 \\(\\mu\\)  ）而言，是可取 \\(\\mu=1,2,\\dots\\)  的。 重复上下抽象指标表示对这两个指标求缩并。比如： \\(T^a_{\\ \\ a}=T(e^{\\mu*};e_\\mu)=T^\\mu_{\\ \\ \\mu},T^{ab}_{\\ \\ \\ a}=T(e^{\\mu*},\\bullet;e_\\mu),T^{ab}_{\\ \\ \\ b}=T(\\bullet,e^{\\mu*};e_\\mu)\\)  。 在抽象指标体系中，张量积记号可以省略。比如：对(2,1)型张量 \\(T\\)  和(1,1)型张量 \\(S\\)  ，张量积 \\(T \\otimes S\\)  可写成 \\(T^{ab}_{\\ \\ \\ c}S^d_e\\)  。 一般而言， \\(\\omega \\otimes \\mu \\neq \\mu \\otimes \\omega\\)  ，这是因为两边同时作用于 \\((v,u)\\)  的结果一般是不等的： \\(\\omega \\otimes \\mu(v,u)=\\omega(v) \\mu(u)\\ne\\mu(v) \\omega(u)=\\mu \\otimes \\omega(v,u)\\)  。这个不可交换性，改成抽象指标可表示成： \\(\\omega_a \\mu_b \\ne \\mu_a \\omega_b\\)  。 但是另一方面，由于重复抽象指标代表缩并，那么 \\(\\omega \\otimes\\mu(v,u)\\)  即可写成 \\(\\omega_a \\mu_b v^a u^b\\)  ,也可写成 \\(\\mu_b \\omega_a v^a u^b\\)  （都代表 \\(\\omega(v)\\mu(u)\\)  ），所以 \\(\\omega_a \\mu_b = \\mu_b \\omega_a\\)  。这意味着张量的字母带着自己的抽象指标是可交换的。 抽象指标可用具体指标表示： \\(T^{ab}_{\\ \\ \\ c}=T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}(e_\\mu)^a(e_\\upsilon)^b(e^\\sigma)_c\\)  其中 \\((e_\\mu)^a\\)  代表第 \\(\\mu\\)  个基矢， \\((e^\\sigma)_c\\)  代表第 \\(\\sigma\\)  个对偶基矢。注意：这个表达式本质是把 \\(T=T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}e_\\mu \\otimes e_\\upsilon \\otimes e^{\\sigma *}\\)  ，改写成的抽象指标形式。 具体指标当然也可用抽象指标表示： \\(T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}=T^{ab}_{\\ \\ \\ c}(e^\\mu)_a(e^\\upsilon)_b(e_\\sigma)^c\\)  。 在抽象指标观点下， \\(T^{ab}_{\\ \\ \\ c}\\)  代表一个张量，而 \\(T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}\\)  仅仅代表一个数（分量）。 可从线性映射的角度看待张量。比如： \\(V\\)  上(1,1)型张量 \\(T^a_{\\ \\ b}\\)  ，既可以看成 \\(V\\)  到 \\(V\\)  的线性映射，也可以看成 \\(V^*\\)  到 \\(V^*\\)  的线性映射。因为 \\(\\forall v^b\\in V,T^a_{\\ \\ b}v^b \\in V\\)  ，同时也有 \\(\\forall \\omega_a\\in V^*,T^a_{\\ \\ b}\\omega_a \\in V^*\\)  。 特别地， \\(\\delta^a_{\\ \\ b}\\)  即表示从 \\(V\\)  到 \\(V\\)  的恒等映射，也表示从 \\(V^*\\)  到 \\(V^*\\)  的恒等映射。 度规张量是一个(0,2)型对称张量，通常记做 \\(g_{ab}\\)  。很明显，可以看成是从 \\(V\\)  到 \\(V^*\\)  的一个线性映射。由于度规的特殊性，这个线性映射同时是同构映射，所以可将 \\(v^b\\)  和 \\(g_{ab}v^b\\)  进行同构意义上的认同，于是用相同符号表示： \\(v_a=g_{ab}v^b\\)  。同样的原因， \\(g\\)  的逆映射 \\(g^{-1}\\)  必然存在，用抽象指标表示成： \\(g^{ab}\\overset{\\Delta}{=}(g^{-1})^{ab}\\)  。采用类似的思路，也有 \\(\\omega^a=g^{ab}\\omega_b\\)  。 由此可见，度规张量 \\(g_{ab}\\)  及其逆 \\(g^{ab}\\)  可对任意张量进行指标的“下降”和“上升”。由于度规张量的可逆性，我们还有： \\(g^{ab}g_{bc}=g^a_{\\ \\ c}=\\delta^a_{\\ \\ c}\\)  。最后，不难证明，在具体指标下，也有类似的性质。 由于涉及度规时，存在“升降指标”的问题，所以建议上下两排指标错开。  张量的对称性 对张量 \\(T_{ab}\\)  而言，如果 \\(T_{ab}=T_{ba}\\)  ，则称之为对称张量。如果 \\(T_{ab}=-T_{ba}\\)  ，则称之为反对称张量。\n张量 \\(T_{ab}\\)  的对称部分 \\(T_{(ab)}\\)  和反对称部分 \\(T_{[ab]}\\)  分别定义为： \\[ \\boxed{T_{(ab)}:=\\frac{1}{2}(T_{ab}+T_{ba}),\\quad T_{[ab]}:=\\frac{1}{2}(T_{ab}-T_{ba})} \\]  一般而言， \\((0,l)\\)  型张量 \\(T_{a_1,\\dots,a_l}\\)  的对称和反对称部分定义为： \\[ \\boxed{\\begin{aligned}T_{(a_1,\\dots,a_l)}:=\\frac{1}{l!}\\sum_{\\pi}{T_{a_{\\pi(1)}},\\dots,T_{a_{\\pi(l)}}}\\\\ \\quad \\\\ T_{[a_1,\\dots,a_l]}:=\\frac{1}{l!}\\sum_{\\pi}{\\delta_{\\pi} T_{a_{\\pi(1)}},\\dots,T_{a_{\\pi(l)}}}\\end{aligned}} \\]  其中 \\(\\pi\\)  代表 \\((1,\\dots,l)\\)  的一种排列， \\(\\pi(i)\\)  表示 \\(\\pi\\)  排列中的第 \\(i\\)  个数字， \\(\\delta_{\\pi}=\\pm 1\\)  （偶排列取＋，奇排列取-）。\n如果 \\(T_{a_1,\\dots,a_l}=T_{(a_1,\\dots,a_l)}\\)  ，则称 \\(T_{a_1,\\dots,a_l}\\)  为全对称的；如果 \\(T_{a_1,\\dots,a_l}=T_{[a_1,\\dots,a_l]}\\)  ，则称 \\(T_{a_1,\\dots,a_l}\\)  全反称的。\n以上的内容也完全适用于 \\((k,0)\\)  型张量。\n基本性质 全对称张量 \\(T_{a_1,\\dots,a_l}\\)  ，满足 \\(\\forall \\pi,T_{a_1,\\dots,a_l}=T_{a_{\\pi(1)},\\dots,a_{\\pi(l)}}\\)  。\n全反称张量 \\(T_{a_1,\\dots,a_l}\\)  ，满足 \\(\\forall \\pi,T_{a_1,\\dots,a_l}=\\delta_{\\pi}T_{a_{\\pi(1)},\\dots,a_{\\pi(l)}}\\)  。\n对 \\((k,0)\\)  型(上指标)全对称和全反称张量也有类似结论 。\n缩并时括号具有“传染性”，以方括号为例（圆括号依然）： \\[ \\boxed{T_{[a_1,\\dots,a_l]}S^{a_1,\\dots,a_l}=T_{[a_1,\\dots,a_l]}S^{[a_1,\\dots,a_l]}=T_{a_1,\\dots,a_l}S^{[a_1,\\dots,a_l]}} \\]  括号内同种子括号可以随意增删，比如： \\[ \\boxed{T_{[[ab]c]}=T_{[abc]}} \\]  括号内加异种子括号得０，比如： \\[ \\boxed{T_{[(ab)c]}=0,\\quad T_{([ab]c)}=0} \\]  异种括号缩并得０，比如： \\[ \\boxed{T^{(abc)}S_{[abc]}=0} \\]  全对称张量的反称部分为０，反之亦然： \\[ \\boxed{\\begin{aligned}T_{a_1,\\dots,a_l}=T_{(a_1,\\dots,a_l)} \\Rightarrow T_{[a_1,\\dots,a_l]}=0\\\\ \\quad \\\\ T_{a_1,\\dots,a_l}=T_{[a_1,\\dots,a_l]} \\Rightarrow T_{(a_1,\\dots,a_l)}=0\\end{aligned}} \\]  张量分量的坐标变换 作为用抽象指标表示的张量是绝对的，不依赖坐标系的。但对具体指标所表示的坐标分量是坐标系依赖的。特别地，如果我们选择坐标基矢 \\((\\frac{\\partial }{\\partial x^\\mu})^a\\)  和对偶坐标基矢 \\((dx^\\upsilon)_b\\)  来充当 \\((e_\\mu)^a\\)  和 \\((e^\\upsilon)_b\\)  , 张量分量可表示成：\n\\[ \\boxed{T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}=T^{ab}_{\\ \\ \\ c}(dx^\\mu)_a(dx^\\upsilon)_b(\\frac{\\partial }{\\partial x^\\sigma})^c} \\]  当然我们也能选择一组新的坐标基矢，那么对应新的张量分量： \\[ T'^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}=T^{ab}_{\\ \\ \\ c}(dx'^\\mu)_a(dx'^\\upsilon)_b(\\frac{\\partial }{\\partial x'^\\sigma})^c \\]  新的坐标系和旧的坐标系之间的关系： \\(x'^\\mu=x'(x^1,\\dots,x^d)\\)  ，据此容易可写其微分关系： \\[ dx'^\\mu=\\frac{\\partial x'^\\mu}{\\partial x^\\upsilon}dx^\\upsilon,\\quad \\frac{\\partial }{\\partial x'^\\sigma}=\\frac{\\partial x^\\upsilon}{\\partial x'^\\sigma}\\frac{\\partial }{\\partial x^\\upsilon} \\]  代的 \\(T'^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}\\)  表达式，整理并利用 \\(T^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}\\)  的表达式，最后得到张量分量的表达式： \\[ \\boxed{T'^{\\mu\\upsilon}_{\\ \\ \\ \\sigma}=\\frac{\\partial x'^\\mu}{\\partial x^\\alpha}\\frac{\\partial x'^\\upsilon}{\\partial x^\\beta}\\frac{\\partial x^\\gamma}{\\partial x'^\\sigma}T^{\\alpha\\beta}_{\\ \\ \\ \\gamma}} \\]  虽然上面针对的是 \\((2,1)\\)  型张量及其分量，但对任意型张量都成立。只要注意：1)指标平衡，2)相同指标缩并，3)新旧坐标跟随指标而平衡，我们就能随时写下任意型张量分量的坐标变换。\n范例 4维闵氏度规 \\(\\eta_{ab}\\)  的抽象指标表示： \\[ \\eta_{ab}=\\eta_{\\mu \\upsilon}(dx^\\mu)_a(dx^\\upsilon)_b \\]  其中 \\(\\{(dx^\\mu)_a\\}\\)  是洛伦兹坐标系的对偶基底。以 \\(\\{t,x,y,z\\}\\)  代表 \\(\\{x^0,x^1,x^2,x^3\\}\\)  。因为非０的 \\(\\eta_{\\mu \\upsilon}\\)  只有 \\(\\eta_{00}=-1,\\eta_{11}=\\eta_{22}=\\eta_{33}=1\\)  ，进而有： \\[ \\eta_{ab}=-(dt)_a(dt)_b+(dx)_a(dx)_b+(dy)_a(dy)_b+(dz)_a(dz)_b \\]  于线元表达式 \\(ds^2=-dt^2+dx^2+dy^2+dz^3\\)  相应。如果改用球坐标系 \\(\\{t,r,\\theta,\\varphi \\}\\)  代表新坐标 \\(\\{x'^0,x'^1,x'^2,x'^3\\}\\)  ，则由 \\[ x=r\\sin\\theta\\cos\\varphi,y=r\\sin\\theta\\sin\\varphi,z=r\\cos\\theta \\]  张量分量的变换关系可写成： \\[ \\eta'_{\\mu\\upsilon}=\\frac{dx^\\alpha}{dx'^\\mu}\\frac{dx^\\beta}{dx'^\\upsilon}\\eta_{\\alpha\\beta}=\\frac{dx^\\alpha}{dx'^\\mu}\\eta_{\\alpha\\beta}\\frac{dx^\\beta}{dx'^\\upsilon} \\]  改写成矩阵形式，在Julia进行符号推演得到球形坐标下的度规矩阵 \\([\\eta'_{\\mu\\upsilon}]\\)  ：\n根据度规矩阵，容易写出度规张量： \\[ \\eta_{ab}=-(dt)_a(dt)_b+(dr)_a(dr)_b+r^2(d\\theta )_a(d\\theta )_b+r^2\\sin^2\\theta(d\\varphi)_a(d\\varphi)_b \\]  对应的线元表达式就是： \\[ ds^2=-dt^2+dr^2+r^2(d\\theta^2+\\sin^2\\theta d\\varphi^2) \\]  "}),a.add({id:186,href:'/notes/tags/%E6%8A%BD%E8%B1%A1%E6%8C%87%E6%A0%87/',title:"抽象指标",content:""}),a.add({id:187,href:'/notes/tags/%E5%A4%87%E5%BF%98/',title:"备忘",content:""}),a.add({id:188,href:'/notes/posts/0004/',title:"小技巧备忘",content:"1 本地md+LaTex如何完美发布到知乎？  我已写成了脚本：forzhihu\n 答：知乎编辑器提供了md上传，还提供了https://www.zhihu.com/equation?tex=...接口，并且支持贴图自动上传。　因此完全支持本地Markdown+LaTex完美发布到知乎，具体步骤如下：\n 用本地Markdown编辑器放心写作。【我使用Typora】 将本地图片换成网上图片，我个人的做法是先发布到gitbook，比如我的https://chaoskey.gitee.io/notes/。然后复制图片链接，替换原本地图片链接，图片数量一般不多，手工替换也不麻烦。 将LaTex代码用https://www.zhihu.com/equation?tex=...替换。首先得有支持正则表达全文置换编辑器【我使用Visual Studio Code】，然后将　\\$\\$(\\n*)\\s*(.*?)(\\n*)\\s*\\$\\$　替换成　$1\u0026lt;img src=\u0026quot;https://www.zhihu.com/equation?tex=$2\u0026quot; alt=\u0026quot;$2\u0026quot; class=\u0026quot;ee_img tr_noresize\u0026quot; eeimg=\u0026quot;1\u0026quot;\u0026gt;$3。 当然前面这个正则表达式的形式要以实际为准。 最后，保存文件，然后打开知乎编辑器，上传md文件，简单调整后，发布，完工。  2 Git如何永久删除文件(包括历史记录)  20200425追加\n 首先，可参考 github 的帮助:\nhttps://help.github.com/articles/remove-sensitive-data\n第一步：从你的资料库中清除文件\n以Windows下为例(Linux类似), 打开项目的Git Bash,使用命令:\n$ git filter-branch --force --index-filter \u0026#39;git rm --cached --ignore-unmatch \u0026lt;你要删除的文件的相对路径\u0026gt;\u0026#39; --prune-empty --tag-name-filter cat -- --all $ git filter-branch --force --index-filter \u0026#39;git rm --cached -r --ignore-unmatch \u0026lt;你要删除的文件夹的相对路径\u0026gt;\u0026#39; --prune-empty --tag-name-filter cat -- --all ## 相对路径可以用通配符 ## 这里的文件或文件夹，都不能以 \u0026#39;/\u0026#39; 开头，否则文件或文件夹会被认为是从 git 的安装目录开始。 如果你看到类似下面这样的, 就说明删除成功了:\nRewrite 48dc599c80e20527ed902928085e7861e6b3cbe6 (266/266) # Ref \u0026#39;refs/heads/master\u0026#39; was rewritten 第二步: 推送我们修改后的repo\n以强制覆盖的方式推送你的repo, 命令如下:\n$ git push origin --force --all $ git push origin --force --tags 第三步: 清理和回收空间\n虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间.\n$ rm -rf .git/refs/original/ $ git reflog expire --expire=now --all $ git gc --prune=now Counting objects: 2437, done. # Delta compression using up to 4 threads. # Compressing objects: 100% (1378/1378), done. # Writing objects: 100% (2437/2437), done. # Total 2437 (delta 1461), reused 1802 (delta 1048) $ git gc --aggressive --prune=now Counting objects: 2437, done. # Delta compression using up to 4 threads. # Compressing objects: 100% (2426/2426), done. # Writing objects: 100% (2437/2437), done. # Total 2437 (delta 1483), reused 0 (delta 0) 3 Git常用命令速查 # https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings # Linux下忽略换行符的差异 git config --global core.autocrlf input 【推荐，因为我使用git bash】 # Windows下忽略换行符的差异 git config --global core.autocrlf true # 至于乱码，可在Git GUI中设置UTF-8即可解决。 # 注意： 上面的设置必须在拉取代码前或写代码前必须配置好 # Windows下隐藏文件 attrib +s +h .git # Windows下显示文件 attrib -s -h .git ##################################### # 本地仓库初始 # ##################################### # clone默认分支（gitee） git clone git@gitee.com:chaoskey/notes.git notes # 为远程分支取别名 git remote rename origin gitee # 支持多个多个远程仓库（并取别名） git remote add github git@github.com:chaoskey/notes.git # 一个别名all，包括多个远程 git remote add all git@gitee.com:chaoskey/notes.git git remote set-url --add all git@github.com:chaoskey/notes.git ######################################### # 日常操作 # ######################################### # 查看本地分支 git branch -a # 拉取非默认分支 git fetch gitee gh-pages # 分支切换 git checkout gh-pages git checkout master # 文件提交 git add . git commit -m \u0026#34;提交git常用命令备忘\u0026#34; git push all master # 完全放弃本地修改 git checkout . git clean -df ######################################### # 文件修改记录 # ######################################### # 查看单文件修改历史 git log --pretty=oneline \u0026lt;filename\u0026gt; # 查看尚未暂存的文件更新了哪些部分 git diff git diff git.txt # 查看已经暂存起来的文件和上次提交的版本之间的差异 git diff --cached git diff --cached git.txt # 查看某两个版本之间的差异 git diff \u0026lt;id\u0026gt; \u0026lt;id\u0026gt; git diff \u0026lt;id\u0026gt;:\u0026lt;filename\u0026gt; \u0026lt;id\u0026gt;:\u0026lt;filename\u0026gt; # 显示具体的某次的改动的修改【进入行命令状态，:q 退出】 git show \u0026lt;id\u0026gt; git log -p \u0026lt;filename\u0026gt; 4 Ubunt常用备忘命名【只列我老忘的】 # 启动jupyter nohup jupyter notebook \u0026gt; ./log/notebook.log 2\u0026gt;\u0026amp;1 \u0026amp; # 查看后台程序 jobs ps -ef | grep notebook # 将后台转到前台 fg %1 # 杀进程 kill -9 %1 # 解压 tar -zxvf gr-latest-Ubuntu-x86_64.tar.gz 5 VSC Netease Music 无法启动问题的解决 # 务必以管理员身份在PowerShell中执行 # 要翻墙 set http_proxy=http://127.0.0.1:9081 set https_proxy=http://127.0.0.1:9081 # 修复无法启动问题 # https://www.jianshu.com/p/463f8ece033a Invoke-RestMethod https://gist.githubusercontent.com/nondanee/f157bbbccecfe29e48d87273cd02e213/raw | python # 关闭代理 set http_proxy= set https_proxy= 6 adb常用命令 # 获取adb设备列表 adb devices # 结束adb服务 adb kill-server # 启动adb服务 adb start-server # 已安装应用 adb shell pm list packages # 禁用应用 adb shell pm disable-user com.miui.analytics # 开启应用 adb shell pm enable com.miui.analytics # 卸载应用 adb shell pm uninstall --user 0 com.miui.analytics # 查看特定包的详细信息 adb shell dumpsys package com.miui.greenguard # 启动应用 adb shell am start -n com.miui.greenguard/.ui.AppRestrictActivity # 文件传输 adb push ./abc.apk /sdcard/ adb pull /sdcard/abc.apk ./ # 对特定机型，可能需要先root adb root adb remount # 如果uninstall无法卸载，不妨尝试 adb shell pm path com.miui.touchassistant adb shell rm /system/app/TouchAssistant.apk 以后遇到小问题继续添加\u0026hellip;"}),a.add({id:189,href:'/notes/tags/%E6%8A%80%E5%B7%A7/',title:"技巧",content:""}),a.add({id:190,href:'/notes/tags/%E7%9F%A5%E4%B9%8E/',title:"知乎",content:""}),a.add({id:191,href:'/notes/docs/julia/0003/',title:"基于Julia的科学计算功能库整理",content:"线性代数 julia标准库中包括了LinearAlgebra，直接using LinearAlgebra就能用。详细务必移步官方文档 和 GitHub文档阅读。\n统计模块 julia标准库中包括了Statistics，直接using Statistics就能用。详细务必移步官方文档 阅读。\n微分方程 DifferentialEquations这是完全用julia编写的第三方库，目的是为各种微分方程提供有效的Julia求解器实现。　第一次使用前需要先安装。\nusing Pkg Pkg.add(\u0026#34;DifferentialEquations\u0026#34;) 详细务必移步官方文档 阅读，还有交互式教程。 里面提供了丰富的学习资料，关于这个库只需看这个两个网址就足够了。\n要通过Jupyter笔记本交互地运行教程，请安装该软件包并按如下所示打开教程：\nusing Pkg pkg\u0026#34;add https://github.com/JuliaDiffEq/DiffEqTutorials.jl\u0026#34; using DiffEqTutorials DiffEqTutorials.open_notebooks() 未完待续"}),a.add({id:192,href:'/notes/tags/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97/',title:"科学计算",content:""}),a.add({id:193,href:'/notes/docs/julia/0002/',title:"Julia中的数学符号演算",content:"前言 在整合Julia和Python的集成环境中已经配置好环境，可以在Jupyter中进行学习研究了。\n由于Julia本身暂时还没有好用的符号演算库，只好借用Python的SymPy库。所以，标题应该是“Julia和Python中的数学符号演算”，但由于本文都在Julia环境下进行，单独说Julia将就也可以。\n安装SymPy:\n] pkg\u0026gt; add SymPy　# 安装SymPy的对应接口库 本文的内容主要来自，SymPy.jl教程 和 SymPy官方教程。\n模块导入:\nusing SymPy 变量符号 @vars x y z # 无假设变量定义１ a,b,c = Sym(\u0026#34;a,b,c\u0026#34;) # 无假设变量定义２ 带假设的变量符号 u = symbols(\u0026#34;u\u0026#34;) # 无假设变量定义３ t = symbols(\u0026#34;t\u0026#34;, real=true) # 带假设变量定义 y1, y2 = symbols(\u0026#34;y1, y2\u0026#34;, positive=true) alpha = symbols(\u0026#34;alpha\u0026#34;, integer=true, positive=true) @vars u1 u2 positive=true # @vars也能定义带假设变量 比如：\nusing SymPy @vars x real=true y solve(x^2+1) # 应该无解（没实数解） solve(y^2+1) # 应该有解 SymPy中的特殊常数 PI, oo 依次代表SymPy中的符号圆周率，符号无穷大。 务必注意和julia中的pi和   \\(\\infty\\)  区分。\n符号置换 单变量置换：\n@vars x y ex = x^2 + 2x + 1 ex.subs(x, y) # 结果是y^2 + 2x +1 多变量置换\n@vars x y z ex = x + y + z ex.subs((x,y),(1,pi)) # 不建议这样置换，无法得到正确结果 ex(x=\u0026gt;1, y=\u0026gt;pi) # 推荐使用 ex(1,pi) # 等价与 ex(y=\u0026gt;1, z=\u0026gt;pi) 符号转换成数值 以圆周率为范例展示（注意：后面有是符号还是数值的注释）：\nPI # 符号圆周率, 符号 N(PI) # 转换成无理数圆周率，数值 PI.evalf()　# 转换成默认个有效位数的圆周率，还是符号 PI.evalf(30)　# 转换成30个有效位数的圆周率，还是符号 N(PI.evalf(30)) # 最后转换成有理数，数值 多项式常用操作 1 展开 @vars x expr = expand(prod((x-i) for i in 1:5)) 结果是： \\(x^5−15x^4+85x^3−225x^2+274x−120\\)  2 因式分解 factor(expr) 结果是： \\((x−5)(x−4)(x−3)(x−2)(x−1)\\)  非规则多项式，有时也能因式分解：\nfactor(exp(2x) + 3exp(x) + 2) 结果是： \\((e^x+1)(e^x+2)\\)  3 合并同类项 @vars x y q q = x*y + x*y^2 + x^2*y + x collect(q, x) 结果是：　\\(x^2y+x(y^2+y+1)\\)  collect(q, y) 结果是： \\(xy^2+x+y(x^2+x)\\)  4 化简 simplify(q) 结果是： \\(x(xy+y^2+y+1)\\)  有时，展开操作也能起到化简的作用，可酌情先试试：\nexpand((x + 1)*(x - 2) - (x - 1)*x) 结果是: -2\n有理式常用操作 1 分部 apart( (4x^3 + 21x^2 + 10x + 12) / (x^4 + 5x^3 + 5x^2 + 4x)) 结果是： \\(\\dfrac{2x−1}{x^2+x+1}−\\dfrac{1}{x+4}+\\dfrac{3}{x}\\)  2 合并公母 together(1/x + 1/x^2) 结果是： \\(\\dfrac{1}{x^2}(x+1)\\)  3 消去分子分母公因子 cancel((x^3-6x^2+11x-6)/(x^2-5x+4)) 结果是： \\(\\dfrac{x^2−5x+6}{x−4}\\)  原式本质是： \\(\\dfrac{(x-1)(x-2)(x-3)}{(x-1)(x-4)}\\)  指数化简 可以对含指数的表达式进行无条件或有条件的化简。背后实际是调用powsimp\n有条件化简：\n@vars x y nonnegative=true a real=true simplify(x^a * y^a - (x*y)^a) 结果是：0\n无条件化简：\n@vars x y a simplify(x^a * y^a - (x*y)^a) 结果是： \\(x^ay^a−(xy)^a\\)  三角化简 三角表达式的化简，背后实际是调用trigsimp，当然我们可以不关心。\n@vars θ real=true simplify(cos(θ)^2 + sin(θ)^2) simplify(sin(2θ) - 2sin(θ)*cos(θ)) 结果分别是： 1, 0\n多项式系数 提取多项式系数\n@vars a b c x p = a*x^2 + b*x + c p.coeff(x^2) # a p.coeff(x) # b p(x=\u0026gt;0) # c 注意：SymPy原生有函数coeffs()来获取所有系数，但在Julia中执行会失败。但有两种变通的方法可以使用。\n# p.coeffs() # SymPy原生有这个函数，但在Julia中执行会失败 # 变通的方法 Sym[[p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1]; p(x=\u0026gt;0)] # 通过sympy构造对应的q, 这样才能调用SymPy原生的coeffs q = sympy.Poly(p, x) q.coeffs() 多项式的根 1 实数根 real_roots(x^2 - 2) real_roots((x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)) 结果分别是： \\(\\left[ \\begin{array}{r}- \\sqrt{2}\\\\ \\sqrt{2}\\end{array} \\right]\\)  和　\\(\\left[ \\begin{array}{r}-1\\\\0\\\\1\\\\2\\\\3\\\\3\\end{array} \\right]\\)  2 复数根 Sym(roots(a*x^2 + b*x + c,x)) Sym(roots((x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1))) # 对应的数值根 # nroots((x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1))  结果分别是：　\\(\\left \\{ - \\frac{b}{2 a} - \\frac{1}{2 a} \\sqrt{- 4 a c + b^{2}} : 1, \\quad - \\frac{b}{2 a} + \\frac{1}{2 a} \\sqrt{- 4 a c + b^{2}} : 1\\right \\}\\)  和　\\(\\left \\{ -1 : 1, \\quad 0 : 1, \\quad 1 : 1, \\quad 2 : 1, \\quad 3 : 2, \\quad - \\frac{1}{2} - \\frac{\\sqrt{3} i}{2} : 1, \\quad - \\frac{1}{2} + \\frac{\\sqrt{3} i}{2} : 1\\right \\}\\)  3 更通用的求解方法 rts = solve((x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)) # 可求得数值 # N.(rts) 结果是： \\(\\left[ \\begin{array}{r}-1\\\\0\\\\1\\\\2\\\\3\\\\- \\frac{1}{2} - \\frac{\\sqrt{3} i}{2}\\\\- \\frac{1}{2} + \\frac{\\sqrt{3} i}{2}\\end{array} \\right]\\)  solve函数 除了仅查找单变量多项式的根以外，solve函数还具有更广泛的用途。该函数尝试求解表达式为0或一组表达式都为0的情况。\nsolve(cos(x) - sin(x)) # 返回一个确定范围内的解 solveset(cos(x) - sin(x)) # 返回一个解集合 结果分别是： \\(\\left[ \\begin{array}{r}- \\frac{3 \\pi}{4}\\\\ \\frac{\\pi}{4}\\end{array} \\right]\\)  和 \\(\\left\\{2 n \\pi + \\frac{5 \\pi}{4}\\; |\\; n \\in \\mathbb{Z}\\right\\} \\cup \\left\\{2 n \\pi + \\frac{\\pi}{4}\\; |\\; n \\in \\mathbb{Z}\\right\\}\\)  其中，solveset得到的是一个集合，对有限解集而言，可用collect来收集解，但需要先转换成Julia集，再收集：\nv = solveset(x^2 - 4) collect(Set(v...)) # 先转换成Julia集，再收集 elements(v) # 也可以直接获得 第二个表达式的结果是： \\(\\left[ \\begin{array}{r}-2\\\\2\\end{array} \\right]\\)  需要注意的是，SymPy中的solve是有局限性的，如果没有形式解，将会报错：\nsolve(cos(x) - x) # 没有形式解，会报错 此时，只能求对应的数值解：\nnsolve(cos(x) - x, 1) 结果是：0.7390851332151606416553120876738734040134117589007574649656806357732846548836\n尽管不是什么都是能求解，但可能的话，能够给出一般形式的解，比如：\n@vars a b c real=true p = a*x^2 + b*x + c solve(p, x) solveset(p, x) 结果分别是： \\(\\left[ \\begin{array}{r}\\frac{1}{2 a} \\left(- b + \\sqrt{- 4 a c + b^{2}}\\right)\\\\- \\frac{1}{2 a} \\left(b + \\sqrt{- 4 a c + b^{2}}\\right)\\end{array} \\right]\\)  和 \\(\\left\\{- \\frac{b}{2 a} - \\frac{1}{2 a} \\sqrt{- 4 a c + b^{2}}, - \\frac{b}{2 a} + \\frac{1}{2 a} \\sqrt{- 4 a c + b^{2}}\\right\\}\\)  还可以求解方程组：\n@vars x y real=true exs = [2x+3y-6, 3x-4y-12] d = solve(exs) Sym(d) 结果是： \\(\\left \\{ x : \\frac{60}{17}, \\quad y : - \\frac{6}{17}\\right \\}\\)  将这个结果代入原方程，看是否每个表达式都为０：\nmap(ex -\u0026gt; ex.subs(d), exs) ＯＫ，结果的确都为０：　\\(\\left[ \\begin{array}{r}0\\\\0\\end{array} \\right]\\)  我们也可以选定求解变量：\n@vars a b c h real=true p = a*x^2 + b*x + c fn = cos exs = [fn(0*h)-p(x=\u0026gt;0), fn(h)-p(x =\u0026gt; h), fn(2h)-p(x =\u0026gt; 2h)] d = solve(exs, [a,b,c]) # 选定a,b,c为待求解变量 Sym(d) 结果是： \\(\\left \\{ a : \\frac{1}{2 h^{2}} \\left(- 2 \\cos{\\left (h \\right )} + \\cos{\\left (2 h \\right )} + 1\\right), \\quad b : \\frac{1}{2 h} \\left(4 \\cos{\\left (h \\right )} - \\cos{\\left (2 h \\right )} - 3\\right), \\quad c : 1\\right \\}\\)  将结果d代入p表达式:\nquad_approx = p.subs(d) 得到： \\(1 + \\frac{x}{2 h} \\left(4 \\cos{\\left (h \\right )} - \\cos{\\left (2 h \\right )} - 3\\right) + \\frac{x^{2}}{2 h^{2}} \\left(- 2 \\cos{\\left (h \\right )} + \\cos{\\left (2 h \\right )} + 1\\right)\\)  最后我们再求解一个方程：\nn = 3 @vars x c as = Sym[\u0026#34;a$i\u0026#34; for i in 0:(n-1)] bs = Sym[\u0026#34;b$i\u0026#34; for i in 0:(n-1)] p = sum([as[i+1]*x^i for i in 0:(n-1)]) q = sum([bs[i+1]*(x-c)^i for i in 0:(n-1)]) d = solve(p-q, bs) Sym(d) 结果是： \\(\\left \\{ b_{0} : a_{0} + a_{1} c + a_{2} c^{2}, \\quad b_{1} : a_{1} + 2 a_{2} c, \\quad b_{2} : a_{2}\\right \\}\\)  solve中的逻辑操作 前面的solve中，没必须将表达式写成ex=0，但对更复杂的方程，还是需要逻辑操作的。\n在SymPy中，定义了各种逻辑操作：Eq, Lt, Le, Ge, Gt。　在Julia中则可用符号替代：\\ll[tab]( \\(\\ll\\)  ), \\leqq[tab]( \\(\\leqq\\)  ), \\Equal[tab]( \\(==\\)  ), \\geqq[tab]( \\(\\geqq\\)  ), \\gg[tab]( \\(\\gg\\)  ) , \\neg[tab]( \\(\\neg\\)  )。\n比如：\n@vars x y real=true exs = [2x+3y ⩵ 6, 3x-4y ⩵ 12] ## Using \\Equal[tab] d = solve(exs) Sym(d) 结果是： \\(\\left \\{ x : \\frac{60}{17}, \\quad y : - \\frac{6}{17}\\right \\}\\)  绘图 Plots库可以直接绘制处于符号状态的表达式，比如：\nusing Plots @vars x plot(x^2 -2, -2,2) 再比如参数绘制：\nplot(sin(2x), cos(3x), 0, 4pi) 微积分 1 极限 比如计算 \\(\\lim\\limits_{x \\to +\\infty}{\\dfrac{\\sin(x)}{x}}=1\\)  ，有两种写法：\n@vars x limit(sin(x)/x, x, 0) # 写法１：3个参数 limit(sin(x)/x, x=\u0026gt;0) # 写法２：2个参数, 我喜欢这种 至于 \\(\\infty\\)  ，可以写成两个o来表示，即oo：\nlimit((1+1/x)^x, x =\u0026gt; oo)　# 结果是　e 即： \\(\\lim\\limits_{x \\to \\infty}{(1+\\dfrac{1}{x})^x}=e\\)  再比如：\n@vars a positive=true ex = (sqrt(2a^3*x-x^4) - a*(a^2*x)^(1//3)) / (a - (a*x^3)^(1//4)) ex(x=\u0026gt;a) # 返回NaN，错误 denom(ex)(x =\u0026gt; a), numer(ex)(x =\u0026gt; a)# 返回(0,0),找到原因 limit(ex, x =\u0026gt; a) # 返回16a/9,正确 左、右极限 对于左右极限，可用表示方向的可选参数dir=\u0026quot;-\u0026quot;, dir=\u0026quot;+\u0026quot;,比如：\nlimit(sign(x), x =\u0026gt; 0, dir=\u0026#34;-\u0026#34;), limit(sign(x), x =\u0026gt; 0, dir=\u0026#34;+\u0026#34;) # 结果是：　(-1,1) 数值的局限性 我现在考虑一个特别的函数 \\(f(x)=x^{- \\log{\\left (\\log{\\left (\\log{\\left (\\log{\\left (\\frac{1}{x} \\right )} \\right )} \\right )} \\right )} + 1}\\)  ,很明显这个函数的定义域是： \\((0,\\infty)\\)  f(x) = 1/x^(log(log(log(log(1/x)))) - 1) plot(f(x),0,0.1) # 绘图展示此函数的形态 从此图看，我们会感觉到，向左趋向0的极限，趋向 \\(\\infty\\)  的极限都应该是０。但实际情况是：\nlimit(f(x), x =\u0026gt; 0, dir=\u0026#34;＋\u0026#34;), limit(f(x), x =\u0026gt; oo) 返回的结果是：(oo, 0)。\n这个例子说明了数值的局限性。limit函数使用了Gruntz算法，它比简单的极限数值尝试可靠得多。\n2 导数 我们自然可以根据导数的定义用极限进行求导：\n@vars x h f(x) = exp(x)*sin(x) limit((f(x+h) - f(x)) / h, h, 0) 返回结果是： \\(e^{x} \\sin{\\left (x \\right )} + e^{x} \\cos{\\left (x \\right )}\\)  关于求导，推荐的方法还是使用diff函数：\ndiff(f(x)) # 对默认符号变量x求导 diff(f(x),x) # 对指定符号变量x求导, 【推荐】 返回结果： \\(e^{x} \\sin{\\left (x \\right )} + e^{x} \\cos{\\left (x \\right )}\\)  二阶导数（n阶导数类推），比如：\ndiff(exp(-x^2), x, 2) # 用２表示二阶导数，【推荐】 diff(exp(-x^2), x, x) # 用两个x表示二阶导数 返回结果： \\(2 \\left(2 x^{2} - 1\\right) e^{- x^{2}}\\)  我们经常要求解微分后等于０的方程，可以用diff和solve通过|\u0026gt;进行组合来实现：\nf(x) = (12x^2 - 1) / (x^3) diff(f(x), x) |\u0026gt; solve 返回的结果是： \\(\\left[ \\begin{array}{r}- \\frac{1}{2}\\\\ \\frac{1}{2}\\end{array} \\right]\\)  偏导数 diff也可用来求偏导数，比如：\n@vars x y ex = x^2*cos(y) Sym[diff(ex,v1, v2) for v1 in [x,y], v2 in [x,y]] 返回的结果： \\(\\left[ \\begin{array}{rr}2 \\cos{\\left (y \\right )}\u0026- 2 x \\sin{\\left (y \\right )}\\\\- 2 x \\sin{\\left (y \\right )}\u0026- x^{2} \\cos{\\left (y \\right )}\\end{array}\\right]\\)  形式求导 所谓形式求导，就是给出求导形式，但暂时不计算出求导结果。比如：\nex = sympy.Derivative(exp(x*y), x, y, 2) 返回的结果是： \\(\\frac{\\partial^{3}}{\\partial x\\partial y^{2}} e^{x y}\\)  。　这个函数julia中没有，需要通过sympy调用。\n当然，这个形式求导可以在需要的时候将求导结果计算出来：\nex.doit() 返回的结果是： \\(x \\left(x y + 2\\right) e^{x y}\\)  隐式求导 所谓隐式求导，就是给出多个变量之间的方程关系，求其中一个变量相对其它变量的导数。也就是对隐函数求导。 比如：\n@vars x y # 定义变量 F, G = SymFunction(\u0026#34;F,G\u0026#34;) # 定义隐函数 ex = y^4 - x^4 - y^2 + 2x^2 # 关系ex=0 ex1 = ex(y=\u0026gt;F(x)) # 将隐函数代入 ex2 = diff(ex1, x) # 求导 ex3 = solve(ex2, F\u0026#39;(x))[1] # 求隐函数导数的形式解 ex4 = ex3(F(x) =\u0026gt; y) # 隐函数复原后，就是隐式求导结果 [ex⩵0,ex1⩵0,ex2⩵0,F\u0026#39;(x)⩵ex3,F\u0026#39;(x)⩵ex4] 计算过程：\n\\[ \\left. \\begin{array}{r}- x^{4} + 2 x^{2} + y^{4} - y^{2} = 0\\\\- x^{4} + 2 x^{2} + F^{4}{\\left (x \\right )} - F^{2}{\\left (x \\right )} = 0\\\\- 4 x^{3} + 4 x + 4 F^{3}{\\left (x \\right )} \\frac{d}{d x} F{\\left (x \\right )} - 2 F{\\left (x \\right )} \\frac{d}{d x} F{\\left (x \\right )} = 0\\\\ \\frac{d}{d x} F{\\left (x \\right )} = \\frac{2 x \\left(x^{2} - 1\\right)}{\\left(2 F^{2}{\\left (x \\right )} - 1\\right) F{\\left (x \\right )}}\\\\ \\frac{d}{d x} F{\\left (x \\right )} = \\frac{2 x \\left(x^{2} - 1\\right)}{y \\left(2 y^{2} - 1\\right)}\\end{array} \\right. \\]  范例：最大化诺尔曼窗口的面积 如下图（诺尔曼窗口），周长固定的前提下，求诺尔曼窗口面积最大的宽高。\n@vars w h P nonnegative=true # 宽w,高h, 周长P（固定） r = w/2 # 半圆的半径r A = w*h + 1//2 * (pi * r^2) # 诺尔曼窗口面积 p = w + 2h + pi*r # 周长 求解目标：A最大化。\n首先根据周长固定的约束条件，消除变量h，保留一个变量w：\nh0 = solve(P-p, h)[1] A1 = A(h =\u0026gt; h0) 得到关于w的面积公式： \\(\\frac{\\pi w^{2}}{8} + w \\left(\\frac{P}{2} - \\frac{\\pi w}{4} - \\frac{w}{2}\\right)\\)  要使这个面积最大，除了极值外，还需要考虑 \\(w=0\\)  和 \\(h=0\\)  这两个端点的情况：\nA1(w =\u0026gt; 0) # 宽０,则面积０,不是目标解 b = solve((P-p)(h =\u0026gt; 0), w)[1] # 高０时所对应的宽 下面求面积极值所对应的宽：\nc = solve(diff(A1, w), w)[1] 比较宽分别为b,c时，谁面积更大，面积更大者为问题解：\nsimplify(A1(w =\u0026gt; c)-A1(w =\u0026gt; b)) 返回的结果是正值： \\(\\frac{2 P^{2}}{16 + \\pi^{3} + 20 \\pi + 8 \\pi^{2}}\\)  这个结果说明，当宽度为c时，面积最大。 对应的宽度，高度，面积分别是：\nsimplify.([c,h0(w=\u0026gt;c),A1(w=\u0026gt;c)]) 结果是：\n\\[ \\left[ \\begin{array}{r}\\frac{2 P}{\\pi + 4}\\\\ \\frac{P}{\\pi + 4}\\\\ \\frac{P^{2}}{2 \\left(\\pi + 4\\right)}\\end{array} \\right] \\]  这个结果表明：宽是高的２倍为此问题的最优解。\n3 积分 首先来一个不定积分：\n@vars x n real=true ex = integrate(x^n, x) # 不定积分的参数和diff基本一致 返回结果： \\(\\begin{cases} \\log{\\left (x \\right )} \u0026 \\text{for}\\: n = -1 \\\\ \\frac{x^{n + 1}}{n + 1} \u0026 \\text{otherwise} \\end{cases}\\)  至于定积分，只需要将变量扩展成变量区间即可：\nintegrate(x^2, (x, 0, 1)) # 将不定积分x换成形如(x,0,1) 结果是： \\(\\dfrac{1}{3}\\)  多重积分 多重积分，主要将一个变量元组换成多个变量元组即可，比如：\n@vars x y integrate(x*y, (y, 0, 1), (x, 0, 1)) # 这里有两个变量元组 再比如：\n# 内层积分的变量的上下限可以依赖外层积分的变量 integrate(x^2*y, (y, 0, sqrt(1 - x^2)), (x, -1, 1)) 形式积分 形式积分　和　形式求导对应，比如：\ninteg = sympy.Integral(sin(x^2), x) [integ,integ.doit()] 结果是： \\(\\left[ \\begin{array}{r}\\int \\sin{\\left (x^{2} \\right )}\\, dx\\\\ \\frac{3 \\sqrt{2} \\sqrt{\\pi} S\\left(\\frac{\\sqrt{2} x}{\\sqrt{\\pi}}\\right)}{8 \\Gamma{\\left(\\frac{7}{4} \\right)}} \\Gamma{\\left(\\frac{3}{4} \\right)}\\end{array} \\right]\\)  4 泰勒级数 比如，求关于x，在０点附近，４阶的泰勒级数展开：\n@vars x s1 = series(exp(sin(x)), x, 0, 4) 结果是： \\(1 + x + \\frac{x^{2}}{2} + \\mathcal{O}\\left(x^{4}\\right)\\)  将两个泰勒级数展开式相乘：\ns2 = series(cos(exp(x)), x, 0, 6) s3 = simplify(s1 * s2)　#　相乘后再化简 结果是： \\(\\cos{\\left (1 \\right )} + \\sqrt{2} x \\cos{\\left (\\frac{\\pi}{4} + 1 \\right )} - \\frac{3 x^{2}}{2} \\sin{\\left (1 \\right )} - \\sqrt{2} x^{3} \\sin{\\left (\\frac{\\pi}{4} + 1 \\right )} + \\mathcal{O}\\left(x^{4}\\right)\\)  去除高阶项：\ns3.removeO() 结果是： \\(- \\sqrt{2} x^{3} \\sin{\\left (\\frac{\\pi}{4} + 1 \\right )} - \\frac{3 x^{2}}{2} \\sin{\\left (1 \\right )} + \\sqrt{2} x \\cos{\\left (\\frac{\\pi}{4} + 1 \\right )} + \\cos{\\left (1 \\right )}\\)  求和 比如计算 \\(\\sum\\limits_{i=1}^n{i^2}\\)  的结果：\n@vars i n summation(i^2, (i, 1, n)) 结果是： \\(\\frac{n^{3}}{3} + \\frac{n^{2}}{2} + \\frac{n}{6}\\)  自然也可以进行形式求和：\nsn = sympy.Sum(1/i^2, (i, 1, n)) 结果是： \\(\\sum\\limits_{i=1}^{n} \\frac{1}{i^{2}}\\)  关于无穷项求和，有两种方法：\nlimit(sn.doit(), n, oo) # 先求和，再取极限 summation(1/i^2, (i, 1, oo)) # 直接求和，【推荐】 结果是： \\(\\dfrac{\\pi^{2}}{6}\\)  向量值函数 在Julia中构造一个符号向量很容易：\n@vars x y v = [1,2,x] w = [1,y,3] 更一般的向量操作定义在LinearAlgebra中：\nusing LinearAlgebra dot(v,w) cross(v,w) 通过组合操作可以根据定义计算梯度（多元一阶导数向量），比如：\nex = x^2*y - x*y^2 Sym[diff(ex,var) for var in (x,y)] 结果是： \\(\\left[ \\begin{array}{r}2 x y - y^{2}\\\\x^{2} - 2 x y\\end{array} \\right]\\)  还可以利用hessian计算多元二阶导数矩阵(海森矩阵)：\nhessian(ex, (x,y)) 结果是： \\(\\left[ \\begin{array}{rr}2 y\u00262 x - 2 y\\\\2 x - 2 y\u0026- 2 x\\end{array}\\right]\\)  矩阵 在Julia中，符号矩阵的构造和符号向量的构造一样容易：\n@vars x y M = [1 x; x 1] 如果计算的结果是矩阵，但不是Julia型矩阵，不妨依次试试Sym[.]和sympy.Matrix(.)，比如：\nM^2 # 形式难看 Sym(M^2) # 依然难看 sympy.Matrix(M^2)　# 嗯，合适 结果是： \\(\\left[ \\begin{array}{rr}x^{2} + 1\u00262 x\\\\2 x\u0026x^{2} + 1\\end{array}\\right]\\)  计算矩阵行列式：\ndet(M) # 方法１，【推荐】 M.det() # 方法２ 结果： \\(- x^{2} + 1\\)  计算特征向量：\n# A.eigenvects() 有问题 eigvecs(M) 结果： \\(\\left[ \\begin{array}{rr}-1\u00261\\\\1\u00261\\end{array}\\right]\\)  矩阵对角化：\nA = [1 x; x 1] P, D = A.diagonalize() # M = PDP^-1 A - P*D*inv(P) # 验证，如果全０则ＯＫ 微分方程 比如，我们要 \\(y{\\left (x \\right )} - 2 \\frac{d}{d x} y{\\left (x \\right )} + \\frac{d^{2}}{d x^{2}} y{\\left (x \\right )} = \\sin{\\left (x \\right )}\\)  的通解：\n@vars x y = SymFunction(\u0026#34;y\u0026#34;) diffeq = diff(y(x), x, 2) - 2*diff(y(x)) + y(x)⩵ sin(x) ex = dsolve(diffeq, y(x)) 结果是： \\(y{\\left (x \\right )} = \\left(C_{1} + C_{2} x\\right) e^{x} + \\frac{1}{2} \\cos{\\left (x \\right )}\\)  上面这个微分方程也可以写成：\ndiffeq = y\u0026#39;\u0026#39;(x) - 2y\u0026#39;(x) + y(x) ⩵ sin(x) 如果给定初值条件： \\(y(0)=0,y'(0)=1\\)  ，进而可确定积分常数 \\(C_1,C_2\\)  :\nex1 = ex.rhs() # 右边的表达式 # 据y(0)=0，得C1 c1=solve(ex1(x=\u0026gt;0),Sym(\u0026#34;C1\u0026#34;))[1] ex2=ex1(Sym(\u0026#34;C1\u0026#34;)=\u0026gt;c1) # 将c1代入得到只含C2表达式 # 据y\u0026#39;(0)=1，得C2 c2=solve(diff(ex2,x)(x=\u0026gt;0)-1,Sym(\u0026#34;C2\u0026#34;) )[1]　ex3 = ex2(Sym(\u0026#34;C2\u0026#34;) =\u0026gt; c2) # 将c2代入得最终表达式 结果是： \\(\\left(\\frac{3 x}{2} - \\frac{1}{2}\\right) e^{x} + \\frac{1}{2} \\cos{\\left (x \\right )}\\)  初值问题 前面通过比较麻烦方法，先求通解，再初值回代解出积分常数。　其实可以直接解出初值问题，只需要简单加上边值条件的参数即可：\n@vars x y = SymFunction(\u0026#34;y\u0026#34;) diffeq = y\u0026#39;\u0026#39;(x) - 2y\u0026#39;(x) + y(x) ⩵ sin(x) ex = dsolve(diffeq, y(x), ics=((y, 0, 0), (y\u0026#39;, 0, 1))) 结果和前面一样。\n最后说明 符号推演不是万能的，可能没有想要的符号解。如果没有，最终还需要靠数值解法。\n"}),a.add({id:194,href:'/notes/tags/%E7%AC%A6%E5%8F%B7%E6%BC%94%E7%AE%97/',title:"符号演算",content:""}),a.add({id:195,href:'/notes/tags/sed/',title:"sed",content:""}),a.add({id:196,href:'/notes/tags/typora/',title:"typora",content:""}),a.add({id:197,href:'/notes/tags/vscode/',title:"vscode",content:""}),a.add({id:198,href:'/notes/docs/julia/0001/',title:"整合Julia和Python的集成环境（Win10）",content:"目标 １） 统一利用Visual Studio Code作为Julia和Python的ＩＤＥ\n２） 统一利用Jupyter作为Julia和Python的Notebook\n３） 以Julia作为我主要的使用语言，确保能调用Python的库包\n第一步 安装Anaconda  国内建议到清华开源镜像站根据各自的情况选择下载。\n 1）下载、安装【按提示安装VSCode，如果没有的话】\n我选择的是： Anaconda3-5.3.1-Windows-x86_64.exe 建议安装在非系统盘。\n2）配置国内镜像，我选择清华开源镜像：\n 启动Anaconda命令行，执行下面命令配置镜像：  conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --set show_channel_urls yes  检查镜像设置  conda config --show channels 3）安装时VSCode自动配置好了，如果手工安装的VSCode,需要手工搜索安装Anaconda扩展\n4）最后用VSCode写一个简单的Hello World程序验证之。\n第二步 安装Julia  国内建议到北外镜像站站根据各自的情况选择下载。\n 1）Julia的下载、安装、设置环境变量PATH\n我选择的是： julia-1.4.2-win64.exe 建议安装在非系统盘。\n2） 设置Julia库目录 【注意目录要和实际一致】\nmklink /D /J %HOMEPATH%\\.julia D:\\ProgramData\\Julia\\JuliaDepot 设置北外镜像站 【要重启julia】  # %HOMEPATH%\\.julia\\config\\startup.jl ENV[\u0026#34;JULIA_PKG_SERVER\u0026#34;] = \u0026#34;https://mirrors.bfsu.edu.cn/julia/static\u0026#34; 4）更新Julia库\n\u0026gt; julia julia \u0026gt; ] pkg\u0026gt; update 第三步 为Julia配置VSCode 1）安装julia扩展插件\n2）打开 文件》首选项》设置，设置Julia命令路径【注意红圈标记】\n3）写一个简单的Hello world程序，验证配置是否成功。\n第四步 为Julia配置Jupyter 安装Anaconda时，已经为Python配置过Jupyter了，现在只要补充为Julia配置即可。\n1）设置Jupyter路径 【要重启julia】\n# %HOMEPATH%/.julia/config/startup.jl 【注意和实际一致】 ENV[\u0026#34;JUPYTER\u0026#34;]=\u0026#34;D:\\\\ProgramData\\\\Anaconda3\\\\Scripts\\\\jupyter.exe\u0026#34; 然后安装IJulia  ] pkg\u0026gt; add IJulia 3） 设置jupter的默认目录：\n# 务必在Anaconda命令行中执行 jupyter notebook --generate-config # 这个命令会生成一个文件： # %HOMEPATH%/.jupyter/jupyter_notebook_config.py # 在此文件中找到下行，取消注释，修改目标目录【以实际为准】 # c.NotebookApp.notebook_dir = u\u0026#39;E:\\\\Work\u0026#39; 启动Jupyter Notebook，能看见julia内核就算成功。  # 在Anaconda命令行中执行 jupyter notebook 第五步 安装GR库 1）首先当然试图正常安装，如果一切正常，后续步骤忽略\n\u0026gt; julia julia\u0026gt; ] pkg\u0026gt; add GR 2） 如果报错，或等待时间太长，意味着是网络问题. 并且大概率是卡在build阶段。 那么你务必准备好翻墙软件再继续：\n# 建议在cmd命令行中开始 # 设置代理【以实际为准】 \u0026gt; set http_proxy=http://127.0.0.1:9081 \u0026gt; set https_proxy=http://127.0.0.1:9081 \u0026gt; julia julia\u0026gt; ] pkg\u0026gt; build GR Ctrl+c julia\u0026gt; exit() # 清除代理 \u0026gt; set http_proxy= \u0026gt; set https_proxy=   验证安装成功否【也可在jupyter notebook中执行】\nusing GR histogram(randn(10000))   第六步 Julia调用Python库包的基础配置 Ａ．进入Julia命令行，首先设置Python的路径 【要重启julia】\n# vim ~/.julia/config/startup.jl 【注意和实际一致】 ENV[\u0026#34;PYTHON\u0026#34;] = \u0026#34;D:\\\\ProgramData\\\\Anaconda3\\\\python.exe\u0026#34; Ｂ．安装调用Python的基础库\n] pkg\u0026gt; add PyCall Ｃ．以SymPy作为范例，先安装范例需要的Python库，然后执行相应的代码\n] pkg\u0026gt; add SymPy　# 安装Python库的对应接口库 using SymPy @vars x h # 定义符号变量 limit((sin(x+h)-sin(x))/h,h,0) # 求极限 diff(sin(x)) # 求导 大功告成   后面的内容是额外补充的\n  第七步 改用Jupyter Lab 【“淘汰掉”Juppter Notebook】 【Juppter Notebook的配置全部保留】\n安装Jupyter Lab：\n# 在Anaconda命令行中执行 conda install -c conda-forge jupyterlab 启动Jupyter Lab\n# 在Anaconda命令行中执行 jupyter lab 启动后的效果：\n第八步 整合WolframScript  假设1)你已经安装了Wolfram Mathematica 或 免费的WolframEngine，都有WolframScript，并设置好PATH环境变量;\n假设2）你已经安装配置好了Git，并设置好PATH环境变量\n 参考 WolframLanguageForJupyter\n# 务必在Anaconda命令行中执行【要和jupyter整合】 git clone https://github.com/WolframResearch/WolframLanguageForJupyter.git cd WolframLanguageForJupyter .\\configure-jupyter.wls add 重启Jupyter Lab， 就可以看见前面那张图中的Wolfram Lanquaqe的图标。\n"}),a.add({id:199,href:'/notes/posts/0067/',title:"通过实例掌握流编辑器sed",content:"缘由 由于Hugo对Markdown的解析和LaTeX存在诸多冲突。比如：当LaTex中出现\\\\、\\{、\\}之类的东西，Hugo就无法正常解析数学公式。\n解决方案之一就是用Hugo的shortcodes机制，在md文件中用形如{{\u0026lt; katex [display] \u0026gt;}}latex code{{\u0026lt; /katex \u0026gt;}}格式。\n这样一来，网站显示正常了，但在本地Typora就无法识别了。 个人体验不好。\n于是我想到用流编编器sed对md内容进行替换。 我以前用sed都是简单的情况，复杂需求我就不会用了。 于是有了此文。\n需求 利用Hugo发布到站点前：将$latex code$，置换成 {{\u0026lt; katex [display] \u0026gt;}}latex code{{\u0026lt; /katex \u0026gt;}}。\n用Typora写作编辑前： 将 {{\u0026lt; katex [display] \u0026gt;}}latex code{{\u0026lt; /katex \u0026gt;}}，置换成 $latex code$。\n注意：置换时，同时要跳过代码块不处理。\n我写成的代码（后面将逐项解释，备忘） #!/bin/bash  # md文件递归 function action(){ for file in `ls $1` do if [ -d $1\u0026#34;/\u0026#34;$file ] then action $1\u0026#34;/\u0026#34;$file elif [ \u0026#34;${file#*.}\u0026#34;x = \u0026#34;md\u0026#34;x ] then # 方便发布到gitee sed -i \u0026#39;/```/ { :begin1; /```.*```/! { $! { N; b begin1 }; }; n; }; /\\$\\$/ { :begin2; /\\$\\$[^$]*\\$\\$/! { $! { N; b begin2 }; }; }; s/\\$\\$\\(\\n[^$]*\\n\\)\\$\\$/{{\u0026lt; katex display \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g; s/\\$\\$\\([^$]*\\)\\$\\$/{{\u0026lt; katex \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g; s/!\\[.*\\](\\.\\.\\/images\\//![](..\\/..\\/images\\//g;\u0026#39; $1\u0026#34;/\u0026#34;$file fi done } action ./content if [ \u0026#34;$1\u0026#34;x = \u0026#34;server\u0026#34;x ] then # 站点本地预览 hugo server --disableFastRender -D else # 站点静态文件生成 hugo -D # 文件恢复成Typora可正常阅读状态 ./fortypora fi 相关SED代码的详细解释(备忘) 把上面代码中SED部分单独提出来，写成方便阅读的形式，并逐行解释：\n# 正则识别代码块的开始界定符 /```/ { :begin1 # 正则识别完整代码块 /```.*```/! { # 没能匹配代码块，则读取下行，附加到“模式空间” $! { N; b begin1 } } # 成功匹配代码块，则读取下行，清空“模式空间” n; } # 上面这段代码目的: 跳过代码块```code``` # 正则识别标准数学公式开始界定符 /\\$\\$/ { :begin2 # 正则识别完整的数学公式块（界定符） /\\$\\$[^$]*\\$\\$/! { # 没能数学公式块，则读取下行，附加到“模式空间” $! { N; b begin2 } } } # 对“（多行）模式空间” 进行置换：块公式的界定符变换 s/\\$\\$\\(\\n[^$]*\\n\\)\\$\\$/{{\u0026lt; katex display \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g # 对“（多行）模式空间” 进行置换：内联公式的界定符变换 s/\\$\\$\\([^$]*\\)\\$\\$/{{\u0026lt; katex \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g # 对“（多行）模式空间” 进行置换：顺带进行链接变换 s/!\\[.*\\](\\.\\.\\/images\\//![](..\\/..\\/images\\//g 上面的注释已经解释的很清楚了：\n 展示了如何用SED进行多行匹配：先识别开始界定符，然后反复检查代码块的完整性，不完整则逐行添加，完整则继续。 这里只用到了\u0026quot;模式空间\u0026quot;。命令N可将”单行模式空间“扩展成”多行模式空间“；命令n则将”多行模式空间“清空，恢复成”单行模式空间“。 最后通过s/\u0026lt;正则匹配被替换老的部分\u0026gt;/\u0026lt;新的部分\u0026gt;/g，完成置换。 注意： 把多行压缩时需要添加; （注意后面有个空格）。  一旦理解这个例子，我想一般的SED就不在话下。\n"}),a.add({id:200,href:'/notes/posts/0000/',title:"用Hugo+码云搭建支持Markdown+LaTeX的云笔记",content:"目标(配置好后的日常操作)  更新流程简单舒服，页面主题简洁，完全支持Markdown+LaTeX。\n 1）本地撰写内容：用Typora写基于Markdown+LaTeX的内容。\n2）利用静态网站生成器Hugo生成待发布的静态文件： 执行./forgitee。\n 这个脚本实际依次执行了：1. 对所有md文件进行部分内容替换，确保站点可以完全解析； 2. 执行hugo -D,生成待发布的静态文件，生成文件夹public; 3. 执行./fortypora对所有md文件进行逆向置换复原，确保Typora打开能完全显示正常。  3） 将站点git提交到码云（gitee）： https://gitee.com/chaoskey/notes\n 包括站点全部源码（相当于文档云同步）和生成的静态文件目录public。  4） 部署到： https://chaoskey.gitee.io/notes\n5） 一键发布的脚本./publish（注意，必须根据你自己的情况修改之），依次执行了： 1. ./forgitee; 2. 将修改过的笔记提交到master分支； 3. 将public提交到gh-pages分支； 4. 将gh-pages分支push到gitee和github。\n 第一步：安装git 我选择的是官方winGUI版本，国内很难下载，建议翻墙下载。默认选项安装即可。\n由于官方版本本来就支持shell，后面的操作主要是在git bash下进行，如果GUI更方便时就使用GUI。\n第二步：安装Hugo 选择Hugo的原因，是因为配置简单、库依赖度很低。\n依然选择官方win版本，翻墙下载。\n我选择的是hugo_extended_0.64.1_Windows-64bit.zip，解压，设置好PATH就能用。\n第三步：在码云上创建一个初始库 选择码云而不是GitHub的原因是众所周知，虽然可以翻墙，毕竟麻烦。\n创建一个初始库即可，不用额外设置。\n我所创建的库是：https://gitee.com/chaoskey/notes\n第四步：建立初始站点 打开git bash，后同。\n# 初始化本地站点 hugo new site notes cd notes 打开git GUI, 将https://gitee.com/chaoskey/notes克隆到刚构建本地目录notes。 如果克隆时提示已存在，则先备份notes，克隆后再覆盖回去。\n先设置站点根目录 https://chaoskey.gitee.io/notes/\n第五步：选择主题 我的目标是学习笔记，所以我找到一款简洁并适合的主题hugo-book：\n# 克隆主题到themes/book git clone https://github.com/alex-shpak/hugo-book themes/book # 复制主题范例站点和配置 cp -a themes/book/exampleSite/config.toml . cp -a themes/book/exampleSite/content . 第六步：公式引擎配置(可选) 由于该主题已经支持katex,所以此步可选，对应的代码位置：\nthemes\\book\\layouts\\shortcodes\\katex.html\n但原版默认只支持{{\u0026lt; katex [display] \u0026gt;}}latex{{\u0026lt; /katex \u0026gt;}}格式，所以我作了后面的改动，以支持$\\latex$的格式，并且还通过配置支持katex和mathjax。\n\u0026lt;!-- 原始位置： themes\\book\\layouts\\shortcodes\\katex.html 也可以将其独立出来放在站点根目录下： layouts\\shortcodes\\katex.html --\u0026gt; {{ if not (.Page.Scratch.Get \u0026#34;katex\u0026#34;) }} {{ if and (isset .Site.Params \u0026#34;katex\u0026#34;) (eq .Site.Params \u0026#34;mathjax\u0026#34; ) }} \u0026lt;!-- Include mathjax only first time --\u0026gt; \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; MathJax.Hub.Config({ showProcessingMessages: false, messageStyle: \u0026#34;none\u0026#34;, extensions: [\u0026#34;tex2jax.js\u0026#34;], jax: [\u0026#34;input/TeX\u0026#34;, \u0026#34;output/HTML-CSS\u0026#34;], tex2jax: { inlineMath: [ [\u0026#34;$\u0026#34;, \u0026#34;$\u0026#34;], [\u0026#34;\\(\u0026#34;, \u0026#34;\\)\u0026#34;] ], displayMath: [ [\u0026#34;$\\n\u0026#34;,\u0026#34;\\n$\u0026#34;], [\u0026#34;\\\\[\u0026#34;,\u0026#34;\\\\]\u0026#34;] ], skipTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;,\u0026#39;code\u0026#39;,\u0026#39;a\u0026#39;], ignoreClass:\u0026#34;comment-content\u0026#34; }, \u0026#34;HTML-CSS\u0026#34;: { availableFonts: [\u0026#34;STIX\u0026#34;,\u0026#34;TeX\u0026#34;], showMathMenu: false } }); MathJax.Hub.Queue([\u0026#34;Typeset\u0026#34;,MathJax.Hub]); \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ else }} \u0026lt;!-- Include katext only first time --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css\u0026#34; integrity=\u0026#34;sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.js\u0026#34; integrity=\u0026#34;sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;https://cdn.bootcss.com/KaTeX/0.11.1/contrib/auto-render.min.js\u0026#34; integrity=\u0026#34;sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; onload=\u0026#34;renderMathInElement(document.body, {delimiters: [{left: \u0026#39;$\\n\u0026#39;, right: \u0026#39;\\n$\u0026#39;, display: true}, {left: \u0026#39;$\u0026#39;, right: \u0026#39;$\u0026#39;, display: false}, {left: \u0026#39;\\\\[\u0026#39;, right: \u0026#39;\\\\]\u0026#39;, display: true}, {left: \u0026#39;\\\\(\u0026#39;, right: \u0026#39;\\\\)\u0026#39;, display: false}]});\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{ end }} {{ .Page.Scratch.Set \u0026#34;katex\u0026#34; true }} {{ end }} \u0026lt;span class=\u0026#34;katex{{ with .Get \u0026#34;class\u0026#34; }} {{ . }}{{ end }}\u0026#34;\u0026gt; {{ if in .Params \u0026#34;display\u0026#34; }}\\[{{ else }}\\({{ end -}} {{ $.Inner }} {{- if in .Params \u0026#34;display\u0026#34; }}\\]{{ else }}\\){{ end }} \u0026lt;/span\u0026gt; 然后，在config.toml中添加一段配置，默认使用katex引擎\n####################################### # (Optional, default none) 选择数学公式渲染引擎 # 默认就是katex引擎, 另外的选择就是 mathjax引擎 (即使改了引擎，标签也继续沿用katex) # 优先使用$$作为公式界定符号 # 1. 内联公式，比如： $a^2$ # 2. 块公式，比如： # $$ # a^2 # $$ # 如果渲染失败时（hugo和引擎的冲突），首先作如下2个置换 # 1. 内联公式:\\$\\$(.*?\\\\[\\\\\\}\\{].*?)\\$\\$ =\u0026gt; {{\u0026lt; katex \u0026gt;}}$1{{\u0026lt; /katex \u0026gt;}} # 2. 块公式:\\$\\$(\\n.*?\\\\[\\\\\\}\\{].*?\\n)\\$\\$ =\u0026gt; {{\u0026lt; katex display \u0026gt;}}$1{{\u0026lt; /katex \u0026gt;}} # 如果还是失败，则修改公式。 ####################################### # katex = \u0026#34;mathjax\u0026#34; 第七步：Typora和Hugo站点协调 由于Hugo的Markdown解析机制和$$格式下的公式有时存在冲突，导致在Typora显示正常的公式，在Hugo解析Markdown时会错误显示或不显示公式。\n为了解决这个问题，我写了两个shell脚本：\n1） ./fortypora： 执行后确保用Typora打开本地md文件可以正常渲染，特别是数学公式。\n#!/bin/bash  # 执行后确保用Typora打开本地md文件可以正常渲染，特别是数学公式。 # 将`{{\u0026lt; katex [display] \u0026gt;}}latex{{\u0026lt; /katex \u0026gt;}}` # 转换成$$格式 # ./fortypora # md文件递归 function action(){ for file in `ls $1` do if [ -d $1\u0026#34;/\u0026#34;$file ] then action $1\u0026#34;/\u0026#34;$file elif [ \u0026#34;${file#*.}\u0026#34;x = \u0026#34;md\u0026#34;x ] then # 方便用typora阅读 sed -i \u0026#39;s/{{\u0026lt;\\s*katex\\s*\u0026gt;}}/$/g; s/{{\u0026lt;\\s*katex\\s*display\\s*\u0026gt;}}/$/g; s/{{\u0026lt;\\s*\\/katex\\s*\u0026gt;}}/$$/g; s/!\\[.*\\](\\.\\.\\/\\.\\.\\/images\\//![](..\\/images\\//g; \u0026#39; $1\u0026#34;/\u0026#34;$file fi done } action ./content 2）./forgitee： 执行后确保用Hugo生成的站点可以正常渲染，特别是数学公式。\n#!/bin/bash  # 执行后确保用Hugo生成的站点可以正常渲染，特别是数学公式。 # 先将`$$` # 转换成`{{\u0026lt; katex [display] \u0026gt;}}latex{{\u0026lt; /katex \u0026gt;}}` # 再执行 hugo [servere] -D 命令 # ./forgitee # 站点发布（生成静态文件） # ./forgitee server # 站点预览 # md文件递归 function action(){ for file in `ls $1` do if [ -d $1\u0026#34;/\u0026#34;$file ] then action $1\u0026#34;/\u0026#34;$file elif [ \u0026#34;${file#*.}\u0026#34;x = \u0026#34;md\u0026#34;x ] then # 方便发布到gitee sed -i \u0026#39;/```/ { :begin1; /```.*```/! { $! { N; b begin1 }; }; n; }; /\\$\\$/ { :begin2; /\\$\\$[^$]*\\$\\$/! { $! { N; b begin2 }; }; }; s/\\$\\$\\(\\n[^$]*\\n\\)\\$\\$/{{\u0026lt; katex display \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g; s/\\$\\$\\([^$]*\\)\\$\\$/{{\u0026lt; katex \u0026gt;}}\\1{{\u0026lt; \\/katex \u0026gt;}}/g; s/!\\[.*\\](\\.\\.\\/images\\//![](..\\/..\\/images\\//g;\u0026#39; $1\u0026#34;/\u0026#34;$file fi done } action ./content if [ \u0026#34;$1\u0026#34;x = \u0026#34;server\u0026#34;x ] then # 本地预览 hugo server --disableFastRender -D else rm -rf public # 生成待发布的静态文件，生成的目录 public hugo -D # 方便用typora阅读 ./fortypora fi "}),a.add({id:201,href:'/notes/docs/mlapp/07linear_regression/0065/',title:"7.6 贝叶斯线性回归",content:"返回本章目录\n虽然岭回归是计算点估计的有用方法，但有时我们想要计算关于   \\(\\boldsymbol{w}\\)  和 \\(\\sigma^2\\)  的完全后验。 为简单起见，我们首先假设噪声方差 \\(\\sigma^2\\)  是已知的，因此我们专注于计算 \\(p(\\boldsymbol{w}| \\mathcal{D},\\sigma^2)\\)  。 然后在7.6.3节我们将考虑一般情况，也就是计算 \\(p(\\boldsymbol{w},\\sigma^2|\\mathcal{D})\\)  。 我们假设始终是高斯似然模型。 以稳健拟然执行贝叶斯推断也是可能的，但需要更高级的技术（参见练习24.5）。\n7.6.1 计算后验 在线性回归中，拟然由下式给出\n\\[ \\begin{aligned} p(\\boldsymbol{y}|\\boldsymbol{X},\\boldsymbol{w},\\mu, \\sigma^2) = \u0026 \\mathcal{N}(\\boldsymbol{y}|\\mu+\\boldsymbol{X}\\boldsymbol{w},\\sigma^2 \\boldsymbol{I}_N) \\\\ \\quad = \u0026 \\exp \\left(-\\dfrac{1}{2\\sigma^2}(\\boldsymbol{y}-\\mu \\boldsymbol{1}_N-\\boldsymbol{X}\\boldsymbol{w})^T(\\boldsymbol{y}-\\mu \\boldsymbol{1}_N-\\boldsymbol{X}\\boldsymbol{w})\\right) \\end{aligned} \\tag{7.52-53} \\]  其中 \\(\\mu\\)  是偏移项。 如果输入已经中心化了，那么对于每个 \\(\\sum_i{x_{ij}}=0,\\forall j\\)  ，输出的均值同样可能为正或负。 因此，让我们在 \\(\\mu\\)  上放置一个形如 \\(p(\\mu) \\propto 1\\)  的不恰当的先验，然后将其积分得到\n\\[ p(\\boldsymbol{y}|\\boldsymbol{X},\\boldsymbol{w},\\sigma^2) = \\exp \\left(-\\dfrac{1}{2\\sigma^2}\\|\\boldsymbol{y}-\\bar{y} \\boldsymbol{1}_N-\\boldsymbol{X}\\boldsymbol{w}\\|_2^2\\right) \\tag{7.54} \\]  其中 \\(\\bar{y}=\\frac{1}{N}\\sum_{i=1}^N{y_i}\\)  是输出的经验均值。 为了简化符号，假设输出已经中心化，于是可将 \\(\\boldsymbol{y}-\\bar{y}\\boldsymbol{1}_N\\)  可简写成 \\(\\boldsymbol{y}\\)  。\n在上述高斯似然之前的共轭也是高斯，我们将通过p（w）= N（w | w0，V0）来表示。 使用贝叶斯规则求高斯，公式4.125，后验由下式给出\n\\[ a \\tag{7.55-58} \\]  If w0 = 0 and V0 = τ 2I, then the posterior mean reduces to the ridge estimate, if we define λ = σ2 τ2 . This is because the mean and mode of a Gaussian are the same.\nTo gain insight into the posterior distribution (and not just its mode), let us consider a 1D example:\n\\[ a \\tag{7.59} \\]  where the “true” parameters are w0 = −0.3 and w1 = 0.5. In Figure 7.11 we plot the prior, the likelihood, the posterior, and some samples from the posterior predictive. In particular, the right hand column plots the function y(x, w(s) ) where x ranges over [−1, 1], and w(s) ∼ N (w|wN , VN ) is a sample from the parameter posterior. Initially, when we sample from the prior (first row), our predictions are “all over the place”, since our prior is uniform. After we see one data point (second row), our posterior becomes constrained by the corresponding likelihood, and our predictions pass close to the observed data. However, we see that the posterior has a ridge-like shape, reflecting the fact that there are many possible solutions, with different slopes/intercepts. This makes sense since we cannot uniquely infer two parameters from one observation. After we see two data points (third row), the posterior becomes much narrower, and our predictions all have similar slopes and intercepts. After we observe 20 data points (last row), the posterior is essentially a delta function centered on the true value, indicated by a white cross. (The estimate converges to the truth since the data was generated from this model, and because Bayes is a consistent estimator; see Section 6.4.1 for discussion of this point.)\n7.6.2 计算后验预测  It’s tough to make predictions, especially about the future. — Yogi Berra\n In machine learning, we often care more about predictions than about interpreting the parameters. Using Equation 4.126, we can easily show that the posterior predictive distribution at a test point x is also Gaussian:\n\\[ a \\tag{7.60-62} \\]  The variance in this prediction, σ2 N (x), depends on two terms: the variance of the observation noise, σ2, and the variance in the parameters, VN . The latter translates into variance about observations in a way which depends on how close x is to the training data D. This is illustrated in Figure 7.12, where we see that the error bars get larger as we move away from the training points, representing increased uncertainty. This is important for applications such as active learning, where we want to model what we don’t know as well as what we do. By contrast, the plugin approximation has constant sized error bars, since\n\\[ a \\tag{7.63} \\]  See Figure 7.12(a).\n7.6.3 当 \\(\\sigma^2\\)  未知时的贝叶斯推断* In this section, we apply the results in Section 4.6.3 to the problem of computing p(w, σ2|D) for a linear regression model. This generalizes the results from Section 7.6.1 where we assumed σ2 was known. In the case where we use an uninformative prior, we will see some interesting connections to frequentist statistics.\n7.6.3.1 共轭先验 As usual, the likelihood has the form\n\\[ a \\tag{7.64} \\]  By analogy to Section 4.6.3, one can show that the natural conjugate prior has the following form:\n\\[ a \\tag{7.65-68} \\]  With this prior and likelihood, one can show that the posterior has the following form:\n\\[ a \\tag{7.69-73} \\]  The expressions for wN and VN are similar to the case where σ2 is known. The expression for aN is also intuitive, since it just updates the counts. The expression for bN can be interpreted as follows: it is the prior sum of squares, b0, plus the empirical sum of squares, yT y, plus a term due to the error in the prior on w.\nThe posterior marginals are as follows:\n\\[ a \\tag{7.74-75} \\]  We give a worked example of using these equations in Section 7.6.3.3.\nBy analogy to Section 4.6.3.6, the posterior predictive distribution is a Student T distribution. In particular, given m new test inputs X˜ , we have\n\\[ a \\tag{7.76} \\]  The predictive variance has two components: (bN /aN )Im due to the measurement noise, and (bN /aN )XV˜ N X˜ T due to the uncertainty in w. This latter terms varies depending on how close the test inputs are to the training data.\nIt is common to set a0 = b0 = 0, corresponding to an uninformative prior for σ2, and to set w0 = 0 and V0 = g(XT X)−1 for any positive value g. This is called Zellner’s g-prior (Zellner 1986). Here g plays a role analogous to 1/λ in ridge regression. However, the prior covariance is proportional to (XT X)−1 rather than I. This ensures that the posterior is invariant to scaling of the inputs (Minka 2000b). See also Exercise 7.10.\nWe will see below that if we use an uninformative prior, the posterior precision given N measurements is V−1 N = XT X. The unit information prior is defined to contain as much information as one sample (Kass and Wasserman 1995). To create a unit information prior for linear regression, we need to use V−1 0 = 1 N XT X, which is equivalent to the g-prior with g = N.\n7.6.3.2 无信息先验 An uninformative prior can be obtained by considering the uninformative limit of the conjugate g-prior, which corresponds to setting g = ∞. This is equivalent to an improper NIG prior with w0 = 0, V0 = ∞I, a0 = 0 and b0 = 0, which gives p(w, σ2) ∝ σ−(D+2).\nAlternatively, we can start with the semi-conjugate prior p(w, σ2) = p(w)p(σ2), and take each term to its uninformative limit individually, which gives p(w, σ2) ∝ σ−2. This is equivalent to an improper NIG prior with w0 = 0,V = ∞I, a0 = −D/2 and b0 = 0. The corresponding posterior is given by\n\\[ a \\tag{7.77-82} \\]  The marginal distribution of the weights is given by\n\\[ a \\tag{7.83} \\]  where C = (XT X)−1 and wˆ is the MLE. We discuss the implications of these equations below.\n7.6.3.3 贝叶斯和频率推断重合的例子* The use of a (semi-conjugate) uninformative prior is interesting because the resulting posterior turns out to be equivalent to the results from frequentist statistics (see also Section 4.6.3.9). In particular, from Equation 7.83 we have\n\\[ a \\tag{7.84} \\]  This is equivalent to the sampling distribution of the MLE which is given by the following (see e.g., (Rice 1995, p542), (Casella and Berger 2002, p554)):\n\\[ a \\tag{7.85} \\]  where\n\\[ a \\tag{7.86} \\]  is the standard error of the estimated parameter. (See Section 6.2 for a discussion of sampling distributions.) Consequently, the frequentist confidence interval and the Bayesian marginal credible interval for the parameters are the same in this case.\nAs a worked example of this, consider the caterpillar dataset from (Marin and Robert 2007). (The details of what the data mean don’t matter for our present purposes.) We can compute the posterior mean and standard deviation, and the 95% credible intervals (CI) for the regression coefficients using Equation 7.84. The results are shown in Table 7.2. It is easy to check that these 95% credible intervals are identical to the 95% confidence intervals computed using standard frequentist methods (see linregBayesCaterpillar for the code).\nWe can also use these marginal posteriors to compute if the coefficients are “significantly” different from 0. An informal way to do this (without using decision theory) is to check if its 95% CI excludes 0. From Table 7.2, we see that the CIs for coefficients 0, 1, 2, 4, 5 are all significant by this measure, so we put a little star by them. It is easy to check that these results are the same as those produced by standard frequentist software packages which compute p-values at the 5% level.\nAlthough the correspondence between the Bayesian and frequentist results might seem appealing to some readers, recall from Section 6.6 that frequentist inference is riddled with pathologies. Also, note that the MLE does not even exist when NN.)\n7.6.4 经验贝叶斯用于线性回归（证据程序） So far, we have assumed the prior is known. In this section, we describe an empirical Bayes procedure for picking the hyper-parameters. More precisely, we choose η = (α, λ) to maximize the marignal likelihood, where λ = 1/σ2 be the precision of the observation noise and α is the precision of the prior, p(w) = N (w|0, α−1I). This is known as the evidence procedure (MacKay 1995b). See Section 13.7.4 for the algorithmic details\nThe evidence procedure provides an alternative to using cross validation. For example, in Figure 7.13(b), we plot the log marginal likelihood for different values of α, as well as the maximum value found by the optimizer. We see that, in this example, we get the same result as 5-CV, shown in Figure 7.13(a). (We kept λ = 1/σ2 fixed in both methods, to make them comparable.)\nThe principle practical advantage of the evidence procedure over CV will become apparent in Section 13.7, where we generalize the prior by allowing a different αj for every feature. This can be used to perform feature selection, using a technique known as automatic relevancy determination or ARD. By contrast, it would not be possible to use CV to tune D different hyper-parameters\nThe evidence procedure is also useful when comparing different kinds of models, since it provides a good approximation to the evidence:\n\\[ \\tag{7.87-88} \\]  It is important to (at least approximately) integrate over η rather than setting it arbitrarily, for reasons discussed in Section 5.3.2.5. Indeed, this is the method we used to evaluate the marginal likelihood for the polynomial regression models in Figures 5.7 and 5.8. For a “more Bayesian” approach, in which we model our uncertainty about η rather than computing point estimates, see Section 21.5.2.\n返回本章目录\n"}),a.add({id:202,href:'/notes/docs/mlapp/07linear_regression/0066/',title:"Exercises",content:"返回本章目录\n"}),a.add({id:203,href:'/notes/tags/%E5%90%8E%E9%AA%8C/',title:"后验",content:""}),a.add({id:204,href:'/notes/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/',title:"机器学习",content:""}),a.add({id:205,href:'/notes/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/',title:"线性回归",content:""}),a.add({id:206,href:'/notes/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF/',title:"贝叶斯",content:""}),a.add({id:207,href:'/notes/docs/mlapp/07linear_regression/0064/',title:"7.5 岭回归",content:"返回本章目录\n最大拟然估计(MLE)的一个问题是它可能导致过拟合。 在本节中，我们将讨论一种通过使用高斯先验的最大后验估计(MAP)的方法来改善此问题。 为简单起见，我们假设高斯似然，而不是稳定性拟然。\n7.5.1 基本思路 MLE可能过拟合的原因是它选择了最适合建模训练数据的参数值; 但如果数据有噪声，这些参数通常会导致复杂的函数。 作为一个简单的例子，假设我们使用最小二乘法将14阶多项式拟合到N = 21个数据点。 得到的曲线非常“摇摆”，如图7.7（a）所示。 相应的最小二乘系数（不包括   \\(w_0\\)  ）如下：\n6.560, -36.934, -109.255, 543.452, 1022.561, -3046.224, -3768.013, 8524.540, 6607.897, -12640.058, -5530.188, 9479.730, 1774.639, -2821.526\n 图7.7 14阶多项式拟合N = 21个数据点，由于 \\(\\ell_2\\)  正则化量强度不同而又(a)(b)两图。 数据由方差 \\(\\sigma^2= 4\\)  的噪声生成。表示噪声方差 \\(\\sigma^2\\)  的误差条，随着拟拟合的越光滑就越宽，因为我们将更多的数据变化归结为噪声。 由_linregPolyVsRegDemo_生成的图。\n 我们看到有许多大的正数和负数。 这些完全平衡，使曲线以正确的方式“摆动”，以便几乎完美地插入数据。 但是这种情况是不稳定的：如果我们稍微改变数据，系数会发生很大变化。\n我们可以通过使用零均值高斯先验来促进参数变小，从而产生更平滑的曲线：\n\\[ p(\\boldsymbol{w})=\\prod_{j=1}^D{\\mathcal{N}(w_j|0,\\tau^2)} \\tag{7.30} \\]  其中 \\(1/\\tau^2\\)  控制先验的强度。 相应的MAP估计问题变为\n\\[ \\underset{\\boldsymbol{w}}{\\rm argmax} \\ \\left[ \\sum_{i=1}^N{ \\log \\mathcal{N}(y_i|w_0+\\boldsymbol{w}^T\\boldsymbol{x}_i,\\sigma^2)} + \\sum_{j=1}^D{\\log \\mathcal{N}(w_j|0,\\tau^2)}\\right] \\tag{7.31} \\]  这是一个简单的练习，可以证明这个优化问题等价于对下式最小化：\n\\[ \\begin{aligned} J(\\boldsymbol{w}) = \u0026 \\sum_{i=1}^N{ (y_i-(w_0+\\boldsymbol{w}^T\\boldsymbol{x}_i))^2} +\\lambda \\|\\boldsymbol{w}\\|_2^2 \\\\ \\quad = \u0026 \\left\\|\\boldsymbol{y}-(\\boldsymbol{1}_{N},\\boldsymbol{X})\\left(\\begin{matrix}w_0\\\\ \\boldsymbol{w}\\end{matrix}\\right)\\right\\|_2^2 +\\lambda \\left(w_0,\\boldsymbol{w}^T\\right) \\left(\\begin{matrix}0 \u0026 \\boldsymbol{0}_{1 \\times D}\\\\\\boldsymbol{0}_{D \\times 1} \u0026 \\boldsymbol{I}_{D \\times D} \\end{matrix} \\right)\\left(\\begin{matrix}w_0\\\\ \\boldsymbol{w}\\end{matrix}\\right) \\\\ \\quad \\overset{\\Delta}{=} \u0026 (\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})^T(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w}) + \\lambda \\boldsymbol{w}^T \\boldsymbol{I} \\boldsymbol{w} \\end{aligned} \\tag{7.32,32',32''} \\]  其中 \\(\\lambda \\overset{\\Delta}{=}\\frac{\\sigma^2}{\\tau^2}\\)  和 \\(\\|\\boldsymbol{w}\\|_2^2=\\sum_j{w_j}=\\boldsymbol{w}^T\\boldsymbol{w}\\)  是二范数平方。 这里第一项是通常的MSE / NLL，第二项， \\(\\lambda \\ge 0\\)  是复杂性惩罚。(译者注: 式7.3.2'\u0026lsquo;中的 \\(\\boldsymbol{X}\\)  ， \\(\\boldsymbol{w}\\)  和 \\(\\boldsymbol{I}\\)  都是扩展矩阵或向量, 扩展细节见式7.32\u0026rsquo;。原文表述有细节上错误, 所以这部分按译者的理解进行了修改) 相应的最优解由下式给出(基于式7.32'')\n\\[ \\boxed{\\hat{\\boldsymbol{w}}_{\\rm ridge}= (\\lambda \\boldsymbol{I}_{D+1} + \\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}} \\tag{7.33} \\]  这种技术称为岭回归或惩罚最小二乘法。 通常，通过添加模型参数的高斯先验以减小参数的方法被称为正则化或权重衰减(weight decay)。 请注意，偏移项 \\(w_0\\)  不是正则化的（译者注: 扩展矩阵 \\(\\boldsymbol{I}\\)  不是单位矩阵，注意对角的第一个元素为0, 右下角的矩阵才是单位矩阵），因为这只会影响函数的高度，而不会影响其复杂性。 通过惩罚权重的大小的总和，我们确保函数是简单的（因为 \\(\\boldsymbol{w}_D = 0\\)  对应于直线是常数，这是最简单的可能函数）。\n我们在图7.7中说明了这个想法，我们看到增加 \\(\\lambda\\)  会导致更平滑的函数。 结果系数也变小。 例如，使用 \\(\\lambda= 10^{-3}\\)  ，我们有\n2.128, 0.807, 16.457, 3.704, -24.948, -10.472, -2.625, 4.360, 13.711, 10.063, 8.716, 3.966, -9.349, -9.232\n在图7.8（a）中，我们绘制了训练和测试集MSE与 \\(\\log(\\lambda)\\)  的关系。 我们看到，随着我们增加 \\(\\lambda\\)  （因此模型变得更加受约束），训练集上的误差增加。 对于测试集，我们看到U形曲线的特点，其中模型先过拟合然后欠拟合。 通常使用交叉验证来选择λ，如图7.8（b）所示。 在1.4.8节中，我们将讨论一种更具概率性的方法。\n我们将在本书中将考虑各种不同先验。 每一个对应于不同形式的正则化。 该技术被广泛用于防止过拟合。\n 图7.8 （a）通过岭回归计算的14阶多项式拟合的训练误差（点蓝色）和测试误差（实心红色），绘制与log（λ）的关系。 数据由方差 \\(\\sigma^2= 4\\)  的噪声生成（训练集的大小N = 21）。 注意：模型从左侧的复杂（小正则化器）到右侧的简单（大正则化器）进行排序。 星形对应于用于绘制图7.7中的函数的值。 （b）使用训练集估计效果。 虚线蓝色：未来MSE的5倍交叉验证估计。 纯黑：负对数边际似然 \\(- \\log p(\\mathcal{D}|\\lambda)\\)  。 两条曲线都已垂直重新缩放为[0,1]，以使它们具有可比性。 由_linregPolyVsRegDemo_生成的图。\n 7.5.2 数值计算稳定性* 有趣的是，在统计学上能更好工作的岭回归，也更容易进行数值拟合，因为 \\((\\lambda \\boldsymbol{I}_{D+1} + \\boldsymbol{X}^T\\boldsymbol{X})\\)  比 \\(\\boldsymbol{X}^T\\boldsymbol{X}\\)  有更好的条件（更可能是可逆的），至少对于合适的 \\(\\lambda\\)  来说。\n然而，出于数值稳定性的原因，仍然最好避免使用逆矩阵。 （实际上，如果你在Matlab中写w = inv（X' _X）_X'*y，它会给你一个警告。）我们现在描述一个有用的技巧来拟合在数值上更稳健的岭回归模型（并且通过扩展，计算vanilla普通最小二乘估计 ）。 我们假设先验形如 \\(p(\\boldsymbol{w})=\\mathcal{N}(0,\\boldsymbol{\\Lambda}^{-1})\\)  ，其中 \\(\\boldsymbol{\\Lambda}\\)  是精度矩阵。 在岭回归情形下， \\(\\boldsymbol{\\Lambda}=(1/\\tau^2)\\boldsymbol{I}\\)  。 为了避免 \\(w_0\\)  惩罚项，我们应该首先将数据中心化，如练习7.5中所述。(译者注: 如果数据已经中心化, 那么前面的的扩展矩阵或向量都退化成扩展以前的形式，比如 \\(\\boldsymbol{X}\\)  是 \\(N \\times D\\)  矩阵， \\(\\boldsymbol{w}\\)  是 \\(D\\)  维向量和 \\(\\boldsymbol{I}\\)  是 \\(D \\times D\\)  单位矩阵)\n首先让我们用源自先验的一些“虚拟数据”来扩充原始数据：\n\\[ \\tilde{\\boldsymbol{X}}=\\left(\\begin{matrix}\\boldsymbol{X}/\\sigma\\\\\\sqrt{\\Lambda}\\end{matrix}\\right),\\tilde{\\boldsymbol{y}}=\\left(\\begin{matrix}\\boldsymbol{y}/\\sigma\\\\\\boldsymbol{0}_{D \\times 1}\\end{matrix}\\right) \\tag{7.34} \\]  其中 \\(\\Lambda=\\sqrt{\\Lambda}\\sqrt{\\Lambda}^T\\)  是 \\(\\Lambda\\)  的Cholesky分解。 我们看到 \\(\\tilde{\\boldsymbol{X}}\\)  是 \\((N + D) \\times D\\)  维的，其中额外的行表示来自先验的伪数据。\n我们现在证明，这个扩展数据的NLL等同于原始数据上的惩罚NLL：\n\\[ \\begin{aligned} f(\\boldsymbol{w})= \u0026 (\\tilde{\\boldsymbol{y}}-\\tilde{\\boldsymbol{X}}\\boldsymbol{w})^T(\\tilde{\\boldsymbol{y}}-\\tilde{\\boldsymbol{X}}\\boldsymbol{w}) \\\\ \\quad = \u0026 (\\left(\\begin{matrix}\\boldsymbol{y}/\\sigma\\\\ \\boldsymbol{0}_{D \\times 1}\\end{matrix}\\right)-\\left(\\begin{matrix}\\boldsymbol{X}/\\sigma\\\\\\sqrt{\\Lambda}\\end{matrix}\\right)\\boldsymbol{w})^T(\\left(\\begin{matrix}\\boldsymbol{y}/\\sigma\\\\ \\boldsymbol{0}_{D \\times 1}\\end{matrix}\\right)-\\left(\\begin{matrix}\\boldsymbol{X}/\\sigma\\\\ \\sqrt{\\Lambda}\\end{matrix}\\right)\\boldsymbol{w}) \\\\ \\quad = \u0026 \\left(\\begin{matrix}\\frac{1}{\\sigma}(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})\\\\ -\\sqrt{\\Lambda}\\boldsymbol{w}\\end{matrix}\\right)^T\\left(\\begin{matrix}\\frac{1}{\\sigma}(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})\\\\-\\sqrt{\\Lambda}\\boldsymbol{w}\\end{matrix}\\right) \\\\ \\quad = \u0026 \\dfrac{1}{\\sigma^2}(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})^T(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})+(\\sqrt{\\Lambda}\\boldsymbol{w})^T(\\sqrt{\\Lambda}\\boldsymbol{w}) \\\\ \\quad = \u0026 \\dfrac{1}{\\sigma^2}(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})^T(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})+\\boldsymbol{w}^T \\Lambda\\boldsymbol{w} \\end{aligned} \\tag{7.35-39} \\]  因此MAP估计可由下式给出\n\\[ \\hat{\\boldsymbol{w}}_{\\rm ridge}= ( \\tilde{\\boldsymbol{X}}^T\\tilde{\\boldsymbol{X}})^{-1}\\tilde{\\boldsymbol{X}}^T\\tilde{\\boldsymbol{y}} \\tag{7.40} \\]  现在令\n\\[ \\tilde{\\boldsymbol{X}}=\\boldsymbol{Q}\\boldsymbol{R} \\tag{7.41} \\]  是 \\(\\tilde{\\boldsymbol{X}}\\)  的QR分解，其中 \\(\\boldsymbol{Q}\\)  是正交的（意思是 \\(\\boldsymbol{Q}^T\\boldsymbol{Q} = \\boldsymbol{Q}\\boldsymbol{Q}^T=\\boldsymbol{I}\\)  ）， \\(\\boldsymbol{R}\\)  是上三角形。 于是\n\\[ (\\tilde{\\boldsymbol{X}}^T\\tilde{\\boldsymbol{X}})^{-1}=(\\boldsymbol{R}^T\\boldsymbol{Q}^T\\boldsymbol{Q}\\boldsymbol{R})^{-1}=(\\boldsymbol{R}^T\\boldsymbol{R})^{-1}=\\boldsymbol{R}^{-1}\\boldsymbol{R}^{-T} \\tag{7.42} \\]  于是\n\\[ \\hat{\\boldsymbol{w}}_{\\rm ridge}= \\boldsymbol{R}^{-1}\\boldsymbol{R}^{-T}\\boldsymbol{R}^T\\boldsymbol{Q}^T\\tilde{\\boldsymbol{y}}=\\boldsymbol{R}^{-1}\\boldsymbol{Q}^T\\tilde{\\boldsymbol{y}} \\tag{7.43} \\]  注意， \\(\\boldsymbol{R}\\)  是很容易求逆的，因为它是上三角形。 这为我们提供了一种计算岭估计的方法，同时避免求 \\(\\tilde{\\boldsymbol{X}}^T\\tilde{\\boldsymbol{X}}=\\boldsymbol{\\Lambda}+\\frac{1}{\\sigma^2}\\boldsymbol{X}^T\\boldsymbol{X}=\\frac{1}{\\sigma^2}(\\lambda\\boldsymbol{I}+\\boldsymbol{X}^T\\boldsymbol{X})\\)  的逆。\n我们可以使用这种技术通过QR分解利用原始的 \\(\\boldsymbol{X},\\boldsymbol{y}\\)  找到MLE。 这是解决最小二乘问题的首选方法。 （事实上，它可以在Matlab的一行中实现，使用反斜杠运算符：w = X y。）注意，计算N×D矩阵的QR分解需要 \\(O(N D^2)\\)  时间， 并且在数值上非常稳定\n如果 \\(D \\gg N\\)  ，首选SVD分解。 特别地，令 \\(\\boldsymbol{X} = \\boldsymbol{U} \\boldsymbol{S} \\boldsymbol{V}^T\\)  是 \\(\\boldsymbol{X}\\)  的SVD，其中 \\(\\boldsymbol{V}^T \\boldsymbol{V} = \\boldsymbol{I}_N, \\boldsymbol{U}\\boldsymbol{U}^T = \\boldsymbol{U}^T\\boldsymbol{U} = \\boldsymbol{I}_N\\)  ，并且 \\(\\boldsymbol{S}\\)  是对角 \\(N \\times N\\)  矩阵。 现令 \\(\\boldsymbol{Z}= \\boldsymbol{U}\\boldsymbol{S}\\)  为N×N矩阵。 然后我们可以重写岭估计：\n\\[ \\hat{\\boldsymbol{w}}_{\\rm ridge}= \\boldsymbol{V}(\\boldsymbol{Z}^T\\boldsymbol{Z} +\\lambda \\boldsymbol{I}_N)^{-1}\\boldsymbol{Z}^T \\boldsymbol{y} \\tag{7.44} \\]  换句话说，我们可以用N维向量 \\(z_i\\)  替换D维向量 \\(x_i\\)  ，并像以前一样执行我们的惩罚拟合。 然后我们通过乘以 \\(\\boldsymbol{V}\\)  将N维解变换为D维解。几何上，我们旋转到一个新的坐标系，其中除了前N个坐标之外的所有坐标都是零。 这不会影响解，因为球面高斯先验是旋转不变的。 整个时间需要 \\(O(D N^2)\\)  。\n7.5.3 与PCA的关系* 在本节中，我们讨论岭回归和PCA之间的有趣联系（第12.2节），这进一步深入了解了岭回归为什么运作良好。 我们的讨论基于（Hastie等，2009，第66页）。\n设 \\(\\boldsymbol{X} = \\boldsymbol{U} \\boldsymbol{S} \\boldsymbol{V}^T\\)  为 \\(\\boldsymbol{X}\\)  的SVD。从公式7.44，我们得到\n\\[ \\hat{\\boldsymbol{w}}_{\\rm ridge}= \\boldsymbol{V}(\\boldsymbol{S}^2 +\\lambda \\boldsymbol{I}_N)^{-1}\\boldsymbol{S}\\boldsymbol{U}^T \\boldsymbol{y} \\tag{7.45} \\]  因此，训练集的岭预测由下式给出\n\\[ \\begin{aligned} \\hat{\\boldsymbol{y}} = \u0026\\boldsymbol{X}\\hat{\\boldsymbol{w}}_{\\rm ridge} = \\boldsymbol{U} \\boldsymbol{S} \\boldsymbol{V}^T\\boldsymbol{V}(\\boldsymbol{S}^2 +\\lambda \\boldsymbol{I}_N)^{-1}\\boldsymbol{S}\\boldsymbol{U}^T \\boldsymbol{y} \\\\ \\quad = \u0026 \\boldsymbol{U} \\tilde{\\boldsymbol{S}} \\boldsymbol{U}^T \\boldsymbol{y} = \\sum_{j=1}^D{\\boldsymbol{u}_j \\tilde{S}_{jj} \\boldsymbol{u}_j^T \\boldsymbol{y}} \\end{aligned} \\tag{7.46-47} \\]  其中\n\\[ \\tilde{S}_{jj} \\overset{\\Delta}{=} \\left[\\boldsymbol{S} (\\boldsymbol{S}^2 +\\lambda \\boldsymbol{I}_N)^{-1}\\boldsymbol{S}\\right]_{jj}=\\dfrac{s_j^2}{s_j^2+\\lambda} \\tag{7.48} \\]  并且 \\(s_j\\)  是 \\(\\boldsymbol{X}\\)  的奇异值(译者注: 原文写成 \\(\\sigma_j\\)  容易产生误解, 于是译者采用和 \\(\\boldsymbol{S}\\)  保持一致的记法)。 于是\n\\[ \\hat{\\boldsymbol{y}} = \\boldsymbol{X}\\hat{\\boldsymbol{w}}_{\\rm ridge} = \\sum_{j=1}^D{\\boldsymbol{u}_j \\dfrac{s_j^2}{s_j^2+\\lambda} \\boldsymbol{u}_j^T \\boldsymbol{y}} \\tag{7.49} \\]  特别地，最小二乘预测(取 \\(\\lambda=0\\)  )是\n\\[ \\hat{\\boldsymbol{y}} = \\boldsymbol{X}\\hat{\\boldsymbol{w}}_{\\rm ls} = \\sum_{j=1}^D{\\boldsymbol{u}_j \\boldsymbol{u}_j^T \\boldsymbol{y}} \\tag{7.50} \\]  如果 \\(\\sigma_j^2\\)  与 \\(\\lambda\\)  相比较小，则方向 \\(\\boldsymbol{u}_j\\)  对预测的影响不大。 从这个观点看，我们定义模型的有效自由度数：\n\\[ {\\rm dof}(\\lambda)=\\sum_{j=1}^D{\\dfrac{s_j^2}{s_j^2+\\lambda}} \\tag{7.51} \\]  当 \\(\\lambda=0\\)  时, \\({\\rm dof}(\\lambda) = D\\)  , 并且当 \\(\\lambda \\to \\infty\\)  时, \\({\\rm dof}(\\lambda) \\to 0\\)  。\n让我们试着理解为什么这种行为是可取的。如果为 \\(\\boldsymbol{w}\\)  使用均匀先验，那么可证明了 \\({\\rm cov} [\\boldsymbol{w}|\\mathcal{D}] =\\sigma^2(\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\)  (参见7.6节)。 因此，对 \\(\\boldsymbol{w}\\)  最不确定的方向是由矩阵最小特征值所对应的特征向量所确定的，如图4.1所示。 此外，在12.2.3节中，我们证明了平方奇异值 \\(s_j^2\\)  等于 \\(\\boldsymbol{X}^T\\boldsymbol{X}\\)  的特征值。因此，较小的奇异值 \\(s_j\\)  对应于具有较高后验方差的方向。 这是岭收缩最多的方向。\n该过程如图7.9所示。 水平 \\(w_1\\)  参数不能很好地由数据确定的（具有较高的后验方差），但是垂直 \\(w_2\\)  参数可以很好确定的。 因此， \\(w_2^{\\rm map}\\)  接近 \\(\\hat{w}_2^{\\rm mle}\\)  ，但是 \\(w_1^{\\rm map}\\)  强烈移向先验均值0。（与图4.14（c）相比，它描述不同可靠性的传感器的融合。）这样，病态确定的参数, 会大小减小到0. 这称为收缩(shrinkage)。\n有一种相关但不同的技术称为主成分回归(principal components regression)。 这个想法是这样的：首先使用PCA将维度降低到K维度，然后使用这些低维特征作为回归的输入。 然而，这种技术在预测准确性方面不如岭回归（Hastie等，2001，第70页）。 原因是在主成分回归中，仅保留了头K（派生）个维度，并且完全忽略了剩余的D-K维度。 相比之下，岭回归使用了所有维度的“软”加权。\n 图7.9 岭回归的几何意义。 似然显示为椭圆，并且先验显示为以原点为中心的圆。 基于（Bishop 2006b）的图3.15。 由geomRidge生成的图\n 7.5.4 大数据的正则化效应 正规化是避免过度拟合的最常用方法。 然而，另一种有效的方法 - 但并不总是可用 - 是使用大量数据。 直观上应该是显而易见的，我们拥有的训练数据越多，我们就能越好地学习。 因此，我们预计随着N的增加，测试集误差会降低到某个稳定水平。\n参见图7.10，其中我们绘制了不同阶多项式回归模型下，测试集上产生的均方误差 v.s 训练样本数N（误差与训练集大小的关系称为学习曲线）。 测试误差的稳定水平由两个项组成：由于生成过程的固有可变性（所谓的本底噪声），所有模型都会产生不可减少的成分; 和一个依赖于生成过程（“真相”）和模型之间差异的成分：这称为结构误差。\n在图7.10中，实际是2次多项式，但我们尝试用1次，2次和25次的多项式拟合到该数据。 称3个模型为 \\(\\mathcal{M}_1\\)  ， \\(\\mathcal{M}_2\\)  和 \\(\\mathcal{M}_{25}\\)  。 我们看到模型 \\(\\mathcal{M}_2\\)  和 \\(\\mathcal{M}_{25}\\)  的结构误差为零，因为两者都能够捕获真正的生成过程。 然而， \\(\\mathcal{M}_1\\)  的结构误差是很大的，这可以从稳定水平远高于本底噪声的事实中看出。\n对于任何表达足以捕获实际数据的模型（即具有小结构误差的模型），当 \\(N \\to \\infty\\)  时测试误差进入本底噪声。 但是，对于更简单的模型，它通常会更快地变为零，因为要估计的参数更少。 特别是，对于有限训练集，我们估计的参数与我们可以根据特定模型类估计的最佳参数之间存在一些差异。 这称为近似误差，并且在 \\(N \\to \\infty\\)  时变为零，但对于更简单的模型，它会更快地变为零。 如图7.10所示。 另见练习7.1。\n在具有大量数据的领域中，简单的方法可以令人惊讶地工作（Halevy等人，2009）。 然而，仍然有理由研究更复杂的学习方法，因为总会存在我们几乎没有数据的问题。 例如，即使在像网络搜索这样的数据丰富的域中，只要我们想要开始个性化结果，任何给定用户可用的数据量开始再次变小（相对于问题的复杂性）。\n在这种情况下，我们可能希望同时学习多个相关模型，这被称为多任务学习。 这将使我们能够从具有大量数据的任务中“借用统计强度”，并将其与具有少量数据的任务共享。 我们将在本书后面讨论如何做。\n 图7.10 训练和测试集的MSE v.s. 训练集的大小，基于由具有方差 \\(\\sigma^2=4\\)  的高斯噪声的2次多项式生成的数据。我们将不同次数多项式模型拟合到该数据。 （a）1次.（b）2次.（c）10次.（d）25次。 注意，对于小训练集大小，25次多项式的测试误差高于2次多项式的测试误差， 由于过度拟合，但一旦我们有足够的数据，这种差异就会消失。 另请注意，1阶多项式过于简单，即使给定大量训练数据也具有较高的测试误差。 由_linregPolyVsN_生成的图。\n 返回本章目录\n"}),a.add({id:208,href:'/notes/tags/%E5%B2%AD%E5%9B%9E%E5%BD%92/',title:"岭回归",content:""}),a.add({id:209,href:'/notes/tags/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/',title:"最小二乘",content:""}),a.add({id:210,href:'/notes/tags/%E6%AD%A3%E5%88%99%E5%8C%96/',title:"正则化",content:""}),a.add({id:211,href:'/notes/docs/mlapp/07linear_regression/0063/',title:"7.4 稳健线性回归*",content:"返回本章目录\n在回归模型中，使用零均值和常数方差的高斯分布对噪声进行建模是很常见的。   \\(\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)\\)  ，其中 \\(\\epsilon_i=y_i-\\boldsymbol{w}^T \\boldsymbol{x}_i\\)  。 在这种情况下，最大化拟然等价于最小化残差平方和。 但是，如果我们的数据中存在异常值，则可能导致拟合不良，如图7.6（a）所示。 （异常值是图底部的点。）这是因为平方误差以二次方处理偏差，因此远离线的点对拟合的影响大于线附近的点。\n实现异常值稳健性的一种方法是用厚尾分布替代高斯分布。 这样的分布将给异常值分配高拟然，而不必干扰直线来“解释”它们。\n一种可能是使用第2.4.3节中介绍的拉普拉斯分布。 如果我们使用它作为观察模型进行回归，我们得到如下拟然：\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{w},b) = {\\rm Lap}(y|\\boldsymbol{w}^T\\boldsymbol{x},b) \\propto \\exp\\left(-\\dfrac{1}{b}|y-\\boldsymbol{w}^T\\boldsymbol{x}|\\right) \\tag{7.24} \\]  稳健性源于 \\(|y-\\boldsymbol{w}^T\\boldsymbol{x}|\\)  的使用 而不是 \\((y-\\boldsymbol{w}^T\\boldsymbol{x})^2\\)  。 为简单起见，我们假设b是固定的。 令 \\(r_i \\overset{\\Delta}{=} y_i-\\boldsymbol{w}^T\\boldsymbol{x}_i\\)  成表示为第 \\(i\\)  个残差。 于是NLL形如\n\\[ \\ell(\\boldsymbol{w}) = \\sum_{i=1}^N{|r_i(\\boldsymbol{w})|} \\tag{7.25} \\]  不幸的是，这是一个非线性目标函数，很难优化。 幸运的是，我们可以使用以下分割变量技巧将NLL转换为受线性约束线性目标。 首先我们定义\n\\[ \\begin{aligned} r_i^+ \\overset{\\Delta}{=}\u0026 (r_i+|r_i|)/2 \\ge 0 \\\\ r_i^- \\overset{\\Delta}{=}\u0026 (|r_i|-r_i)/2 \\ge 0 \\\\ \\Rightarrow \\quad \u0026\\\\ r_i = \u0026r_i^+ - r_i^- ,\\quad |r_i| = r_i^+ + r_i^- \\\\ \\end{aligned} \\tag{7.26} \\]  于是我们绝对值目标优化问题，变成一个含不等式约束的优化问题\n\\[ \\min_{\\boldsymbol{w},\\boldsymbol{r}^+,\\boldsymbol{r}^-} \\sum_i{r_i^+ + r_i^-} \\quad s.t.\\quad r_i^+ \\ge 0, r_i^- \\ge 0, \\boldsymbol{w}^T\\boldsymbol{x}_i + r_i^+ - r_i^- = y_i \\tag{7.27} \\]  这是一个有 \\(D+2N\\)  个未知变量和3个约束的线性规划问题。\n由于这是凸优化问题，因此它具有唯一的解。 要解决这个LP，我们必须先写成标准格式，如下所示：\n\\[ \\min_{\\boldsymbol{\\theta}} \\boldsymbol{f}^T\\boldsymbol{\\theta} \\quad s.t. \\quad \\boldsymbol{A} \\boldsymbol{\\theta} \\le \\boldsymbol{b}, \\boldsymbol{A}_{eq}\\boldsymbol{\\theta}=\\boldsymbol{b}_{eq},\\boldsymbol{l}\\le\\boldsymbol{\\theta} \\le \\boldsymbol{u} \\tag{7.28} \\]  在我们当前的例子中， \\(\\boldsymbol{\\theta}=[\\boldsymbol{w};\\boldsymbol{r}^+;\\boldsymbol{r}^-]\\)  ， \\(\\boldsymbol{f} = [\\boldsymbol{0}_{D\\times1};\\boldsymbol{1}_{N\\times1};\\boldsymbol{1}_{N\\times1}]\\)  ， \\(\\boldsymbol{A}_{eq} = [\\boldsymbol{X} ,\\boldsymbol{1}_{N \\times N} ,- \\boldsymbol{1}_{N \\times N} ]\\)  ， \\(\\boldsymbol{b}_{eq} = \\boldsymbol{y}\\)  ， \\(\\boldsymbol{A} = []\\)  ， \\(\\boldsymbol{b} = []\\)  ， \\(\\boldsymbol{l} = [-\\boldsymbol{\\infty}_{D \\times 1},\\boldsymbol{0}_{N \\times 1} ;\\boldsymbol{0}_{N \\times 1}]\\)  ， \\(\\boldsymbol{u}= []\\)  。 于是可以通过任何LP求解器来解决（参见例如（Boyd和Vandenberghe 2004））。 有关实际方法的示例，请参见图7.6（a）。\n在拉普拉斯似然下使用NLL的另一种方法是最小化Huber损失函数（Huber 1964），定义如下：\n\\[ L_H(r,\\delta)=\\left\\{ \\begin{aligned} r^2/2 \\quad\u0026 if \\quad |r| \\le \\delta \\\\ \\delta|r|-\\delta^2/2 \\quad\u0026 if \\quad |r|  \\delta \\\\ \\end{aligned} \\right. \\tag{7.29} \\]  当误差小于 \\(\\delta\\)  时，相当于 \\(\\ell_2\\)  ; 当误差大于 \\(\\delta\\)  时，相当于 \\(\\ell_1\\)  。 参见图7.6（b）。 这种损失函数的优点在于处处可微，实际上 \\(\\frac{d}{dr}|r|={\\rm sign}(r), \\ if \\ r \\ne 0\\)  。并且此函数是 \\(C_1\\)  连续的，因为函数的两部分交界处 \\(r =\\pm \\delta\\)  的梯度是匹配的，即 \\(\\left. \\frac{d}{dr}L_H(r,\\delta)\\right|_{r=\\delta}=\\delta\\)  。 因此，优化Huber损失比使用拉普拉斯似然快得多，因为我们可以使用标准平滑优化方法（例如quasiNewton）而不是线性规划。\n图7.6（a）给出了Huber损失函数的图示。 结果在定性地类似于概率方法。 （事实上，Huber方法也有概率解释，尽管它很不自然（Pontil et al.1998）。）\n 图7.6 （a）稳健线性回归的图示。 由_linregRobustDemoCombined_生成的图。 （b） \\(\\ell_2\\)  ， \\(\\ell_1\\)  和Huber损失函数的图示。 _huberLossDemo_生成的图。\n 返回本章目录\n"}),a.add({id:212,href:'/notes/tags/%E5%8E%9A%E5%B0%BE/',title:"厚尾",content:""}),a.add({id:213,href:'/notes/tags/%E7%A8%B3%E5%81%A5%E6%80%A7/',title:"稳健性",content:""}),a.add({id:214,href:'/notes/docs/mlapp/07linear_regression/0062/',title:"7.3 最大似然估计（最小二乘）",content:"返回本章目录\n估计统计模型参数的常用方法是计算MLE，其定义为\n  \\[ \\hat{\\boldsymbol{\\theta}} \\overset{\\Delta}{=} \\underset{\\boldsymbol{\\theta}}{\\rm argmax} \\log p(\\mathcal{D}|\\boldsymbol{\\theta}) \\tag{7.4} \\]  通常假设训练样本是独立同分布的，通常缩写为iid。 这意味着我们可以将对数似然写成：\n\\[ \\ell(\\boldsymbol{\\theta}) \\overset{\\Delta}{=} \\log p(\\mathcal{D}|\\boldsymbol{\\theta})=\\sum_{i=1}^N{\\log p(y_i|\\boldsymbol{x}_i,\\boldsymbol{\\theta})} \\tag{7.5} \\]  作为最大化对数似然性的替代, 我们可以使用等价的最小化负对数似然或NLL：\n\\[ {\\rm NLL}(\\boldsymbol{\\theta}) \\overset{\\Delta}{=} - \\sum_{i=1}^N{\\log p(y_i|\\boldsymbol{x}_i,\\boldsymbol{\\theta})} \\tag{7.6} \\]  NLL公式有时更方便，因为许多优化软件包被设计成寻找函数的最小值，而不是最大值。\n现在让我们将MLE方法应用于线性回归。 将高斯的定义插入，我们获得具体的对数似然\n\\[ \\begin{aligned} \\ell(\\boldsymbol{\\theta}) = \u0026\\sum_{i=1}^N{\\log \\left[\\dfrac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp\\left(-\\dfrac{1}{2\\sigma^2}(y_i-\\boldsymbol{w}^T\\boldsymbol{x}_i)^2\\right) \\right]} \\\\ \\quad = \u0026 -\\dfrac{1}{2\\sigma^2} {\\rm RSS}(\\boldsymbol{w}) - \\dfrac{N}{2} \\log (2 \\pi \\sigma^2) \\\\ \\end{aligned} \\tag{7.7-8} \\]  RSS代表残差平方和(residual sum of squares)，由下式定义\n\\[ {\\rm RSS}(\\boldsymbol{w}) \\overset{\\Delta}{=}\\sum_{i=1}^N{(y_i-\\boldsymbol{w}^T\\boldsymbol{x}_i)^2} \\tag{7.9} \\]  RSS也称为误差平方和或SSE， \\({\\rm SSE}/N\\)  称为均方误差或MSE。 可以写成残差向量的 \\(\\ell_2\\)  范数的平方：\n\\[ {\\rm RSS}(\\boldsymbol{w}) = \\|\\boldsymbol{\\epsilon}\\|_2^2 = \\sum_{i=1}^N{\\epsilon_i^2} \\tag{7.10} \\]  其中 \\(\\epsilon_i =y_i-\\boldsymbol{w}^T\\boldsymbol{x}_i\\)  。\n 图7.2 （a）在线性最小二乘中，我们试图最小化从每个训练点（用红色圆圈表示）到其近似点（用蓝色十字表示）的平方距离之和，也就是说，我们最小化小的垂直蓝线长度之和。 用 \\(\\hat{y}(x)= w_0 + w_1 x\\)  表示的红色对角线，就是最小二乘回归线。 注意，与图12.5相比，这些残差线并不垂直于最小二乘线。 由_residualsDemo_生成的图。 （b）同一个例子的RSS误差曲面的等高线。 红十字代表MLE， \\(\\boldsymbol{w} =(1.45,0.93)\\)  。 由contoursSSEdemo生成的图。\n 注意关于 \\(\\boldsymbol{w}\\)  的MLE就是最小化RSS的那个，因此这种方法被称为最小二乘法。 该方法如图7.2（a）所示。 训练数据 \\((x_i,y_i)\\)  显示为红色圆圈，估计值 \\((x_i,\\hat{y}_i)\\)  显示为蓝色十字形，残差 \\(\\epsilon_i= y_i-\\hat{y}_i\\)  显示为垂直蓝线。 目标是找到合适的参数设置（斜率 \\(w_1\\)  和截距 \\(w_0\\)  ），进而使对应的红线满足最小化残差平方和（垂直蓝线的长度）。\n在图7.2（b）中，我们绘制了线性回归示例的NLL曲面。 我们看到它是一个具有唯一最小值的二次“碗” （重要的是，即使我们使用基函数展开，例如多项式也是如此，因为NLL对参数 \\(\\boldsymbol{w}\\)  而言仍然是线性的，即使它在输入 \\(\\boldsymbol{x}\\)  中不是线性的。）\n7.3.1 MLE的推导 首先，以更容易微分的形式重写目标函数(译者注: 每一个等号都忽略了不影响最小化的常数或比例项)：\n\\[ {\\rm NLL}(\\boldsymbol{w})=\\dfrac{1}{2}(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})^T(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})=\\dfrac{1}{2}\\boldsymbol{w}^T(\\boldsymbol{X}^T\\boldsymbol{X})\\boldsymbol{w}-\\boldsymbol{w}^T(\\boldsymbol{X}^T\\boldsymbol{y}) \\tag{7.11} \\]  其中\n\\[ \\boldsymbol{X}^T\\boldsymbol{X}=\\sum_{i=1}^N{\\boldsymbol{x}_i \\boldsymbol{x}_i^T}=\\sum_{i=1}^N{\\left( \\begin{matrix} x_{i,1}^2 \u0026 \\dots \u0026 x_{i,1}x_{i,D} \\\\ \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ x_{D,i}x_{i,1} \u0026 \\dots \u0026 x_{i,D}^2 \\\\ \\end{matrix} \\right)} \\tag{7.12} \\]  是方阵求和，并且\n\\[ \\boldsymbol{X}^T\\boldsymbol{y} = \\sum_{i=1}^N{\\boldsymbol{x}_i y_i} \\tag{7.13} \\]  使用公式4.10的结果，我们看到它的梯度由下式给出\n\\[ \\boldsymbol{g}(\\boldsymbol{w})=\\boldsymbol{X}^T\\boldsymbol{X}\\boldsymbol{w}-\\boldsymbol{X}^T\\boldsymbol{y}=\\sum_{i=1}^N{\\boldsymbol{x}_i (\\boldsymbol{w}^T\\boldsymbol{x}_i-y_i)} \\tag{7.14} \\]  梯度取零，得到\n\\[ \\boldsymbol{X}^T\\boldsymbol{X}\\boldsymbol{w}=\\boldsymbol{X}^T\\boldsymbol{y} \\tag{7.15} \\]  这就是所谓的正则方程。 该线性方程组的相应解 \\(\\hat{\\boldsymbol{w}}\\)  被称为普通最小二乘或OLS解，由下式给出\n\\[ \\boxed{\\hat{\\boldsymbol{w}}_{\\rm OLS}=(\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y}} \\tag{7.16} \\]  7.3.2 几何解释 这个等式具有优雅的几何解释。 我们假设 \\(N D\\)  ，所以我们的样本比特征多。 \\(\\boldsymbol{X}\\)  的列被定义成嵌入在N维中的D维线性子空间。 令第 \\(j\\)  列为 \\(\\tilde{\\boldsymbol{x}}_j \\in \\mathbb{R}^N\\)  （不要与 \\(\\boldsymbol{x}_i \\in \\mathbb{R}^D\\)  混淆，后者代表第 \\(i\\)  个样本）。同样， \\(\\boldsymbol{y}\\)  也是 \\(\\mathbb{R}^N\\)  中的向量。 例如，假设我们有 \\(N = 3\\)  个样本， \\(D = 2\\)  个特征：\n\\[ \\boldsymbol{X}=\\left( \\begin{matrix} 1 \u0026 2 \\\\ 1 \u0026 -2 \\\\ 1 \u0026 2 \\\\ \\end{matrix} \\right), y=\\left( \\begin{matrix} 8.8957 \\\\ 0.6130 \\\\ 1.7761 \\\\ \\end{matrix} \\right) \\tag{7.17} \\]  这些向量描述于如图7.3。\n 图7.3 \\(N = 3\\)  个样本和 \\(D = 2\\)  个特征的最小二乘法图解。 \\(\\tilde{\\boldsymbol{x}}_1\\)  和 \\(\\tilde{\\boldsymbol{x}}_2\\)  是 \\(\\mathbb{R}^3\\)  中的向量; 他们一起定义了2维平面。 \\(\\boldsymbol{y}\\)  也是 \\(\\mathbb{R}^3\\)  中的矢量，但不位于此2维平面上。 \\(\\boldsymbol{y}\\)  在该平面上的正交投影表示为 \\(\\hat{\\boldsymbol{y}}\\)  。 从 \\(\\boldsymbol{y}\\)  到 \\(\\hat{\\boldsymbol{y}}\\)  的红线是残差，我们想要最小化它的范数。 为了清晰起见，所有向量都已转换为单位范数。 由_leastSquaresProjection_生成的图。\n 我们需要寻找一个在这D维线性子空间中的向量 \\(\\hat{\\boldsymbol{y}} \\in \\mathbb{R}^N\\)  ，并且尽可能接近 \\(\\boldsymbol{y}\\)  ，即我们想要找到\n\\[ \\underset{\\hat{\\boldsymbol{y}} \\in {\\rm span({\\tilde{\\boldsymbol{x}}_1,\\dots,\\tilde{\\boldsymbol{x}}_D})}}{\\rm argmin} \\ \\|\\boldsymbol{y}-\\hat{\\boldsymbol{y}}\\|_2 \\tag{7.18} \\]  由于 \\(\\hat{\\boldsymbol{y}} \\in {\\rm span(\\boldsymbol{X})}\\)  ，因此存在一些权重向量 \\(\\boldsymbol{w}\\)  满足\n\\[ \\hat{\\boldsymbol{y}} = w_1 \\tilde{\\boldsymbol{x}}_1+\\dots+w_D \\tilde{\\boldsymbol{x}}_D=\\boldsymbol{X}\\boldsymbol{w} \\tag{7.19} \\]  为了最小化残差 \\(\\boldsymbol{y}-\\hat{\\boldsymbol{y}}\\)  的范数，我们希望残差向量与 \\(\\boldsymbol{X}\\)  的每一列都正交，即 \\(\\tilde{\\boldsymbol{x}}_j^T(\\boldsymbol{y}-\\hat{\\boldsymbol{y}})=0, \\forall j=1:D\\)  。因此\n\\[ \\tilde{\\boldsymbol{x}}_j^T(\\boldsymbol{y}-\\hat{\\boldsymbol{y}})=0 \\Rightarrow \\boldsymbol{X}^T(\\boldsymbol{y}-\\boldsymbol{X}\\boldsymbol{w})=0 \\Rightarrow \\boldsymbol{w} = (\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y} \\tag{7.20} \\]  因此， \\(\\boldsymbol{y}\\)  的投影值是\n\\[ \\hat{\\boldsymbol{y}} =\\boldsymbol{X}\\hat{\\boldsymbol{w}}= \\boldsymbol{X}(\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\boldsymbol{y} \\tag{7.21} \\]  这对应于 \\(\\boldsymbol{y}\\)  在 \\(\\boldsymbol{X}\\)  的列空间上的正交投影。投影矩阵 \\(P\\overset{\\Delta}{=}\\boldsymbol{X}(\\boldsymbol{X}^T\\boldsymbol{X})^{-1}\\boldsymbol{X}^T\\)  被称为帽子矩阵(hat matrix)，因为它“将帽子^放在 \\(\\boldsymbol{y}\\)  上”。\n7.3.3 凸性 在讨论最小二乘时，我们注意到NLL是具有唯一的最小值的碗形。 像这样的函数的技术术语是凸的。 凸函数在机器学习中起着非常重要的作用。\n让我们更准确地定义这个概念。我们称 \\(\\mathcal{S}\\)  集是凸的， 如果对于任何 \\(\\boldsymbol{\\theta},\\boldsymbol{\\theta}' \\in \\mathcal{S}\\)  ，有\n\\[ \\lambda \\boldsymbol{\\theta}+(1-\\lambda)\\boldsymbol{\\theta}' \\in \\mathcal{S}, \\forall \\lambda \\in [0,1] \\tag{7.22} \\]  也就是说，如果我们画一条从 \\(\\boldsymbol{\\theta}\\)  到 \\(\\boldsymbol{\\theta}'\\)  的线，那么线上的所有点都在集合内。有关凸集的说明，请参见图7.4（a）;有关非凸集的说明，请参见图7.4（b）。\n 图7.4 （a）凸集的图示。 （b）非凸集的图示。\n  图7.5 （a）凸函数的图示。 我们看到和弦连接 \\((x,f(x))\\)  到 \\((y,f(y))\\)  位于函数之上。 （b）既不凸也不凹的函数。 A是局部最小值，B是全局最小值。 由_convexFnHand_生成的图。\n 一个函数 \\(f(\\boldsymbol{\\theta})\\)  是凸的，如果其上境图（epigraph, 函数上方的点集）是凸集。 等价地，一个函数 \\(f(\\boldsymbol{\\theta})\\)  被称为凸的， 是定义在凸集上，并且对任何 \\(\\boldsymbol{\\theta},\\boldsymbol{\\theta}' \\in \\mathcal{S}\\)  ，任何 \\(0 \\le \\lambda \\le 1\\)  ，我们有\n\\[ f(\\lambda \\boldsymbol{\\theta}+(1-\\lambda)\\boldsymbol{\\theta}') \\le \\lambda f(\\boldsymbol{\\theta})+(1-\\lambda)f(\\boldsymbol{\\theta}') \\tag{7.23} \\]  参见图7.5的1维的例子。 如果不等式是严格的，则该函数被称为严格凸。 如果函数 \\(-f(\\boldsymbol{\\theta})\\)  是凸的，那么函数 \\(f(\\boldsymbol{\\theta})\\)  是凹的。 标量凸函数的例子包括 \\(\\theta^2\\)  ， \\(e^\\theta\\)  和 \\(\\theta \\log \\theta,\\forall \\theta0\\)  。 标量凹函数的例子包括 \\(\\log \\theta\\)  和 \\(\\sqrt{\\theta}\\)  。\n直观地，（严格地）凸函数具有“碗形”，因此具有对应于碗底部的唯一全局最小 \\(\\theta^{\\\\*}\\)  。 因此它的二阶导数在任何地方都必须是正的 \\(\\frac{d^2}{d\\theta^2}f(\\theta) 0\\)  。 一个二次连续可微多元函数 \\(f\\)  是凸的， 当且仅当，其Hessian矩阵对所有 \\(\\boldsymbol{\\theta}\\)  都是正定的。在机器学习环境中，函数 \\(f\\)  经常 对应于NLL。\nNLL是凸的模型是可取的，因为这意味着我们总能找到全局最优的MLE。 我们将在本书后面看到许多这方面的例子。 然而，许多感兴趣的模型不会有凹的拟然。 在这种情况下，我们将讨论导出局部最优参数估计的方法。\n返回本章目录\n"}),a.add({id:215,href:'/notes/tags/%E4%BC%BC%E7%84%B6/',title:"似然",content:""}),a.add({id:216,href:'/notes/tags/%E5%87%B8%E6%80%A7/',title:"凸性",content:""}),a.add({id:217,href:'/notes/docs/mlapp/07linear_regression/0061/',title:"7.2 模型选择",content:"返回本章目录\n正如我们在1.4.5节中讨论的那样，线性回归是一个形如下式的模型\n  \\[ p(y|\\boldsymbol{x},\\boldsymbol{\\theta})=\\mathcal{N}(y | \\boldsymbol{w}^T\\boldsymbol{x},\\sigma^2) \\tag{7.1} \\]  只用输入的一些非线性函数 \\(\\boldsymbol{\\phi}(\\boldsymbol{x})\\)  代替 \\(\\boldsymbol{x}\\)  ，就可以用线性回归以模拟非线性关系。 也就是说，可用如下模型\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{\\theta})=\\mathcal{N}(y | \\boldsymbol{w}^T\\boldsymbol{\\phi}(\\boldsymbol{x}),\\sigma^2) \\tag{7.2} \\]  这被称为基函数扩展(basis function expansion)。 （注意，模型在参数 \\(\\boldsymbol{w}\\)  中仍然是线性的，因此它仍然被称为线性回归; 这一点的重要性将在下面变得清晰。）一个简单的例子是多项式基函数，其模型形如\n\\[ \\boldsymbol{\\phi}(\\boldsymbol{x}) = [1,x,x^2,\\dots,x^d]\\tag{7.3} \\]  图1.18说明了改变 \\(d\\)  的效果：增加阶数 \\(d\\)  使我们能够创建越来越复杂的函数。\n我们还可以将线性回归应用于多个输入。 例如，考虑将温度建模为位置的函数。 图7.1（a）绘制了 \\(\\mathbb{E} [y | \\boldsymbol{x}] = w_0 + w_1 x_1 + w_2 x_2\\)  ，图7.1（b）绘制了 \\(\\mathbb{E} [y | \\boldsymbol{x}] = w_0 + w_1 x_1 + w_2 x_2+w_3 x_1^2+w_4 x_2^2\\)  。\n 图7.1 线性回归应用于2d数据。 垂直轴是温度，水平轴是房间内的位置。 数据由加利福尼亚州伯克利的英特尔实验室的一些遥感元素收集（数据由Romain Thibaux提供）。 （a）拟合平面的形式 \\(\\hat{f}(\\boldsymbol{x})= w_0 + w_1 x_1 + w_2 x_2\\)  。 （b）温度数据拟合形式 \\(\\hat{f}(\\boldsymbol{x})= w_0 + w_1 x_1 + w_2 x_2+w_3 x_1^2+w_4 x_2^2\\)  的二次曲面由_surfaceFitDemo_生成。\n 返回本章目录\n"}),a.add({id:218,href:'/notes/tags/%E5%9F%BA%E5%87%BD%E6%95%B0/',title:"基函数",content:""}),a.add({id:219,href:'/notes/docs/mlapp/07linear_regression/0060/',title:"7.1 导论",content:"返回本章目录\n线性回归是统计学和（监督）机器学习的“驮马(work horse)”。 当对核或其他形式的基函数进行扩展时，它也能模拟非线性关系。 当用伯努利或广义伯努利分布代替高斯分布输出时，它可以用于分类，我们将在下面看到这点。 因此，详细研究这个模型是值得的。\n返回本章目录\n"}),a.add({id:220,href:'/notes/docs/mlapp/07linear_regression/',title:"第七章 线性回归",content:"第七章 线性回归 本节中的目录：\n  7.1 导论\n  7.2 模型选择\n  7.3 最大似然估计（最小二乘）\n  7.4 稳健线性回归*\n  7.5 岭回归\n  7.6 贝叶斯线性回归\n  Exercises\n  "}),a.add({id:221,href:'/notes/tags/%E4%B9%A0%E9%A2%98/',title:"习题",content:""}),a.add({id:222,href:'/notes/docs/mlapp/06frequentist_statistics/0059/',title:"习题",content:"返回本章目录\n练习6.1 LOOCV的最坏情况\n（来源：Witten05，p152。）。 假设我们有一个完全随机标记的数据集（即，特征   \\(\\boldsymbol{x}\\)  没有告诉我们关于类标签 \\(y\\)  的任何内容），其中类1有 \\(N_1\\)  个样本，类2有 \\(N_2\\)  个样本，并且 \\(N_1 = N_2\\)  。 任何方法可以实现的最佳错分率是多少？ 使用LOOCV对同一方法的估计的错分类率是多少？\n练习6.2 高斯均值的James Stein估计器\n考虑2阶段模型 \\(Y_i |\\theta_i \\sim \\mathcal{N}(\\theta_i,\\sigma^2)\\)  和 \\(\\theta_i|\\mu \\sim \\mathcal{N}(m_0，\\tau_0^2)\\)  。 假设 \\(\\sigma^2= 500\\)  是已知的，我们观察了以下6个数据点， \\(i = 1:6\\)  ：\n1505, 1528, 1564, 1498, 1600, 1470\n a. 求出 \\(m_0\\)  和 \\(\\tau_0^2\\)  的ML-II估计。 b. 对于 \\(i = 1\\)  , 求出后验估计 \\(\\mathbb{E} [\\theta_i | y_i, m_0, \\tau_0]\\)  和 \\({\\rm var} [\\theta_i | y_i, m_0, \\tau_0]\\)  。（其他项 \\(i = 2:6\\)  ，也类似地计算。） c. 对于 \\(i = 1\\)  ，给出 \\(p(\\theta_i | y_i, m_0, \\tau_0)\\)  的95％可信区间。你确信这个区间（假设高斯假设是合理的）吗？ 即它可能太大或太小，或者恰到好处？ d. 如果 \\(\\sigma^2\\)  小得多（比如说 \\(\\sigma^2= 1\\)  ），你对你的估计会有什么期望？ 您不需要计算数字答案; 只是简单地定性解释一下会发生什么，以及为什么。  练习6.3 \\(\\hat{\\sigma}_{\\rm MLE}^2\\)  是有偏的\n证明 \\(\\hat{\\sigma}_{\\rm MLE}^2= \\frac{1} {N} \\sum_{n = 1}^N{(x_n-\\hat{\\mu})^2}\\)  是 \\(\\sigma^2\\)  的有偏估计器，即证明\n\\[ \\mathbb{E}_{X_1,\\dots,X_n \\sim \\mathcal{N}(\\mu,\\sigma)}[\\hat{\\sigma}^2(X_1,\\dots,X_n)]\\ne \\sigma^2 \\]  提示：请注意， \\(X_1,\\dots,X_N\\)  是独立的，并且使用独立随机变量乘积的期望是期望的乘积这一事实。\n练习6.4 当 \\(\\mu\\)  已知时, 估计 \\(\\sigma^2\\)  假设我们采样 \\(x_1,\\dots,x_N \\sim \\mathcal{N}(\\mu, \\sigma^2)\\)  ，其中 \\(\\mu\\)  是已知常数。 在这种情况下，为 \\(\\sigma^2\\)  导出MLE的表达式。 它是无偏的吗？\n返回本章目录\n"}),a.add({id:223,href:'/notes/docs/mlapp/06frequentist_statistics/0057/',title:"6.5 经验风险最小化",content:"返回本章目录\n频率派决策理论存在一个根本问题，即人们实际上无法计算风险函数，因为它依赖于知道真实的数据分布。 （相比之下，贝叶斯后验预期损失总是可以计算，因为它更取决于数据，而不是   \\(\\theta^{\\\\*}\\)  。）但是，有一个设置可以避免这个问题，这就是预测可观察性量的任务，而不是估计隐藏变量或参数。 也就是说，不再关注形如 \\(L(\\boldsymbol{\\theta},\\delta(\\mathcal{D}))\\)  的损失函数，其中 \\(\\boldsymbol{\\theta}\\)  是真实但未知的参数，而 \\(\\delta(\\mathcal{D})\\)  是我们的估计器; 而是让我们关注形如 \\(L(y,\\delta(\\boldsymbol{x}))\\)  的损失函数，其中 \\(y\\)  是真实但未知的响应， \\(\\delta(\\boldsymbol{x})\\)  是给定输入 \\(\\boldsymbol{x}\\)  的预测。 在这种情况下，频率派风险变为\n\\[ R(p_{\\\\*},\\delta)\\overset{\\Delta}{=}\\mathbb{E}_{(\\boldsymbol{x},y) \\sim p_{\\\\*}}\\left[L(y,\\delta(\\boldsymbol{x}))\\right]=\\sum_{\\boldsymbol{x}}{\\sum_y{L(y,\\delta(\\boldsymbol{x}))p_{\\\\*}(\\boldsymbol{x},y)}} \\tag{6.47} \\]  其中 \\(p_{\\\\*}\\)  代表“自然的分布”。 当然，这种分布是未知的，但一种简单的方法是使用从一些训练数据导出的经验分布来近似 \\(p^{\\\\*}\\)  ，即，\n\\[ p_{\\\\*}(\\boldsymbol{x},y) \\approx p_{\\rm emp}(\\boldsymbol{x},y)\\overset{\\Delta}{=}\\dfrac{1}{N}\\sum_{i=1}^N{\\delta_{\\boldsymbol{x}_i}(\\boldsymbol{x})\\delta_{y_i}(y)} \\tag{6.48} \\]  然后我们将经验风险定义如下：\n\\[ R_{\\rm emp}(\\mathcal{D},\\mathcal{D})\\overset{\\Delta}{=}R(p_{\\rm emp},\\delta)=\\dfrac{1}{N}\\sum_{i=1}^N{L(y_i,\\delta(\\boldsymbol{x}_i))} \\tag{6.49} \\]  在0-1损失的情况下， \\(L(y,\\delta(\\boldsymbol{x}))=\\mathbb{I} (y \\ne \\delta(\\boldsymbol{x}))\\)  变成了错分率(misclassification rate)。 在平方误差损失的情况下， \\(L(y,\\delta(\\boldsymbol{x}))=(y - \\delta(\\boldsymbol{x}))^2\\)  ，这变为均方误差(mean squared error)。 我们将经验风险最小化或ERM的任务定义为寻找决策程序（通常是分类规则）以使最小化经验风险：\n\\[ \\delta_{\\rm ERM}(\\mathcal{D})=\\underset{\\delta}{\\rm argmin} \\ R_{\\rm emp}(\\mathcal{D},\\delta) \\tag{6.50} \\]  在无监督的情况下，我们消除对 \\(y\\)  的所有引用，并用 \\(L(\\boldsymbol{x},\\delta(\\boldsymbol{x}))\\)  代替 \\(L(y,\\delta(\\boldsymbol{x}))\\)  ，比如 \\(L(\\boldsymbol{x},\\delta(\\boldsymbol{x}))= \\| \\boldsymbol{x} - \\delta(\\boldsymbol{x})\\|_2^2\\)  被用来度量重建误差。 我们可以使用 \\(\\delta(\\boldsymbol{x})= {\\rm decode}({\\rm encode}(\\boldsymbol{x}))\\)  定义决策规则，用作矢量量化（第11.4.2.6节）或PCA（第12.2节）。 最后，我们将经验风险定义为\n\\[ R_{\\rm emp}(\\mathcal{D},\\delta)=\\dfrac{1}{N}\\sum_{i=1}^N{L(\\boldsymbol{x}_i,\\delta(\\boldsymbol{x}_i))} \\tag{6.51} \\]  当然，我们总是可以通过设置 \\(\\delta(\\boldsymbol{x})= \\boldsymbol{x}\\)  来最小化这种风险，因此编码器-解码器通过某种瓶颈是至关重要的。\n6.5.1 正则化风险最小化 请注意，如果我们的先验相关的“自然分布”与经验分布完全相等（Minka 2001b），则经验风险等于贝叶斯风险：\n\\[ \\mathbb{E}\\left[R(p_{\\\\*},\\delta)_{p_{\\\\*}=p_{\\rm emp}}\\right]=R_{\\rm emp}(\\mathcal{D},\\delta) \\tag{6.52} \\]  因此，最小化经验风险通常会导致过度拟合。 因此，经常需要为目标函数添加复杂性惩罚：\n\\[ R'(\\mathcal{D},\\delta)=R_{\\rm emp}(\\mathcal{D},\\delta)+\\lambda C(\\delta) \\tag{6.53} \\]  其中 \\(C(\\delta)\\)  度量了预测函数 \\(\\delta{\\boldsymbol{x}}\\)  的复杂度， \\(\\lambda\\)  控制了复杂性惩罚的强度。 这种方法称为正则化风险最小化（RRM）。 注意，如果损失函数是负对数似然，并且正则化项是负对数先验，则这相当于MAP估计。\nRRM中的两个关键问题是：我们如何度量复杂性，以及如何选择 \\(\\lambda\\)  。 对于线性模型，我们可以根据第7.5.3节中讨论的自由度来定义复杂性。 对于更一般的模型，我们可以使用第6.5.4节中讨论的VC维度。 至于 \\(\\lambda\\)  的选择，我们可以使用第6.5.2节中讨论的方法。\n6.5.2 结构风险最小化 正则化风险最小化原则表明，对于给定的复杂性惩罚，我们应该通过使用下式来拟合模型\n\\[ \\hat{\\delta}_\\lambda = \\underset{\\delta}{\\rm argmin} \\left[R_{\\rm emp}(\\mathcal{D},\\delta)+\\lambda C(\\delta)\\right] \\tag{6.54} \\]  但是我们该怎么选择 \\(\\lambda\\)  呢？ 我们不能使用训练集，因为这会低估真正的风险，这个问题被称为训练误差的乐观(optimism of the training error)。 作为替代方案，我们可以使用以下规则，称为结构风险最小化原则：（Vapnik 1998）：\n\\[ \\hat{\\lambda}=\\underset{\\lambda}{\\rm argmin} \\ \\hat{R}(\\hat{\\delta}_\\lambda) \\tag{6.55} \\]  其中 \\(\\hat{R}(\\delta)\\)  是风险的估计值。 有两种广泛使用的估计：交叉验证和风险的理论上限。 我们将在下面讨论这两个方面。\n6.5.3 使用交叉验证估计风险 我们可以使用验证集来估计某些估算器的风险。 如果我们没有单独的验证集，我们可以使用交叉验证（CV），正如我们在1.4.8节中简要讨论的那样。 更确切地说，CV定义如下。 在训练集中令 \\(N = |\\mathcal{D}|\\)  。 用 \\(\\mathcal{D}_k\\)  表示第k折叠的测试数据，用 \\(\\mathcal{D}_{-k}\\)  表示所有其他数据。 （在分层CV(stratified CV)中，选择的这些折叠使得每个类的占比（如果存在离散标签）在每个折叠中大致相等。）设 \\(\\mathcal{F}\\)  是一个基于数据集和第 \\(m\\)  模型上的学习算法或拟合函数（这个索引 \\(m\\)  可能是 离散索引，例如多项式的次数，或连续索引，例如正则化器的强度）并返回参数向量：\n\\[ \\hat{\\boldsymbol{\\theta}}_m = \\mathcal{F}(\\mathcal{D},m) \\tag{6.56} \\]  最后，让 \\(\\mathcal{P}\\)  为预测函数，它接受输入和参数向量并返回预测：\n\\[ \\hat{y} = \\mathcal{P}(\\boldsymbol{x},\\hat{\\boldsymbol{\\theta}})=f(\\boldsymbol{x},\\hat{\\boldsymbol{\\theta}}) \\tag{6.57} \\]  因此，组合得到的拟合-预测循环表示为\n\\[ f_m(\\boldsymbol{x},\\mathcal{D})=\\mathcal{P}(\\boldsymbol{x},\\mathcal{F}(\\mathcal{D},m)) \\tag{6.58} \\]   \\(f_m\\)  风险的K折CV估计定义为\n\\[ R(m,\\mathcal{D},K)\\overset{\\Delta}{=}\\dfrac{1}{N}\\sum_{k=1}^K{\\sum_{i\\in\\mathcal{D}_k}{L(y_i,\\mathcal{P}(\\boldsymbol{x}_i,\\mathcal{F}(\\mathcal{D}_{-k},m)))}} \\tag{6.59} \\]  请注意，我们可以每折都调用拟合算法一次。 令 \\(f_m^k(\\boldsymbol{x})=\\mathcal{P}(\\boldsymbol{x},\\mathcal{F}(\\mathcal{D}_{-k},m))\\)  是除了 \\(k\\)  折测试数据之外的所有数据上训练的函数。 于是我们可以将CV估计重写为\n\\[ R(m,\\mathcal{D},K)=\\dfrac{1}{N}\\sum_{k=1}^K{\\sum_{i\\in\\mathcal{D}_k}{L(y_i,f_m^k(\\boldsymbol{x}_i))}}=\\dfrac{1}{N}\\sum_{i=1}^N{L(y_i,f_m^{k(i)}(\\boldsymbol{x}_i))} \\tag{6.60} \\]  其中 \\(k(i)\\)  是第 \\(i\\)  个数据被用作测试数据所在的折叠。 换句话说，我们使用在不包含 \\(\\boldsymbol{x}_i\\)  的数据上训练模型来预测 \\(y_i\\)  。\n在 \\(K = N\\)  的情况下，该方法被称为留一交叉验证或LOOCV。 在这种情况下，估计的风险就变成了\n\\[ R(m,\\mathcal{D},K)=\\dfrac{1}{N}\\sum_{i=1}^N{L(y_i,f_m^{-i}(\\boldsymbol{x}_i))} \\tag{6.61} \\]  其中 \\(f_m^i(\\boldsymbol{x})=\\mathcal{P}(\\boldsymbol{x},\\mathcal{F}(\\mathcal{D}_{-i},m))\\)  。 这需要将模型拟合N次，其中 \\(f_m^{-i}\\)  我们省略了第 \\(i\\)  个训练案例。 幸运的是，对于某些模型类和损失函数（即线性模型和二次损失），我们可以将模型拟合一次，并在分析地“消除”第 \\(i\\)  个训练案例的效果。 这称为广义交叉验证或GCV。\n6.5.3.1 示例：使用CV为岭回归选择λ 作为一个具体的例子，考虑在惩罚线性回归中选择 \\(l_2\\)  正则化强度。 我们使用以下规则：\n\\[ \\hat{\\lambda}=\\underset{\\lambda \\in [\\lambda_{\\min},\\lambda_{\\max}]}{\\rm argmin} \\ R(\\lambda,\\mathcal{D}_{\\rm train},K) \\tag{6.62} \\]  其中 \\([\\lambda_{\\min},\\lambda_{\\max}]\\)  是我们搜索的 \\(\\lambda\\)  值的有限范围， \\(R(\\lambda,\\mathcal{D}_{\\rm train},K)\\)  是使用 \\(\\lambda\\)  的K折CV风险估计值，由下式给出：\n\\[ R(\\lambda,\\mathcal{D}_{\\rm train},K)=\\dfrac{1}{|\\mathcal{D}_{\\rm train}|}\\sum_{k=1}^K{\\sum_{i\\in\\mathcal{D}_k}{L(y_i,f_\\lambda^k(\\boldsymbol{x}_i))}} \\tag{6.63} \\]  其中 \\(f_\\lambda^k(\\boldsymbol{x})=\\boldsymbol{x}^T \\hat{\\boldsymbol{w}}_\\lambda(\\mathcal{D}_{-k})\\)  是在不包括 \\(k\\)  折叠数据上训练的预测函数，并且 \\(\\hat{\\boldsymbol{w}}_\\lambda(\\mathcal{D})= \\underset{\\boldsymbol{w}}{\\rm argmin}\\left[{\\rm NLL}(\\boldsymbol{w},\\mathcal{D})+\\lambda \\| \\boldsymbol{w} \\|_2^2\\right]\\)  是MAP估计。 图6.6（b）给出了风险v.s. \\(\\log(\\lambda)\\)  的CV估计的一个例子，其中损失函数是平方误差。\n 图6.6 （a）14阶多项式回归的 \\(l_2\\)  惩罚v.s.对数正则化的均方误差。 与图7.8相同，除了现在我们有N = 50个训练点而不是21个。星形对应于图7.7中用于绘制函数的值。 （b）CV估计。 为清楚起见，垂直刻度被截断。 蓝线对应于基于标准误差规则选择的值。 由_linregPolyVsRegDemo_生成的图。\n 进行分类时，我们通常使用0-1损失。 在这种情况下，我们通过优化经验风险的凸上界来估计 \\(\\boldsymbol{w}_\\lambda\\)  ，但我们优化（CV估计）风险本身来估计 \\(\\lambda\\)  。 我们可以在估计 \\(\\lambda\\)  时处理非平滑0-1损失函数，因为我们在整个（一维）空间上使用强力搜索。\n当我们有超过一个或两个调整参数时，这种方法变得不可行。 在这种情况下，可以使用经验贝叶斯，这允许人们使用基于梯度的优化器而不是强力搜索来优化大量超参数。 详细信息请参见第5.6节。\n6.5.3.2 一个标准误差规则(one-standard error rule) 上述估计风险程序，没有给出任何不确定性的衡量标准。 关于估计不确定性的标准频率派度量是均值的标准误差，由定义如下\n\\[ {\\rm se} = \\dfrac{\\hat{\\sigma}}{\\sqrt{N}}=\\sqrt{\\dfrac{\\hat{\\sigma}^2}{N}} \\tag{6.64} \\]  其中 \\(\\hat{\\sigma}^2\\)  是损失方差的一个估计：\n\\[ \\hat{\\sigma}^2 = \\dfrac{1}{N}\\sum_{i=1}^N{(L_i-\\bar{L})^2},L_i=L(y_i,f_m^{k(i)}(\\boldsymbol{x}_i)),\\bar{L}=\\dfrac{1}{N}\\sum_{i=1}^N{L_i} \\tag{6.65} \\]  请注意， \\(\\sigma\\)  度量所有样本损失 \\(L_i\\)  的内在变化，而 \\({\\rm se}\\)  测量我们关于均值 \\(\\bar{L}\\)  的不确定性。\n假设我们将CV应用于一组模型并计算其风险估计的均值和标准误差。 从这些噪声估计中挑选模型的常用启发式方法是选择对应于最简单模型的值，该模型的风险不超过最佳模型风险的一个标准误差; 这被称为一个标准误差规则（Hastie等，2001，第216页）。 例如，在图6.6中，我们看到这种启发式算法并没有选择曲线上的最低点，而是略微偏向右侧，因为这对应于具有基本相同经验性能的更严格的正则化模型。\n6.5.3.3 非概率无监督学习中CV模型选择 如果我们正在进行无监督学习，我们必须使用形如 \\(L(\\boldsymbol{x},\\delta(\\boldsymbol{x}))= \\| \\boldsymbol{x} - \\delta(\\boldsymbol{x})\\|_2^2\\)  的损失函数，它度量了重建误差。 这里 \\(\\delta(\\boldsymbol{x})\\)  是一些编码-解码方案。 然而，正如我们在第11.5.2节中讨论的那样，我们不能使用CV来确定 \\(\\delta\\)  的复杂性，因为即使在测试集上进行评估，我们也总能通过更复杂的模型获得更低的损失。 这是因为更复杂的模型会减少压缩数据，并减少失真。 因此，我们必须使用概率模型，或发明其他启发式。\n6.5.4 使用统计学习理论的风险上限* 交叉验证的主要问题是它很慢，因为我们不得不多次拟合模型。 这激发了对分析近似或泛化误差界限的计算欲望。 这是在统计学习理论（SLT）领域中所研究的。 更确切地说，SLT试图根据经验风险 \\(R_{\\rm emp}(\\mathcal{D},h)\\)  ，样本大小 \\(N =| \\mathcal{D} |\\)  ，以及假设空间 \\(\\mathcal{H}\\)  的大小， 限制任意一个数据分布 \\(p_{\\\\*}\\)  和假设 \\(h \\in \\mathcal{H}\\)  的风险 \\(R(p_{\\\\*},h)\\)  。\n让我们首先考虑假设空间是有限的情况，其大小为 \\({\\rm dim}(\\mathcal{H})= | \\mathcal{H} |\\)  。 换句话说，我们从有限列表中选择一个模型/假设，而不是优化实值参数。然后我们可以证明以下内容。\n定理6.5.1. 对于任何数据分布 \\(p_{\\\\*}\\)  ，以及从 \\(p_{\\\\*}\\)  中提取的任何大小为 \\(N\\)  的数据集 \\(\\mathcal{D}\\)  ，对一个有限大小的假设空间 \\(\\mathcal{H}\\)  而言，有如下不等式成立：\n\\[ P\\left(\\underset{h\\in\\mathcal{H}}{\\rm max}\\left|R_{\\rm emp}(\\mathcal{D},h)-R(p_{\\\\*},h)\\right|\\epsilon\\right)\\le 2 \\ {\\rm dim}(\\mathcal{H}) e^{-2N\\epsilon^2} \\tag{6.66} \\]  证明: 为了证明这一点，我们需要两个有用的结果。 首先，Hoeffding不等式，它表明如果 \\(X_1,\\dots,X_N \\sim {\\rm Ber}(\\theta)\\)  ，那么，\n\\[ P\\left(|\\bar{x}-\\theta|\\epsilon\\right) \\le 2 \\ e^{-2N\\epsilon^2} \\tag{6.67} \\]  其中 \\(\\bar{x}=\\frac{1}{N} \\sum_{i = 1}^N{x_i}\\)  。 其次，联合上界，即如果 \\(A_1,\\dots,A_d\\)  是一组事件，那么 \\(P(\\bigcup_{i=1}^d{A_i}) \\le \\sum_{i= 1}^d{P(A_i)}\\)  。\n最后，为了符号简洁性，让 \\(R(h)= R(h,p_{\\\\*})\\)  表示真实风险， \\(\\hat{R}_N(h)= R_{\\rm emp}(\\mathcal{D},h)\\)  表示经验风险。\n使用这些结果，我们有\n\\[ \\begin{aligned} P\\left(\\underset{h \\in \\mathcal{H}}{\\rm max}\\left|\\hat{R}_N(h)-R(h)\\right|\\epsilon\\right) = \u0026 P\\left(\\bigcup_{h \\in \\mathcal{H}}\\left|\\hat{R}_N(h)-R(h)\\right|\\epsilon\\right) \\\\ \\quad \\le \u0026 \\bigcup_{h \\in \\mathcal{H}}P\\left(\\left|\\hat{R}_N(h)-R(h)\\right|\\epsilon\\right) \\\\ \\quad \\le \u0026 \\bigcup_{h \\in \\mathcal{H}}{2 \\ e^{-2N\\epsilon^2}} = 2 \\ {\\rm dim}(\\mathcal{H}) e^{-2N\\epsilon^2} \\\\ \\end{aligned} \\tag{6.68-70} \\]  这个上界告诉我们，训练误差的乐观程度随着 \\({\\rm dim}(\\mathcal{H})\\)  而增加，但随着 \\(N = | \\mathcal{D} |\\)  而减小，正如预期的那样。\n如果假设空间 \\(\\mathcal{H}\\)  是无穷大的（比如，实值参数），我们就不能使用 \\({\\rm dim}(\\mathcal{H})= | \\mathcal{H} |\\)  。 相反，我们可以使用称为Vapnik-Chervonenkis的量或假设类的VC维度。 有关详细信息，请参阅（Vapnik 1998）。\n统计学习理论背后的关键直觉非常简单。 假设我们找到了一个较低经验风险的模型。 如果相对于数据大小，假设空间 \\(\\mathcal{H}\\)  非常大，那么很可能我们只是“幸运”地用我们选择的函数为给定数据集就很好建模了。 然而，这并不意味着这样的函数具有低泛化误差。 但是，如果假设类的大小受到足够的约束，和/或，训练集足够大，那么我们不太可能以这种方式获得幸运，所以低经验风险是低真实风险的证据。\n请注意，训练误差的乐观性不一定随模型复杂性而增加，但它确实随着搜索的不同模型的数量而增加。\n与CV相比，统计学习理论的优势在于风险界限的计算比使用CV更快。 缺点是很难为许多有趣的模型计算VC维度，并且上限通常非常松散（尽管参见（Kaariainen和Langford 2005））。\n人们可以通过考虑学习者的计算复杂性来扩展统计学习理论。 该领域称为计算学习理论或COLT。 这项工作大部分集中在 \\(h\\)  是二元分类器并且损失函数是0-1损失的情况下。 如果我们观察到低经验风险，并且假设空间适当地“小”，那么我们可以说我们的估计函数可能近似正确或PAC。 如果存在一个多项式时间算法，可以识别一个函数是PAC的，那么假设空间被有效地PAC学习。 有关详细信息，请参阅（Kearns和Vazirani 1994）。\n6.5.5 代理损失函数( Surrogate loss functions) 最小化ERM / RRM框架中的损失并非易事。 例如，我们可能想要优化AUC或F1分数。 或者更简单地说，我们可能只想最小化0-1损失，这在分类中很常见。 不幸的是，0-1风险是一个非常不平滑的目标，因此难以优化。 一种替代方案是使用最大似然估计，因为对数似然是0-1风险的平滑凸上限，如下所示。\n为了看到这一点，考虑二元逻辑斯蒂回归，并令 \\(y_i \\in \\{-1,+1\\}\\)  。 假设我们的决策函数计算对数比值比(log-odds ratio)，\n\\[ f(\\boldsymbol{x}_i)=\\log \\dfrac{p(y=1|\\boldsymbol{x}_i,\\boldsymbol{w})}{p(y=-1|\\boldsymbol{x}_i,\\boldsymbol{w})}=\\boldsymbol{w}^T\\boldsymbol{x}_i=\\eta_i \\tag{6.71} \\]  然后输出标签上的相应概率分布是\n\\[ p(y_i|\\boldsymbol{x}_i,\\boldsymbol{w})={\\rm sigm}(y_i \\eta_i) \\tag{6.72} \\]  让我们将对数损失(log-loss)定义为\n\\[ L_{\\rm nll}(y,\\eta) = - \\log \\ p(y|\\boldsymbol{x},\\boldsymbol{w})=\\log (1+e^{-y \\eta}) \\tag{6.73} \\]  很明显，最小化对数损失平均等价于最大化拟然。\n 图6.7 二进制分类的各种损失函数的描述。 横轴是边缘 \\(y \\eta\\)  ，纵轴是损失。 对数损失使用基于2的对数.由_hingeLossPlot_生成的图。\n 现在考虑计算最可能的标签，这等价于，如果 \\(\\eta_i则 \\(y = -1\\)  ;如果 \\(\\eta_i \\ge 0\\)  则 \\(y = 1\\)  。 我们函数的0-1损失变成\n\\[ L_{01}(y,\\eta)=\\mathbb{I}(y \\ne \\hat{y})=\\mathbb{I}(y \\eta图6.7绘制了这两个损失函数。 我们看到NLL确实是0-1损失的上限。\n对数损失是代理损失函数(surrogate loss function)的一个例子。 另一个例子是合页损失(hinge loss)：\n\\[ L_{\\rm hinge}(y,\\eta)=\\max(0,1-y\\eta) \\tag{6.75} \\]  请参见图6.7的绘图。 我们看到该函数看起来像一个门合页，因此得名。 这种损失函数构成了一种流行的分类方法的基础，称为支持向量机（SVM），我们将在14.5节中讨论。\n代理通常被选择为凸上界，因为凸函数易于最小化。 例如，参见（Bartlett等人，2006）以获得更多信息。\n返回本章目录\n"}),a.add({id:224,href:'/notes/docs/mlapp/06frequentist_statistics/0058/',title:"6.6 频率派统计的病态*",content:"返回本章目录\n 我认为说服一个认为\u0026quot;现在的[频率派]统计实践是明智的\u0026quot;的聪明人是很难的，但通过拟然和贝叶斯定理的方法困难会更少。 - George Box，1962年。\n 频率派统计表现出各种形式的奇怪和不良行为，称之为病态(pathologies)。 我们在下面举几个例子，以提醒读者; 这些和其他实例在（Lindley 1972; Lindley和Phillips 1976; Lindley 1982; Berger 1985; Jaynes 2003; Minka 1999）中有更详细的解释。\n6.6.1 置信区间的反直觉行为 置信区间是从估计器的采样分布导出的区间（而贝叶斯可信区间是从参数的后验得出的，正如我们在5.2.2节中讨论的那样）。 更准确地说，某些参数   \\(\\theta\\)  的频率派置信区间由以下（相当不自然）表达式定义：\n\\[ C_\\alpha^{'}(\\theta)=(l,u):P(l(\\tilde{\\mathcal{D}} \\le \\theta \\le u(\\tilde{\\mathcal{D}})|\\tilde{\\mathcal{D}} \\sim \\theta)=1-\\alpha \\tag{6.76} \\]  也就是说，如果我们从 \\(\\theta\\)  采样得到假想的未来数据 \\(\\tilde{\\mathcal{D}}\\)  ，再如果参数 \\(\\theta\\)  以 \\(1-\\alpha\\)  ％的时间出现在区间 \\((l(\\tilde{\\mathcal{D}},u(\\tilde{\\mathcal{D}}))\\)  中 ，那么，那么该区间就是 \\(\\alpha\\)  置信区间。\n让我们退一步，思考一下发生了什么。 在贝叶斯统计中，我们根据已知的情况 - 即已观测数据 \\(\\mathcal{D}\\)  - 和未知数的平均值，即参数 \\(\\theta\\)  。 而在频率派统计中，我们完全相反：我们根据未知的情况 - 即真实参数值 \\(\\theta\\)  - 和假想的未来数据集 \\(\\tilde{\\mathcal{D}}\\)  的平均值。\n这种反直觉的置信区间定义可能会导致奇怪的结果。 请考虑以下示例（Berger 1985，第11页）。 假设我们从下式抽取两个整数 \\(\\mathcal{D} =(x_1,x_2)\\)  \\[ p(x|\\theta)=\\left\\{ \\begin{aligned} 0.5 \\quad \u0026 {\\rm if} \\quad x=\\theta \\\\ 0.5 \\quad \u0026 {\\rm if} \\quad x=\\theta+1 \\\\ 0 \\quad \u0026 {\\rm otherwise} \\\\ \\end{aligned} \\right. \\tag{6.77} \\]  如果 \\(\\theta = 39\\)  ，我们预计以下结果各有概率0.25：\n\\[ (39,39),\\ (39,40), \\ (40,39), \\ (40,40) \\tag{6.78} \\]  设 \\(m = \\min (x_1,x_2)\\)  并定义以下置信区间：\n\\[ [l(\\mathcal{D}),u(\\mathcal{D})]=[m,m] \\tag{6.79} \\]  对于上述样本，由此产生\n\\[ [39,39],\\ [39,39], \\ [39,39], \\ [40,40] \\tag{6.78} \\]  因此，式6.79显然是75％CI，因为39包含在这些间隔的3/4中。 然而，如果 \\(\\mathcal{D} =（39,40)\\)  ，那么 \\(p(\\theta = 39 | \\mathcal{D})= 1.0\\)  ，这意味着 \\(\\theta\\)  必须是39，但我们在这个事实中只有75％的“置信度”。\n另一个不那么人为的例子如下。 假设我们想要估计伯努利分布的参数 \\(\\theta\\)  。 令 \\(\\bar{x} = \\frac{1}{N} \\sum_{i = 1}^N{x_i}\\)  为样本均值。 MLE是 \\(\\hat{\\theta}= \\bar{x}\\)  。 伯努利参数的大约95％置信区间为 \\(\\bar{x} \\pm 1.96 \\sqrt{\\bar{x}(1-\\bar{x})/ N}\\)  （这称为Wald区间，这是基于二项分布的高斯近似; 与公式3.27相比）。 现在考虑一个单独的试验，其中 \\(N = 1\\)  且 \\(x_1 = 0\\)  。 MLE为0，如第3.3.4.1节所述，这是过拟合的。 但我们的95％置信区间也是 \\((0,0)\\)  ，这似乎更糟。 可以认为上述缺陷是因为我们用高斯近似了真实的采样分布，或者因为样本大小很小，或者参数“太极端”。 然而，即使对于大的 \\(N\\)  和非极端参数，Wald区间也会表现很差（Brown et al.2001）。\n6.6.2 p-值被认为是有害的 假设我们想要决定是接受还是拒绝某些我们称之为零假设的底线( baseline)模型。 我们需要定义一些决策规则。 在频率派统计中，标准上首先要计算一个被称作p-值的量，被定义为源自零假设的统计量 \\(f(\\tilde{\\mathcal{D}})\\)  （比如,卡方统计量）大于或等于源自实际观察的该统计量 \\(f(\\mathcal{D})\\)  的概率 :\n\\[ {\\rm pvalue}(\\mathcal{D}) \\overset{\\Delta}{=} P(f(\\tilde{\\mathcal{D}}) \\ge f(\\mathcal{D}) | \\tilde{\\mathcal{D}} \\sim H_0) \\tag{6.81} \\]  该量依赖于计算采样分布的尾区概率(tail area probability); 下面我们举一个如何执行此操作的示例。\n给定p-值，我们将决策规则定义如下：拒绝零假设，当且仅当，如果p值小于某个阈值（例如 \\(\\alpha= 0.05\\)  ）。 如果我们拒绝它，我们说观察到的检验统计量与预期检验统计量之间的差异是 \\(\\alpha\\)  水平统计显著(statistically significant)。 这种方法称为零假设显著性检验(null hypothesis significance testing)或NHST。\n此过程保证我们预期的I型（假阳）错误率最多为 \\(\\alpha\\)  。 这有时被解释为频率假设检验是非常保守的，因为它不太可能意外地拒绝零假设。 但实际情况恰恰相反：因为这种方法只是担心尝试拒绝零假设，所以无论样本大小多大，它都无法收集有利于零假设的证据。 因此，p-值往往夸大了对零假设的证据，因此非常“trigger happy”。\n一般来说，p-值和我们真正关注的量（给定数据下零假设的后验概率 \\(p(H_0 | \\mathcal{D})\\)  ）之间可能存在巨大差异。 特别是，Sellke等人 （2001）表明，即使p值低到0.05， \\(H_0\\)  的后验概率至少为30％，并且通常要高得多。 因此，频率派经常声称拥有零假设无法解释的效果的“重要”证据, ，而贝叶斯主义者的主张通常更为保守。 例如，p-值已被用于“证明”ESP（超感官感知, extra-sensory perception）是真实的（Wagenmakers等人，2011），尽管ESP显然是非常不可能的。 出于这个原因，某些医学期刊禁止使用p值（Matthews 1998）。\np-值的另一个问题是它们的计算取决于你决定何时停止收集数据的决定，即使这些决定不会改变你实际观察到的数据。 例如，假设我掷硬币n = 12次并观察s = 9次成功（头部）和f = 3次失败（尾部），因此n = s + f。 在这种情况下，n是固定的，s（因此f）是随机的。 相关的抽样模型是二项的\n\\[ {\\rm Bin}(s|n,\\theta)=\\binom{n}{s}\\theta^s(1-\\theta)^{n-s} \\tag{6.82} \\]  令零假设表示硬币是公平的 \\(\\theta= 0.5\\)  ，其中 \\(\\theta\\)  是成功的概率（头）。 使用检验统计量 \\(t(s)= s\\)  的单侧p-值是\n\\[ p_1 = P(S \\ge 9 | H_0)=\\sum_{s=9}^{12}{{\\rm Bin}(s|12,0.5)}=\\sum_{s=9}^{12}{\\binom{12}{s} 0.5^{12}}=0.073 \\tag{6.83} \\]  双侧p-值是\n\\[ p_2=\\sum_{s=9}^{12}{{\\rm Bin}(s|12,0.5)}+\\sum_{s=0}^{3}{{\\rm Bin}(s|12,0.5)} =0.072+0.073=0.146 \\tag{6.84} \\]  在任何一种情况下，p值都大于神奇的5％阈值，因此频率派不会拒绝零假设。\n现在假设我告诉过你我实际上一直在扔硬币，直到我观察到f = 3个尾巴。 在这种情况下，f是固定的，并且n（因此s = n-f）是随机的。 概率模型变为负二项分布(negative binomial distribution)，由下式给出\n\\[ {\\rm NegBinom}(s|f,\\theta)=\\binom{s+f-1}{f-1}\\theta^s(1-\\theta)^f \\tag{6.85} \\]  其中 f = n − s。\n注意，用来与 \\(\\theta\\)  的项在式6.82和6.85中是相同的，因此在两种情况下，关于 \\(\\theta\\)  都的后验都是相同的。 然而，对相同数据的这两种解释给出不同的p-值。 特别是在我们得到的负二项模型下\n\\[ p_3=P(S \\ge 9 | H_0)=\\sum_{s=9}^\\infty {\\binom{3+s-1}{2}(1/2)^s(1/2)^s}=0.0327 \\tag{6.86} \\]  所以p-值是3％，突然间硬币似乎有显著偏差证据！ 显然这很荒谬：数据是一样的，所以我们对硬币的推论应该是一样的。 毕竟，我可以随机选择实验方案。 重要的是实验的结果，而不是我决定运行哪一个的细节。\n虽然这似乎只是一种数学好奇心，但这也具有重要的实际意义。 特别是，停止规则影响p值的计算意味着频率派通常不会提前终止实验，即使很明显结论是什么，以免对其统计分析产生不利影响。 如果实验成本高或对人有害，这显然是一个坏主意。 因此，管理新药临床试验的美国食品和药物管理局（FDA）最近可能支持贝叶斯方法，这也就不足为奇了，因为贝叶斯方法不受停止规则的影响。\n6.6.3 拟然原则 许多这些病态的根本原因是频率推断违反了拟然原则，即基于观察数据可能(拟然)的推断，而不是基于您未观察到的假想未来数据。 贝叶斯显然满足似然原则，因此不会受到这些病态的影响。\nBirnbaum（1962）提出了一个支持拟然原则的令人信服的论据，他表明它遵循两个更简单的原则。第一个是充分性原则(sufficiency principle)，它表示一个充分统计包含有关未知参数的所有相关信息（可以说这是定义的）。第二个原则被称为弱条件(weak conditionality)，它表示推论应该基于发生的事件，而不是可能发生的事件。为了明确这一点，请考虑一个例子（Berger 1985）。假设我们需要分析一种物质，并将其发送到纽约或加利福尼亚的实验室。这两个实验室看起来同样好，所以用一个公平的硬币来决定它们之间的关系。硬币出现在头上，于是加州实验室被选中。当结果回来时，是否应该考虑到硬币可能会出现尾巴，因此可以使用纽约实验室？大多数人会认为纽约实验室是无关紧要的，因为尾巴事件没有发生。这是弱条件的一个例子。根据这一原则，可以证明所有推论都应该仅基于观察到的内容，这与标准的频率派程序形成对比。有关拟然原则的更多详细信息，请参见（Berger和Wolpert 1988）。\n6.6.4 为什么不是每个人都是贝叶斯人？ 考虑到频率派统计的这些根本缺陷，以及贝叶斯方法没有这样的缺陷这一事实，一个显而易见的问题是：“为什么不是每个人都是贝叶斯人？”（频率派）统计学家布拉德利·埃夫隆写了一篇论文，正是这个 标题（Efron 1986）。 对于对这个主题感兴趣的人，他的简短论文非常值得一读。 下面我们引用他的开头部分：\n 主题是一个合理的问题，至少要问两个问题。 首先，以前曾经是贝叶斯人。 拉普拉斯全力支持贝叶斯推理问题的制定，大多数19世纪的科学家也纷纷效仿。 这包括高斯，其统计工作通常以频率派术语表示。 第二个也是更重要的一点是贝叶斯论证的有说服力。 在Savage和de Finetti的带领下，现代统计学家为偏爱贝叶斯推理提出了强有力的理论论据。 这项工作的副产品是关于频率派观点中不一致的一份令人不安的条目列表(A byproduct of this work is a disturbing catalogue of inconsistencies in the frequentist point of view.)。 然而，每个人都不是贝叶斯人。 当前时代（1986年）是统计学被广泛用于科学报道的第一个世纪，事实上，20世纪的统计数据主要是非贝叶斯统计学。 然而，Lindley（1975）预测21世纪将发生变化。  时间会证明Lindley是对的\u0026hellip;\u0026hellip;\n返回本章目录\n"}),a.add({id:225,href:'/notes/tags/p%E5%80%BC/',title:"p值",content:""}),a.add({id:226,href:'/notes/tags/%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81/',title:"交叉验证",content:""}),a.add({id:227,href:'/notes/tags/%E6%8B%9F%E7%84%B6/',title:"拟然",content:""}),a.add({id:228,href:'/notes/tags/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/',title:"损失函数",content:""}),a.add({id:229,href:'/notes/tags/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/',title:"置信区间",content:""}),a.add({id:230,href:'/notes/tags/%E9%A2%91%E7%8E%87%E6%B4%BE/',title:"频率派",content:""}),a.add({id:231,href:'/notes/tags/%E9%A3%8E%E9%99%A9/',title:"风险",content:""}),a.add({id:232,href:'/notes/docs/mlapp/06frequentist_statistics/0056/',title:"6.4 估计器的理想属性",content:"返回本章目录\n由于频率派决策理论没有提供选择最佳估计器的自动方法，我们需要提出其他启发式方法来选择它们。 在本节中，我们将讨论我们所希望估计器应该具有的一些属性。 不幸的是，我们将看到我们无法同时实现所有这些属性。\n6.4.1 一致估计器(Consistent estimators) 如果随着样本大小趋于无穷大而最终恢复生成数据的真实参数，即   \\(| \\mathcal{D}|\\to \\infty \\Rightarrow \\hat{\\theta}(\\mathcal{D}) \\to \\theta^{\\\\*}\\)  （单线箭头表示概率收敛），那么该估计器被称为一致的。 当然，这个概念只有在数据实际来自具有参数 \\(\\theta^{\\\\*}\\)  的指定模型时才有意义，而实际数据通常不是这种情况。 然而，它可能是一个有用的理论属性。\n可以证明MLE是一致估计器。 直观的原因是最大似然相当于最小化 \\(\\mathbb{KL}(p(\\cdot|\\boldsymbol{\\theta}^{\\\\*})| p(\\cdot|\\hat{\\boldsymbol{\\theta}}))\\)  ，其中 \\(p(\\cdot|\\boldsymbol{\\theta}^{\\\\*})\\)  是真实分布， \\(p(\\cdot|\\hat{\\boldsymbol{\\theta}})\\)  是我们的估计。 我们可以实现0KL散度，当且仅当 \\(\\hat{\\boldsymbol{\\theta}}=\\boldsymbol{\\theta}^{\\\\*}\\)  。\n6.4.2 无偏估计器(Unbiased estimators) 估计器的偏差(bias)定义为\n\\[ {\\rm bias}(\\hat{\\theta}(\\cdot))=\\mathbb{E}_{p(\\mathcal{D}|\\theta_{\\\\*})}\\left[\\hat{\\theta}(\\mathcal{D})-\\theta_{\\\\*}\\right] \\tag{6.32} \\]  其中 \\(\\theta_{\\\\*}\\)  是真实参数值。 如果偏差为零，则估计器被称为无偏的(unbiased)。 这意味着采样分布以真实参数为中心。 例如，高斯均值的MLE是无偏的：\n\\[ {\\rm bias}(\\hat{\\mu})=\\mathbb{E}\\left[\\bar{x}\\right]-\\mu=\\mathbb{E}\\left[\\dfrac{1}{N}\\sum_{i=1}^N{x_i}\\right]-\\mu=\\dfrac{N \\mu}{N}-\\mu=0 \\tag{6.33} \\]  然而，高斯方差的MLE \\(\\hat{\\sigma}^2\\)  不是 \\(\\sigma^2\\)  的无偏估计。 事实上，可以证明（练习6.3）\n\\[ \\mathbb{E}\\left[\\hat{\\sigma}^2\\right]=\\dfrac{N-1}{N}\\sigma^2 \\tag{6.34} \\]  但是，下面这个估计器\n\\[ \\hat{\\sigma}_{N-1}^2=\\dfrac{N}{N-1}\\hat{\\sigma}^2=\\dfrac{1}{N-1}\\sum_{i=1}^N{(x_i-\\bar{x})^2} \\tag{6.35} \\]  是无偏估计器，我们很容易证明如下:\n\\[ \\mathbb{E}\\left[\\hat{\\sigma}_{N-1}^2\\right]=\\mathbb{E}\\left[\\dfrac{N}{N-1}\\hat{\\sigma}^2\\right]=\\dfrac{N}{N-1}\\dfrac{N-1}{N}\\sigma^2=\\sigma^2 \\tag{6.36} \\]  在Matlab中，var(X)返回 \\(\\hat{\\sigma}_{N-1}^2\\)  ，而var(X,1)返回 \\(\\sigma^2\\)  （MLE）。 对于足够大的N，差异可以忽略不计。\n尽管MLE有时可能是一个有偏差的估计器，但人们可以渐近地认为它总是无偏见的。 （这对于MLE是一致估计器来说是必要的。）\n虽然无偏听起来像一个理想的属性，但并非总是如此。 有关这一点的讨论，请参见第6.4.4节和（Lindley 1972）。\n6.4.3 最小方差估计器(Minimum variance estimators) 我们希望我们的估算器是无偏的，似乎在直觉上是合理的（尽管我们将在下面提出一些反对这一主张的论据）。 但是，无偏是不够的。 例如，假设我们想要从 \\(\\mathcal{D} = \\{x_1,\\dots,x_N\\}\\)  估计高斯均值。 仅查看第一个数据点 \\(\\hat{\\theta}(\\mathcal{D})= x_1\\)  的估计器是无偏估计器，但通常比经验均值 \\(\\bar{x}\\)  （也是无偏的）更远离 \\(\\theta_{\\\\*}\\)  。 因此估计器的方差也很重要。\n一个自然的问题是：方差可以持续多久？(how long can the variance go?) 一个著名的结果，称为Cramer-Rao下界，提供了无偏估计器的方差下界。 更确切地说，\n定理6.4.1.（Cramer-Rao不等式） 令 \\(X_1,\\dots,X_n \\sim p(X |\\theta_0)\\)  , 并且 \\(\\hat{\\theta}=\\hat{\\theta}(x_1,\\dots,x_n)\\)  是 \\(\\theta_0\\)  的无偏估计器。 那么，在 \\(p(X |\\theta_0)\\)  的各种平滑假设下，我们有\n\\[ {\\rm var}\\left[\\hat{\\theta}\\right] \\ge \\dfrac{1}{n I(\\theta_0)} \\tag{6.37} \\]  其中 \\(I(\\theta_0)\\)  是Fisher信息矩阵 (参见第6.2.2节)。\n证明可以在比如（Rice 1995，p275）中找到。\n可以证明MLE达到了CramerRao下界，因此具有任何无偏估计器的最小渐近方差。 因此，MLE被认为是渐近最优的。\n6.4.4 偏差-方差权衡 虽然使用无偏估计器似乎是一个好主意，但情况并非总是如此。 为了解原因，假设我们使用二次损失。 如上所示，相应的风险是MSE。 我们现在推导一个非常有用的MSE分解。 （所有的期望和方差都是关于真正的分布 \\(p(\\mathcal{D} |\\theta^{\\\\*})\\)  的，但是为了符号简洁我们放弃了显式条件。）设 \\(\\hat{\\theta}=\\hat{\\theta}(\\mathcal{D})\\)  表示估计， \\(\\bar{\\theta}=\\mathbb{E}\\left[\\hat{\\theta}\\right]\\)  表示估计的期望值。 估计（会随 \\(\\mathcal{D}\\)  而变）。 于是我们有\n\\[ \\begin{aligned} \\mathbb{E}\\left[(\\hat{\\theta}-\\theta^{*})^2\\right]=\u0026 \\mathbb{E}\\left[\\left[(\\hat{\\theta}-\\bar{\\theta})+(\\bar{\\theta}-\\theta^{*})\\right]^2\\right] \\\\ \\quad =\u0026 \\mathbb{E}\\left[(\\hat{\\theta}-\\bar{\\theta})^2\\right]+2(\\bar{\\theta}-\\theta^{*})\\mathbb{E}\\left[(\\hat{\\theta}-\\bar{\\theta})\\right]+(\\bar{\\theta}-\\theta^{*})^2 \\\\ \\quad =\u0026 \\mathbb{E}\\left[(\\hat{\\theta}-\\bar{\\theta})^2\\right]+(\\bar{\\theta}-\\theta^{*})^2 \\\\ \\quad =\u0026 {\\rm var}\\left[\\hat{\\theta}\\right]+{\\rm bias}^2(\\hat{\\theta}) \\end{aligned} \\tag{6.38-41} \\]  用文字表述为:\n\\[ \\boxed{{\\rm MSE}={\\rm variance}+{\\rm bias}^2} \\tag{6.42} \\]  这称为偏差-方差权衡（参见例如（Geman等人，1992））。 这意味着使用偏差估计器可能是明智的，只要它减少我们的方差，进而假设我们的目标是最小化平方误差。\n6.4.4.1 示例：估计高斯均值 让我们举一个例子，基于（Hoff 2009，p79）。 假如我们想要从 \\(\\boldsymbol{x} =(x_1,\\dots,x_N)\\)  估计高斯均值。 我们假设数据是从 \\(x_i \\sim \\mathcal{N}(\\theta^{\\\\*} = 1，σ2)\\)  中采样的。 一个明显的估计是MLE。 它的偏差为0，方差为\n\\[ {\\rm var}[\\bar{x}|\\theta^{\\\\*}]=\\dfrac{\\sigma^2}{N} \\tag{6.43} \\]  但我们也可以使用MAP估计。 在4.6.1节中，我们证明了在 \\(\\mathcal{N}(\\theta_0,\\sigma^2/\\kappa_0)\\)  形式的高斯先验下的MAP估计由下式给出：\n\\[ \\tilde{x}\\overset{\\Delta}{=}\\dfrac{N}{N+\\kappa_0}\\bar{x}+\\dfrac{\\kappa_0}{N+\\kappa_0}\\theta_0=w \\bar{x}+(1-w)\\theta_0 \\tag{6.44} \\]  其中 \\(0 \\le w \\le 1\\)  控制我们相信MLE与先验相比的程度。 （这也是后验均值，因为高斯的均值和众数是相同的。）偏差和方差由下式给出：\n\\[ \\begin{aligned} \\mathbb{E}[\\tilde{x}]-\\theta^{*}=\u0026w \\theta^{*}+(1-w) \\theta_0-\\theta^{*}=(1-w)(\\theta_0-\\theta^{*}) \\\\ {\\rm var}[\\tilde{x}]=\u0026 w^2\\dfrac{\\sigma^2}{N} \\end{aligned} \\tag{6.45-46} \\]  因此，虽然MAP估计是有偏的（假设w \u0026lt;1），但它具有较低的方差。\n 图6.4 左：采用不同先验强度 \\(\\kappa_0\\)  的MAP估计的采样分布。 （MLE对应于 \\(\\kappa_0=0\\)  .）右：相对于不同样本大小的MLE的MSE。 基于图5.6（Hoff 2009）。 由_samplingDistGaussShrinkage_生成的图。\n  图6.5 岭回归的偏差-方差权衡的描述。 我们从真实函数生成100个数据集，以纯绿色显示。 左图：我们绘制了20个不同数据集的正则拟合。 我们使用具有高斯RBF展开的线性回归，其中25个中心均匀地分布在[0,1]间隔上。 右图：我们绘制拟合的平均值，对所有100个数据集求平均值。 顶行：强正规化：我们看到个体拟合彼此相似（低方差），但平均值远非事实（高偏差）。 底行：轻度正则化：我们看到个体拟合彼此非常不同（高方差），但平均值接近事实（低偏差）。 基于（Bishop 2006a）图3.5。 由biasVarModelComplexity3生成的图。\n 让我们假设我们先验的略有错误指定，因此我们使用 \\(\\theta_0= 0\\)  ，而事实是 \\(\\theta^{\\\\*} = 1\\)  .在图6.4（a）中，我们看到对 \\(\\kappa_0 0\\)  的MAP估计的采样分布偏离事实，但比MLE有更小的方差（较窄）。\n在图6.4（b）中，我们绘制了 \\({\\rm mse}(\\tilde{x})/{\\rm mse}(x) \\ {\\rm v.s.} \\ N\\)  。我们看到MAP的估计比MLE有更低的MSE，特别是对于小样本( \\(\\kappa_0 \\in \\{1,2\\}\\)  )。 \\(\\kappa_0= 0\\)  情况下对应于MLE， \\(\\kappa_0= 2\\)  情况对应于强先验，这会损害性能，因为先验均值是错误的。 “调整”先验的强度显然很重要，这是我们稍后讨论的一个主题。\n6.4.4.2 示例：岭回归(ridge regression) 偏差方差权衡的另一个重要例子出现在岭回归中，我们将在7.5节中讨论。 简而言之，这对应于在高斯先验 \\(p(\\boldsymbol{w})=\\mathcal{N}(\\boldsymbol{w} | 0,\\lambda^{-1}\\boldsymbol{I})\\)  下的线性回归的MAP估计。这个零均值先验鼓励小权重，这减少了过度拟合; 精度项 \\(\\lambda\\)  控制该先验的强度。 使用 \\(\\lambda= 0\\)  导致MLE; 使用 \\(\\lambda 0\\)  会导致有偏估计。 为了说明对方差的影响，请考虑一个简单的例子。 图6.5的左边绘制了每条拟合曲线，右边绘制了平均拟合曲线。 我们看到，随着我们增加正则化器的强度，方差减小，但偏差增加。\n6.4.4.3 分类的偏差-方差权衡 如果我们使用0-1损失而不是平方误差，则上述分析会中断，因为频率派风险不再表示为平方偏差加方差。 事实上，可以证明（（Hastie et al.2009）的习题7.2）变成了偏差和方差相乘。 如果估计值位于决策边界的正确一侧，则偏差为负，减小方差将降低误分类率。 但如果估计是在决策边界的错误一侧，则偏差是正的，因此增加方差是值得的（Friedman 1997a）。 这个鲜为人知的事实说明偏差-方差权衡对于分类来说并不是非常有用。 最好关注预期损失（见下文），而不是直接关注偏差和方差。 我们可以使用交叉验证来估计预期损失，正如我们在6.5.3节中讨论的那样。\n返回本章目录\n"}),a.add({id:233,href:'/notes/tags/%E4%BC%B0%E8%AE%A1%E5%99%A8/',title:"估计器",content:""}),a.add({id:234,href:'/notes/tags/%E5%81%8F%E5%B7%AE/',title:"偏差",content:""}),a.add({id:235,href:'/notes/tags/%E5%9D%87%E5%80%BC/',title:"均值",content:""}),a.add({id:236,href:'/notes/tags/%E6%96%B9%E5%B7%AE/',title:"方差",content:""}),a.add({id:237,href:'/notes/docs/mlapp/06frequentist_statistics/0055/',title:"6.3 频率派决策理论",content:"返回本章目录\n在频率派或经典决策理论中，存在一个损失函数和一个拟然，但没有先验因而没有后验或后验预期损失。 因此，与贝叶斯情况不同，没有自动推导出最优估计器的方法。 相反，在频率派方法中，我们可以自由选择我们想要的任何估计器或决策程序   \\(\\delta：\\mathcal{X} \\to \\mathcal{A}\\)  。\n选择估计器后，我们将其预期损失或风险定义如下：\n\\[ R(\\theta^{\\\\*},\\delta)\\overset{\\Delta}{=}\\mathbb{E}_{p(\\tilde{\\mathcal{D}}|\\theta^{\\\\*})}\\left[L(\\theta^{\\\\*},\\delta(\\tilde{\\mathcal{D}}))\\right]=\\int{L(\\theta^{\\\\*},\\delta(\\tilde{\\mathcal{D}}))p(\\tilde{\\mathcal{D}}|\\theta^{\\\\*})d\\tilde{\\mathcal{D}}} \\tag{6.9} \\]  其中 \\(\\tilde{\\mathcal{D}}\\)  是从“自然分布”中采样的数据，其由参数 \\(\\theta^{\\\\*}\\)  表示。 换句话说，期望是关于估计器采样分布的。 将此与贝叶斯后验预期损失进行比较：\n\\[ \\rho(a|\\mathcal{D},\\pi)\\overset{\\Delta}{=}\\mathbb{E}_{p(\\theta|\\mathcal{D},\\pi)}\\left[L(\\theta,a)\\right]=\\int_\\Theta{L(\\theta^{\\\\*},a)p(\\theta|\\mathcal{D},\\pi)d\\theta} \\tag{6.10} \\]  我们看到贝叶斯方法关于 \\(\\theta\\)  均值（未知）和 \\(\\mathcal{D}\\)  上的条件（已知），而频率派方法在 \\(\\tilde{\\mathcal{D}}\\)  上的均值（因此忽略观测到的数据）， \\(\\theta^{\\\\*}\\)  上的条件（未知）。\n频率派不仅定义不自然，甚至无法计算，因为 \\(\\theta^{\\\\*}\\)  未知。 因此，我们无法比较不同的估计器的频率派风险来。 我们将在下面讨论各种解决方案。\n6.3.1 贝叶斯风险 我们如何在估计器中进行选择？ 我们需要一些方法将 \\(R(\\boldsymbol{\\theta}^{\\\\*},\\delta)\\)  转换为一个单独的度量 \\(R(\\delta)\\)  ，要求不依赖于知道 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  。 一种方法是在 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  上放置先验，然后如下定义一个估计器的贝叶斯风险或积分风险(integrated risk)：\n\\[ R_B(\\delta)\\overset{\\Delta}{=}\\mathbb{E}_{p(\\boldsymbol{\\theta}^{\\\\*})}\\left[R(\\boldsymbol{\\theta}^{\\\\*},\\delta)\\right]=\\int{R(\\boldsymbol{\\theta}^{\\\\*},\\delta)p(\\boldsymbol{\\theta}^{\\\\*})d \\boldsymbol{\\theta}^{\\\\*}} \\tag{6.11} \\]  贝叶斯估计器或贝叶斯决策规则是最小化预期风险：\n\\[ \\delta_B \\overset{\\Delta}{=} \\underset{\\delta}{\\rm argmin} \\ R_B(\\delta) \\tag{6.12} \\]  请注意，积分风险也称为预后验风险(pre-posterior risk)，因为它是在我们看到数据之前。 对其进行最小化对于试验设计是有用的。\n我们现在将证明一个非常重要的定理，将贝叶斯和频率派方法与决策理论联系起来。\n定理6.3.1. 可以通过对每个 \\(\\boldsymbol{x}\\)  最小化后验预期损失来获得贝叶斯估计器。\n证明: 通过改变积分顺序，我们有\n\\[ \\begin{aligned} R_B(\\delta)=\u0026 \\int{\\left[\\sum_{\\boldsymbol{x}}{\\sum_y{L(y,\\delta(\\boldsymbol{x}))p(\\boldsymbol{x},y|\\boldsymbol{\\theta}^{*})}}\\right]p(\\boldsymbol{\\theta}^{*})d\\boldsymbol{\\theta}^{*}} \\\\ \\quad = \u0026 \\sum_{\\boldsymbol{x}}{\\sum_y{\\int_\\Theta{L(y,\\delta(\\boldsymbol{x}))p(\\boldsymbol{x},y,\\boldsymbol{\\theta}^{*})d\\boldsymbol{\\theta}^{*}}}} \\\\ \\quad = \u0026 \\sum_{\\boldsymbol{x}}{\\left[\\sum_y{L(y,\\delta(\\boldsymbol{x}))p(y | \\boldsymbol{x})}\\right]p(\\boldsymbol{x})} \\\\ \\quad = \u0026 \\sum_{\\boldsymbol{x}}{\\rho(\\delta(\\boldsymbol{x})|\\boldsymbol{x})p(\\boldsymbol{x})} \\end{aligned} \\tag{6.13-16} \\]  为了最小化整体期望，我们只是最小化每个 \\(\\boldsymbol{x}\\)  对应的内部项，因此我们的决策规则是\n\\[ \\delta_B(\\boldsymbol{x})=\\underset{a\\in\\mathcal{A}}{\\rm argmin} \\ \\rho(a|\\boldsymbol{x}) \\tag{6.17} \\]  因此，我们看到根据具体情况（如贝叶斯方法）选择最优行动是平均最优的（如在频率派方法中）。 换句话说，贝叶斯方法提供了实现频率派目标的好方法。 事实上，人们可以进一步证明以下几点。\n定理6.3.2.（Wald，1950） 每个可接受的决策规则都是关于某些（可能是不正确的）先验分布的贝叶斯决策规则。\n这个定理表明，最小化频率派风险的最好方法是贝叶斯！ 参见（Bernardo和Smith 1994，第448页）进一步讨论这一点。\n6.3.2 最小极大风险 显然，一些频率派的人不喜欢使用贝叶斯风险，因为它需要选择先验（尽管只出现在估计器计算时，不一定是其构造的一部分）。 另一种方法如下。 将估计器的最大风险定义为\n\\[ R_{\\max}(\\delta)\\overset{\\Delta}{=}\\underset{\\boldsymbol{\\theta}^{\\\\*}}{\\max} \\ R(\\boldsymbol{\\theta}^{\\\\*},\\delta) \\tag{6.18} \\]  最小极大规则(minimax rule )是最小化最大风险：\n\\[ \\delta_{MM}\\overset{\\Delta}{=}\\underset{\\delta}{\\rm argmin} \\ R_{\\max}(\\delta) \\tag{6.19} \\]   图6.2 两个决策程序δ1和δ2的风险函数。 由于δ1具有较低的最坏情况风险，因此它是最小极大值估计器，尽管δ2对于大多数θ值具有较低的风险。 因此，极小极大估计器过于保守。\n 例如，在图6.2中，我们看到在 \\(\\theta^{\\\\*}\\)  的所有可能值范围， \\(\\delta_1\\)  的最坏情况风险低于 \\(\\delta_2\\)  ，因此它是最小极大估计器（有关实际模型中如何计算风险函数的解释，请参见第6.3.3.1节）。\n最小极大估计器具有一定的吸引力。 但是，计算它们可能很难。 并且非常悲观。 事实上，人们可以证明所有极小极大估计器都等同于最不利先验(least favorable prior)下的贝叶斯估计器。 在大多数统计情况下（不包括博弈论），假设自然是对手，是一个不合理的假设。\n6.3.3 可接受的估计器(Admissible estimators) 频率派决策理论的基本问题是它依赖知道的真实分布 \\(p(·|\\theta^{\\\\*})\\)  来评估风险。 然而，无论 \\(\\theta^{\\\\*}\\)  的值如何，有些估计器可能比另一些更差。 特别地，如果 \\(R(\\theta,\\delta_1) \\le R(\\theta,\\delta_2), \\forall \\theta \\in \\Theta\\)  ，那么我们说 \\(\\delta_1\\)  支配 \\(\\delta_2\\)  。 如果对 \\(\\theta\\)  ，前述不等式严格成立，那么该支配被认为是严格的。 如果一个估计器不受任何其他估计器的严格支配，则可以认为该估计器是可接受的(admissible)。\n6.3.3.1 示例 让我们举一个例子，基于（Bernardo和Smith 1994）。 考虑估计高斯均值的问题。 我们假设数据是采样自 \\(x_i \\sim \\mathcal{N}(\\theta^{\\\\*},\\sigma^2= 1)\\)  ，并使用二次损失 \\(L(\\theta,\\hat{\\theta})=(\\theta-\\hat{\\theta})^2\\)  。 相应的风险函数是MSE。 一些可能的决策规则或估计器 \\(\\hat{\\theta}(\\boldsymbol{x})=\\delta(\\boldsymbol{x})\\)  如下：\n  \\(\\delta_1(\\boldsymbol{x}) = \\bar{\\boldsymbol{x}}\\)  , 样本均值  \\(\\delta_2(\\boldsymbol{x}) = \\tilde{\\boldsymbol{x}}\\)  , 样本中位数  \\(\\delta_3(\\boldsymbol{x}) = \\theta_0\\)  , 固定值  \\(\\delta_{\\kappa}(\\boldsymbol{x})\\)  , \\(\\mathcal{N}(\\theta|\\theta_0,\\sigma^2/\\kappa)\\)  先验下的后验均值:  \\[ \\delta_{\\kappa}(\\boldsymbol{x})=\\dfrac{N}{N+\\kappa}\\bar{x}+\\dfrac{\\kappa}{N+\\kappa}\\theta_0 = w \\bar{x}+ (1-w)\\theta_0 \\tag{6.20} \\]  对于 \\(\\delta_{\\kappa}\\)  ，我们考虑一个弱先验 \\(\\kappa=1\\)  和更强的先验 \\(\\kappa=1\\)  。先验均值是 \\(\\theta_0\\)  ，一些固定值。 我们假设 \\(\\sigma^2\\)  是已知的。 （因此 \\(\\delta_3(\\boldsymbol{x})\\)  与具有无穷强的先验的 \\(\\delta_{\\kappa}(\\boldsymbol{x}), \\kappa \\to \\infty\\)  相同。）\n现在让我们分析地推导出风险函数。 （我们可以这样做，因为在这个玩具示例中，我们知道真实参数 \\(\\theta^{\\\\*}\\)  。）在6.4.4节中，我们证明了MSE可以分解为平方偏差加方差：\n\\[ {\\rm MSE}(\\hat{\\theta}(\\cdot)|\\theta^{\\\\*})={\\rm var}\\left[\\hat{\\theta}\\right]+{\\rm bias}^2(\\hat{\\theta}) \\tag{6.21} \\]  样本均值是无偏的，因此其风险为:\n\\[ {\\rm MSE}(\\delta_1|\\theta^{\\\\*})={\\rm var}[\\bar{x}]=\\dfrac{\\sigma^2}{N} \\tag{6.22} \\]  样本中位数也是无偏的。 可以证明方差近似为 \\(\\pi/(2N)\\)  ，因此\n\\[ {\\rm MSE}(\\delta_2|\\theta^{\\\\*})=\\dfrac{\\pi}{2N} \\tag{6.23} \\]  对于 \\(\\delta_3(x)=\\theta_0\\)  ，方差为零，因此\n\\[ {\\rm MSE}(\\delta_2|\\theta^{\\\\*})=(\\theta^{\\\\*}-\\theta_0)^2 \\tag{6.24} \\]  最后，对于后验均值，我们有\n\\[ \\begin{aligned} {\\rm MSE}(\\delta_\\kappa|\\theta^{*}) = \u0026 \\mathbb{E}\\left[(w \\bar{x}+(1-w)\\theta_0-\\theta^{*})^2\\right] \\\\ \\quad = \u0026 \\mathbb{E}\\left[(w(\\bar{x}-\\theta^{*})+(1-w)(\\theta_0-\\theta^{*}))^2\\right] \\\\ \\quad = \u0026 w^2\\dfrac{\\sigma^2}{N}+(1-w)^2(\\theta_0-\\theta^{*})^2 \\\\ \\quad = \u0026 \\dfrac{1}{(N+\\kappa)^2}(N\\sigma^2+\\kappa^2(\\theta_0-\\theta^{*})^2) \\end{aligned} \\tag{6.25-28} \\]  对于 \\(N \\in \\{5,20\\}\\)  ，这些函数绘制在图6.3中。 我们看到，一般来说，最佳估计器取依于 \\(\\theta^{\\\\*}\\)  的值，这是未知的。 如果非常 \\(\\theta^{\\\\*}\\)  接近 \\(\\theta_0\\)  ，则 \\(\\delta_3\\)  （仅预测 \\(\\theta_0\\)  ）最佳。 如果 \\(\\theta^{\\\\*}\\)  在 \\(\\theta_0\\)  附近的某个合理范围内，那么将 \\(\\theta_0\\)  的先验猜测与实际数据相结合的后验均值是最佳的。 如果 \\(\\theta^{\\\\*}\\)  远离 \\(\\theta_0\\)  ，则MLE最佳。 这一点都不应该令人惊讶：假设我们的先验均值是合理的，通常需要少量收缩（使用具有弱先验的后验均值）。\n 图6.3 估计采样自 \\(\\mathcal{N}(\\theta^{\\\\*},\\sigma^2= 1)\\)  的高斯均值的风险函数。 实心深蓝色水平线是MLE，当κ= 5时，实心浅蓝色曲线是后验均值。左：N = 5个样本。 右：N = 20个样本。 基于图B.1（Bernardo和Smith 1994）。 由_riskFnGauss_生成的图。\n 更令人惊讶的是，对于 \\(\\theta^{\\\\*}\\)  的每个值，决策规则 \\(\\delta_2\\)  （样本中位数）的风险总是高于 \\(\\delta_1\\)  （样本均值）的风险。 因此，针对该特定问题（假设数据来自高斯）, 样本中位数是不可接受的估计器。\n在实践中，样本中位数通常优于样本均值，因为它对异常值更加稳健。 如果我们假设数据来自拉普拉斯分布，其尾部比高斯分布更重，那么可以证明（Minka 2000d）中位数是贝叶斯估计器（在平方损失之下）。 更一般地，我们可以通过使用我们数据的灵活模型（例如混合模型或非参数密度估计器（第14.7.2节））构建稳健(鲁棒)估计器，然后计算后验均值或中位数。\n6.3.3.2 Stein悖论* 假设我们有N个iid随机变量 \\(X_i \\sim \\mathcal{N}(\\theta_i,1)\\)  ，我们想估计 \\(\\theta_i\\)  。 明显的估计是MLE，在这种情况下设置 \\(\\hat{\\theta}_i= x_i\\)  。 事实证明，当 \\(N \\ge 4\\)  时，这是二次损失下的不可接受的估计器。\n为了证明这一点，只要构建一个更好的估计器就足够了。 James-Stein估计器就是这样一个估计器，定义如下：\n\\[ \\hat{\\theta}_i=\\hat{B}\\bar{x}+(1-\\hat{B})x_i=\\bar{x}+(1-\\hat{B})(x_i-\\bar{x}) \\tag{6.29} \\]  其中 \\(\\bar{x} = \\dfrac{1}{N}\\sum_{i=1}^N{x_i}\\)  ，并且 \\(0 \\le B \\le 1\\)  是调节常数。 该估计将 \\(\\theta_i\\)  “收缩”到整体均值。 （我们在5.6.2节中使用经验贝叶斯方法推导出这个估计器。）\n可以证明，对于N≥4，这种收缩估计器比MLE（样本均值）有更低的频率派风险（MSE）。这被称为Stein悖论。 下面的例子说明了它被称为悖论的原因。 假设 \\(\\theta_0\\)  是学生 \\(i\\)  的“真实”智商，而 \\(X_i\\)  是他的考试成绩。 为什么我对 \\(\\theta_i\\)  的估计值依赖全局均值 \\(\\bar{x}\\)  ，进而依赖于他学生的分数？ 通过使不同维度不同量上的差异，可以构建更多自相矛盾的例子，例如， \\(\\theta_1\\)  是我的智商， \\(\\theta_2\\)  是温哥华的平均降雨量等。\n悖论的解决方案如下。 如果你的目标只是估计 \\(\\theta_i\\)  ，你不能比使用 \\(x_i\\)  更好，但如果目标是估计整个矢量 \\(\\boldsymbol{\\theta}\\)  ，并且你使用平方误差作为你的损失函数，那么收缩就会有所帮助。 为了看到这一点，假设我们想要从单个样本 \\(\\boldsymbol{x} \\sim \\mathcal{N}(\\boldsymbol{\\theta},\\boldsymbol{I})\\)  估计 \\(\\|\\boldsymbol{\\theta}\\|_2^2\\)  。 一个简单的估计是 \\(\\|\\boldsymbol{x}\\|_2^2\\)  ，但这会高估结果，因为\n\\[ \\mathbb{E}[\\|x\\|_2^2]=\\mathbb{E}\\left[\\sum_i{x_i^2}\\right]=\\sum_{i=1}^N{1+\\theta_i^2}=N+\\|\\boldsymbol{\\theta}\\|_2^2 \\tag{6.30} \\]  因此，我们可以通过汇集信息来降低风险，甚至可以从不相关的来源汇集信息，并缩小到整体均值。 在5.6.2节中，我们给出了贝叶斯的解释。 另见（Efron和Morris 1975）。\n6.3.3.3 可接受还是不够的 很明显，我们可以将我们对良好估计器的搜索限制在可接受的估计器类中。 但事实上，构建可接受的估计量很容易，如下例所示。\n定理6.3.3. 设 \\(X \\sim \\mathcal{N}(\\theta, 1)\\)  ，并考虑在平方损失下估计 \\(\\theta\\)  。 设 \\(\\delta_1(x)=\\theta_0\\)  是与数据无关的常数。 这就是一个可接受的估计器。\n证明: 假设不对。 那么还有一些其他估计器 \\(\\delta_2\\)  具有较小的风险，因此 \\(R(\\theta^{\\\\*},\\delta_2) \\le R(\\theta^{\\\\*},\\delta_1)\\)  ，其中不等式必须对某些 \\(\\theta^{\\\\*}\\)  是严格的。 设真实参数是 \\(\\theta^{\\\\*} =\\theta_0\\)  。 于是 \\(R(\\theta^{\\\\*},\\delta_1)=0\\)  ，并且\n\\[ R(\\theta^{\\\\*},\\delta_2)=\\int{(\\delta_2(x)-\\theta_0)^2p(x|\\theta_0)dx} \\tag{6.31} \\]  由于 \\(0 \\le R(\\theta^{\\\\*},\\delta_2) \\le R(\\theta^{\\\\*},\\delta_1)\\)  ，并且 \\(R(\\theta^{\\\\*},\\delta_1)= 0\\)  ，因此我们得到 \\(R(\\theta^{\\\\*},\\delta_2)= 0\\)  ，进而 \\(\\delta_2(x)= \\theta_0=\\delta_1(x)\\)  。 因此，在某个特定点 \\(\\theta_0\\)  ， \\(\\delta_2\\)  可以避免比 \\(\\delta_1\\)  具有更高风险的唯一方法是等于 \\(\\delta_1\\)  。 因此，没有其他估计器 \\(\\delta_2\\)  具有严格较低的风险，因此 \\(\\delta_2\\)  是可接受的。\n返回本章目录\n"}),a.add({id:238,href:'/notes/tags/%E5%86%B3%E7%AD%96%E8%A7%84%E5%88%99/',title:"决策规则",content:""}),a.add({id:239,href:'/notes/tags/%E6%82%96%E8%AE%BA/',title:"悖论",content:""}),a.add({id:240,href:'/notes/docs/mlapp/06frequentist_statistics/0054/',title:"6.2 估计器的采样分布",content:"返回本章目录\n在频率派统计中，通过将估计器   \\(\\delta\\)  应用在某些数据 \\(\\mathcal{D}\\)  来计算参数估计 \\(\\hat{\\boldsymbol{\\theta}}\\)  ，因此 \\(\\hat{\\boldsymbol{\\theta}}=δ(\\mathcal{D})\\)  。 该参数被视为固定的，并且数据被视为随机的，这与贝叶斯方法完全相反。 可以通过计算估计器的采样分布来测量参数估计的不确定性。 为了理解这个概念，想象从一些真实模型 \\(p(·|\\boldsymbol{\\theta}^*)\\)  中采样许多不同的数据集 \\(\\mathcal{D}^{(s)}\\)  ，即让 \\(\\mathcal{D}^{(s)}= \\left\\{x_i^{(s)}\\right\\}_{i=1}^N\\)  ，其中 \\(x_i^s \\sim p(·|\\boldsymbol{\\theta}^*)\\)  ， \\(\\boldsymbol{\\theta}^*\\)  是真实参数。 这里 \\(s = 1:S\\)  已采样数据集的索引， \\(N\\)  是每个这样的数据集的大小。 现在将估计器 \\(\\hat{\\theta}(·)\\)  应用到每个 \\(\\mathcal{D}^{(s)}\\)  以获得一组估计 \\(\\{\\hat{\\boldsymbol{\\theta}}(\\mathcal{D}^{(s)})\\}\\)  。 当我们让 \\(S\\to \\infty\\)  时，在 \\(\\hat{\\theta}(·)\\)  上诱导的分布就是估计器的采样分布。 我们将在后面的章节中讨论使用采样分布的各种方法。 但首先我们描绘了两种计算采样分布本身的方法。\n6.2.1 自举(Bootstrap)  图6.1 对伯努利分布的 \\(\\hat{\\theta}\\)  的采样分布的自举近似。 我们使用 \\(B = 10000\\)  个自举样本。 N个数据库由 \\({\\rm Ber}(\\theta= 0.7)\\)  生成。 （a） \\(N = 10\\)  的MLE。（b） \\(N = 100\\)  的MLE。由_bootstrapDemoBer_生成的图。\n 自举(Bootstrap)是一种简单的蒙特卡罗技术，用于近似采样分布。 这在估计器是真实参数的复杂函数的情况下特别有用。\n这个想法很简单。 如果我们知道真实参数 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  ，我们可以从真实分布生成许多（比如S个）假数据集，每个大小都为 \\(N\\)  ，即 \\(x_i^s \\sim p(·|\\boldsymbol{\\theta}^{\\\\*}), s=1:S,i=1:N\\)  。然后，我们可以从每个样本计算我们的估计量 \\(\\hat{\\boldsymbol{\\theta}}^s= f(x_{1:N}^s)\\)  ，并使用所得样本的经验分布作为我们对采样分布的估计。 由于 \\(\\boldsymbol{\\theta}\\)  未知，参数自举(parametric bootstrap)的思想是使用 \\(\\hat{\\boldsymbol{\\theta}}(\\mathcal{D})\\)  作为替代来生成样本。 另一种称为非参数自举(non-parametric bootstrap)的方法是从原始数据 \\(\\mathcal{D}\\)  中采样 \\(x_i^s\\)  （替换），然后像以前一样计算诱导分布。 在（Kleiner等人，2011）中讨论了一些在应用于海量数据集时加速自举的方法。\n图6.1展示了一个示例，我们使用参数自举来计算伯努利的MLE采样分布。 （使用非参数自举的结果基本相同。）当N = 10时，我们看到采样分布是不对称的，因此离高斯相当远; 当N = 100时，分布看起来更高斯，正如理论所暗示的那样（见下文）。\n一个自然的问题是：由自举计算的参数估计值 \\(\\hat{\\boldsymbol{\\theta}}^s=\\hat{\\boldsymbol{\\theta}}(x_{1:N}^s)\\)  与从后验采样的参数值 \\(\\boldsymbol{\\theta}^s \\sim p(·| \\mathcal{D})\\)  之间的关系是什么？ 从概念上讲，它们完全不同。 但在常见的情况下，先验不是很强，它们可能非常相似。 例如，图6.1（c-d）展现的一个例子，我们使用均匀的 \\({\\rm Beta}(1,1)\\)  先验计算后验，然后从中进行采样。 我们看到后验和采样分布非常相似。 因此，人们可以将自举分布视为“穷人”的后验; 有关详细信息，请参阅（Hastie等，2001，第235页）。\n然而，也许令人惊讶的是，自举可能比后验采样慢。 原因是自举必须拟合模型S次，而在后验采样中，我们通常只拟合模型一次（找到局部众数），然后围绕众数进行局部探索。 这种局部探索通常比从头开始拟合模型快得多。\n6.2.2 MLE的大样本理论* 在某些情况下，可以分析地计算某些估计器的采样分布。 特别是，可以证明，在某些条件下，当样本大小趋于无穷大时，MLE的采样分布变为高斯分布。 非正式地，对此结果的要求是模型中的每个参数都“看到”无限量的数据，并且模型是可识别的。 不幸的是，这排除了许多对机器学习感兴趣的模型。 然而，让我们假设我们处于定理所在的简单环境中。\n高斯的中心将是MLE \\(\\hat{\\boldsymbol{\\theta}}\\)  。 但是这个高斯的方差呢？ 直观地，估计器的方差将（相反地）与可能性表面在其峰值处的曲率量相关。 如果曲率很大，峰值将“尖锐”，方差低; 在这种情况下，估计是“很好地确定”。 相反，如果曲率很小，峰值将几乎“平坦”，因此方差很高。\n现在让我们正式化这种直觉。 将得分函数定义为在某点 \\(\\hat{\\boldsymbol{\\theta}}\\)  计算的对数似然梯度：\n\\[ s(\\hat{\\boldsymbol{\\theta}})\\overset{\\Delta}{=}\\left.\\nabla \\log p(\\mathcal{D}|\\boldsymbol{\\theta})\\right|_{\\hat{\\boldsymbol{\\theta}}} \\tag{6.1} \\]  将观察到的信息矩阵(observed information matrix)定义为得分函数的负梯度，或等效地，NLL的Hessian：\n\\[ \\boldsymbol{J}(\\hat{\\boldsymbol{\\theta}}|\\mathcal{D})\\overset{\\Delta}{=}-\\nabla s(\\hat{\\boldsymbol{\\theta}})=-\\left.\\nabla_{\\boldsymbol{\\theta}}^2 \\log p(\\mathcal{D}|\\boldsymbol{\\theta})\\right|_{\\hat{\\boldsymbol{\\theta}}} \\tag{6.2} \\]  在1维情况下, 上式变成\n\\[ J(\\hat{\\theta}|\\mathcal{D})=-\\left.\\dfrac{d^2}{d\\theta^2} \\log p(\\mathcal{D}|\\theta)\\right|_{\\hat{\\theta}} \\tag{6.3} \\]  这只是 \\(\\hat{\\theta}\\)  处对数似然函数曲率的度量。\n由于我们正在研究采样分布，因此 \\(\\mathcal{D} =(\\boldsymbol{x}_1,\\dots,\\boldsymbol{x}_N)\\)  是一组随机变量。 Fisher信息矩阵被定义为观察到的信息矩阵的预期值：\n\\[ \\boldsymbol{I}_N(\\hat{\\boldsymbol{\\theta}|\\boldsymbol{\\theta}^{\\\\*}})\\overset{\\Delta}{=}\\mathbb{E}_{\\boldsymbol{\\theta}^{\\\\*}}\\left[\\boldsymbol{J}(\\hat{\\boldsymbol{\\theta}}|\\mathcal{D})\\right] \\tag{6.4} \\]  其中 \\(\\mathbb{E}_{\\boldsymbol{\\theta}^{\\\\*}} [\\boldsymbol{f}(\\mathcal{D})]\\overset{\\Delta}{=} \\frac{1}{N}\\sum_{i=1}^N{ \\boldsymbol{f}(\\boldsymbol{x}_i)p(\\boldsymbol{x}_i | \\boldsymbol{\\theta}^{\\\\*})}\\)  是当应用于从 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  采样的数据的函数 \\(\\boldsymbol{f}\\)  的期望值。 通常 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  表示生成数据的“真实参数”，被假设为已知，因此我们只写更短的形式 \\(\\boldsymbol{I}_N(\\hat{\\boldsymbol{\\theta}})\\overset{\\Delta}{=}\\boldsymbol{I}_N(\\hat{\\boldsymbol{\\theta}}|\\boldsymbol{\\theta}^{\\\\*})\\)  。 此外，很容易看出 \\(\\boldsymbol{I}_N(\\hat{\\boldsymbol{\\theta}})=N \\boldsymbol{I}_1(\\hat{\\boldsymbol{\\theta}})\\)  ，因为大小为N的样本的对数似然仅比大小为1的样本的对数似然的“陡” \\(N\\)  倍。所以我们 可以删除1下标，只写 \\(\\boldsymbol{I}(\\hat{\\boldsymbol{\\theta}})\\overset{\\Delta}{=}\\boldsymbol{I}_1(\\hat{\\boldsymbol{\\theta}})\\)  。 这是通常使用的符号。\n现在让 \\(\\hat{\\boldsymbol{\\theta}}\\overset{\\Delta}{=}\\hat{\\boldsymbol{\\theta}}_{\\rm mle}(\\mathcal{D})\\)  为MLE，其中 \\(\\mathcal{D} \\sim \\boldsymbol{\\theta}^{\\\\*}\\)  。 可以证明\n\\[ \\hat{\\boldsymbol{\\theta}} \\to \\mathcal{N}(\\boldsymbol{\\theta}^{\\\\*},\\boldsymbol{I}(\\boldsymbol{\\theta}^{\\\\*})^{-1}) \\tag{6.5} \\]  当 \\(N\\to \\infty\\)  （参见例如（Rice 1995，p265）作为证据）。 我们说MLE的采样分布是渐近正态的(asymptotically normal)。\nMLE的方差(可用来衡量MLE的信任度)怎么样呢？ 不幸的是， \\(\\boldsymbol{\\theta}^{\\\\*}\\)  是未知的，因此我们无法评估采样分布的方差。 但是，我们可以通过用 \\(\\hat{\\boldsymbol{\\theta}}\\)  代替 \\(\\boldsymbol{\\theta}^{\\\\*}\\)  来近似采样分布。 因此， \\(\\hat{\\theta}_k\\)  的近似标准误差(standard errors )由下式给出\n\\[ \\hat{\\rm se}_k\\overset{\\Delta}{=}\\boldsymbol{I}_N(\\hat{\\boldsymbol{\\theta}})_{kk}^{-\\frac{1}{2}} \\tag{6.6} \\]  例如，根据公式5.60，我们知道二项采样模型的Fisher信息是\n\\[ I(\\theta)=\\dfrac{1}{\\theta(1-\\theta)} \\tag{6.7} \\]  因此，MLE的近似标准误差是\n\\[ \\hat{\\rm se}_k=\\dfrac{1}{\\sqrt{I_N(\\hat{\\theta})}}=\\dfrac{1}{\\sqrt{N I(\\hat{\\theta})}}=\\sqrt{\\dfrac{\\hat{\\theta}(1-\\hat{\\theta})}{N}} \\tag{6.8} \\]  其中 \\(\\hat{\\theta}= \\frac{1}{N}\\sum_i{X_i}\\)  。 将其与公式3.27进行比较，公式3.27是均匀先验下的后验标准差。\n返回本章目录\n​\n"}),a.add({id:241,href:'/notes/tags/%E5%A4%A7%E6%A0%B7%E6%9C%AC/',title:"大样本",content:""}),a.add({id:242,href:'/notes/tags/%E8%87%AA%E4%B8%BE/',title:"自举",content:""}),a.add({id:243,href:'/notes/tags/%E9%87%87%E6%A0%B7%E5%88%86%E5%B8%83/',title:"采样分布",content:""}),a.add({id:244,href:'/notes/docs/mlapp/06frequentist_statistics/0053/',title:"6.1 导论",content:"返回本章目录\n我们在第5章中描述的统计推断方法称为贝叶斯统计。 也许令人惊讶的是，这被一些人认为是有争议的，而贝叶斯应用于非统计问题 - 例如医疗诊断（第2.2.3.1节），垃圾邮件过滤（第3.4.4.1节）或飞机跟踪（第18.2.1节）。 - 没有争议。 反对的原因与统计模型的参数和其他类型的未知量之间的误导性区别有关。\n已经尝试设计统计推断方法，避免处理随机变量等参数，从而避免使用先验和贝叶斯规则。 这种方法被称为频率派统计，经典统计或正统统计。 它们不是基于后验分布，而是基于抽样分布的概念。 这是估计器应用于采样自真实但未知分布的多个数据集时的分布; 详见6.2节。 正是这种反复试验的变异概念构成了频率派方法所使用的不确定性建模的基础。\n相比之下，在贝叶斯方法中，我们只对实际观察到的数据进行调整; 没有反复试验的概念。 这允许贝叶斯计算一次性事件的概率，正如我们在2.1节中讨论的那样。 也许更重要的是，贝叶斯方法避免了困扰频率派方法的某些悖论（见第6.6节）。 然而，熟悉频率派统计（尤其是第6.5节）非常重要，因为它广泛用于机器学习。\n返回本章目录\n"}),a.add({id:245,href:'/notes/docs/mlapp/06frequentist_statistics/',title:"第六章 频率派统计",content:"第六章 频率派统计 本节中的目录：\n  6.1 导论\n  6.2 估计器的采样分布\n  6.3 频率派决策理论\n  6.4 估计器的理想属性\n  6.5 经验风险最小化\n  6.6 频率派统计的病态*\n  习题\n  "}),a.add({id:246,href:'/notes/tags/%E7%BB%9F%E8%AE%A1/',title:"统计",content:""}),a.add({id:247,href:'/notes/docs/mlapp/05bayesian_statistics/0052/',title:"习题",content:"返回本章目录\n习题5.1 证明共轭先验的混合确实是共轭的\n推导等式5.69.\n习题5.2 分类概率的最佳阈值\n考虑我们已经学到了条件概率分布   \\(P(y|\\boldsymbol{x})\\)  的情况。 假设只有两个类，并且令 \\(p_0 = P(Y = 0 | \\boldsymbol{x})\\)  并且 \\(p_1 = P(Y = 1 | \\boldsymbol{x})\\)  。 考虑下面的损失矩阵：\n   预测标签 \\(\\hat{y}\\)  \\(\\Downarrow\\)  真值标签 \\(y\\)  \\(\\Rightarrow\\)   0 1     0 0 \\(\\lambda_{01}\\)     1 \\(\\lambda_{10}\\)   0     a. 最小化预期损失的决策 \\(\\hat{y}\\)  等价于设定概率阈值 \\(\\theta\\)  并且如果 \\(p_1 则预测 \\(\\hat{y} = 0\\)  并且如果 \\(p_1\\le \\theta\\)  则预测 \\(\\hat{y} = 1\\)  。 那么 \\(\\theta\\)  作为 \\(\\lambda_{01}\\)  和 \\(\\lambda_{10}\\)  的函数是什么？（展现你的工作。） b. 展现阈值为0.1的损失矩阵。 （展现你的工作。）  习题5.3 分类中的拒绝选项\n（来源：（Duda et al.2001，Q2.13）。）\n在许多分类问题中，可以选择将 \\(\\boldsymbol{x}\\)  分配给 \\(j\\)  类，或者如果你太不确定，可以选择拒绝选项。 如果拒绝的成本低于错误对对象进行分类的成本，则可能是最佳操作。 设 \\(\\alpha_i\\)  表示你选择动作 \\(i, i = 1:C+1\\)  ，其中 \\(C\\)  是类的数量， \\(C + 1\\)  是拒绝动作。 设 \\(Y = j\\)  是真的（但未知）的自然状态。 确定损失函数如下\n\\[ \\lambda(\\alpha_i|Y=j)=\\left\\{ \\begin{aligned} 0\\quad \u0026 if \\quad i=j \\ and \\ i,j \\in \\{1,\\dots,C\\} \\\\ \\lambda_r \\quad \u0026 if \\quad i=C+1 \\\\ \\lambda_s \\quad \u0026 otherwise \\end{aligned} \\right. \\tag{5.122} \\]  换句话说，如果您正确分类，则会导致0损失，如果您选择拒绝选项，则会产生 \\(\\lambda_r\\)  损失（成本），如果您发生替换错误（错误分类），则会导致 \\(\\lambda_s\\)  损失（成本）。\n权衡，人们需要使用某种“货币”来比较不同的行动方式。保险公司一直这样做。斯坦福大学决策理论家罗斯·沙克特（Ross Schachter）喜欢讲述一个学校董事会的故事，他拒绝了一项关于从学校清除石棉的研究，因为它进行了一项成本效益分析，被认为是“不人道”的，因为他们为孩子的健康付出了美元价值; 拒绝报告的结果是石棉没有被移除，这肯定更“不人道”。在医学领域，人们通常用QALY或质量调整的生命年来衡量效用，而不是美元，但这是相同的想法。当然，即使您没有明确说明您对不同人的生活有多重视，您的行为也会揭示您的隐含价值/偏好，然后可以将这些偏好转换为实际值，例如美元或QALY。从行为推断效用函数称为逆强化学习(inverse reinforcement learning)。\n a. 如果 \\(p(Y=j|\\boldsymbol{x})\\ge p(Y = k | \\boldsymbol{x}), \\forall k\\)  (即, \\(j\\)  是最可能的类)，并且 \\(p(Y=j|\\boldsymbol{x}) \\ge 1 - \\frac{\\lambda_r}{\\lambda_s}\\)  ，于是可确定 \\(Y=j\\)  。 请你展示如果可以这样则可获得最小风险; 否则我们决定拒绝。 b. 定性地描述当从 \\(\\frac{\\lambda_r}{\\lambda_s}\\)  从0增加到1时发生的情况（即，拒绝的相对成本增加）。  习题5.4 更多拒绝选项\n在许多应用程序中，分类器被允许“拒绝”测试示例，而不是将其分类到其中一个类中。 例如，考虑一个错误分类的成本是10美元的情况，但是人工手动做出决定的成本仅为3美元。 我们可以将其表示为以下损失矩阵：\n   \\(\\hat{y} \\Downarrow\\)  \\(y \\Rightarrow\\)   0 1     0 0 10   1 10 0   拒绝 3 3     a. 假设 \\(P((y = 1|\\boldsymbol{x})\\)  预计是0.2。 那么最小期望损失的决策是那个? b. 现在假设 \\(P((y = 1|\\boldsymbol{x})=0.4\\)  。那么现在最小期望损失的决策是那个? c. 一般来说，对于这个同样的损失矩阵，但对于任何后验分布而言，都会有两个阈值 \\(\\theta_0\\)  和 \\(\\theta_1\\)  ，这样最优决策是：如果 \\(p_1 ，则预测为0；如果 \\(\\theta_0 \\le p_1 \\le \\theta_1\\)  ，则拒绝；如果 \\(p_1 \\ge \\theta_1\\)  ，则预测为1（其中, \\(p_1 = p(y = 1 | \\boldsymbol{x})\\)  ）。 这些阈值应该是多少？  习题5.5 报童问题\n考虑决策理论/经济学中的以下经典问题。 假设您正在尝试确定某些产品（例如报纸）的购买量Q以最大化您的利润。 最佳金额将取决于您认为您的产品需求量D，以及您的成本C和销售价格P。假设D未知但具有pdf \\(f(\\mathcal{D})\\)  和cdf \\(F(\\mathcal{D})\\)  。 我们可以通过考虑两种情况来评估预期的利润：如果 \\(D Q\\)  ，那么我们可卖掉所有的Q，并且得到利润 \\(\\pi=(P - C) Q\\)  ; 但如果 \\(D \\lt Q\\)  ，我们只卖出D，获得利润 \\((P - C) D\\)  ，但在未售出部分上浪费了 \\(C(Q-D)\\)  。 因此，如果我们购买量Q，预期的利润是\n\\[ \\mathbb{E} \\ \\pi(Q) = \\int_Q^\\infty{(P-C)Qf(D)dD} + \\int_0^Q{(P-C)Df(D)dD}-\\int_0^Q{C(Q-D)f(D)dD} \\tag{5.123} \\]  简化此表达式，然后利用Q的导数来获得最佳数量Q *（最大化预期利润）满足\n\\[ F(Q^*)=\\dfrac{P-C}{P} \\tag{5.124} \\]  习题5.6 贝叶斯因子和ROC曲线\n设 \\(B = p(D | H_1)/ p(D | H_0)\\)  是有利于模型1的贝叶斯因子。假设我们绘制两条ROC曲线，一条通过阈值B计算，另一条通过阈值处理 \\(p(H_1 | D)\\)  计算 。 他们会是相同还是不同？ 请解释为什么？\n习题5.7 贝叶斯模型平均有助于预测准确性\n设 \\(\\Delta\\)  是我们想要预测的量，这 \\(\\mathcal{D}\\)  为观测数据， \\(\\mathcal{M}\\)  为有限的模型集。 假设为我们的动作是提供概率性预测 \\(p(.)\\)  ，并且损失函数是 \\(L(\\Delta,p(.))= - \\log p(\\Delta)\\)  。 我们可以执行贝叶斯模型平均并使用下式进行预测\n\\[ p^{\\rm BMA}(\\Delta)=\\sum_{m\\in\\mathcal{M}}{p(\\Delta|m,\\mathcal{D})p(m|\\mathcal{D})} \\tag{5.125} \\]  或者, 我们能使用任何一个单模型进行预测(插入近似)\n\\[ p^m(\\Delta)=p(\\Delta|m,\\mathcal{D}) \\tag{5.126} \\]  证明，对于所有模型 \\(m\\in \\mathcal{M}\\)  ，使用BMA的后验预期损失较低，即\n\\[ \\mathbb{E}\\left[L(\\Delta,p^{\\rm BMA})\\right] \\le \\mathbb{E}\\left[L(\\Delta,p^m)\\right] \\tag{5.127} \\]  对 \\(\\Delta\\)  的期望是相对于\n\\[ p(\\Delta|\\mathcal{D})=\\sum_{m\\in \\mathcal{M}}{p(\\Delta|m,\\mathcal{D})p(m|\\mathcal{D})} \\tag{5.128} \\]  提示：使用非负的KL散度。\n习题5.8 用于二维离散分布的MLE和模型选择\n(来源: Jaakkola.)\n设 \\(x\\in \\{0,1\\}\\)  表示抛硬币的结果（反面 \\(x = 0\\)  ，正面 \\(x = 1\\)  ）。 硬币可能存在偏差，因此头部的概率为 \\(\\theta_1\\)  。假设其他人观察硬币并向您报告结果 \\(y\\)  。 但是这个人不可靠，只能用概率 \\(\\theta_2\\)  正确地报告结果; 即 \\(p(y | x,\\theta_2)\\)  由下式给出\n    \\(y=0\\)   \\(y=1\\)       \\(x=0\\)   \\(\\theta_2\\)   \\(1-\\theta_2\\)     \\(x=1\\)   \\(1-\\theta_2\\)   \\(\\theta_2\\)      假设 \\(\\theta_2\\)  与 \\(x\\)  和 \\(\\theta_1\\)  无关。\n a. 以2×2表格的方式写下联合概率分布 \\(p(x，y |\\boldsymbol{\\theta})\\)  ，其中 \\(\\boldsymbol{\\theta}=(\\theta_1,\\theta_2)\\)  。 b. 假设有以下数据集： \\(\\boldsymbol{x} =(1,1,0,1,1,0,0), \\boldsymbol{y} =(1,0,0,0,1,0,1)\\)  。 \\(\\theta_1\\)  和 \\(\\theta_2\\)  的MLE是多少？ 证明你的答案。 提示：请注意似然函数因子，  \\[ p(x,y | \\boldsymbol{\\theta})=p(y|x,\\theta_2)p(x|\\theta_1) \\tag{5.129} \\]  ​ \\(p(\\mathcal{D} | \\hat{\\boldsymbol{\\theta}}, M_2)\\)  是什么？其中 \\(M_2\\)  表示一个2参数模型。 （如果您愿意，可以以分数形式留下您的答案。）\n c. 现在考虑具有4个参数的模型， \\(\\boldsymbol{\\theta}=(\\theta_{00},\\theta_{01},\\theta_{10},\\theta_{11})\\)  ，表示 \\(p(x，y |\\boldsymbol{\\theta})=θ_{xy}\\)  。 （这些参数中只有3个是可以自由变化的，因为它们总和必须为1。） \\(\\boldsymbol{\\theta}\\)  的MLE是多少？ \\(p(\\mathcal{D} |\\boldsymbol{\\theta},M_4)\\)  是什么？ 其中 \\(M_4\\)  表示一个4参数模型。 d. 假设我们不确定哪种模型是正确的。 我们计算2参数模型和4参数模型的留一交叉验证对数似然如下：  \\[ L(m)=\\sum_{i=1}^n{\\log p (x_i,y_i|m,\\hat{\\theta}(\\mathcal{D}_{-i}))} \\tag{5.130} \\]  ​ 并且 \\(\\hat{\\theta}(\\mathcal{D}_{-i})\\)  表示在排除第 \\(i\\)  行的 \\(\\mathcal{D}\\)  上计算的MLE。 CV选择哪模型？为什么？ 提示：注意当您一次省略一个训练样本时，计数表如何变化。\n e. 回想一下CV的替代方案是使用BIC得分，定义为  \\[ {\\rm BIC}(M,\\mathcal{D})\\overset{\\Delta}{=} \\log p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}}_{\\rm MLE})-\\dfrac{{\\rm dof}(M)}{2} \\log N \\tag{5.131} \\]  ​ 其中 \\({\\rm dof}(M)\\)  是模型中自由参数的数量，计算两个模型的BIC分数（使用基于e的 \\(\\log\\)  ）。 BIC更喜欢哪种模型？\n习题5.9 后验中位数是 \\(L_1\\)  损失下的最佳估计值\n证明后验中位数是 \\(L_1\\)  损失下的最优估计。\n习题5.10 FP和FN权衡的决策规则\n如果 \\(L_{\\rm FN} = c L_{\\rm FP}\\)  ，证明我们应该选择 \\(\\hat{y} = 1\\)  当且仅当 \\(p(y = 1 | \\boldsymbol{x})/ p(y = 0 | \\boldsymbol{x})\\tau\\)  ，其中 \\(\\tau= c /(1+c)\\)  返回本章目录\n"}),a.add({id:248,href:'/notes/docs/mlapp/05bayesian_statistics/0051/',title:"5.7 贝叶斯决策理论",content:"返回本章目录\n我们已经看到概率论如何用来表示和更新我们对世界状况的信念( beliefs)。 然而，最终我们的目标是将我们的信念转化为行动。 在本节中，我们将讨论实现此目的的最佳方法。\n我们可以将任何给定的统计决策问题形式化为对抗自然的游戏（与针对其他战略玩家的游戏相反，这是游戏理论的主题，参见例如（Shoham和Leyton-Brown 2009）的细节）。 在这个游戏中，大自然选择一个状态或参数或标签   \\(y\\in \\mathcal{Y}\\)  ，这对我们是未知的，然后生成一个观察， \\(x\\in \\mathcal{X}\\)  ，这是我们可看到的。 然后我们必须做出决策，也就是说，我们必须从某个动作空间(action space) \\(\\mathcal{A}\\)  中选择一个动作。 最后，我们会产生一些损失 \\(L(y,a)\\)  ，它衡量我们的行为与自然隐藏状态 \\(y\\)  的相容程度。 例如，我们可能会使用错误分类损失 \\(L(y,a)= \\mathbb{I}(y\\ne a)\\)  或平方损失 \\(L(y,a)=(y-a)^2\\)  。我们将在下面看到其他一些例子。\n我们的目标是设计一个决策程序或策略 \\(\\delta:\\mathcal{X} \\to \\mathcal{A}\\)  ，它规定了每种可能输入的最佳行动。 这个最佳，意思是最小化预期损失的行为：\n\\[ \\delta(\\boldsymbol{x}) = \\underset{a \\in \\mathcal{A}}{\\rm argmin} \\ \\mathbb{E}[L(y,a)] \\tag{5.96} \\]  在经济学中，谈论效用函数更为常见; 这只是负损失， \\(U(y,a)= - L(y,a)\\)  。 因此，上述规则成为\n\\[ \\delta(\\boldsymbol{x}) = \\underset{a \\in \\mathcal{A}}{\\rm argmax} \\ \\mathbb{E}[U(y,a)] \\tag{5.97} \\]  这被称为最大期望效用原则，是我们理性行为的本质。\n请注意，我们对“预期”的含义有两种不同的解释。 在我们下面讨论的贝叶斯版本中，我们指的是给定我们目前所见数据的 \\(y\\)  的预期值。 在我们在6.3节讨论的频率论版本中，我们指的是我们期望在未来看到的 \\(y\\)  和 \\(\\boldsymbol{x}\\)  的期望值。\n在贝叶斯决策理论方法中，已经观察到 \\(\\boldsymbol{x}\\)  下的最优作用被定义为最小化后验预期损失的动作 \\(a\\)  ：\n\\[ \\rho(a|\\boldsymbol{x}) \\overset{\\Delta}{=} \\mathbb{E}_{p(y|\\boldsymbol{x})} [L(y,a)] = \\sum_y{L(y,a)p(y|\\boldsymbol{x})} \\tag{5.98} \\]  （如果 \\(y\\)  是连续的（例如，当我们想要估计参数向量时），我们应该用积分替换和。）因此贝叶斯估计量，也称为贝叶斯决策规则，由下式给出：\n\\[ \\delta(\\boldsymbol{x}) = \\underset{a\\in \\mathcal{A}}{\\rm argmin} \\ \\rho(a | \\boldsymbol{x}) \\tag{5.99} \\]  5.7.1 贝叶斯估计量的常用损失函数 在本节中，我们将展示在机器学习中如何用最常见的损失函数来构建贝叶斯估计器。\n5.7.1.1 MAP估计最小化0-1损失 0-1损失被定义为:\n\\[ L(y,a) = \\mathbb{I}(y \\ne a) = \\left\\{ \\begin{aligned} 0 \\quad \u0026 if\\quad a=y \\\\ 1 \\quad \u0026 if\\quad a \\ne y \\end{aligned} \\right. \\tag{5.100} \\]  这通常用于分类问题，其中 \\(y\\)  是真值类标签， \\(a = \\hat{y}\\)  是估计值。\n例如，在两个类的情况下，我们可以编写如下的损失矩阵下所示：\n    \\(\\hat{y}=1\\)   \\(\\hat{y}=0\\)       \\(y=1\\)   0 1   \\(y=0\\)   1 0    （在第5.7.2节中，我们推广了这个损失函数，因此它会对不对角线上的两种误差进行不同的处理。）\n后验预期损失是\n\\[ \\rho(a | \\boldsymbol{x})=p(a \\ne y | \\boldsymbol{x}) = 1 - p(y|\\boldsymbol{x}) \\tag{5.101} \\]  因此，使最小化预期损失的动作是后验众数(mode)或MAP估计\n\\[ y^{*}(\\boldsymbol{x})= \\underset{y \\in \\mathcal{Y}}{\\rm arg max} \\ p(y | \\boldsymbol{x}) \\tag{5.102} \\]  5.7.1.2 拒绝选项 在 \\(p(y | \\boldsymbol{x})\\)  非常不确定的分类问题中，我们可能更愿意选择拒绝动作，其中我们拒绝将案例分类为任何指定的类，而是说“不知道”。 这种模糊的情况可以由例如人类专家处理。 有关说明，请参见图5.13。 这在医学和金融等风险规避领域很有用。\n我们可以将拒绝选项形式化如下。 令选择 \\(a = C + 1\\)  对应于选择拒绝动作，并选择 \\(a\\in \\{1,\\dots,C\\}\\)  对应于选择其中一个类。 假设我们定义损失函数如下\n\\[ L(y=j,a=i)=\\left\\{ \\begin{aligned} 0 \\quad \u0026 if \\quad i=j \\ and \\ i,j \\in \\{1,\\dots,C \\} \\\\ \\lambda_r \\quad \u0026 if \\quad i=C+1 \\\\ \\lambda_s \\quad \u0026 otherwise \\end{aligned} \\right. \\tag{5.103} \\]  其中 \\(\\lambda_r\\)  是拒绝动作的代价， \\(\\lambda_s\\)  是替换错误(substitution error)的代价。 在练习5.3中，将表明如果最可能类的概率低于 \\(1 - \\frac{\\lambda_r}{\\lambda_s}\\)  , 那么最佳操作是选择拒绝操作; 否则你应该选择最可能的类。\n 图5.13 对于某些输入空间区域，类别后验是不确定，我们可能不愿意选择1类或2类; 相反，我们可能更喜欢拒绝选项。 基于（Bishop 2006a）的图1.26。\n 5.7.1.3 后验均值最小 \\(l\\_2\\)  （二次）损失 对于连续参数，更合适的损失函数是平方误差， \\(l_2\\)  损失或二次损失，定义为\n\\[ L(y,a)=(y-a)^2 \\tag{5.104} \\]  后验预期损失由下式给出\n\\[ \\rho(a | \\boldsymbol{x}) = \\mathbb{E} \\left[(y-a)^2 | \\boldsymbol{x}\\right] = \\mathbb{E}[y^2|\\boldsymbol{x}]-2a\\mathbb{E}[y|\\boldsymbol{x}] + a^2 \\tag{5.105} \\]  因此，最优估计是后验均值：\n\\[ \\dfrac{\\partial}{\\partial a} \\rho(a | \\boldsymbol{x}) = -2\\mathbb{E}[y|\\boldsymbol{x}] + 2a = 0 \\Rightarrow \\hat{y}=\\mathbb{E}[y|\\boldsymbol{x}]=\\int{y p(y|\\boldsymbol{x})dy} \\tag{5.106} \\]  这通常称为最小均方误差估计或MMSE估计。\n在线性回归问题中，我们有\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{\\theta})=\\mathcal{N}(y|\\boldsymbol{x}^T \\boldsymbol{w},\\sigma^2) \\tag{5.107} \\]  在这种情况下，给出一些训练数据 \\(\\mathcal{D}\\)  的最佳估计由下式给出\n\\[ \\mathbb{E}[y | \\boldsymbol{x},\\mathcal{D}] = \\boldsymbol{x}^T \\mathbb{E}[\\boldsymbol{w}|\\mathcal{D}] \\tag{5.108} \\]  也就是说，我们只要插入后验均值参数估计。 请注意，无论我们使用什么先验 \\(\\boldsymbol{w}\\)  ，这都是最佳的。\n5.7.1.4 后验中位数最小 \\(l\\_1\\)  （绝对）损失  \\(l_2\\)  损失以二次方式惩罚与真值的偏差，因此对异常值敏感。 更强大的替代方案是绝对或 \\(l_1\\)  损失， \\(L(y,a)= | y - a |\\)  （见图5.14）。 最佳估计是后验中位数，即，是一个值 \\(a\\)  使得 \\(P(y \\lt a | \\boldsymbol{x})= P(y\\le a|\\boldsymbol{x})= 0.5\\)  。 有关证明，请参见练习5.9。\n 图5.14 （a-c）绘制 \\(L(y,a)= | y - a |^q\\)  V.S. | y - a | 对 \\(q = 0.2\\)  ， \\(q = 1\\)  和 \\(q = 2\\)  。 由_lossFunctionFig_生成的图。\n 5.7.1.5 监督学习 考虑预测函数 \\(\\delta:\\mathcal{X}\\to \\mathcal{Y}\\)  ，并假设我们有一些成本函数 \\(l(y,y^{'})\\)  ，它给出了当真值是 \\(y^{'}\\)  ,预测 \\(y\\)  的成本。 当未知自然状态为 \\(\\boldsymbol{\\theta}\\)  （数据生成机制的参数）时，我们可以定义采取动作 \\(\\delta\\)  （即使用此预测器）所引起的损失如下：\n\\[ L(\\boldsymbol{\\theta},\\delta) \\overset{\\Delta}{=} \\mathbb{E}_{(\\boldsymbol{x},y) \\sim p(\\boldsymbol{x},y|\\boldsymbol{\\theta})} [l(y, \\delta(\\boldsymbol{x}))] = \\sum_{\\boldsymbol{x}}{\\sum_y{L(y,\\delta(\\boldsymbol{x}))p(\\boldsymbol{x},y|\\boldsymbol{\\theta})}} \\tag{5.109} \\]  这称为泛化误差(generalization error)。 我们的目标是尽量减少后期预期的损失\n\\[ \\rho(\\delta|\\mathcal{D}) = \\int{p(\\boldsymbol{\\theta}|\\mathcal{D})L(\\boldsymbol{\\theta},\\delta)d\\boldsymbol{\\theta}} \\tag{5.110} \\]  这应该与公式6.47中定义的频率风险形成对比。\n5.7.2 假阳性与假阴性权衡 在本节中，我们将重点放在二元决策问题上，例如假设检验，两类分类，对象/事件检测等。我们可以做出两种类型的错误：假阳（false positive,又称误报），当我们估计 \\(\\hat{y} = 1\\)  但实际是 \\(y = 0\\)  时出现; 或假阴（ false negative, 又称错过检测），当我们估计 \\(\\hat{y} = 0\\)  但实际是 \\(y = 1\\)  时出现。 0-1损失等价地处理这两种错误。 但是，我们可以考虑以下更一般的损失矩阵：\n    \\(\\hat{y}=1\\)   \\(\\hat{y}=0\\)       \\(y=1\\)   0 \\(L_{FN}\\)     \\(y=0\\)   \\(L_{FP}\\)   0    其中 \\(L_{FN}\\)  是假阴的成本，而 \\(L_{FP}\\)  是假阳的成本。 两种可能行为的后验预期损失由下式给出\n\\[ \\begin{aligned} \\rho(\\hat{y}=0|\\boldsymbol{x})=L_{FN}p(y=1|\\boldsymbol{x}) \\\\ \\rho(\\hat{y}=1|\\boldsymbol{x})=L_{FP}p(y=0|\\boldsymbol{x}) \\end{aligned} \\tag{5.111-112} \\]  因此我们应该选择 \\(\\hat{y} = 1\\)  当且仅当\n\\[ \\begin{aligned} \\rho(\\hat{y}=0|\\boldsymbol{x})\u0026\\rho(\\hat{y}=1|\\boldsymbol{x}) \\\\ \\dfrac{p(y=1|\\boldsymbol{x})}{p(y=0|\\boldsymbol{x})}\u0026\\dfrac{L_{FP}}{L_{FN}} \\end{aligned} \\tag{5.113-114} \\]  如果 \\(L_{FN} = c L_{FP}\\)  ，很容易证明（练习5.10）我们应该选择 \\(\\hat{y} = 1\\)  当且仅当 \\(p(y=1|\\boldsymbol{x})/p(y=0|\\boldsymbol{x})\\tau\\)  ，其中 \\(\\tau= c /(1+c)\\)  （另见（Muller等，2004））。 例如，如果假阴成本是假阳性的两倍，那么c = 2，那么我们在宣布阳性之前使用2/3的决策阈值。\n下面我们讨论ROC曲线，它提供了一种研究FP-FN权衡的方法，而无需选择特定的阈值。\n5.7.2.1 ROC曲线及其一切 假设我们正在解决二元决策问题，例如分类，假设检验，对象检测等。另外，假设我们有一个标记数据集， \\(\\mathcal{D} = \\{(x_i,y_i)\\}\\)  。 设 \\(\\delta(x)= \\mathbb{I}(f(\\boldsymbol{x})\\tau)\\)  是我们的决策规则，其中 \\(f(\\boldsymbol{x})\\)  是 \\(y = 1\\)  的置信度量（这应该与 \\(p(y=1|\\boldsymbol{x})\\)  单调相关， 但不需要是概率）， \\(\\tau\\)  是一些阈值参数。 对于每个给定的 \\(\\tau\\)  值，我们可以应用我们的决策规则并计算出现的真阳，假阳，真阴和假阴的数量，如表5.2所示。 该错误表称为混淆矩阵(confusion matrix)。\n   估计 \\(\\Downarrow\\)  实际 \\(\\Rightarrow\\)   1 0 汇总     1 TP FP \\(\\hat{N}_+\\)  =TP+FP   0 FN TN \\(\\hat{N}_-\\)  =FN+TN   汇总 \\(N_+\\)  =TP+FN \\(N_-\\)  =FP+TN N=TP+FP+FN+TN     表 5.2 可从混淆矩阵导出的量。 \\(N_+\\)  是实际的阳数， \\(\\hat{N}_+\\)  是估计的阳数， \\(N_-\\)  是实际阴数， \\(\\hat{N}_-\\)  是估计的阴数。\n     \\(y=1\\)   \\(y=0\\)       \\(\\hat{y}=1\\)   \\(TP/N_+\\)  =真阳率(TPR)=敏感性=召回率 \\(FP/N_-\\)  =假阳率(FPR)=I型   \\(\\hat{y}=0\\)   \\(FN/N_+\\)  =假阴率(FNR)=错过率=II型 \\(TN/N_-\\)  =真阴率(TNR)=特异性     表 5.3 从混淆矩阵估计 \\(p(\\hat{y}|y)\\)  。 缩写：FNR =假阴率，FPR =假阳率，TNR =真阴率，TPR =真阳率。\n 从该表中，我们可以通过使用 \\(TPR = TP / N_+ \\approx p(\\hat{y} = 1 | y = 1)\\)  来计算真阳率（TPR），也称为灵敏度，召回率或命中率。 我们还可以通过使用 \\(FPR = FP /N_- \\approx p(\\hat{y} = 1 | y = 0)\\)  来计算误报率（FPR），也称为误报率或I型错误率。 这些和其他定义总结在表5.3和5.4中。 我们可以以我们选择的任何方式组合这些错误来计算损失函数。\n然而，我们可以将检测器运行一组阈值，然后将TPR与FPR绘制为τ的隐函数，而不是计算固定阈值τ的TPR和FPR。 这被称为接收者操作特征(receiver operating characteristic)或ROC曲线。 有关示例，请参见图5.15（a）。 任何系统都可以通过设置 \\(\\tau= 1\\)  来实现左下角的点（FPR = 0，TPR = 0），从而将所有内容分类为负数; 类似地，任何系统都可以通过设置 \\(\\tau= 0\\)  来实现右上角的点（FPR = 1，TPR = 1），从而将所有内容分类为正数。 如果系统在机会级别( chance level)执行，那么我们可以通过选择适当的阈值来实现对角线TPR = FPR上的任何点。 完美地将正数与负数分开的系统具有可以实现左上角的阈值（FPR = 0，TPR = 1）; 通过改变阈值，这样的系统将“拥抱”左轴，然后“拥抱”顶轴，如图5.15（a）所示。\nROC曲线的质量通常使用曲线下面积(area under the curve)或AUC汇总为单个数字。 AUC分数越高越好; 最大值显然是1.使用的另一个汇总统计量是等误差率(equal error rate)或EER，也称为交叉率(cross over rate)，定义为满足FPR = FNR的值。 由于FNR = 1 - TPR，我们可以通过从左上角到右下角绘制一条线来计算EER，并查看它与ROC曲线相交的位置（参见图5.15（a）中的点A和B）。 较低的EER分数更好; 最小值显然是0。\n 图5.15 （a）两个假设分类系统的ROC曲线。 A优于B.当我们改变阈值 \\(\\tau\\)  时，我们绘制真阳性率（TPR）与假阳性率（FPR）。 我们还指出了红色和蓝色点的等错误率（EER），以及分类器B的曲线下面积（AUC）。（b）两个假设分类系统的精确回忆曲线。 A优于B.由_PRhand_生成的图。\n     \\(y=1\\)   \\(y=0\\)       \\(\\hat{y}=1\\)   \\(TP/\\hat{N}_+\\)  =精度=PPV \\(FP/\\hat{N}_+\\)  =FDP   \\(\\hat{y}=0\\)   \\(FN/\\hat{N}_-\\)   \\(TN/\\hat{N}_-\\)  =NPV     表 5.4 从混淆矩阵估计 \\(p(y | \\hat{y})\\)  。 缩写：FDP =错误发现概率，NPV =阴性预测值，PPV =阳性预测值，\n 5.7.2.2 精确召回曲线(Precision recall curves) 当试图检测罕见事件（例如检索相关文档或在图像中找到面部）时，反例的量非常大。 因此，将 \\({\\rm TPR} = {\\rm TP} / N_+\\)  与 \\({\\rm FPR} = {\\rm FP} / N_-\\)  进行比较不是非常有用的，因为FPR将非常小。 因此，ROC曲线中的所有“动作”都将发生在最左侧。 在这种情况下，通常将TPR与假阳的数量进行比较，而不是与误报率进行比较。\n但是，在某些情况下，“否定”的概念并不是很明确。 例如，当检测图像中的对象时（参见第1.2.1.3节），如果检测器通过分类补丁工作，则检查的补丁数量(并且进而真阴性的数量) 是算法的参数，而不是 问题定义。 因此，我们希望使用仅涉及正例因素的措施。\n精度(precision)定义为 \\({\\rm TP} / \\hat{N}_+ = p(y = 1 | \\hat{y} = 1)\\)  ，并且召回(recall)定义为 \\({\\rm TP} / N_+ = p(\\hat{y} = 1 | y = 1)\\)  。 精度测量我们估计为阳的真阳部分，并召回测量我们实际检测到的真阳部分。 如果 \\(\\hat{y}_i \\in \\{0,1\\}\\)  是预测标签，并且 \\(y_i \\in \\{0,1\\}\\)  是真实标签，我们可以使用下式估计精度和召回\n\\[ P=\\dfrac{\\sum_i{y_i \\hat{y}_i}}{\\sum_i{\\hat{y}_i}}, R=\\dfrac{\\sum_i{y_i \\hat{y}_i}}{\\sum_i{y_i}}\\tag{5.115} \\]  精确召回曲线(precision recall curve)是我们改变阈值 \\(\\tau\\)  时精度与召回的关系图。 见图5.15（b）。 拥抱右上角是最好的。\n该曲线可以使用平均精度（平均召回）来概括为单个数字，其近似于曲线下面积。 或者，可以引用固定召回级别的精度，例如召回的第一个K = 10个实体的精度。 这称为K平均精度(average precision at K)得分。 在评估信息检索系统时广泛使用该度量。\n5.7.2.3 F分数* 对于固定阈值，可以计算单个精度和召回值。 这些通常组合成一个统计，称为F分数，或F1分数，这是精度和召回的调和平均值：\n\\[ F_1 \\overset{\\Delta}{=}\\dfrac{2}{1/P + 1/R}=\\dfrac{2 P R}{P + R} \\tag{5.116} \\]  使用公式5.115，我们可以将其写为\n\\[ F_1 = \\dfrac{2 \\sum_{i=1}^N{y_i \\hat{y}_i}}{\\sum_{i=1}^N{\\hat{y}_i} + \\sum_{i=1}^N{y_i}} \\tag{5.117} \\]  这是信息检索系统中广泛使用的措施。\n要理解为什么我们使用调和均值而不是算术平均值 \\((P + R)/ 2\\)  ，请考虑以下情形。 假设我们召回所有条目，即 \\(R = 1\\)  。 精度将由患病率(prevalence) \\(p(y = 1)\\)  给出。 假设患病率较低，比如 \\(p(y = 1)=10^{-4}\\)  。 P和R的算术平均值由 \\((P + R)/ 2 =(10^{-4} + 1)/2 \\approx 50\\)  %给出。 相比之下，该策略的调和均值仅为 \\(\\frac{2\\times 10^{-4}\\times 1}{ 1 + 10^{-4}} \\approx 0.2\\)  %。\n 表5.5 宏观和微观平均之间差异的插图。 \\(y\\)  是真正的标签， \\(\\hat{y}\\)  是估计的标签。 在该示例中，宏观平均精度为[10 /（10 + 10）+90 /（10 + 90）] / 2 =（0.5 + 0.9）/ 2 = 0.7。 微观平均精度为100 /（100 + 20）≈0.83。 基于（Manning等人，2008）的表13.7。\n 在多类情况下（例如，对于文档分类问题），有两种方法可以推广 \\(F_1\\)  分数。 第一个被称为宏观平均F1(macro-averaged F1)，并被定义为 \\(\\sum_{c=1}^C{F_1(c)}/ C\\)  ，其中 \\(F_1(c)\\)  是在将c类与所有其他类别区分开来的任务上获得的 \\(F_1\\)  分数。 另一个被称为微观平均F1(micro-averaged F1)，并被定义为我们汇集每个类的列联表中的所有计数作为 \\(F_1\\)  分数。\n表5.5给出了一个说明差异的工作实例。 我们看到1级的精度是0.5，而2级的精度是0.9。 因此，宏观平均精度为0.7，而微观平均精度为0.83。 后者更接近2级的精度而不是1级的精度，因为2级比1级大5倍。为了给每个等级赋予相同的权重，使用宏观平均。\n5.7.2.4 错误发现率(False discovery rates)* 假设我们试图使用某种高通量测量装置发现罕见的现象，例如基因表达微阵列或射电望远镜。 我们需要做出形式为 \\(p(y_i = 1 | \\mathcal{D})\\tau\\)  的许多二元决策，其中 \\(\\mathcal{D} = \\{\\boldsymbol{x}_i\\}_{i=1}^N\\)  并且 \\(N\\)  可能很大。 这称为多重假设检验(multiple hypothesis testing)。 请注意，与标准二元分类的区别在于我们基于所有数据对 \\(y_i\\)  进行分类，而不仅仅基于 \\(\\boldsymbol{x}_i\\)  。 所以这是一个同时发生的分类问题，我们可能希望比一系列单独的分类问题做得更好。\n我们应该如何设定阈值 \\(\\tau\\)  ？ 一种自然的方法是最小化期望的假阳数。 在贝叶斯方法中，这可以计算如下：\n\\[ {\\rm FD}(\\tau,\\mathcal{D})\\overset{\\Delta}{=}\\sum_i{\\underbrace{(1-p_i)}_{pr. error}\\underbrace{\\mathbb{I}(p_i\\tau)}_{discovery}} \\tag{5.118} \\]  其中 \\(p_i \\overset{\\Delta}{=} p(y_i = 1 | \\mathcal{D})\\)  是你相信这个对象表现出有问题的现象。 然后，我们将后验预期错误发现率(False discovery rates)定义如下：\n\\[ {\\rm FDR}(\\tau,\\mathcal{D})={\\rm FD}(\\tau,\\mathcal{D})/N(\\tau,\\mathcal{D}) \\tag{5.119} \\]  其中 \\(N(\\tau,\\mathcal{D})= \\sum_i{\\mathbb{I}(p_i\\tau)}\\)  是发现的项数。 给定期望FDR容差，例如 \\(\\alpha= 0.05\\)  ，可以调整 \\(\\tau\\)  来实现这一点; 这被称为控制FDR的直接后验概率方法(direct posterior probability approach)（Newton等，2004; Muller等，2004）。\n为了控制FDR，估计 \\(p_i\\)  的联合分布是非常有用的（例如，使用分层贝叶斯模型，如第5.5节），而不是独立地估计。 这样可以汇集统计强度，从而降低FDR。 例如，参见（Berry和Hochberg 1999）以获得更多信息。\n5.7.3 其他主题* 在本节中，我们简要介绍一些与贝叶斯决策理论相关的其他主题。 我们没有足够的空间详细介绍，但我们提供了相关文献的指示。\n5.7.3.1 上下文强盗(Contextual bandits) 单臂强盗(one-armed bandit)是世界各地赌场中出现的老虎机(slot machine)的俗称。 游戏是这样的：你插入一些钱，拉一臂，等待机器停止; 如果你很幸运，你会赢一些钱。 现在假设有K组这样的机器可供选择。 你应该使用哪一个？ 这被称为多臂强盗(multi-armed bandit)，并且可以使用贝叶斯决策理论建模：存在K个可能的动作，并且每个动作具有未知的奖励（支付函数） \\(r_k\\)  。 通过维持信念状态 \\(p(r_{1:K} | \\mathcal{D})=\\prod_k{p(r_k | \\mathcal{D})}\\)  ，可以设计最优策略; 这可以汇编成一系列的Gittins指数（Gittins 1989）。 这最佳地解决了探索-开发(exploration-exploitation)权衡，指示了在成为赢家之前每次动作应该尝试的次数。\n现在考虑一个扩展，其中每个手臂和玩家都有一个相关的特征向量; 所有这些特征记作 \\(\\boldsymbol{x}\\)  。 这被称为上下文强盗(Contextual bandits)（参见例如（Sarkar 1991; Scott 2010; Li等人2011））。 例如，“手臂”可以表示我们想要向用户显示的广告或新闻文章，并且这些特征可以表示这些广告或文章的属性，例如一袋文字，以及用户的属性，例如 人口统计学。 如果我们假设将一个线性模型用于奖励， \\(r_k =\\boldsymbol{\\theta}_k^T \\boldsymbol{x}\\)  ，我们可以保持每个臂参数的分布， \\(p(\\boldsymbol{\\theta}_k | \\mathcal{D})\\)  ，其中 \\(\\mathcal{D}\\)  是一个形如 \\((a,\\boldsymbol{x},r)\\)  的元组序列，其说明哪个手臂被拉动，其特征是什么，以及结果是什么（例如，如果用户点击广告则 \\(r = 1\\)  ，否则 \\(r = 0\\)  ）。 我们将在后面的章节中讨论从线性和逻辑斯蒂回归模型计算 \\(p(\\boldsymbol{\\theta}_k | \\mathcal{D})\\)  的方法。\n给定一个后验，我们必须决定采取什么行动。 一种常见的启发式方法，即UCB（代表“上置信边界”），是按最大下式来采取行动\n\\[ k^*=\\underset{k=1:K}{\\rm argmax} \\ \\mu_k+\\lambda \\sigma_k \\tag{5.120} \\]  其中 \\(\\mu_k= \\mathbb{E} [r_k | \\mathcal{D}], \\sigma_k^2= {\\rm var} [r_k | \\mathcal{D}]\\)  ， \\(\\lambda\\)  是一个用于权衡探索-开发的调整参数。 直觉是我们应该选择我们认为好的行动（ \\(\\mu_k\\)  很大）和/或我们不确定的行动（ \\(\\sigma_k\\)  很大）。\n一种更简单的方法，称为汤普森采样(Thompson sampling)，如下所述。 在每一步，我们选择动作 \\(k\\)  的概率等于其作为最优动作的概率：\n\\[ p_k = \\int{\\mathbb{I}\\left(\\mathbb{E}[r|a,\\boldsymbol{x},\\boldsymbol{\\theta}]=\\underset{a^{'}}{\\rm max}\\ \\mathbb{E}[r|a^{'},\\boldsymbol{x},\\boldsymbol{\\theta}]\\right) p(\\boldsymbol{\\theta}|\\mathcal{D}) d\\boldsymbol{\\theta} } \\tag{5.121} \\]  我们可以通过绘制单个样本后验 \\(\\boldsymbol{\\theta}^t \\sim p(\\boldsymbol{\\theta}|\\mathcal{D})\\)  ，然后选择 \\(k^* = {\\rm argmax}_k \\ \\mathbb{E}[r | \\boldsymbol{x}，k，\\boldsymbol{\\theta}^t]\\)  来近似。 尽管它很简单，但它已被证明效果很好（Chapelle和Li 2011）。\n5.7.3.2 效用理论 假设我们是一名医生，试图决定是否对患者进行手术。 我们想象有三种自然状态：患者没有癌症，患者患有肺癌，或患者患有乳腺癌。 由于动作和状态空间是离散的，我们可以将损失函数 \\(L(\\theta,a)\\)  表示为损失矩阵(loss matrix)，如下所示：\n    手术 无须手术     没有癌症 20 0   肺癌 10 50   乳腺癌 10 60    这些数字反映了这样一个事实：当患者患有癌症时不进行手术是非常糟糕的（由于癌症的类型而损失50或60），因为患者可能死亡; 当患者没有患癌症时不进行手术，不会造成任何损失（0）; 当患者没有患癌症时进行手术是浪费（损失20）; 当患者患有癌症时进行手术是痛苦但必要的（10）。\n很自然地会问这些数字来自哪里。 最终，它们代表了一位狡猾的医生的个人偏好或价值观，并且有点武断：正如有些人喜欢巧克力冰淇淋而其他人更喜欢香草，没有“正确”的损失/效用功能。 然而，可以示出（参见例如（DeGroot 1970））可以将任何一致的偏好集转换为标量损失/效用函数。 请注意，效用可以在任意比例上测量，例如美元，因为它只是重要的相对值。\n5.7.3.3 顺序决策理论 到目前为止，我们一直专注于一次性决策问题(one-shot decision problems)，我们只需做出一个决定然后游戏结束。 在第10.6节中，我们将其概括为多阶段或顺序决策问题。 这些问题经常出现在许多商业和工程设置中。 这与强化学习问题密切相关。 但是，对这一点的进一步讨论超出了本书的范围。\n返回本章目录\n"}),a.add({id:249,href:'/notes/tags/%E4%BC%B0%E8%AE%A1%E9%87%8F/',title:"估计量",content:""}),a.add({id:250,href:'/notes/tags/%E6%95%88%E7%94%A8/',title:"效用",content:""}),a.add({id:251,href:'/notes/tags/%E7%90%86%E6%80%A7%E8%A1%8C%E4%B8%BA/',title:"理性行为",content:""}),a.add({id:252,href:'/notes/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/',title:"监督学习",content:""}),a.add({id:253,href:'/notes/docs/mlapp/05bayesian_statistics/0050/',title:"5.6 经验贝叶斯",content:"返回本章目录\n在分层贝叶斯模型中，我们需要计算多个级别潜在变量的后验。 例如，在两级模型中，我们需要计算\n  \\[ p(\\boldsymbol{\\eta}, \\boldsymbol{\\theta} | \\mathcal{D}) \\propto p(\\mathcal{D} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} | \\boldsymbol{\\eta}) p(\\boldsymbol{\\eta}) \\tag{5.78} \\]  在某些情况下，我们可以分析地将 \\(\\boldsymbol{\\theta}\\)  边缘化; 每个分量只是计算 \\(p(\\boldsymbol{\\eta} | \\mathcal{D})\\)  的简单问题。\n作为计算捷径，我们可以用点估计近似超参数的后验， \\(p(\\boldsymbol{\\eta} | \\mathcal{D}) \\approx \\delta_{\\hat{\\boldsymbol{\\eta}}} (\\boldsymbol{\\eta})\\)  ，其中 \\(\\hat{\\boldsymbol{\\eta}}= {\\rm argmax} \\ p(\\boldsymbol{\\eta} | \\mathcal{D})\\)  。 由于 \\(\\boldsymbol{\\eta}\\)  在维数上通常远小于 \\(\\boldsymbol{\\theta}\\)  ，因此不太容易过拟合，因此我们可以安全地在 \\(\\boldsymbol{\\eta}\\)  上使用均匀的先验。 然后估计变成了\n\\[ \\hat{\\boldsymbol{\\eta}}= {\\rm argmax} \\ p(\\boldsymbol{\\eta} | \\mathcal{D}) = {\\rm argmax} \\ \\left[\\int {p(\\mathcal{D}|\\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} | \\boldsymbol{\\eta}) d \\boldsymbol{\\theta}} \\right] \\tag{5.79} \\]  括号内的量是边际或积分拟然，有时称为证据。 这种整体方法称为经验贝叶斯（EB）或II型最大似然。 在机器学习中，它有时被称为证据程序。\n经验贝叶斯违反了先验应该独立于数据选择的原则。 然而，我们可以将其视为分层贝叶斯模型中推理的计算上便宜的近似，正如我们将MAP估计视为一级模型 \\(\\boldsymbol{\\theta} \\to \\mathcal{D}\\)  中的推理近似。 事实上，我们可以构建一个层次结构，然后执行积分，“更多的贝叶斯”如下：\n   方法 定义     最大拟然 \\(\\hat{\\boldsymbol{\\theta}}={\\rm argmax}_{\\boldsymbol{\\theta}} \\ p(\\mathcal{D} \\| \\boldsymbol{\\theta})\\)     MAP估计 \\(\\hat{\\boldsymbol{\\theta}}={\\rm argmax}_{\\boldsymbol{\\theta}} \\ p(\\mathcal{D} \\| \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} \\| \\boldsymbol{\\eta})\\)     ML-II(经验贝叶斯) \\(\\hat{\\boldsymbol{\\eta}}={\\rm argmax}_{\\boldsymbol{\\eta}} \\int {p(\\mathcal{D} \\| \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} \\| \\boldsymbol{\\eta})d \\boldsymbol{\\theta}}= {\\rm argmax}_{\\boldsymbol{\\eta}} \\ p(\\mathcal{D} \\| \\boldsymbol{\\eta})\\)     MAP-II \\(\\hat{\\boldsymbol{\\eta}}={\\rm argmax}_{\\boldsymbol{\\eta}} \\int {p(\\mathcal{D} \\| \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} \\| \\boldsymbol{\\eta}) p(\\boldsymbol{\\eta})d \\boldsymbol{\\theta}}= {\\rm argmax}_{\\boldsymbol{\\eta}} \\ p(\\mathcal{D} \\| \\boldsymbol{\\eta})p(\\boldsymbol{\\eta})\\)     完全贝叶斯 \\(p(\\boldsymbol{\\eta}, \\boldsymbol{\\theta} \\| \\mathcal{D}) \\propto p(\\mathcal{D} \\| \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} \\| \\boldsymbol{\\eta}) p(\\boldsymbol{\\eta})\\)      注意，EB可以显示具有良好的频率属性（参见例如（Carlin和Louis 1996; Efron 2010）），因此它被非贝叶斯主义者广泛使用。 例如，在6.3.3.2节中讨论的流行的James-Stein估计可以使用EB导出。\n5.6.1示例：贝塔-二项模型 让我们回到癌症发病率模型。 我们可以分析地积分 \\(\\theta_i\\)  ，并直接写下边际拟然：\n\\[ \\begin{aligned} p(\\mathcal{D} | a,b) = \u0026 \\prod_i{\\int{{\\rm Bin}(x_i|N_i,\\theta_i){\\rm Beta}(\\theta_i|a,b)d\\theta_i}} \\\\ \\quad = \u0026 \\prod_i{\\dfrac{B(a+x_i,b+N_i-x_i)}{B(a,b)}} \\end{aligned} \\tag{5.80-81} \\]  在（Minka 2000e）中讨论了使这个关于a和b最大化的各种方法。\n估计了a和b之后，我们可以使用共轭分析以常规方式插入超参数来计算后验 \\(p(\\theta_i | \\hat{a},\\hat{b},\\mathcal{D})\\)  。 最终结果是每个 \\(\\theta_i\\)  的后验均值是依赖于 \\(\\boldsymbol{\\eta}=(a,b)\\)  的局部MLE和先验均值的加权平均; 但由于 \\(\\boldsymbol{\\eta}\\)  是根据所有数据估算的，因此每个 \\(\\theta_i\\)  都受到所有数据的影响。\n5.6.2 示例：高斯-高斯模型 我们现在研究另一个类似于癌症率例子的例子，除了数据是实值的。 我们将使用高斯似然和高斯先验。 这将允许我们分析地写下解决方案。\n特别是，假设我们有来自多个相关组的数据。 例如， \\(x_{ij}\\)  可以是学校 \\(j\\)  中的学生 \\(i\\)  的考试分数， \\(j = 1:D\\)  且 \\(i = 1:N_j\\)  。 我们想要估算每所学校的平均分数 \\(\\theta_j\\)  。 然而，由于样本大小 \\(N_j\\)  对于某些学校来说可能很小，我们可以通过使用分层贝叶斯模型来规范化问题，其中我们假设 \\(\\theta_j\\)  来自共同的先验 \\(N(\\mu，\\tau^2)\\)  。\n联合分布具有以下形式：\n\\[ p(\\boldsymbol{\\theta},\\mathcal{D}|\\boldsymbol{\\eta}, \\sigma^2)= \\prod_{j=1}^D{\\mathcal{N}(\\theta_j|\\mu,\\tau^2)\\prod_{i=1}^{N_j}{\\mathcal{N}(x_{ij}|\\theta_j,\\sigma^2)}} \\tag{5.82} \\]  我们假设 \\(\\sigma^2\\)  是已知的简单的。 （我们在练习24.4中放松了这个假设。）我们解释如何估计下面的 \\(\\boldsymbol{\\eta}\\)  。 一旦我们估计了 \\(\\boldsymbol{\\eta}=(\\mu,\\tau)\\)  ，我们就可以计算 \\(\\theta_j\\)  上的后验。 要做到这一点，以下面的形式简化重写联合分布，利用值为 \\(x_{ij}\\)  和方差 \\(\\sigma^2\\)  的 \\(N_j\\)  个高斯测量相当于值为 \\(\\bar{x}_j \\overset{\\Delta}{=}\\frac{1}{N_j}\\sum_{i=1}^{N_j}{x_{ij}}\\)  方差为 \\(\\sigma_j^2\\overset{\\Delta}{=}\\sigma^2/N_j\\)  的一次测量的事实。 这会产生\n\\[ p(\\boldsymbol{\\theta},\\mathcal{D}|\\hat{\\boldsymbol{\\eta}}, \\sigma^2)= \\prod_{j=1}^D{\\mathcal{N}(\\theta_j|\\hat{\\mu},\\hat{\\tau}^2)\\mathcal{N}(\\bar{x}_j|\\theta_j,\\sigma_j^2)} \\tag{5.83} \\]  从这一点可以看出，依据第4.4.1节的结果, 后验可由下式给出\n\\[ \\begin{aligned} p(\\theta_j|\\mathcal{D},\\hat{\\mu},\\hat{\\tau}^2) = \u0026 \\mathcal{N}(\\theta_j|\\hat{B}_j \\hat{\\mu} + (1-\\hat{B}_j)\\bar{x}_j,(1-\\hat{B}_j)\\sigma_j^2) \\\\ \\hat{B}_j \\overset{\\Delta}{=} \u0026 \\dfrac{\\sigma_j^2}{ \\sigma_j^2+\\hat{\\tau}^2} \\end{aligned} \\tag{5.84-85} \\]  其中 \\(\\hat{\\mu}= \\bar{x}\\)  和 \\(\\hat{\\tau}^2\\)  将在下面定义。\n量 \\(0 \\le \\hat{B}_j \\le 1\\)  控制朝向总体平均值 \\(\\mu\\)  的收缩程度。 如果数据对于组 \\(j\\)  是可靠的（例如，因为样本大小 \\(N_j\\)  很大），则 \\(\\sigma_j^2\\)  相对于 \\(\\tau^2\\)  将是小的; 因此 \\(\\hat{B}_j\\)  会很小，当估算 \\(\\theta_j\\)  时我们会更加重视 \\(\\bar{x}_j\\)  。 然而，样本量较小的组将更加规范化（缩小到整体平均 \\(\\mu\\)  ）。 我们将在下面看到一个例子。\n如果所有组 \\(j\\)  的 \\(\\sigma_j=\\sigma\\)  ，则后验均值变为\n\\[ \\hat{\\theta}_j=\\hat{B} \\bar{x} + (1-\\hat{B})\\bar{x}_j = \\bar{x} + (1-\\hat{B})(\\bar{x}_j-\\bar{x}) \\tag{5.86} \\]  这与第6.3.3.2节中讨论的James Stein估计完全相同。\n5.6.2.1 示例：预测棒球比分  图5.12 （a）MLE参数（上）和相应的缩减估计（下）。 （b）我们绘制了5个玩家的真实参数（蓝色），后验平均估计值（绿色）和MLE（红色）。 由_shrinkageDemoBaseball_生成的图。\n 我们现在给出一个应用于棒球击球平均值的收缩的例子，来自（Efron和Morris 1975）。 我们观察了在第一场T = 45场比赛中D = 18名球员的命中数。 命中数 \\(b_i\\)  ， 我们假设 \\(b_j \\sim {\\rm Bin}(T，\\theta_j)\\)  ，其中 \\(\\theta_j\\)  是球员 \\(j\\)  的“真实”击球平均值。 目标是估计 \\(\\theta_j\\)  。 MLE当然是 \\(\\hat{\\theta}_j= x_j\\)  ，其中 \\(x_j = b_j / T\\)  是经验击球均值。 但是，我们可以使用EB方法做得更好。\n为了应用上述高斯收缩方法，我们要求似然是高斯 \\(x_j \\sim \\mathcal{N}(\\theta_j,\\sigma^2)\\)  的(已知 \\(\\sigma^2\\)  )。 （因为我们假设 \\(N_j = 1\\)  ，所以我们删除了 \\(i\\)  下标，因为 \\(x_j\\)  已经代表了球员 \\(j\\)  的平均值。）但是，在这个例子中我们有二项似然。 虽然这具有正确的均值 \\(\\mathbb{E} [x_j] =\\theta_j\\)  ，但方差不是常数：\n\\[ {\\rm var}[x_j] = \\dfrac{1}{T} {\\rm var}[b_j]=\\dfrac{T\\theta_j(1-\\theta_j)}{T^2}=\\dfrac{\\theta_j(1-\\theta_j)}{T} \\tag{5.87} \\]  因此，让我们将方差稳定变换(variance stabilizing transform) 应用于 \\(x_j\\)  以更好地匹配高斯假设：\n\\[ y_j \\to f(y_j)=\\sqrt{T} \\arcsin (2y_j-1) \\tag{5.88} \\]  现在我们有近似 \\(y_j \\sim \\mathcal{N}(f(\\theta_j),1)= \\mathcal{N}(\\mu_j,1)\\)  。 我们使用高斯收缩来估计 \\(\\mu_j\\)  ，利用了公式5.86并取 \\(\\sigma^2= 1\\)  ，然后我们作一个逆变换\n\\[ \\hat{\\theta}_j=0.5(\\sin(\\hat{\\mu}_j/\\sqrt{T})+1) \\tag{5.89} \\]  结果如图5.12（a-b）所示。 在（a）中，我们绘制了MLE \\(\\hat{\\theta}_j\\)  和后验均值 \\(\\bar{\\theta}_j\\)  。我们看到所有估计都缩小到全局均值0.265。 在（b）中，我们绘制真值 \\(\\theta_j\\)  ，MLE \\(\\hat{\\theta}_j\\)  和后验均值 \\(\\bar{\\theta}_j\\)  。 （ \\(\\theta_j\\)  的“真实”值是从大量独立游戏中估算出来的。）我们看到，平均而言，收缩估计比MLE更接近真实参数。 具体而言，对定义为 \\({\\rm MSE} = \\dfrac{1}{N}\\sum_{j=1}^D{(\\theta_j-\\bar{\\theta})^2}\\)  的均方误差而言, 使用收缩估计 \\(\\bar{\\theta}_j\\)  比使用MLE的 \\(\\hat{\\theta}_j\\)  小三倍。\n5.6.2.2 估计超参数 在本节中，我们给出了估计 \\(\\boldsymbol{\\eta}\\)  的算法。 首先假设 \\(\\sigma_j^2=\\sigma^2\\)  对于所有组都是相同的。 在这种情况下，我们可以推导出EB的封闭式估计值，正如我们现在所示。 从公式4.126，我们有\n\\[ p(\\bar{x}_j|\\mu,\\tau^2,\\sigma^2) = \\int{\\mathcal{N}(\\bar(x)_j|\\theta_j,\\sigma^2)\\mathcal{N}(\\theta_j|\\mu,\\tau^2)d\\theta_j} = \\mathcal{N}(\\bar{x}_j | \\mu,\\tau^2+\\sigma^2) \\tag{5.90} \\]  因此，边际拟然是\n\\[ p(\\mathcal{D}|\\mu,\\tau^2,\\sigma^2) = \\prod_{j=1}^D {\\mathcal{N}(\\bar{x}_j | \\mu,\\tau^2+\\sigma^2)} \\tag{5.91} \\]  因此，我们可以使用通常的MLE估计高斯参数。 对于 \\(\\mu\\)  ，我们有\n\\[ \\hat{\\mu} = \\dfrac{1}{D}\\sum_{j=1}^D{\\bar{x}_j} = \\bar{x} \\tag{5.92} \\]  这是整体均值。\n对于方差，我们可以使用矩匹配（相当于高斯的MLE）：我们简单地将模型方差等同于经验方差：\n\\[ \\hat{\\tau}^2 + \\sigma^2 = \\dfrac{1}{D} \\sum_{j=1}^D{(\\bar{x}_j-\\bar{x})^2} \\overset{\\Delta}{=} s^2 \\tag{5.93} \\]  所以 \\(\\hat{\\tau}^2= s^2 - \\sigma^2\\)  。 由于我们知道 \\(\\tau^2\\)  必须是正数，因此通常使用以下修订估算：\n\\[ \\hat{\\tau}^2=\\max\\{0,s^2-\\sigma^2\\}=(s^2-\\sigma^2)_+ \\tag{5.94} \\]  因此收缩因子是\n\\[ \\hat{B}=\\dfrac{\\sigma^2}{\\sigma^2+\\hat{\\tau}^2} = \\dfrac{\\sigma^2}{\\sigma^2+(s^2-\\sigma^2)_+} \\tag{5.95} \\]  在 \\(\\sigma_j^2\\)  不同的情况下，我们不能再以封闭形式得出解。 练习11.13讨论了如何使用EM算法导出EB估计，练习24.4讨论了如何在此层次模型中执行完全贝叶斯推理。\n返回本章目录\n"}),a.add({id:254,href:'/notes/tags/%E6%A8%A1%E5%9E%8B/',title:"模型",content:""}),a.add({id:255,href:'/notes/tags/%E8%B6%85%E5%8F%82%E6%95%B0/',title:"超参数",content:""}),a.add({id:256,href:'/notes/tags/%E9%A2%84%E6%B5%8B/',title:"预测",content:""}),a.add({id:257,href:'/notes/docs/mlapp/05bayesian_statistics/0049/',title:"5.5 分层贝叶斯",content:"返回本章目录\n计算后验   \\(p(\\boldsymbol{\\theta} | \\mathcal{D})\\)  的关键要求是先验 \\(p(\\boldsymbol{\\theta} | \\boldsymbol{\\eta})\\)  的指定，其中 \\(\\boldsymbol{\\eta}\\)  是超参数。 如果我们不知道如何设置 \\(\\boldsymbol{\\eta}\\)  怎么办？ 在某些情况下，我们可以使用无信息的先验，我们在上面讨论过。 更多贝叶斯方法是在我们的先验前再放置一个先验！ 在图模型（第10章）术语下，我们可以表示如下情况：\n\\[ \\boldsymbol{\\eta} \\to \\boldsymbol{\\theta} \\to \\mathcal{D} \\tag{5.76} \\]  这是分层贝叶斯模型( hierarchical Bayesian model)的一个示例，也称为多级模型(multi-level model)，因为存在多个级别的未知量。 我们在下面给出一个简单的例子，我们将在本书后面看到许多其他的例子。\n5.5.1 示例：癌症发病率建模 考虑在各个城市预测癌症发病率的问题（这个例子来自（Johnson and Albert 1999，p24））。特别地，假设我们测量不同城市的人数 \\(N_i\\)  ，以及这些城市中死于癌症的人数 \\(x_i\\)  。我们假设 \\(x_i \\sim {\\rm Bin}(N_i，\\theta_i)\\)  ，并且我们想要估计癌症率 \\(\\theta_i\\)  。一种方法是单独估计它们，但是这将受到稀疏数据问题（低估由于小的 \\(N_i\\)  引起的癌症速率）的影响。另一种方法是假设所有 \\(\\theta_i\\)  都相同;这称为参数绑定(parameter tying)。由此产生的混合MLE恰好是只 \\(\\hat{\\theta}=\\frac{\\sum_i{x_i}}{\\sum_i{N_i}}\\)  。但是所有城市具有相同比率的假设是相当强的。一种折衷的方法是假设 \\(\\theta_i\\)  是相似的，但可能存在城市特定的变化。这可以通过假设 \\(\\theta_i\\)  是从一些共同分布中得出来建模，比如 \\(\\theta_i \\sim {\\rm Beta}(a,b)\\)  。完整的联合分布可以写成\n\\[ p(\\mathcal{D}, \\boldsymbol{\\theta}, \\boldsymbol{\\eta} | \\boldsymbol{N}) = p(\\boldsymbol{\\eta}) \\prod_{i=1}^N {{\\rm Bin}(x_i | N_i, \\theta_i) {\\rm Beta}(\\theta_i | \\boldsymbol{\\eta}) } \\tag{5.77} \\]  其中: \\(\\boldsymbol{\\eta}=(a,b)\\)  。\n注意，我们从数据推断 \\(\\boldsymbol{\\eta}=(a,b)\\)  是至关重要的; 如果我们只是将它固定成一个常数， \\(\\theta_i\\)  将是条件独立的，并且它们之间将没有信息流。 相比之下，通过将 \\(\\boldsymbol{\\eta}\\)  视为未知（隐藏变量），我们允许从数据丰富的城市借用统计力量应用到数据贫乏的城市。\n假设我们要计算联合后验 \\(p(\\boldsymbol{\\eta}，\\boldsymbol{\\theta} | \\mathcal{D})\\)  。 由此我们可以得到边缘后验 \\(p(\\theta_i | \\mathcal{D})\\)  。 在图5.11（a）中，我们绘制了后验均值 \\(\\mathbb{E} [\\theta_i | \\mathcal{D}]\\)  (蓝色条)，以及人口水平均值 \\(\\mathbb{E} [a /(a + b) | \\mathcal{D}]\\)  (显示为红线 , 这代表 \\(\\theta_i\\)  的均值）。 我们看到，对于样本量小的城市 \\(N_i\\)  ，相对更强的汇总估计, 后验均值会更小,。 例如，城市1和城市20都有0观察到的癌症发病率，但城市20的人口较少，因此相对城市1, 其人口水平估计（即，它更接近水平红线）的比率更低。\n 图5.11 （a）使用来自（Johnson和Albert 1999，第24页）的数据来拟合模型的结果。 第一行：密苏里州20个城市的癌症事件数量 \\(x_i\\)  。 第二行：人口规模 \\(N_i\\)  。 最大的城市（编号15）的人口为 \\(N_{15} = 53637\\)  , 和 \\(x_{15} = 54\\)  个事件，但我们截断了前两行的垂直轴，以便可以看到其他城市之间的差异。 第三排：MLE \\(\\hat{\\theta}_i\\)  。 红线是汇集的MLE。 第四行：后验均值 \\(\\mathbb{E} [\\theta_i | \\mathcal{D}]\\)  。 红线是 \\(\\mathbb{E} [a /(a+b) | \\mathcal{D}]\\)  ，即人口水平均值。 （b）癌症发病率的95％后验可信区间。 由_cancerRatesEb_生成的图\n 图5.11（b）显示了 \\(\\theta_i\\)  的95％后验可信区间。 我们看到，人口众多（53,637人）的城市15具有较小的后验不确定性。 因此，这个城市对 \\(\\boldsymbol{\\eta}\\)  的后验估计影响最大，这反过来将影响其他城市的癌症率估计。 具有最高MLE的城市10和19也具有最高的后验不确定性，反映出这样的高估计与先验（与所有其他城市估计）相矛盾的事实。\n在上面的例子中，我们每个城市有一个参数，来建模响应的概率。 通过使伯努利率参数成为协变量的函数， \\(\\theta_i= {\\rm sigm}(\\boldsymbol{w}_i^T \\boldsymbol{x})\\)  ，我们可以建模多个相关逻辑斯蒂回归任务。 这称为多任务学习，将在第9.5节中详细讨论。\n返回本章目录\n"}),a.add({id:258,href:'/notes/docs/mlapp/05bayesian_statistics/0048/',title:"5.4 先验",content:"返回本章目录\n贝叶斯统计数据中最具争议的方面是它依赖于先验。 贝叶斯认为这是不可避免的，因为没有人是白板(tabula rasa或blank slate)：所有的推论都必须以某些关于世界的假设为条件。 然而，人们可能有兴趣尽量减少先验假设的影响。 我们将在下面简要讨论一些方法。\n5.4.1 无信息先验 如果我们对   \\(\\theta\\)  没有强烈的信念，那么通常使用无信息(uninformative或non-informative)先验，并“让数据说明一切”。\n设计无信息先验的问题实际有点棘手。 用一个例子来说明其难度，考虑伯努利参数， \\(\\theta \\in [0,1]\\)  。 一个可能想法，信息最少的先验就是均匀分布， \\({\\rm Beta}(1,1)\\)  。 但在这种情况下的后验均值是 \\(\\mathbb{E} [\\theta| \\mathcal{D}] = \\frac{N_1 + 1} {N_1 + N_0 + 2}\\)  ，而MLE是 \\(\\frac{N_1} {N_1 + N_0}\\)  。 因此，有人可能会争辩说，先验并不是完全没有信息。\n显然，通过减少伪计数的大小，我们可以减轻先验的影响。 通过上述论证，最无信息的先验是\n\\[ \\lim_{c \\to 0} {\\rm Beta}(c,c)={\\rm Beta}(0,0) \\tag{5.49} \\]  它是0和1处两个等质量点的混合（见（Zhu和Lu 2004））。 这也称为Haldane先验。 请注意，Haldane先验是一个不恰当的先验，意味着它不是积分到1的.但是，只要我们看到至少一个\u0026quot;正面\u0026quot;和至少一个\u0026quot;反面\u0026quot;，后验都将是正确的。\n在5.4.2.1节中，我们将论证“正确的”无信息先验实际上是 \\({\\rm Beta}(\\frac{1}{2},\\frac{1}{2})\\)  。 显然，这三个先验之间的实践差异很可能是微不足道的。 一般来说，建议进行某种敏感性分析，以检查一个人的结论或预测随着建模假设的变化而变化多少，其中包括先验的选择，以及拟然的选择及任何种类的数据预处理。 如果结论对建模假设相对不敏感，那么人们可以对结果更有信心。\n5.4.2 Jeffreys先验* Harold Jeffreys 设计了一种用于创建无信息先验的通用技术。 结果被称为Jeffreys先验( Jeffreys priors)。 关键的观察是，如果 \\(p(\\phi)\\)  是无信息的，那么先验的任何重新参数化，诸如 \\(\\theta= h(\\phi)\\)  的某些函数 \\(h\\)  ，也应该是无信息的。 现在，通过变量替换公式，\n\\[ p_{\\theta}(\\theta)=p_{\\phi}(\\phi)\\left|\\dfrac{d\\phi}{d\\theta}\\right| \\tag{5.50} \\]  所以先验一般也会改变的。 但是，让我们选择\n\\[ p_{\\phi}(\\phi) \\propto \\left(I(\\phi)\\right)^{\\frac{1}{2}} \\tag{5.51} \\]  其中 \\(I(\\phi)\\)  是费雪信息(Fisher information)：\n\\[ I(\\phi) \\overset{\\Delta}{=} - \\mathbb{E} \\left[\\left(\\dfrac{d \\log p(\\boldsymbol{X}|\\phi)}{d\\phi} \\right)^2\\right] \\tag{5.52} \\]  这是负对数似然曲率期望的度量，因此是MLE稳定性的度量（参见第6.2.2节）。 现在\n\\[ \\dfrac{d \\log p(x|\\theta)}{d\\theta}=\\dfrac{d \\log p(x|\\phi)}{d\\phi}\\left|\\dfrac{d\\phi}{d\\theta}\\right| \\tag{5.53} \\]  进而我们有\n\\[ \\begin{aligned} I(\\theta) =\u0026 - \\mathbb{E} \\left[\\left(\\dfrac{d \\log p(\\boldsymbol{X}|\\theta)}{d\\theta} \\right)^2\\right] = I(\\phi) \\left(\\dfrac{d\\phi}{d\\theta}\\right)^2 \\\\ I(\\theta)^{\\frac{1}{2}} =\u0026 I(\\phi)^{\\frac{1}{2}} \\left|\\dfrac{d\\phi}{d\\theta}\\right| \\end{aligned} \\tag{5.54-55} \\]  所以我们找到转换后的先验\n\\[ p_{\\theta}(\\theta)=p_{\\phi}(\\phi)\\left|\\dfrac{d\\phi}{d\\theta}\\right| \\propto \\left(I(\\phi)\\right)^{\\frac{1}{2}}\\left|\\dfrac{d\\phi}{d\\theta}\\right|=I(\\theta)^{\\frac{1}{2}} \\tag{5.56} \\]  所以 \\(p_{\\theta}(\\theta)\\)  和 \\(p_{\\phi}(\\phi)\\)  是相同的。\n一些例子将使这更清楚\n5.4.2.1示例：伯努利和多项分布的Jeffreys先验 假设 \\(X \\sim {\\rm Ber}(\\theta)\\)  。 单个样本的对数似然性是\n\\[ \\log p(X|\\theta) = X \\log \\theta + (1-X) \\log (1-\\theta) \\tag{5.57} \\]  得分函数只是对数似然的梯度：\n\\[ s(\\theta) \\overset{\\Delta}{=} \\dfrac{d}{d\\theta} \\log p(X|\\theta)=\\dfrac{X}{\\theta}-\\dfrac{1-X}{1-\\theta} \\tag{5.58} \\]  已观测信息(observed information)是对数似然的二阶导数：\n\\[ J(\\theta)=-\\dfrac{d^2}{d\\theta^2} \\log p(X|\\theta)=-s^{'}(\\theta|X)= \\dfrac{X}{\\theta^2}+\\dfrac{1-X}{(1-\\theta)^2} \\tag{5.59} \\]  费雪信息(Fisher information)是已观测信息的期望：\n\\[ I(\\theta) = \\mathbb{E} [J(\\theta|X)|X \\sim \\theta]=\\dfrac{\\theta}{\\theta^2}+\\dfrac{1-\\theta}{(1-\\theta)^2}=\\dfrac{1}{\\theta (1-\\theta)} \\tag{5.60} \\]  于是Jeffreys先验就是\n\\[ p(\\theta) \\propto \\theta^{-\\frac{1}{2}}(1-\\theta)^{-\\frac{1}{2}} = \\dfrac{1}{\\sqrt{\\theta(1-\\theta)}} \\propto {\\rm Beta}(\\dfrac{1}{2},\\dfrac{1}{2}) \\tag{5.61} \\]  现在考虑具有K个状态的多项分布随机变量。 可证明对应的Jeffreys先验是\n\\[ p(\\theta) \\propto {\\rm Dir}(\\dfrac{1}{2},\\dots,\\dfrac{1}{2}) \\tag{5.62} \\]  请注意，这与更明显的选择 \\({\\rm Dir}(\\frac{1}{K},\\dots,\\frac{1}{K})\\)  或 \\({\\rm Dir}(1,\\dots,1)\\)  有所不同。\n5.4.2.2示例：位置和尺度参数的Jeffreys先验 一方面，考虑位置参数的Jeffreys先验，比如高斯均值， \\(p(\\mu) \\propto 1\\)  。因此这是平移不变先验(translation invariant prior)的例子，满足任意指定区间 \\([A,B]\\)  的概率质量与平移后区间 \\([A-c,B-c]\\)  的概率质量相同。\n\\[ \\int_{A-c}^{B-c}{p(\\mu)d\\mu}=(A-c)-(B-c) = (A-B)=\\int_{A}^{B}{p(\\mu)d\\mu} \\tag{5.63} \\]  这可由 \\(p(\\mu) \\propto 1\\)  来实现，我们可以通过使用具有无穷方差的高斯 \\(p(\\mu)= \\mathcal{N}(\\mu | 0, \\infty)\\)  来近似。 注意，这是一个不恰当先验(improper prior)，因为它不能积分到1。 只要后验是恰当的，使用不恰当先验也不错，我们看到 \\(N \\ge 1\\)  个数据点就是这种情况，因为我们可以在看到单个数据点后立即“确定”该位置。\n类似地，可以展示Jeffreys先验的尺度参数，比如高斯方差 \\(p(\\sigma^2) \\propto 1/\\sigma^2\\)  。 这是缩放不变先验(scale invariant prior)的例子，满足任意指定区间 \\([A,B]\\)  的概率质量与缩放后区间 \\([A/c,B/c]\\)  的概率质量相同，其中缩放常数因子 \\(c 0\\)  .（例如，如果我们将单位从米改为英尺，我们不希望这会影响我们的推论。）这可以通过下式来实现\n\\[ p(s) \\propto 1/s \\tag{5.64} \\]  为了看到这点，只需注意\n\\[ \\begin{aligned} \\int_{A/c}^{B/c}{p(s)ds}=\u0026 \\left[\\ln s\\right]_{A/c}^{B/c}=\\ln(B/c)-\\ln(A/c) \\\\ \\quad =\u0026 \\ln(B)-\\ln(A)=\\int_{A}^{B}{p(s)ds} \\end{aligned} \\tag{5.65-66} \\]  我们可以使用退化Gamma分布（第2.4.4节） \\(p(s)= {\\rm Ga}(s|0,0)\\)  来近似。 这个先验 \\(p(s) \\propto 1/ s\\)  也是不恰当的，但只要我们看到N≥2个数据点（因为我们需要至少两个数据点来估计方差），后验就是恰当的。\n5.4.3 鲁棒先验 在许多情况下，我们并不确信我们的先验，因此我们希望确保它不会对结果产生不恰当的影响。 这可以通过使用鲁棒先验（robust priors, Insua和Ruggeri 2000）来完成，它通常具有厚重的尾部，这避免了迫使事件过于接近先验均值。\n让我们考虑一个例子（Berger 1985，p7）。 假设 \\(x \\sim \\mathcal{N}(\\theta,1)\\)  。 我们观察到 \\(x = 5\\)  并且我们想要估计 \\(\\theta\\)  。 MLE当然是 \\(\\hat{\\theta}= 5\\)  ，这似乎是合理的。 均匀先验下的后验均值也是 \\(\\bar{\\theta}= 5\\)  。但是现在假设我们知道先验中位数是0，而先验4分位数是-1和1，所以 \\(p(\\theta \\le -1)= p(-1 。 让我们假设先验是平滑且单峰的。\n很容易证明形式为 \\(\\mathcal{N}(\\theta|0, 2.19^2)\\)  的高斯先验满足这些先验约束。 但在这种情况下，后验均值为3.43，这似乎不太令人满意。\n现在假设我们使用Cauchy先验 \\(\\mathcal{T}(\\theta| 0,1,1)\\)  。 这也满足了我们示例的先验约束。 但是这一次我们发现（使用数值积分：参见代码_robustPriorDemo_），后验均值约为4.6，这似乎更合理。\n5.4.4 混合共轭先验 鲁棒先验是有用的，但使用起来计算成本很高。 共轭先验简化了计算，但通常不够稳健，并且不够灵活，无法编码我们的先验知识。 然而，事实证明，混合共轭先验(mixture of conjugate priors)也是共轭的（练习5.1），并且可以近似任何类型的先验（Dallal和Hall 1983; Diaconis和Ylvisaker 1985）。 因此，这些先验提供了计算方便性和灵活性之间的良好折衷。\n例如，假设我们正在建模投掷硬币，我们认为硬币要么公平，要么偏向于\u0026quot;正面\u0026quot;。 这不能用beta分布表示。 但是，我们可以使用两个beta分布的混合来对其进行建模。 例如，我们可能会使用\n\\[ p(\\theta) = 0.5 \\ {\\rm Beta}(\\theta|20,20) + 0.5 \\ {\\rm Beta}(\\theta|30,10) \\tag{5.67} \\]  如果 \\(\\theta\\)  来自第一个分布，硬币是公平的，但如果它来自第二个，它偏向于\u0026quot;正面\u0026quot;。\n我们可以通过引入隐变量 \\(z\\)  来表示混合，其中 \\(z = k\\)  意味着 \\(\\theta\\)  来自第 \\(k\\)  个混合分分。 先验可表示如下:\n\\[ p(\\theta) = \\sum_k{p(z=k) p(\\theta|z=k)} \\tag{5.68} \\]  其中每个 \\(p(\\theta|z=k)\\)  是共轭的，并且 \\(p(z = k)\\)  被称为（先验的）混合权重。 可以证明（练习5.1）后验也可以写成共轭分布的混合，如下所示：\n\\[ p(\\theta | \\mathcal{D}) = \\sum_k{p(z=k | \\mathcal{D}) p(\\theta|\\mathcal{D},z=k)} \\tag{5.69} \\]  其中 \\(p(Z=k | \\mathcal{D})\\)  是后验混合权重\n\\[ p(Z=k | \\mathcal{D}) = \\dfrac{p(Z=k) p(\\mathcal{D} | Z=k )}{\\sum_{k^{'}}{p(Z=k^{'}) p(\\mathcal{D} | Z=k^{'} )}} \\tag{5.70} \\]  这里量 \\(p(\\mathcal{D} | Z=k )\\)  是第 \\(k\\)  个混合成分边际拟然（见5.3.2.1节）。\n5.4.4.1 示例 假设我们使用混合先验\n\\[ p(\\theta) = 0.5 \\ {\\rm Beta}(\\theta|a_1,b_1) + 0.5 \\ {\\rm Beta}(\\theta|a_2,b_2) \\tag{5.71} \\]  其中 \\(a_1= b_1 = 20\\)  且 \\(a_2 = b_2 = 10\\)  .我们观察到 \\(N_1\\)  个\u0026quot;正面\u0026quot;和 \\(N_0\\)  个\u0026quot;反面\u0026quot;。 后验变成了\n\\[ p(\\theta | \\mathcal{D}) = p(Z=1 | \\mathcal{D}) {\\rm Beta}(\\theta|a_1+N_1,b_1+N_0) +p(Z=2 | \\mathcal{D}) {\\rm Beta} (\\theta|a_2+N_1,b_2+N_0) \\tag{5.72} \\]  如果 \\(N_1 = 20\\)  个\u0026quot;正面\u0026quot; \\(N_0 = 10\\)  个\u0026quot;反面\u0026quot;，则使用公式5.23，后验变为\n\\[ p(\\theta | \\mathcal{D}) = 0.346 \\ {\\rm Beta}(\\theta|40,30) +0.654 \\ {\\rm Beta} (\\theta|30,20) \\tag{5.73} \\]  参考图5.10所示。\n 图5.10 两种Beta分布的混合。 _mixBetaDemo_生成的图。\n 5.4.4.2 应用：寻找DNA和蛋白质序列中的保守区域 我们提到狄利克雷-多项模型广泛用于生物序列分析。 让我们举一个简单的例子来说明已经发展起来的一些机制。 具体来说，请考虑第2.3.2.1节中讨论的序列标识。 现在假设我们想要找到代表基因组编码区的位置。 由于进化压力，这些位置通常在所有序列上具有相同的字母。 所以我们需要找到“纯粹”(或接近纯粹)的列，在这种意义下, 要么大部分都是As，要么大部分都是Ts，要么大部分都是Cs，或者要么大部分都是Gs。 一种方法是寻找低熵列; 这些将是几乎确定性（纯粹）的分布。\n但是假设我们想要将置信度量与我们的纯度估计值联系起来。 如果我们认为相邻位置是一起保存的，这可能很有用。 在这种情况下，如果位置 \\(t\\)  是保守的，则令 \\(Z_t = 1\\)  ，否则 \\(Z_t = 0\\)  。 然后我们可以使用马尔可夫链在相邻的 \\(Z_t\\)  变量之间添加依赖关系; 详见第17章。\n在任何情况下，我们都需要定义似然模型 \\(p(\\boldsymbol{N}_t | Z_t)\\)  ，其中 \\(\\boldsymbol{N}_t\\)  是列 \\(t\\)  的 \\((A，C，G，T)\\)  计数向量。 将其作为具有参数 \\(\\boldsymbol{\\theta}_t\\)  的多项分布是很自然的。 由于每列具有不同的分布，我们将希望对 \\(\\boldsymbol{\\theta}_t\\)  积分，从而计算边际拟然\n\\[ p(\\boldsymbol{N}_t | Z_t) = \\int {p(\\boldsymbol{N}_t | \\boldsymbol{\\theta}_t) p(\\boldsymbol{\\theta}_t | Z_t) d\\boldsymbol{\\theta}_t} \\tag{5.74} \\]  但是我们对 \\(\\boldsymbol{\\theta}_t\\)  应该使用什么先验？ 当 \\(Z_t = 0\\)  时，我们可以使用均匀先验 \\(p(\\theta| Z_t = 0)= {\\rm Dir}(1,1,1,1)\\)  ，但是如果 \\(Z_t = 1\\)  ，我们应该使用什么？ 毕竟，如果该列是保守的，它可以是（几乎）纯的As，Cs，Gs或Ts列。 一种自然的方法是使用狄利克雷先验的混合，其中每个都“倾”向4维单纯形的一个适当的角落，例如，\n\\[ p(\\boldsymbol{\\theta} | Z_t=1) = \\dfrac{1}{4} {\\rm Dir}(\\boldsymbol{\\theta} | (10,1,1,1)) + \\dots + \\dfrac{1}{4} {\\rm Dir}(\\boldsymbol{\\theta} | (1,1,1,10)) \\tag{5.75} \\]  由于这是共轭的，我们可以很容易地计算 \\(p(\\boldsymbol{N}_t | Z_t)\\)  。 参见（Brown等人，1993）将这些想法应用于真实的生物序列问题。\n返回本章目录\n"}),a.add({id:259,href:'/notes/tags/%E5%85%88%E9%AA%8C/',title:"先验",content:""}),a.add({id:260,href:'/notes/docs/mlapp/05bayesian_statistics/0047/',title:"5.3贝叶斯模型选择",content:"返回本章目录\n在图1.18中，我们看到使用过高度数多项式会导致过拟合，而使用过低度数会导致欠拟合。类似地，在图7.8（a）中，我们看到使用太小正则化参数会导致过拟合，而太大值会导致欠拟合。一般来说，当面对一组不同复杂度的模型（即参数分布族）时，我们应该如何选择最好的模型呢？这称为模型选择问题。\n一种方法是使用交叉验证来估计所有候选模型的泛化误差，然后选择看起来最好的模型。然而，这需要将每个模型拟合K次，其中K是CV折叠的数量。一种更有效的方法是计算模型后验，\n  \\[ p(m|\\mathcal{D})=\\dfrac{p(\\mathcal{D}|m)p(m)}{\\sum_{m\\in \\mathcal{M}}(m,\\mathcal{D})} \\tag{5.12} \\]  据此, 我们可以容易计算MAP模型， \\(\\hat{m}=\\underset{m}{\\rm argmax} \\ p(m|\\mathcal{D})\\)  。这被称为贝叶斯模型选择。\n如果我们使用均匀的先验模型， \\(p(m) \\propto 1\\)  ，这相当于选择模型使得最大化的下式\n\\[ p(\\mathcal{D}|m)=\\int{p(\\mathcal{D}|\\boldsymbol{\\theta})p(\\boldsymbol{\\theta}|m)d\\boldsymbol{\\theta}} \\tag{5.13} \\]  此量被称为模型m的边际拟然，积分拟然或证据。有关如何执行此积分的详细信息将在第5.3.2节中讨论。但首先，我们会直观地解释了这个量意味着什么。\n5.3.1 贝叶斯奥卡姆剃刀 有人可能认为使用 \\(p(\\mathcal{D}|m)\\)  来选择模型总是偏爱具有最多参数的模型。如果我们使用 \\(p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}}_m)\\)  来选择模型，上述观点这是正确的，其中 \\(\\hat{\\boldsymbol{\\theta}}_m\\)  是模型 \\(m\\)  参数的MLE或MAP估计，因为具有更多参数的模型将更好地拟合数据，因此实现更高拟然。但是，如果我们对参数积分而不是最大化它们，我们会自动防止过度拟合：具有更多参数的模型不一定具有更高的边际拟然。这被称为贝叶斯奥卡姆的剃刀效应（MacKay 1995b; Murray和Ghahramani 2005），以奥卡姆剃刀的原则命名，它说应该选择能够充分解释数据的最简单的模型。\n理解贝叶斯奥卡姆剃刀的一种方法是注意到边际拟然可以根据概率链规则重写如下（公式2.5）：\n\\[ p(\\mathcal{D})=p(y_1)p(y_2|y_1)p(y_3|y_{1:2})\\dots p(y_N|y_{1:N-1}) \\tag{5.14} \\]  这里我们为了简洁而放弃了数据的 \\(x\\)  部分。这类似于拟然的留一交叉验证估计（第1.4.8节），因为给定所有以前的点我们预测了未来点。 （当然，上述表达式中数据的顺序无关紧要。）如果一个模型过于复杂，它将过拟合“早期”的例子，然后会很难预测其余的模型。\n理解贝叶斯奥卡姆剃刀效果的另一种方法是注意概率必须总和为1。因此 \\(\\sum_{\\mathcal{D}^{'}}{p(\\mathcal{D}^{'}|m)}=1\\)  ，这里的求和是对所有可能的数据集的。可以预测许多事物的复杂模型必须将它们的概率质量分散，因此任何给定数据集的简单模型都不会获得过大的概率。这有时被称为概率质量守恒原理(the conservation of probability mass principle)，如图5.6所示。在横轴上，我们按照复杂性增加的顺序绘制所有可能的数据集（在某种抽象意义上测量）。在纵轴上，我们绘制了3种可能模型的预测：一个简单的模型 \\(M_1\\)  ; 中等的 \\(M_2\\)  ; 一个复杂的 \\(M_3\\)  。我们还用垂直线表示实际观察到的数据 \\(\\mathcal{D}_0\\)  。模型1太简单，并且给 \\(\\mathcal{D}_0\\)  分配的概率很低。模型3还是指定 \\(\\mathcal{D}_0\\)  相对较低的概率，因为它可以预测许多数据集，因此它可以相当广泛和薄地传播其概率。模型2“恰到好处”：它以合理的置信度预测观测数据，但不能预测太多其他事物。因此，模型2是最可能的模型。\n 如图5.6 贝叶斯奥卡姆剃刀的示意图。宽（绿色）曲线对应于复杂模型，窄（蓝色）曲线对应于简单模型，中间（红色）曲线恰好对应。 基于（Bishop 2006a）的图3.13。 另见（Murray和Ghahramani 2005，图2）在真实数据上产生的类似图。\n 作为贝叶斯奥卡姆剃刀的具体示例，请考虑图5.7中的数据。我们绘制度数为1,2和3的多项式拟合N = 5个数据点。它还显示了模型后验，这里我们使用了一个高斯先验（详见7.6节）。没有足够的数据来证明复杂模型的合理性，因此MAP模型的d = 1。图5.8显示了当N = 30时发生什么。现在很清楚，d = 2是正确的模型（数据实际上是从二次方生成的）。\n 图5.7 (a-c) 我们使用经验贝叶斯绘制度数为1,2和3的多项式拟合N = 5个数据点。 实线绿色曲线是真实函数，虚线红色曲线是预测（蓝色虚线表示平均值周围的±σ）。 (d) 我们绘制模型后验 \\(p(d|\\mathcal{D})\\)  ，假设均匀先验 \\(p(d) \\propto 1\\)  。 基于Zoubin Ghahramani的数字。 由_linregEbModelSelVsN_生成的图。\n  图5.8 与图5.7相同，但现在N = 30.由_linregEbModelSelVsN_生成的图。\n 作为另一个例子，图7.8（c）绘制了对于多项式岭回归模型的 \\(\\log \\ p(\\mathcal{D}|\\lambda)\\)  v.s. \\(\\log(\\lambda)\\)  ，其中 \\(\\lambda\\)  在CV实验中使用的同一组值。我们看到最大证据出现在与测试MSE的最小值大致相同的点上，也对应于CV选择的点。\n当使用贝叶斯方法时，我们不限于在有限的网格值下评估证据。相反，我们可以使用数值优化来找到 \\(\\lambda^{*}=\\underset{\\lambda}{\\rm argmax} \\ p(\\mathcal{D}|\\lambda)\\)  。这种技术称为经验贝叶斯或II型最大似然（详见5.6节）。 图7.8（b）中显示了一个示例：我们看到曲线具有与CV估计相似的形状，但可以更有效地计算。\n5.3.2 计算边际拟然（证据） 在讨论固定模型的参数推断时，我们经常写成\n\\[ p(\\boldsymbol{\\theta} | \\mathcal{D}, m) \\propto p(\\boldsymbol{\\theta} | m) p(\\mathcal{D} | \\boldsymbol{\\theta}, m) \\tag{5.15} \\]  这里忽略有归一化常量 \\(p(\\mathcal{D}|m)\\)  。 这是有效的，因为 \\(p(\\mathcal{D}|m)\\)  是关于 \\(\\boldsymbol{\\theta}\\)  的常数。但是，在比较模型时，我们需要知道如何计算边际似然 \\(p(\\mathcal{D}|m)\\)  。一般来说，这可能非常困难，因为我们必须对所有可能的参数值积分，但是当我们有一个共轭先验时，它很容易计算，正如我们现在所示。\n设 \\(p(\\boldsymbol{\\theta})=q(\\boldsymbol{\\theta})/Z_0\\)  为我们的先验，其中 \\(q(\\boldsymbol{\\theta})\\)  为非归一化分布， \\(Z_0\\)  为先验的归一化常数。 令 \\(p(\\mathcal{D}|\\boldsymbol{\\theta})=q(\\mathcal{D}|\\boldsymbol{\\theta})/Z_l\\)  为拟然，其中 \\(Z_l\\)  包含似然中的所有常数因子。最后让 \\(p(\\boldsymbol{\\theta}|\\mathcal{D})=q(\\boldsymbol{\\theta}|\\mathcal{D})/Z_N\\)  为我们后验，其中 \\(q(\\boldsymbol{\\theta}|\\mathcal{D})=q(\\mathcal{D}|\\boldsymbol{\\theta})q(\\boldsymbol{\\theta})\\)  为非归一化后验， \\(Z_N\\)  为后验的归一化常数。我们有\n\\[ \\begin{aligned} p(\\boldsymbol{\\theta}|\\mathcal{D}) =\u0026\\dfrac{p(\\mathcal{D}|\\boldsymbol{\\theta})p(\\boldsymbol{\\theta})}{p(\\mathcal{D})} \\\\ \\dfrac{q(\\boldsymbol{\\theta}|\\mathcal{D})}{Z_N} =\u0026\\dfrac{q(\\mathcal{D}|\\boldsymbol{\\theta})q(\\boldsymbol{\\theta})}{Z_l Z_0p(\\mathcal{D})} \\\\ p(\\mathcal{D}) =\u0026\\dfrac{Z_N}{Z_l Z_0 } \\end{aligned} \\tag{5.16-18} \\]  因此，假设相关的归一化常数易于处理，我们有一种简单的方法来计算边际拟然。我们在下面给出一些例子。\n5.3.2.1 \\(\\beta\\)  -二项模型 让我们将上述结果应用于 \\(\\beta\\)  -二项模型。由于我们知道 \\(p(\\theta|\\mathcal{D})={\\rm Beta}(\\theta | a^{'},b^{'})\\)  ，其中 \\(a^{'} = a + N_1\\)  和 \\(b^{'} = b + N_0\\)  ，我们知道后验的归一化常数是 \\(B(a^{'},b^{'})\\)  。于是\n\\[ \\begin{aligned} p(\\theta|\\mathcal{D}) = \u0026 \\dfrac{p(\\mathcal{D}|\\theta)p(\\theta)}{p(\\mathcal{D})} \\\\ \\quad =\u0026 \\dfrac{1}{p(\\mathcal{D})} \\left[\\dfrac{1}{B(a,b)} \\theta^{a-1}(1-\\theta)^{b-1}\\right]\\left[\\binom{N}{N_1} \\theta^{N_1}(1-\\theta)^{N_0}\\right] \\\\ \\quad =\u0026 \\binom{N}{N_1}\\dfrac{1}{p(\\mathcal{D})}\\dfrac{1}{B(a,b)} \\left[ \\theta^{a+N_1-1}(1-\\theta)^{b+N_0-1}\\right] \\end{aligned} \\tag{5.19-21} \\]  所以\n\\[ \\begin{aligned} \\dfrac{1}{B(a+N_1,b+N_0)}= \u0026 \\binom{N}{N_1}\\dfrac{1}{p(\\mathcal{D})}\\dfrac{1}{B(a,b)} \\\\ p(\\mathcal{D})= \u0026 \\binom{N}{N_1}\\dfrac{B(a+N_1,b+N_0)}{B(a,b)} \\end{aligned} \\tag{5.22-23} \\]  Beta-伯努利模型的边际拟然与上述相同，只是缺少 \\(\\binom{N}{N_1}\\)  项。\n5.3.2.2 狄利克雷-多项模型 基于Beta-伯努利情形相同的原因，可知狄利克雷-多项模型的边际拟然由下式给出：\n\\[ p(\\mathcal{D})=\\dfrac{B(\\boldsymbol{N}+\\boldsymbol{\\alpha})}{B(\\boldsymbol{\\alpha})} \\tag{5.24} \\]  这里\n\\[ B(\\boldsymbol{\\alpha})=\\dfrac{\\prod_{k=1}^K{\\Gamma(\\alpha_k)}}{\\Gamma(\\sum_{k=1}^K{\\alpha_k})} \\tag{5.25} \\]  因此，我们可以用以下形式重写上述结果，这通常是文献中所呈现的：\n\\[ p(\\mathcal{D})=\\dfrac{\\Gamma(\\sum_{k=1}^K{\\alpha_k})}{\\Gamma(N+\\sum_{k=1}^K{\\alpha_k})}\\prod_{k=1}^K{\\dfrac{\\Gamma(N_k+\\alpha_k)}{\\Gamma(\\alpha_k)}} \\tag{5.26} \\]  我们稍后会看到这个等式的许多应用。\n5.3.2.3 Gaussian-Gaussian-Wishart模型 考虑共轭NIW先验的MVN情况。 令 \\(Z_0\\)  为先验的归一化常数， \\(Z_N\\)  为后验的归一化常数，并且令 \\(Z_l =(2\\pi)^{N D/2}\\)  为似然的归一化常数。 然后很容易看出来\n\\[ \\begin{aligned} p(\\mathcal{D})=\u0026\\dfrac{Z_N}{Z_0 Z_l} \\\\ \\quad =\u0026 \\dfrac{1}{\\pi^{N D /2}} \\dfrac{1}{2^{N D /2}} \\dfrac{\\left(\\dfrac{2 \\pi}{\\kappa_N}\\right)^{D/2} \\left|\\boldsymbol{S}_N\\right|^{-v_N/2} 2^{(v_0+N)D/2}\\Gamma_D(v_N/2)}{\\left(\\dfrac{2 \\pi}{\\kappa_0}\\right)^{D/2} \\left|\\boldsymbol{S}_0\\right|^{-v_0/2} 2^{v_0 D/2}\\Gamma_D(v_0/2)} \\\\ \\quad =\u0026 \\dfrac{1}{\\pi^{N D /2}} \\left(\\dfrac{\\kappa_0}{\\kappa_N}\\right)^{D/2} \\dfrac{ \\left|\\boldsymbol{S}_N\\right|^{-v_N/2} \\Gamma_D(v_N/2)}{ \\left|\\boldsymbol{S}_0\\right|^{-v_0/2} \\Gamma_D(v_0/2)} \\end{aligned} \\tag{5.27-29} \\]  这个等式将在以后证明有用。\n5.3.2.4 对数边际似然的BIC近似 通常，计算公式5.13中的积分可能非常困难。 一个简单但流行的近似被称为贝叶斯信息准则或BIC，形如下式（Schwarz 1978）：\n\\[ {\\rm BIC} \\overset{\\Delta}{=} \\log p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}})-\\dfrac{{\\rm dof}(\\hat{\\boldsymbol{\\theta}})}{2} \\log N \\approx \\log p(\\mathcal{D}) \\tag{5.30} \\]  其中 \\({\\rm dof}(\\hat{\\boldsymbol{\\theta}})\\)  是模型中的自由度， \\(\\hat{\\boldsymbol{\\theta}}\\)  是模型的MLE。 我们看到它具有惩罚对数似然的形式，其中惩罚项取决于模型的复杂性。 有关BIC分数的推导，请参阅第8.4.2节。\n例如，考虑线性回归。 正如我们在7.3节中所示，MLE由 \\(\\hat{\\boldsymbol{w}} =(\\boldsymbol{X}^T \\boldsymbol{X})^{-1}\\boldsymbol{X}^T \\boldsymbol{y}\\)  和 \\(\\hat{\\sigma}^2= {\\rm RSS}/N\\)  给出，其中 \\({\\rm RSS} = \\sum_{i = 1}^N {(y_i - \\hat{\\boldsymbol{w}}_{\\rm mle}^T \\boldsymbol{x}_i)^2}\\)  。 相应的对数似然由下式给出\n\\[ \\log p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}}) = -\\dfrac{N}{2} \\log (2\\pi\\hat{\\sigma}^2)-\\dfrac{N}{2} \\tag{5.31} \\]  于是BIC得分表示如下（删除了常数项）\n\\[ {\\rm BIC}=-\\dfrac{N}{2} \\log (\\hat{\\sigma}^2)-\\dfrac{D}{2} \\log (N) \\tag{5.32} \\]  其中D是模型中变量的数量。 在统计文献中，通常使用BIC的替代定义，我们将其称为BIC成本（因为我们希望将其最小化）：\n\\[ {\\rm BIC_{cost}}\\overset{\\Delta}{=}-2 \\log p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}}) + {\\rm dof} (\\hat{\\boldsymbol{\\theta}}) \\log N \\approx -2 \\log p(\\mathcal{D}) \\tag{5.33} \\]  在线性回归的背景下，这变成了\n\\[ {\\rm BIC_{cost}}=N \\log (\\hat{\\sigma}^2)+D \\log (N) \\tag{5.34} \\]  BIC方法与最小描述长度(minimum description length)或MDL原则密切相关，MDL原理表征模型在数据拟合程度方面的得分，再减去模型定义的复杂程度的扣分。 有关详细信息，请参阅（Hansen和Yu 2001）\n还有一个和BIC / MDL的表达式非常相似准则，称为赤池信息量准则(Akaike information criterion)或AIC，定义为\n\\[ {\\rm AIC}(m,\\mathcal{D})\\overset{\\Delta}{=} \\log p(\\mathcal{D}|\\hat{\\boldsymbol{\\theta}}_{\\rm MLE})-{\\rm dof}(m) \\tag{5.35} \\]  这源于频率派框架，不能解释为边际拟然的近似值。 然而，这种表达形式与BIC非常相似。 我们看到AIC的罚款低于BIC。 这导致AIC选择更复杂的模型。 但是，这可以带来更好的预测准确性。 参见例如（Clarke等人，2009，第10.2节）以进一步讨论此类信息标准。\n5.3.2.5 先验的影响 有时候不清楚如何设置先验。 当我们进行后验推理时，先验的细节可能并不重要，因为无论如何这种拟然通常会压倒先验。 但是在计算边际拟然时，先验发挥了更重要的作用，因为我们要先验为权重，对所有可能的参数设置的拟然进行平均。\n在图5.7和5.8中，我们展示了线性回归的模型选择，我们使用形如 \\(p(\\boldsymbol{w})=\\mathcal{N}(\\boldsymbol{0}，\\alpha^{-1} \\boldsymbol{I})\\)  的先验。 这里 \\(\\alpha\\)  是一个调整参数，用于控制先验的强度。 正如我们在7.5节中讨论的那样，这个参数会产生很大的影响。 直观地，如果 \\(\\alpha\\)  很大，则“强制”权重变小，因此我们需要使用具有许多小参数（例如，高次多项式）的复杂模型来拟合数据。 相反，如果 \\(\\alpha\\)  很小，我们将倾向于更简单的模型，因为每个参数“允许”大量变化。\n如果先验未知，则正确的贝叶斯过程是添加一个先验作为先验。 也就是说，我们应该在超参数 \\(\\alpha\\)  也添加加上一个先验, 正如参数 \\(\\boldsymbol{w}\\)  上的先验。 为了计算边际拟然，我们应该对所有参数进行积分，即我们应该计算\n\\[ p(\\mathcal{D}|m)=\\iint {p(\\mathcal{D}|\\boldsymbol{w})p(\\boldsymbol{w}|\\alpha,m)p(\\alpha|m)d\\boldsymbol{w}d\\alpha} \\tag{5.36} \\]  当然，这需要指定超先验(译者注: 超参数对应的先验)。 幸运的是，我们在贝叶斯层次结构中越高，对先验设置的结果越不敏感。 因此，我们通常可以使超先验无信息。\n计算捷径是优化α而不是将其积分。 也就是说，我们使用\n\\[ p(\\mathcal{D}|m) \\approx \\int {p(\\mathcal{D}|\\boldsymbol{w})p(\\boldsymbol{w}|\\hat{\\alpha},m)d\\boldsymbol{w}} \\tag{5.37} \\]  其中\n\\[ \\hat{\\alpha} =\\underset{\\alpha}{\\rm argmax} \\ p(\\mathcal{D}|\\alpha,m)=\\underset{\\alpha}{\\rm argmax} \\ \\int {p(\\mathcal{D}|\\boldsymbol{w})p(\\boldsymbol{w}|\\alpha,m)d\\boldsymbol{w}} \\tag{5.38} \\]  这种方法称为经验贝叶斯（EB），在5.6节中有更详细的讨论。 这是图5.7和5.8中使用的方法。\n5.3.3 贝叶斯因子 假设我们模型的先验是均匀的， \\(p(m) \\propto 1\\)  。那么模型选择相当于选择边际拟然最高的模型。 现在假设我们只有两个我们正在考虑的模型，称之为零假设 \\(M_0\\)  和替代假设 \\(M_1\\)  。 将贝叶斯因子定义为边际拟然的比率：\n\\[ {\\rm BF}_{1,0} \\overset{\\Delta}{=} \\dfrac{p(\\mathcal{D}|M_1)}{p(\\mathcal{D}|M_0)} = \\dfrac{p(M_1|\\mathcal{D})}{p(M_0|\\mathcal{D})} / \\dfrac{p(M_1)}{p(M_0)} \\tag{5.39} \\]  （这就像一个似然比，除了对参数积分，这使我们可以比较不同复杂度的模型。）如果 \\({\\rm BF}_{1,0}  1\\)  ，那么我们更喜欢模型1，否则我们更喜欢模型0。\n当然， \\({\\rm BF}_{1,0}\\)  可能仅是略大于1。在这种情况下，我们不太相信模型1更好。Jeffreys（1961）提出了一个解释贝叶斯因子大小的证据量表，如表5.1所示。 这是对频率派p值(p-value)概念的贝叶斯替代。 另外，我们可以将贝叶斯因子转换为后验模型。 如果 \\(p(M_1)= p(M_0)= 0.5\\)  ，我们有\n\\[ p(M_0|\\mathcal{D}) = \\dfrac{{\\rm BF}_{0,1}}{1+{\\rm BF}_{0,1}} = \\dfrac{1}{1+{\\rm BF}_{1,0}} \\tag{5.40} \\]  5.3.3.1 示例：测试硬币是否公平 假设我们观察了一些硬币投掷，并且想要确定数据是由公平硬币生成的， \\(\\theta= 0.5\\)  ，还是可能有偏差的硬币，其中 \\(\\theta\\)  可以是 \\([0,1]\\)  中的任何值。 让我们用 \\(M_0\\)  表示第一个模型，用 \\(M_1\\)  表示第二个模型。 \\(M_0\\)  下的边际拟然简单如下\n\\[ p(\\mathcal{D}|M_0)=\\left(\\dfrac{1}{2}\\right)^N \\tag{5.41} \\]  其中 \\(N\\)  是硬币投掷次数。 \\(M_1\\)  使用Beta先验的边际拟然\n\\[ p(\\mathcal{D}|M_1)=\\int{p(\\mathcal{D}|\\theta)p(\\theta)d\\theta} = \\dfrac{{\\rm B}(\\alpha_1+N_1, \\alpha_0+N_0)}{{\\rm B}(\\alpha_1, \\alpha_0)}\\tag{5.42} \\]  图5.9（a）中，我们绘制 \\(\\log p(\\mathcal{D} | M_1)\\)  与\u0026quot;正面\u0026quot;次数 \\(N_1\\)  的关系，假设 \\(N = 5\\)  且 \\(\\alpha_1=\\alpha_0= 1\\)  .（曲线的形状对 \\(\\alpha_1\\)  和 \\(\\alpha_0\\)  不是很敏感，只要 因为 \\(\\alpha_1=\\alpha_0\\)  。） 如果我们观察到2\u0026quot;正面\u0026quot;或3个\u0026quot;正面\u0026quot;，则无偏硬币假设 \\(M_0\\)  比 \\(M_1\\)  更可能，因为 \\(M_0\\)  是一个更简单的模型（它没有自由参数） - 如果硬币有偏差，那将是一个可疑的巧合 但碰巧产生了几乎正好50/50的\u0026quot;正\u0026quot;/\u0026ldquo;反\u0026rdquo;。 然而，随着计数变得更加极端，我们赞成有偏见的硬币假设。 注意，如果我们绘制对数贝叶斯因子， \\(\\log {\\rm BF}_{1,0}\\)  ，它将具有完全相同的形状，因为 \\(\\log p(\\mathcal{D} | M_0)\\)  是常量。 另见练习3.18。\n在图5.9（b）中显示了5.3.3节中我们偏置硬币示例 \\(\\log p(\\mathcal{D} | M_1)\\)  的BIC近似值。 我们看到曲线与精确的对数边际似然具有大致相同的形状，这对于模型选择目的而言都很重要，因为绝对尺度是无关紧要的。 特别是，它支持更简单的模型，除非数据绝大多数支持更复杂的模型。\n 图5.9 （a）硬币示例的对数边际拟然。 （b）BIC近似。 由_coinsModelSelDemo_生成的图。\n 5.3.4 杰弗里斯 - 林德利悖论 (Jeffreys-Lindley paradox)* 当我们使用不适当的先验（即，先验没有归一化）进行模型选择/假设检验时可能会出现问题，即使这些先验可能是其他目的可接受的。 例如，考虑两个测试假设 \\(M_0:\\theta \\in \\Theta_0\\)  v.s. \\(M_1:\\theta \\in \\Theta_1\\)  。 为了定义 \\(\\theta\\)  上的边际密度，我们使用以下混合模型\n\\[ p(\\theta) = p(\\theta | M_0) p(M_0) + p(\\theta | M_1) p(M_1) \\tag{5.43} \\]  这仅在 \\(p(\\theta | M_0)\\)  和 \\(p(\\theta | M_1)\\)  是适当的（归一化的）密度函数时才有意义。 在这种情况下，后验是由下式给出\n\\[ \\begin{aligned} p(M_0|\\mathcal{D})=\u0026 \\dfrac{p(M_0)p(\\mathcal{D}|M_0)}{p(M_0)p(\\mathcal{D}|M_0) + p(M_1)p(\\mathcal{D}|M_1)} \\\\ \\quad = \u0026 \\dfrac{p(M_0) \\int_{\\Theta_0}{p(\\mathcal{D}|\\theta) p(\\theta|M_0) d\\theta} }{p(M_0)\\int_{\\Theta_0}{p(\\mathcal{D}|\\theta) p(\\theta|M_0) d\\theta} + p(M_1)\\int_{\\Theta_1}{p(\\mathcal{D}|\\theta) p(\\theta|M_1) d\\theta}} \\end{aligned} \\tag{5.44-45} \\]  现在假设我们使用不恰当的先验， \\(p(\\theta | M_0) \\propto c_0\\)  和 \\(p(\\theta | M_1) \\propto c_1\\)  。 那么\n\\[ \\begin{aligned} p(M_0|\\mathcal{D})=\u0026 \\dfrac{p(M_0) c_0 \\int_{\\Theta_0} {p(\\mathcal{D}|\\theta) d\\theta} }{p(M_0) c_0 \\int_{\\Theta_0}{p(\\mathcal{D}|\\theta) d\\theta} + p(M_1)c_1\\int_{\\Theta_1}{p(\\mathcal{D}|\\theta) d\\theta}} \\\\ \\quad = \u0026 \\dfrac{p(M_0) c_0 l_0 }{p(M_0) c_0 l_0 + p(M_1)c_1l_1} \\end{aligned} \\tag{5.46-47} \\]  其中 \\(l_i=\\int_{\\Theta_i} {p(\\mathcal{D}|\\theta) d\\theta}\\)  是关于第 \\(i\\)  个模型的积分，或边际拟然。现在令 \\(p(M_0)=p(M_1)=\\frac{1}{2}\\)  。于是\n\\[ p(M_0|\\mathcal{D})=\\dfrac{ c_0 l_0 }{ c_0 l_0 + c_1l_1}=\\dfrac{ l_0 }{l_0 + (c_1/c_0)l_1} \\tag{5.48} \\]  因此，我们可以随意选择 \\(c_1\\)  和 \\(c_0\\)  来任意改变后验。 请注意，使用适当但非常模糊的先验可能会导致类似的问题。 特别是，贝叶斯因子总是倾向于更简单的模型，因为在具有非常分散的先验的复杂模型下，观测数据的概率将非常小。 这被称为杰弗里斯 - 林德利悖论。\n因此，在进行模型选择时使用适当的先验是很重要的。 但是，请注意，如果 \\(M_0\\)  和 \\(M_1\\)  在参数的子集上共享相同的先验，那么部分先验可能是不恰当的，因为相应的归一化常数将被抵消。\n返回本章目录\n"}),a.add({id:261,href:'/notes/tags/%E5%A5%A5%E5%8D%A1%E5%A7%86%E5%89%83%E5%88%80/',title:"奥卡姆剃刀",content:""}),a.add({id:262,href:'/notes/tags/%E6%A8%A1%E5%9E%8B%E9%80%89%E6%8B%A9/',title:"模型选择",content:""}),a.add({id:263,href:'/notes/tags/%E8%AF%81%E6%8D%AE/',title:"证据",content:""}),a.add({id:264,href:'/notes/tags/%E8%BE%B9%E9%99%85%E6%8B%9F%E7%84%B6/',title:"边际拟然",content:""}),a.add({id:265,href:'/notes/docs/mlapp/05bayesian_statistics/0046/',title:"5.2 后验分布总结",content:"返回本章目录\n后验   \\(p(\\boldsymbol{\\theta} | \\mathcal{D})\\)  总结了我们所知道的关于未知量 \\(\\boldsymbol{\\theta}\\)  的一切。 在本节中，我们将讨论一些可以从概率分布中导出的简单量，例如后验。这些摘要统计数据通常比完整联合更容易理解和可视化。\n5.2.1 最大后验估计(MAP) 我们可以通过计算后验均值，中位数或众数来轻松计算未知量的点估计。在5.7节中，我们讨论了如何使用决策理论在这些方法之间进行选择。通常，后验均值或中位数是实际评估数量的最合适选择，后验边缘向量是离散量的最佳选择。然而，后验众数，即MAP估计，是最受欢迎的选择，因为它归结到优化问题，对于该优化问题，通常存在有效算法。此外，通过将对数先验视为正则化器，可以用非贝叶斯项来解释MAP估计（更多细节见6.5节）。\n虽然这种方法具有计算吸引力，但重要的是要指出MAP估计存在各种缺点，我们将在下面简要讨论。这将为我们在本章后面（以及本书的其他部分）更彻底研究贝叶斯方法提供动力。\n5.2.1.1 无法度量不确定性 MAP估计的最明显的缺点，实际上是任何其他点估计(例如后验均值或中位数)的缺点，就是它不提供不确定性的任何度量。在许多应用中，重要的是要知道可以多大程度上信任给定估计的。正如我们在5.2.2节中讨论的那样，我们可以从后验推导出这种置信度量。\n5.2.1.2 MAP估计插入可能导致过拟合 在机器学习中，我们通常更关心预测准确性，而不是解释模型的参数。但是，如果我们不对参数中的不确定性进行建模，那么我们的预测分布就会过于自信。我们在第3章中看到了几个这样的例子，我们稍后会看到更多的例子。在我们可能厌恶风险的情况下，过度自信的预测尤其成问题; 详见5.7节。\n5.2.1.3 众数是一个非典型点 选择众数作为后验分布的摘要通常是一个非常糟糕的选择，因为众数通常是非常不典型的分布，不像平均值或中位数。 对于1d连续空间，如图5.1（a）所示。基本问题是众数是零测度点，而平均值和中值考虑空间体积。 另一个例子如图5.1（b）所示：这里众数为0，但均值为非零。 在推断方差参数时，尤其是在分层模型中，通常会出现这种偏差分布。在这种情况下，MAP估计（以及因此MLE）显然是非常糟糕的估计。\n 图5.1 （a）双峰分布，其中众数非常不典型。细蓝色垂直线是均值，可以说是分布的更好总结，因为它接近概率质量的大部分。由_bimodalDemo_生成的图。（b）偏差分布，其中众数与均值完全不同。由_gammaPlotDemo_生成的图。\n 如果众数不是一个好的选择，我们应该如何摘要后验？ 答案是使用决策理论，我们将在5.7节中讨论。基本思想是指定一个损失函数，其中 \\(L(\\theta,\\hat{\\theta})\\)  是你发生的损失，如果事实是 \\(\\theta\\)  而你的估计是 \\(\\hat{\\theta})\\)  。如果我们使用0-1损失， \\(L(\\theta,\\hat{\\theta})=\\mathbb{I}(\\theta \\ne \\hat{\\theta})\\)  ，则最优估计是后验众数。0-1损失意味着如果你没有错误，你只能获得“积分”，否则你什么也得不到：在这个损失函数下没有“部分信用”！对于连续值，我们通常更喜欢使用平方误差损失， \\(L(\\theta,\\hat{\\theta})=(\\theta-\\hat{\\theta})^2\\)  ; 然后，相应的最优估计是后验均值，如5.7节所示。或者我们可以使用更鲁棒的损失函数， \\(L(\\theta,\\hat{\\theta})=\\left|\\theta-\\hat{\\theta}\\right |\\)  ，这会产生后验中位数。\n5.2.1.4 MAP估计对重新参数化是不变的*  图5.2 非线性变换下密度变换的例子。注意变换分布的众数不是原始众数的变换。 基于（Bishop 2006b）的练习1.4。由_bayesChangeOfVar_生成的图。\n MAP估计的一个更微妙的问题是我们得到的结果取决于我们如何参数化概率分布。从一个表示变换到另一个等效表示结果变了，这是不太理想的，因为测量单位是任意的（例如，当测量距离时，我们可以使用厘米或英寸）。\n要理解这个问题，假设我们计算 \\(x\\)  的后验。如果我们定义 \\(y = f(x)\\)  ，则 \\(y\\)  的分布由公式2.87给出，为方便起见，我们在此再写一遍：\n\\[ p_y(y)=p_x(x)\\left|\\dfrac{dx}{dy}\\right| \\tag{5.1} \\]   \\(\\left|\\dfrac{dy}{dx}\\right|\\)  项称为雅可比式(其推广便是雅可比行列式)，它度量单位量经过 \\(f\\)  所引起的变化的大小。设 \\(\\hat{x}=\\underset{x}{\\rm argmax} \\ p_x(x)\\)  为 \\(x\\)  的MAP估计。一般来说， \\(\\hat{y}=\\underset{y}{\\rm argmax} \\ p_y(y)\\)  不是由 \\(\\hat{x}\\)  给出。 比如：设 \\(x \\sim \\mathcal{N}(6,1)\\)  和 \\(y=f(x)\\)  ，这里\n\\[ f(x)=\\dfrac{1}{1+\\exp (-x+5)} \\tag{5.2} \\]  我们可以使用蒙特卡罗模拟得出 \\(y\\)  的分布（参见第2.7.1节）。 结果如图5.2所示。我们看到原始高斯已经被非线性的S函数(sigmoid)“压扁”。特别地，我们看到变换分布的众数不等于原始众数的变换。\n要了解在MAP估计的背景下如何出现此问题，请考虑以下由于Michael Jordan提供的示例。伯努利分布通常由其均值 \\(\\mu\\)  参数化，因此 \\(p(y=1 | \\mu)=\\mu\\)  ，其中 \\(y \\in \\{0,1\\}\\)  。假设我们在单位区间上有一个均匀的先验： \\(p_{\\mu}(\\mu)=\\mathbb{I}(0 \\le \\mu \\le 1)\\)  。如果没有数据，MAP估计只是先验的众数，可以是0到1之间的任何值。我们现在将展示不同的参数化可以任意选择该区间中的不同点。\n首先设 \\(\\theta=\\sqrt{\\mu}\\)  ，于是 \\(\\mu = \\theta^2\\)  。那么新的先验是\n\\[ p_{\\theta}(\\theta)=p_{\\mu}(\\mu)\\left|\\dfrac{d\\mu}{d\\theta}\\right|=2 \\theta \\tag{5.3} \\]  对 \\(\\theta \\in [0,1]\\)  ，于是新的众数是\n\\[ \\hat{\\theta}_{\\rm MAP} = \\underset{\\theta \\in [0,1]}{\\rm argmax} \\ 2\\theta=1 \\tag{5.4} \\]  现在设 \\(\\phi=1-\\sqrt{1-\\mu}\\)  。那么新的先验是\n\\[ p_{\\phi}(\\phi)=p_{\\mu}(\\mu)\\left|\\dfrac{d\\mu}{d\\phi}\\right|=2 (\\phi - 1) \\tag{5.5} \\]  对 \\(\\phi \\in [0,1]\\)  ，新的众数是\n\\[ \\hat{\\phi}_{\\rm MAP} = \\underset{\\phi \\in [0,1]}{\\rm argmax} \\ 2 (\\phi - 1)=0 \\tag{5.6} \\]  因此，MAP估计取决于参数化。MLE不会受此影响，因为拟然是函数，而不是概率密度。贝叶斯推断也不会遇到这个问题，因为在参数空间上积分时会考虑度量的变换。该问题的一个解决方案是优化以下目标函数：\n\\[ \\hat{\\boldsymbol{\\theta}}=\\underset{\\theta}{\\rm argmax} \\ p(\\mathcal{D} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\\left|\\boldsymbol{I}(\\boldsymbol{\\theta})\\right|^{-\\frac{1}{2}} \\tag{5.7} \\]  这里 \\(\\boldsymbol{I}(\\boldsymbol{\\theta})\\)  是与 \\(p(\\boldsymbol{x} | \\boldsymbol{\\theta})\\)  相关的Fisher信息矩阵(the Fisher information matrix)（见6.2.2节）。由于（Jermyn 2005; Druilhet and Marin 2007）中解释的原因，该估计是参数化独立的。不幸的是，公式5.7的优化通常很困难，这最大程度上减少了整个方法的吸引力。\n5.2.2 可信区间(Credible intervals)  译者注: 本节稍后会区分: 频率派的置信区间(confidence intervals) 和 贝叶斯的可信区间(Credible intervals)。\n 除了点估计，我们常需要一定可信度。 某些（标量）量 \\(\\theta\\)  的标准置信度是其后验分布的“宽度”。这可以使用 \\(100 (1-\\alpha)\\%\\)  可信区间来度量，该区间是（连续的）区域 \\(C=(l,u)\\)  （代表下上界），其包含后验概率质量的 \\(1-\\alpha\\)  ，即，\n\\[ C_{\\alpha}(\\mathcal{D})=(l,u):P(l \\le \\theta \\le u | \\mathcal{D})=1-\\alpha \\tag{5.8} \\]  可能这样的区间有很多(不唯一)，所以我们选择一个这样的区间，两边尾部有 \\((1-\\alpha)/2\\)  质量; 这被称为中央区间(置信区间的一个特例)。\n如果后验具有已知的函数形式，我们可以使用 \\(l=F^{-1}(\\alpha/2)\\)  和 \\(u=F^{-1}(1-\\alpha/2)\\)  计算后验中心区间，其中F是后验的cdf。例如，如果后验是高斯的， \\(p(\\theta | \\mathcal{D})=\\mathcal{N}(0,1)\\)  和 \\(\\alpha=0.05\\)  ，那么我们有 \\(l=\\Phi(\\alpha/2)=-1.96\\)  和 \\(l=\\Phi(1-\\alpha/2)=1.96\\)  ，其中 \\(\\Phi\\)  表示高斯的cdf。如图2.3（c）所示。这证明了以 \\(\\mu \\pm 2 \\sigma\\)  形式表示可信区间这种通常做法，其中 \\(\\mu\\)  表示后验均值， \\(\\sigma\\)  表示后验标准差，2是对1.96的良好近似。\n当然后验不总是高斯的。例如，在我们的硬币示例中，如果我们使用均匀先验并且我们观察 \\(N=100\\)  个试验中的 \\(N_1=47\\)  个\u0026quot;正面\u0026quot;，那么后验是β分布， \\(p(\\theta | \\mathcal{D})={\\rm Beta}(48,54)\\)  。 我们发现95％后验可信区间是 \\((0.3749,0.5673)\\)  （参见我们用来计算本行的Matlab代码的betaCredibleInt中的一行）。\n如果我们不知道函数形式，但我们可以从后验绘制样本，那么我们可以使用蒙特卡罗逼近后验分位数：我们简单地对 \\(S\\)  个样本进行排序，并沿着排序列表找到在 \\(\\alpha/S\\)  位置发生的样本 。当 \\(S \\to \\infty\\)  时，这会收敛到真正的分位数。 有关演示，请参阅_mcQuantileDemo_。\n人们经常混淆贝叶斯可信区间(Credible intervals)与频率派的置信区间(confidence intervals)。但是，它们并不是一样的，正如我们在6.6.1节中讨论的那样。一般来说，可信区间通常是人们想要计算的区间，但置信区间通常是他们实际计算的区间，因为大多数人都是被频率派统计教导而不是贝叶斯统计。幸运的是，计算可信区间的机制与计算置信区间一样简单（例如，如何在Matlab中计算, 参见betaCredibleInt）。\n5.2.2.1 最高后验密度区域 * 中心区间的问题是在CI之外可能存在具有较高概率密度的点。如图5.3（a）所示，我们看到最左侧CI边界外的点的密度高于最右侧CI边界内的点。\n 如图5.3 (a) 中心区间和 (b) Beta(3,9)先验的HPD区域。 CI (0.06, 0.52) 和 HPD (0.04, 0.48)。基于（Hoff 2009）的图3.6。 由_betaHPD_生成的图。\n 这引入了被称作最高后验密度或HPD区域的替代量。这被定义为总共构成概率质量 \\(100 (1-\\alpha)\\%\\)  的最可能（的一组）点。更正式地，我们在pdf上找到阈值 \\(p^{*}\\)  ，使得\n\\[ 1-\\alpha = \\int_{\\theta:p(\\theta|\\mathcal{D})p^{*}}{p(\\theta|\\mathcal{D})d\\theta} \\tag{5.9} \\]  然后将HPD定义为\n\\[ C_{\\alpha}=\\{\\theta:p(\\theta|\\mathcal{D})\\ge p^{*}\\} \\tag{5.10} \\]  在1维中，HPD区域有时被称为最高密度区间或HDI。例如，图5.3（b）显示了Beta（3,9）分布的95％HDI，即（0.04,0.48）。我们看到它比CI更窄，尽管它仍然包含95％的质量; 此外，它内部的每个点都具有比其外部的每个点更高的密度。\n对于单峰分布，HDI将是围绕众数且包含95％质量的的最窄区间。为了看到这一点，想象一下“注水”的反向(译者注: \u0026ldquo;抽水\u0026quot;可以使得水平面降低)，我们降低水平面直到95％的质量被揭示，只有5％被淹没。这给出了在1维情况下计算HDI的简单算法：简单地搜索点，使得区间包含95％的质量并且具有最小宽度。如果我们知道分布的逆CDF，或者通过搜索已排序数据点（如果我们有一袋样本），那么可以通过1维数值优化来完成（参见演示的_betaHPD_）。\n如果后验是多峰的，则HDI甚至可能不是连通区域：例如，见图5.4（b）。 然而，总结多峰后验总是很困难。\n 图5.4 (a) 中心区间和 (b) 基于多峰后验假设的HPD区域。 基于图2.2（Gelman等人，2004）。_postDensityIntervals_生成的图。\n 5.2.3 比例差异推断(Inference for a difference in proportions) 有时我们有多个参数，我们有兴趣计算这些参数的某些函数的后验分布。例如，假设您即将从Amazon.com购买东西，并且有两个卖家以相同的价格提供它。卖家1有90条正面评价和10条负面评价。卖家2有2条正面评价和0条负面评价。 你应该买谁？\n从表面上看，你应该选择卖家2，但我们不能非常确信卖家2更好，因为它的评论很少。在本节中，我们勾画这个问题的贝叶斯分析。对各种其他设置的组, 可用类似的方法比较其比率或比例。\n设 \\(\\theta_1\\)  和 \\(\\theta_2\\)  是两个卖家的未知可靠性。由于我们对它们知之甚少，我们将赋予它们均匀的先验， \\(\\theta_i \\sim {\\rm Beta}(1,1)\\)  。后验就是 \\(p(\\theta_1 | \\mathcal{D}_1)={\\rm Beta}(91,11)\\)  和 \\(p(\\theta_2 | \\mathcal{D}_2)={\\rm Beta}(3,1)\\)  。\n我们希望计算 \\(p(\\theta_1\\theta_2)\\)  。为方便起见，我们将 \\(\\delta=\\theta_1-\\theta_2\\)  定义为比率的差异。（或者我们可能希望工作在对数优势比项上。）我们可以使用数值积分计算所需要的量：\n\\[ \\begin{aligned} p(\\delta0|\\mathcal{D})=\u0026\\int_0^1{\\int_0^1{\\mathbb{I}(\\theta_1\\theta_2){\\rm Beta}(\\theta_1|y_1+1,N_1-y_1+1)}}\\\\ \\quad \u0026 {\\rm Beta}(\\theta_2|y_2+1,N_2-y_2+1)d\\theta_1 d\\theta_2 \\end{aligned} \\tag{5.11} \\]  我们发现 \\(p(\\delta0|\\mathcal{D})=0.710\\)  ，这意味着你最好从卖家1购买！有关代码，请参阅_amazonSellerDemo_。 （也可以通过解这个积分分析问题（Cook2005）。）\n解决这个问题的一种更简单的方法是通过蒙特卡罗采样来近似后验 \\(p(\\delta|\\mathcal{D})\\)  。这很容易，因为 \\(\\theta_1\\)  和 \\(\\theta_2\\)  是后验独立的，并且都具有β分布，可以使用标准方法对其进行采样。分布 \\(p(\\theta_i|\\mathcal{D})\\)  如图5.5（a）所示，对 \\(p(\\delta|\\mathcal{D})\\)  的MC近似，以及95％HPD，如图5.5（b）所示。 通计数 \\(\\theta_1\\theta_2\\)  的样本占比，得到对 \\(p(\\delta0|\\mathcal{D})\\)  的MC近似。 结果是0.718，非常接近确切的值。 （有关代码，请参阅amazonSellerDemo。）\n 如图5.5 (a) 精确后验 \\(p(\\theta_i|\\mathcal{D})\\)  。 (b) 蒙特卡罗近似到 \\(p(\\delta|\\mathcal{D})\\)  。 我们使用核密度估计来获得平滑的图。 垂直线包围95％的中心间隔。 由_amazonSellerDemo_生成的图。\n 返回本章目录\n"}),a.add({id:266,href:'/notes/tags/%E4%BC%B0%E8%AE%A1/',title:"估计",content:""}),a.add({id:267,href:'/notes/tags/%E5%8F%AF%E4%BF%A1%E5%8C%BA%E9%97%B4/',title:"可信区间",content:""}),a.add({id:268,href:'/notes/tags/%E6%8E%A8%E6%96%AD/',title:"推断",content:""}),a.add({id:269,href:'/notes/docs/mlapp/05bayesian_statistics/0045/',title:"5.1 导言",content:"返回本章目录\n我们已经看到了各种不同的概率模型，并且也讨论了如何拟合数据，即我们讨论过使用各种不同的先验来计算MAP参数估计   \\(\\hat{\\boldsymbol{\\theta}}={\\rm argmax} \\ p(\\boldsymbol{\\theta} | \\mathcal{D})\\)  。 我们还讨论了对于某些特殊情况如何计算完整的后验 \\(p(\\boldsymbol{\\theta} | \\mathcal{D})\\)  ，以及后验预测密度 \\(p(\\boldsymbol{x} | \\mathcal{D})\\)  （在后面的章节中，我们将讨论一般情况下的算法）。\n使用后验分布来总结我们对未知变量集的了解，这是贝叶斯统计的核心。 在本章中，我们将更详细地讨论这种统计方法。 在第6章中，我们讨论了一种称为频率统计或经典统计的替代统计方法。\n返回本章目录\n"}),a.add({id:270,href:'/notes/docs/mlapp/05bayesian_statistics/',title:"第五章 贝叶斯统计",content:"第五章 贝叶斯统计 本节中的目录：\n  5.1 导言\n  5.2 后验分布总结\n  5.3 贝叶斯模型选择\n  5.4 先验\n  5.5 分层贝叶斯\n  5.6 经验贝叶斯\n  5.7 贝叶斯决策理论\n  习题\n  "}),a.add({id:271,href:'/notes/docs/mlapp/04gaussian_models/',title:"第四章 高斯模型",content:"待续\n"}),a.add({id:272,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0044/',title:"Exercises",content:"返回本章目录\n"}),a.add({id:273,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0043/',title:"3.5 朴素贝叶斯分类器",content:"返回本章目录\n在本节中，我们将讨论如何对离散值特征的向量进行分类，   \\(\\boldsymbol{x} \\in {1,\\dots,K}^D\\)  ，其中 \\(K\\)  是每个特征的值域数， \\(D\\)  是特征的数量。我们将使用生成方法。这要求我们指定类条件分布 \\(p(\\boldsymbol{x} | y=c)\\)  。最简单的方法是假设特征是条件独立的, 对给定类标签。这使我们可以将类条件密度写成一维密度的乘积:\n\\[ p(\\boldsymbol{x} | y=c, \\boldsymbol{\\theta}) = \\prod_{j=1}^D {p(\\boldsymbol{x}_j | y=c, \\theta_{jc}) } \\tag{3.54} \\]  此模型被称为 朴素贝叶斯分类器 （NBC）。\n该模型被称为“朴素”，因为我们不希望这些特征是独立的，即使是以类标签为条件。然而，即使朴素贝叶斯假设不正确，它也常常导致分类法运作良好（Domingos and Pazzani 1997）。其中一个原因是该模型非常简单（它只有 O（CD） 参数，对于 C个类 和 D个特征），因此它相对不受过拟合的影响。\n类条件密度的形式依赖于每个特征的类型。我们给出一些可能性：\n 实值特征的情况下，我们可以使用高斯分布： \\(p(\\boldsymbol{x} | y=c, \\boldsymbol{\\theta}) = \\prod_{j=1}^D {\\mathcal{N}(x_j | \\mu_{jc}, \\sigma_{jc}^2)}\\)  ，其中 \\(\\mu_{jc}\\)  是c类对象的特征 \\(j\\)  的均值，而 \\(\\sigma_{jc}^2\\)  是对应的方差。 二值特征的情况下， \\(x_j \\in \\{0,1\\}\\)  ，我们可以使用贝努利分布 ： \\(p(\\boldsymbol{x} | y=c, \\boldsymbol{\\theta}) = \\prod_{j=1}^D {{\\rm Ber}(x_j | \\mu_{jc})}\\)  ，其中 \\(\\mu_{jc}\\)  是c类对象的特征 \\(j\\)  发生的概率。有时称之为 多变量伯努利朴素贝叶斯模型。我们将在下面看到它的一个应用。 在多值分类特征的情况下， \\(x_j \\in \\{1,\\dots,K\\}\\)  ，我们可以使用多项分布建模： \\(p(\\boldsymbol{x} | y=c, \\boldsymbol{\\theta}) = \\prod_{j=1}^D {{\\rm Cat}(x_j | \\boldsymbol{\\mu}_{jc})}\\)  ，其中 \\(\\boldsymbol{\\mu}_{jc}\\)  是c类中 \\(x_j\\)  的 \\(K\\)  个可能值的直方图。  显然，我们可以处理其他类型的特征，或使用不同的分布假设。此外，它很容易混合和匹配不同类型的特征。\n3.5.1 模型拟合 我们现在讨论如何“训练”一个朴素的贝叶斯分类器。这通常意味着计算带参数的MLE或MAP估计。但是，我们还将讨论如何计算完整的后验: \\(p(\\boldsymbol{\\theta} | \\mathcal{D})\\)  。\n3.5.1.1 NBC的MLE 单个数据情况的概率表示如下(译者注: 这里进行了参数的重新编排) :\n\\[ p(\\boldsymbol{x}_i, y_j | \\boldsymbol{\\theta})=p(y_i | \\boldsymbol{\\pi}) \\prod_j {p(x_{ij} | \\boldsymbol{\\theta}_j)}=\\prod_c {\\pi_c^{\\mathbb{I}(y_i=c)}} \\prod_j {\\prod_c {p(x_{ij} | \\boldsymbol{\\theta}_{jc})^{\\mathbb{I}(y_i=c)}}} \\tag{3.55} \\]  因此，对数似然由下式给出:\n\\[ {\\rm log} \\ p(\\mathcal{D} | \\boldsymbol{\\theta})= \\sum_{c=1}^C {N_c {\\rm log} \\ \\pi_c} + \\sum_{j=1}^D {\\sum_{c=1}^C { \\sum_{i:y_i=c} {{\\rm log} \\ p(x_{ij} | \\boldsymbol{\\theta}_{jc})}}} \\tag{3.56} \\]  我们看到，这个表达式分解成一系列的项，第一项是关于参数 \\(\\boldsymbol{\\pi}\\)  的，而DC项是关于参数 \\(\\boldsymbol{\\theta}_{jc}\\)  的。因此，我们可以分别优化所有这些参数。\n依据公式3.48，关于类先验的MLE可表示如下:\n\\[ \\hat{\\pi}_c = \\dfrac{N_c}{N} \\tag{3.57} \\]  其中 \\(N_c \\overset{\\Delta}{=} \\sum_i {\\mathbb{I}(y_i=c)}\\)  是c类的样本数。\n对这个拟然的的MLE依赖于我们为每个特征选择分布类型。为简单起见，我们假设所有特征是二项的，于是 \\(\\boldsymbol{x}_j | y=c \\propto {\\rm Ber}(\\theta_{jc})\\)  。在这种情况下，MLE变为:\n\\[ \\hat{\\theta}_{jc} = \\dfrac{N_{jc}}{N} \\tag{3.58} \\]  可以非常简单地实现该模型拟合程序：见算法8提供的伪代码（及 Matlab代码_naiveBayesFit_ ）。该算法显然需要 \\(O(N D)\\)  时间。该方法易于推广以处理混合类型的特征。这种简单性是该方法有如此广泛使用的一个原因。\n图3.8给出了一个2个类和600个二项特征的示例，用于表示在词袋模型中是否存在单词。绘制了关于2个类的 \\(\\boldsymbol{\\theta}_c\\)  向量的可视化。索引107处的大峰值对应于单词“subject”，它t同时以概率为1出现在两个类别中。（在第3.5.4节中，我们讨论如何“过滤”这样的无信息特征。）\n 图3.8 类条件密度 \\(p(\\boldsymbol{x}_j=1 | y=c)\\)  的两个文档类，对应于“X视窗”和“MS视窗”。由_naiveBayesBowDemo_生成的图。\n 3.5.1.2 朴素贝叶斯的贝叶斯算法(Bayesian naive Bayes) 最大拟然的麻烦是它可能过拟合。例如，考虑在图3.8的例子：\u0026ldquo;subject\u0026quot;这个单词对应的特征(记作特征 \\(j\\)  )总是同时出现在两个类，所以, 我们的估计总是 \\(\\hat{\\theta}_{jc}=1\\)  。如果我们遇到一封没有这个词的新电子邮件，会发生什么？我们的算法会出错，因为我们发现对两个类都有 \\(p(y=c | \\boldsymbol{x}, \\hat{\\boldsymbol{\\theta}})=0\\)  ！这是第3.3.4.1节讨论的黑天鹅悖论的另一种表现形式。\n过拟合的简单解决方案是贝叶斯算法(Bayesian)。为简单起见，我们使用一个先验因式分解 (译者注: 重新编排了参数):\n\\[ p(\\boldsymbol{\\theta})=p(\\boldsymbol{\\pi}) \\prod_{j=1}^D {\\prod_{c=1}^C{p(\\theta_{jc})}} \\tag{3.59} \\]  对 \\(\\boldsymbol{\\pi}\\)  我们使用 \\({\\rm Bir}(\\boldsymbol{\\alpha})\\)  先验, 对每个 \\(\\theta_{jc}\\)  使用 \\({\\rm Beta}(\\beta_0,\\beta_1)\\)  先验。如果我们只取 \\(\\boldsymbol{\\alpha}=1\\)  和 \\(\\boldsymbol{\\beta}=1\\)  ，对应于加1或拉普拉斯平滑。\n结合公式3.56中的拟然因式分解和上面先验的因式分解, 可以得到下面的后验因式分解：\n\\[ \\begin{aligned} p(\\boldsymbol{\\theta} | \\mathcal{D}) =\u0026 p(\\boldsymbol{\\pi} | \\mathcal{D}) \\prod_{j=1}^D {\\prod_{c=1}^C{p(\\theta_{jc} | \\mathcal{D})}} \\\\ p(\\boldsymbol{\\pi} | \\mathcal{D}) =\u0026 {\\rm Dir}(N_1+\\alpha_1,\\dots,N_C+\\alpha_C) \\\\ p(\\theta_{jc} | \\mathcal{D}) =\u0026 {\\rm Beta}((N_c - N_{jc})+\\beta_0,N_{jc}+\\beta_1) \\end{aligned} \\tag{3.60-62} \\]  换句话说，为了计算后验，我们只是把似然的经验计数加上先验计数即可。通过修改算法8来处理此版本的模型“拟合”是很简单的。\n2.5.2 使用这个模型来预测 测试时，目标是计算:\n\\[ p(y=c | \\boldsymbol{x}, \\mathcal{D}) \\propto p(y=c | \\mathcal{D}) \\prod_{j=1}^D {p(x_j | y=c,\\mathcal{D})} \\tag{3.63} \\]  正确的贝叶斯程序是要对未知参数积分(译者注: 原文公式有误, 此处我做了修正):\n\\[ \\begin{aligned} p(y=c | \\boldsymbol{x}, \\mathcal{D}) \\propto \u0026 \\left[ \\int {{\\rm Cat}(y=c | \\boldsymbol{\\pi}) p(\\boldsymbol{\\pi} | \\mathcal{D})} d \\boldsymbol{\\pi} \\right] \\\\ \\quad \u0026 \\prod_{j=1}^D { \\left[ \\int {{\\rm Ber}(x_j | y=c, \\theta_{jc}) p(\\theta_{jc} | \\mathcal{D})}d \\theta_{jc} \\right]} \\end{aligned} \\tag{3.64-65} \\]  幸运的是，这是很容易做到，至少如果后验是狄利克雷分布。特别是，根据公式3.51，我们知道可以通过简单地插入后验平均参数 \\(\\bar{\\boldsymbol{\\theta}}\\)  来获得后验预测密度 θ。因此\n\\[ \\begin{aligned} p(y=c | \\boldsymbol{x}, \\mathcal{D}) \u0026 \\propto \\bar{\\pi} _c \\prod_{j=1}^D {\\left(\\bar{{\\theta}}_{jc}\\right)^{\\mathbb{I}(x_j=1)} \\left(1-\\bar{{\\theta}}_{jc}\\right)^{\\mathbb{I}(x_j=0)}} \\\\ \\bar{{\\theta}}_{jc} \u0026 = \\dfrac{N_{jc}+\\beta_1}{N_c+\\beta_0+\\beta_1} \\\\ \\bar{{\\pi}}_c \u0026 = \\dfrac{N_c+\\alpha_c}{N+\\alpha_0} \\end{aligned} \\tag{3.66-68} \\]  其中 ， \\(\\alpha_0=\\sum_c{\\alpha_c}\\)  。\n如果我们有一个单点的后验近似， \\(p(\\boldsymbol{\\theta} | \\mathcal{D}) \\approx \\delta_{\\hat{\\boldsymbol{\\theta}}}(\\boldsymbol{\\theta})\\)  ，其中 \\(\\hat{\\boldsymbol{\\theta}}\\)  可以是MLE或MAP估计，那么 后验预测密度可通过简单地插入参数而获得，进而获得一个几乎一样的规则:\n\\[ p(y=c | \\boldsymbol{x}, \\mathcal{D}) \\propto \\hat{\\pi} _c \\prod_{j=1}^D {\\left(\\hat{{\\theta}}_{jc}\\right)^{\\mathbb{I}(x_j=1)} \\left(1-\\hat{{\\theta}}_{jc}\\right)^{\\mathbb{I}(x_j=0)}} \\tag{3.69} \\]  唯一的区别是, 我们用后验众数或MLE \\(\\hat{\\boldsymbol{\\theta}}\\)  来取代后验均值 \\(\\bar{\\boldsymbol{\\theta}}\\)  。然而，这种微小差异在实践中很重要，因为后验均值将导致较少的过拟合（参见第3.4.4.1节）。\n3.5.3 log-sum-exp技巧 无论使用任何类型的生成式分类器, 我们要讨论一个重要的实际细节 。尽管我们能够按公式2.13计算后验类标签， 并且使用适当的类条件密度（和近似插入）。但遗憾的是，由于数值下溢，公式2.13的简单实现可能会失败。问题出在 \\(p(\\boldsymbol{x} | y=c)\\)  通常是一个非常小的数字，特别是如果 \\(\\boldsymbol{x}\\)  是一个高维向量。这是因为我们要求 \\(\\sum_{\\boldsymbol{x}}{p(\\boldsymbol{x} | y)}=1\\)  ，因此观察任何特定高维向量的概率很小。一个明显的解决方案是在应用贝叶斯规则时进行log，如下所示：\n\\[ \\begin{aligned} {\\rm log} \\ p(y=c | \\boldsymbol{x}) = \u0026 b_c - {\\rm log} \\left[\\sum_{c^{'}=1}^C {e^{b_{c^{'}}}} \\right] \\\\ b_c \\overset{\\Delta}{=} \u0026 {\\rm log} \\ p(\\boldsymbol{x}|y=c) + {\\rm log} \\ p(y=c) \\end{aligned} \\tag{3.70-71} \\]  然而，这需要计算以下这个表达式:\n\\[ {\\rm log} \\left[\\sum_{c^{'}} {e^{b_{c^{'}}}} \\right] = {\\rm log} \\sum_{c^{'}} {p(y=c^{'} | \\boldsymbol{x})}={\\rm log} \\ p(\\boldsymbol{x}) \\tag{3.72} \\]  我们不能在 \\({\\rm log}\\)  域中加减。幸运的是，我们可以将最大公因项分解出来，比如，\n\\[ {\\rm log} (e^{-120}+e^{-121})={\\rm log} (e^{-120}(1+e^{-1}))={\\rm log} (1+e^{-1}) - 120 \\tag{3.73} \\]  在一般情况下，我们有:\n\\[ {\\rm log} \\sum_c{e^{b_c}}={\\rm log} \\left[(\\sum_c{e^{(b_c-B)}})e^B \\right]= \\left[{\\rm log} (\\sum_c{e^{(b_c-B)}}) \\right] + B \\tag{3.74} \\]  其中 \\(B= \\underset{c}{\\rm max} \\ b_c\\)  。这被称为 log-sum-exp 技巧，并被广泛使用。（有关请参阅函数_logsumexp_的实现。）\n此技巧在算法1中，使用NBC来计算 \\(p(y_i | \\boldsymbol{x}_i,\\hat{\\boldsymbol{\\theta}})\\)  。参阅Matlab代码 naiveBayesPredict。注意，如果我们只希望计算 \\(\\hat{y}_i\\)  , 那么我们不需要log-sum-exp技巧，因为我们只要最大化非标准量 \\({\\rm log} \\ p(y_i=c) + {\\rm log} \\ p(\\boldsymbol{x}_i | y_i=c)\\)  。\n3.5.4 用互信息进行特征选择 由于NBC是拟合潜在很多特征的联合分布，因此可能会受过拟合的影响。此外，运行时开销是 \\(O(D)\\)  ，对于某些应用来说可能太高。\n解决这两个问题的一种常见方法是进行特征选择，以消除对分类问题没有多大帮助的“无关”特征。最简单的特征选择方法是分别评估每个特征的相关性，然后取最高 \\(K\\)  ，其中 \\(K\\)  的选择是基于准确性和复杂性之间的一些权衡。这种方法称为变量排序， 过滤或筛选。\n衡量相关性的一种方法是使用在特征 \\(X_j\\)  和标签 \\(Y\\)  之间的互信息（第2.8.3节）:\n\\[ I(X,Y)=\\sum_{x_j} {\\sum_y{p(x_j,y) \\log\\dfrac{p(x_j,y)}{p(x_j)p(y)}}} \\tag{3.75} \\]  互信息可以被认为是: 一旦我们观察到特征 \\(j\\)  的值，那么标签分布上的熵就减少。如果特征是二项的，那这点很容易证明（练习3.21），这个MI可被如下计算:\n\\[ I_j=\\sum_c{\\left[\\theta_{jc}\\pi_c \\log\\dfrac{\\theta_{jc}}{\\theta_j} +(1-\\theta_{jc}) \\pi_c \\log \\dfrac{1-\\theta_{jc}}{1-\\theta_j} \\right]} \\tag{3.76} \\]  其中 \\(\\pi_c=p(y=c),\\theta_{jc}=p(x_j=1|y=c), \\theta_j=p(x_j=1)=\\sum_c{\\pi_c \\theta_{jc}}\\)  。（所有这些能被计算的量都是朴素贝叶斯分类器的副产品。）\n图3.1说明了如果我们将其应用于图3.8中使用的二项词袋数据集中会发生什么。我们看到具有最高互信息的词比最有可能的词更具有辨别力。例如，两个类中最可能的单词是“subject”，它总是出现，因为这是新闻组的数据，它总是有一个主题(subject)行。但显然这不是很有辨别力的。带有类别标签的MI最高的单词是（按降序排列）“windows”，“microsoft”，“DOS”和“motif”，这是有道理的，因为这些类对应于Microsoft Windows和X Windows。\n3.5.5 使用词袋的文档分类器 文档分类器 是将文本文档分类为不同类别的问题。一种简单的方法是将每个文档表示为二项的向量，其记录每个单词是否存在与否, 于是 \\(x_{ij}=1 \\quad {\\rm iff} \\quad\\)  单词 \\(j\\)  出现在文档 \\(i\\)  中, 否则 \\(x_{ij}=0\\)  。然后我们可以使用如下的类条件密度：\n\\[ p(\\boldsymbol{x}_i | y_i, \\boldsymbol{\\theta})=\\prod_{j=1}^D {{\\rm Ber}(x_{ij} | \\theta_{jc})} = \\prod_{j=1}^D{\\theta_{jc}^{\\mathbb{I}(x_{ij})} (1-\\theta_{jc})^{\\mathbb{I}(1-x_{ij})}} \\tag{3.77} \\]  这称为 伯努利乘积模型(the Bernoulli product model,)，或 二项独立模型(the binary independence model)。\n然而，忽略文档中每个单词出现的次数会丢失一些信息（McCallum和Nigam 1998）。更准确的表示计算每个单词的出现次数。具体来说，让 \\(\\boldsymbol{x}_i\\)  表示文档 \\(i\\)  的计数向量，于是 \\(x_{ij} \\in \\{0,1,\\dots,N_i\\}\\)  ，其中 \\(N_i\\)  是在文件 \\(i\\)  的所有单词数（即, \\(\\sum_{j=1}^D{x_{ij}}=N_j\\)  ）。对于类条件密度，我们可以使用多项分布：\n\\[ p(\\boldsymbol{x}_i | y_i=c,\\boldsymbol{\\theta})={\\rm Mu}(\\boldsymbol{x}_i | N_i,\\boldsymbol{\\theta}_c) = \\dfrac{N_i!}{\\prod_{j=1}^D{x_{ij}!}}\\prod_{j=c}^D{\\theta_{jc}^{x_{ij}}} \\tag{3.78} \\]  我们隐含地假设文件长度为 \\(N_i\\)  独立于分类。这里 \\(\\theta_{jc}\\)  是 \\(c\\)  类文档中生成单词 \\(j\\)  的概率; 这些参数满足约束 \\(\\sum_{j=1}^D{\\theta_{jc}}=1, \\forall \\ c\\)  。\n尽管多项分类器在测试时易于训练且易于使用，但它并不是对文档分类特别有效。其中一个原因是它没有考虑到的突发性单词使用。这指的是大多数单词从未出现在任何给定文档中的现象，但如果它们确实出现一次，则它们可能不止一次出现，即单词以突发形式出现。\n多项模型无法捕捉突发现象。要知道为什么，注意公式3.78有形如 \\(\\theta_{jc}^{x_{ij}}\\)  的项， 由于对于罕见词 \\(\\theta_{jc} \\ll 1\\)  ，越来越不可能产生许多词。对于更频繁的单词，衰减率不是那么快。为了直观地理解原因，请注意最常用的单词是不具体类的功能单词，例如“and”，“the”和“but”; “and”这个词出现的几率基本上是相同的，无论它先前发生了多少时间（模数长度），因此对于常用词而言，独立性假设更合理。然而，由于罕见词是最适合分类目的的词，因此我们想要最仔细地建模。\n已经提出了各种富有启发式方法来改进文档分多项类器的性能（Rennie等人，2003）。我们现在提出了一种替代类条件密度，它与这些特殊方法一样，但概率上是合理的（Madsen等人，2005）。\n假设我们简单地用狄利克雷混合多项(Dirichlet Compound Multinomial)密度 或 DCM 密度来代替多项类条件密度 ， 定义如下\n\\[ p(\\boldsymbol{x}_i | y_i=c,\\boldsymbol{\\theta}) = \\int {{\\rm Mu}(\\boldsymbol{x}_i|N_i,\\boldsymbol{\\theta}_c){\\rm Dir}(\\boldsymbol{\\theta}_c | \\boldsymbol{\\alpha}_c) d \\boldsymbol{\\theta}_c}=\\dfrac{N_i!}{\\prod_{j=1}^D{x_{ij}!}}\\dfrac{{\\rm B}(\\boldsymbol{x}_i+\\boldsymbol{\\alpha}_i)}{{\\rm B}(\\boldsymbol{\\alpha}_i)} \\tag{3.79} \\]  （这个等式推导自公式5.24。）令人惊讶的是，这个简单的变化就是捕获突发现象所需的全部。直观的原因如下：看到一个单词的一个发生后， 比如单词 \\(j\\)  ，那么在 \\(\\theta_j\\)  上的后验计数得到更新，于是单词 \\(j\\)  再次出现有更大可能。相反，如果 \\(\\theta_j\\)  固定，那么每个单词的出现是独立的。多项模型对应于从有K中颜色球的坛子中取出一个球，记录其颜色，然后放回。相比之下，DCM模型对应于取出一个球，记录其颜色，然后将取出的球连同一个同色额外球一起放回; 这被称为 波利亚坛子。\n使用DCM模型作为类条件密度比使用多项模型具有更好的结果，并且具有与现有技术方法相当的性能，正如（Madsen et al. 2005）中所述。唯一的缺点是配置DCM模型更复杂; 详见了（Minka 2000e; Elkan 2006）。\n返回本章目录\n"}),a.add({id:274,href:'/notes/tags/%E4%BA%92%E4%BF%A1%E6%81%AF/',title:"互信息",content:""}),a.add({id:275,href:'/notes/tags/%E5%88%86%E7%B1%BB%E5%99%A8/',title:"分类器",content:""}),a.add({id:276,href:'/notes/tags/%E6%8B%9F%E5%90%88/',title:"拟合",content:""}),a.add({id:277,href:'/notes/tags/%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9/',title:"特征选择",content:""}),a.add({id:278,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0042/',title:"3.4 狄利克雷-多项模型",content:"返回本章目录\n在上一节中，我们讨论了如何推断硬币\u0026quot;正面\u0026quot;出现的概率。在本节中，我们推广这些结果，以推断出有   \\(K\\)  面的骰子出现第 \\(k\\)  面的概率。这似乎是另一种玩具练习，但将在后面看到, 我们的研究方法将被广泛用于分析文本数据，生物序列数据等。\n3.4.1 拟然 我们观察丢 \\(N\\)  次骰子， \\(\\mathcal{D}=\\{x_1,\\dots,x_N\\}\\)  ，其中 \\(x_i \\in \\{1,\\dots,K\\}\\)  。如果假设数据是i.i.d的，那么似然形如下式:\n\\[ p(\\mathcal{D} | \\boldsymbol{\\theta})= \\prod_{k=1}^K {\\theta_k^{N_k}} \\tag{3.36} \\]  其中 \\(N_k=\\sum_{i=1}^N {\\mathbb{I}(x_i=k)}\\)  是事件 \\(k\\)  发生的次数（这是该模型的充分统计）。多项模型的拟然具有相同的形式，只相差一个不相关的常数因子。\n 图3.7 （a）在看到 \\(N_1=3,N_0=17\\)  后的后验预测。（b）绘制了使用MAP的插入近似。\n 3.4.2 先验 由于参数向量落在一个K维概率单纯形中，我们需要支持这个单纯形的先验，理想情况下它也是共轭的。幸运的是，狄利克雷分布（第2.5.4节）满足两个标准。所以我们将使用如下先验：\n\\[ {\\rm Dir}(\\boldsymbol{\\theta} | \\alpha)=\\dfrac{1}{B(\\alpha)}\\prod_{k=1}^K {\\theta_k^{\\alpha_k - 1} \\mathbb{I}(\\boldsymbol{\\theta} \\in S_K)} \\tag{3.37} \\]  3.4.3 后验 将上面的拟然乘上先验得到的后验, 也是狄利克雷分布分布:\n\\[ \\begin{aligned} p(\\boldsymbol{\\theta} | \\mathcal{D}) \u0026 \\propto p(\\mathcal{D} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta}) \\\\ \\quad \u0026 \\propto \\prod_{k=1}^K {\\theta_k^{N_k} \\ \\theta_k^{\\alpha_k - 1}} = \\prod_{k=1}^K { \\theta_k^{\\alpha_k + N_k - 1}} \\\\ \\quad \u0026 = {\\rm Dir}(\\boldsymbol{\\theta} | \\alpha_1+N_1,\\dots,\\alpha_K+N_K) \\end{aligned} \\tag{3.38-40} \\]  我们看到，这个后验是通过先验的超参数（伪计数 ） \\(\\alpha_k\\)  加上经验计数 \\(N_k\\)  而获得的.。\n我们可以通过使用微积分推导出该后验的众数（即，MAP估计）， 当然我们必须强制约束 \\(\\sum_k {\\theta_k} = 1\\)  。我们可以使用拉格朗日乘子做到这一点 。受约束的目标函数，或 拉格朗日量，就是对数似然, 加上对数,再加上约束项:\n\\[ \\ell(\\boldsymbol{\\theta}, \\lambda) = \\sum_k \\ {N_k {\\rm log} \\theta_k}+\\sum_k \\ {(\\alpha_k-1) {\\rm log} \\theta_k} + \\lambda \\left(1- \\sum_k {\\theta_k} \\right) \\tag{3.41} \\]  为了简化记号, 我们定义 \\(N_k^{'} \\overset{\\Delta}{=}N_k+\\alpha_k-1\\)  。取 \\(\\lambda\\)  取导数产生原始约束：\n\\[ \\dfrac{\\partial \\ell}{\\partial \\lambda} = 1- \\sum_k {\\theta_k} = 0 \\tag{3.42} \\]  对 \\(\\theta_k\\)  求导数:\n\\[ \\dfrac{\\partial \\ell}{\\partial \\theta_k} = \\dfrac{N_k^{'}}{\\theta_k}-\\lambda=0 \\tag{3.43} \\]  \\[ N_k^{'}=\\lambda \\ \\theta_k \\tag{3.44} \\]  利用约束求和可以解出 \\(\\lambda\\)  :\n\\[ \\sum_k {N_k^{'}} = \\lambda \\sum_k {\\theta_l} \\tag{3.45} \\]  \\[ N+\\alpha_0-K = \\lambda \\tag{3.46} \\]  其中 ， \\(\\alpha_0 \\overset{\\Delta}{=} \\sum_{k=1}^K {\\alpha_k}\\)  是先验的等效样本尺寸。因此，MAP估计由下式给出:\n\\[ \\hat{\\theta}_k=\\dfrac{N_k+\\alpha_k-1}{N+\\alpha_0-K} \\tag{3.47} \\]  这与公式2.77是一致。如果我们使用均匀先验 \\(\\alpha_k=1\\)  ，我们再次得到类似的MLE:\n\\[ \\hat{\\theta}_k=\\dfrac{N_k}{N} \\tag{3.48} \\]  这恰好是 \\(k\\)  面朝上的经验分式。\n3.4.4 后验预测 这个后验预测分布, 是基于一个单独的多项试验, 表示如下:\n\\[ \\begin{aligned} p(X=j|\\mathcal{D}) \u0026 = \\int {p(X=j|\\boldsymbol{\\theta}) p(\\boldsymbol{\\theta} | \\mathcal{D}) d\\boldsymbol{\\theta}} \\\\ \\quad \u0026 = \\int {p(X=j|\\theta_j) \\left[\\int { p(\\boldsymbol{\\theta}_{-j},\\theta_j | \\mathcal{D}) d\\boldsymbol{\\theta}_{-j}} \\right] d \\theta_j} \\\\ \\quad \u0026 = \\int {\\theta_j\\ p(\\theta_j | \\mathcal{D}) d \\theta_j}=\\mathbb{E}[\\theta_j | \\mathcal{D}]=\\dfrac{\\alpha_j+N_j}{\\sum_k {(\\alpha_k+N_k)}}=\\dfrac{\\alpha_j+N_j}{\\alpha_0+N} \\end{aligned} \\tag{3.49-51} \\]  其中 \\(\\boldsymbol{\\theta}_{-j}\\)  表示从参数向量 \\(\\boldsymbol{\\theta}\\)  中剔除 \\(\\theta_j\\)  后的降1维向量.。参考练习3.13。\n正如我们在3.3.4.1节中看到的那样，上面的表达式避免了零计数问题。实际上，这种贝叶斯平滑的形式,在多项情况下比二项的情况更加重要，因为一旦我们开始将数据划分为多个类别, 数据稀疏的拟然会增加。\n3.4.4.1 工作示例：使用词袋的语言模型 使用狄利克雷-多项模型进行贝叶斯平滑的一种应用是语言建模，这意味着要预测在一个句子中下个可能出现的单词。在这里，我们将采取一种非常简单的方法，假设第 \\(i\\)  个单词 \\(X_i \\in {1,\\dots,K}\\)  简单地独立于所有其他单词, 采用 \\({\\rm Cat}(\\boldsymbol{\\theta})\\)  分布。称此为词袋模型(bag of words model.)。在获得已经出现的单词序列，我们如何预测下一个可能会出现哪一个？\n例如，假设我们观察到如下的序列（儿童童谣的一部分）：\nMary had a little lamb, little lamb, little lamb,\nMary had a little lamb, its fleece as white as snow\n此外，假设我们的词汇包括以下词语：\nmary lamb little big fleece white black snow rain unk\n1 2 3 4 5 6 7 8 9 10\n这里unk代表未知，表示列表中没有出现的所有其他单词。为了编码童谣的每一行，我们首先去除标点符号，并删除任何停止词 ，如“a”，“as”，“the”等。我们也可以执行词干，这意味着将词语缩减为基本形式, 比如删除复数尾部的s， 或 动词的ing（例如， running 变得 run）。在这个例子中，没有词需要词干。最后，我们将每个单词用词汇表的索引替换：\n1 10 3 2 3 2 3 2\n1 10 3 2 10 5 10 6 8\n我们现在忽略单词次序，并计算每个单词出现的频率，从而产生一个单词计数的直方图：\n将上述计数记为 \\(N_j\\)  。如果我们对 \\(\\boldsymbol{\\theta}\\)  使用 \\({\\rm Dir}(\\alpha)\\)  先验，那么后验预测就是:\n\\[ p(\\tilde{X}=j | \\mathcal{D})=\\mathbb{E}[\\theta_j | \\mathcal{D}] = \\dfrac{\\alpha_j+N_j}{\\sum_{j^{'}} {(\\alpha_{j^{'}}+N_{j^{'}})}}= \\dfrac{1+N_j}{10+17} \\tag{3.52} \\]  其中第二等式后, 取 \\(\\alpha_j=1\\)  , 进而得到:\n\\[ p(\\tilde{X}=j | \\mathcal{D})=(3/27,5/27,5/27,1/27,2/27,2/27,1/27,2/27,1/27,5/27) \\tag{3.53} \\]  这个模型的预测分布是 \\(X = 2\\)  （“lamb”）和 \\(X = 10\\)  (“unk”)。请注意，\u0026ldquo;big”，“black”和“rain”这些词在未来也会以非零概率发生，即使它们以前从未见过。稍后我们将看到更复杂的语言模型。\n返回本章目录\n"}),a.add({id:279,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0041/',title:"3.3 贝塔-二项模型",content:"返回本章目录\n在给定一离散观察序列的情况下, 数字游戏涉及从有限假设空间推断出离散变量的分布,   \\(h \\in \\mathcal{H}\\)  。这使计算变得特别简单：我们只需要求和，乘和除。然而，在许多应用中，未知参数是连续的，因此假设空间是 \\(\\mathbb{R}^K\\)  的某个子集, 其中 \\(K\\)  是参数的个数. 这使数学变得复杂，因为我们必须用积分代替和。但是，基本思路是一样的。\n我们将通过考虑一系列观察到的硬币投掷来推断硬币出现头部的可能性的问题来说明这一点。虽然这看似微不足道，但事实证明，这个模型构成了我们将在本书后面考虑的许多方法的基础，包括朴素的贝叶斯分类器，马尔可夫模型等。这在历史上很重要，因为它是一个例子。在贝叶斯1763年的原始论文中进行了分析。（贝叶斯的分析随后由皮埃尔·西蒙·拉普拉斯推广，创造了我们现在所说的“贝叶斯法则” - 参见（Stigler, 1986）了解更多历史细节。）\n我们将遵循现在熟悉的指定拟然和先验的方法，并导出后验和后验预测。\n3.3.1 拟然 假设 \\(X_i \\sim {\\rm Ber}(\\theta)\\)  ，其中 \\(X_i=1\\)  代表“正面”， \\(X_i=0\\)  代表“反面”，并且 \\(\\theta \\in [0,1]\\)  是速率参数（\u0026ldquo;正面\u0026quot;的概率）。如果数据是独立同分布(i.i.d)，那么拟然形如下式:\n\\[ p( \\mathcal{D} | \\theta) = \\theta^{N_1} (1-\\theta)^{N_0} \\tag{3.11} \\]  其中我们有 \\(N_1=\\sum_{i=1}^N {\\mathbb{I}(x_i=1)}\\)  个\u0026quot;正面\u0026rdquo; 和 \\(N_0=\\sum_{i=0}^N {\\mathbb{I}(x_i=1)}\\)  个\u0026quot;反面\u0026quot;。这两个计数被称为数据的充分统计，因为这是我们需要知道的关于 \\(\\mathcal{D}\\)  推断出 \\(\\theta\\)  的所有内容。 （另一组充分统计的数据是 \\(N_1\\)  和 \\(N=N_0 + N_1\\)  ）。\n更正式地，我们称 \\(s(\\mathcal{D})\\)  是数据 \\(\\mathcal{D}\\)  的充分统计, 如果 \\(p(\\theta | \\mathcal{D})=p(\\theta | s(data))\\)  。如果我们使用一个均匀先验, 这等价于说, \\(p(\\mathcal{D} | \\theta) \\propto p(s(\\mathcal{D}) | \\theta)\\)  。因此，如果有两个具有相同充分统计的数据集，我们会推断出相同的 \\(\\theta\\)  值。\n现在假设数据由\u0026quot;正面\u0026quot;计数 \\(N_1\\)  和固定数观察 \\(N=N_1+N_0\\)  组成。在在这种情况下，我们有 \\(N_1 \\sim {\\rm Bin}(N,\\theta)\\)  ，其中 \\({\\rm Bin}\\)  表示二项分布，其具有以下pmf(概率分布)：\n\\[ {\\rm Bin}(k | n, \\theta) \\overset{\\Delta}{=} \\binom{n}{k} \\theta^k (1-\\theta)^{(n-k)} \\tag{3.12} \\]  由于 \\(\\binom{n}{k}\\)  是 \\(\\theta\\)  无关的常数，二项采样模型的拟然等同与伯努利模型的拟然。因此，我们对 \\(\\theta\\)  做出的任何推论都是相同的, 无论我们是观察 \\(\\mathcal{D}=(N_1,N)\\)  的计数, 还是观察序列 \\(\\mathcal{D}=\\{x_1,\\dots,x_N\\}\\)  的计数。\n3.3.2 先验 我们需要一个支持区间 \\([0,1]\\)  的先验。为了使数学上更容易，如果先验和拟然具有相同的形式, 那会很方便的, 比如形如:\n\\[ p(\\theta) \\propto \\theta^{\\gamma_1} (1-\\theta)^{\\gamma_2} \\tag{3.13} \\]  其中, \\(\\gamma_1\\)  和 \\(\\gamma_2\\)  是一些特定的先验参数。如果这样的话，那么我们可以很容易通过简单地增加指数来计算后验:\n\\[ p(\\theta | \\mathcal{D}) \\propto p(\\mathcal{D} | \\theta) p(\\theta)= \\theta^{N_1} (1-\\theta)^{N_0} \\ \\theta^{\\gamma_1} (1-\\theta)^{\\gamma_2} = \\theta^{N_1 + \\gamma_1} (1-\\theta)^{N_0 + \\gamma_2} \\tag{3.14} \\]   图3.6 （a）使用具有充分统计量 \\(N_1=3,N_0=17\\)  的二项拟然来更新 \\({\\rm Beta}(2,2)\\)  以生成一个 \\({\\rm Beta}(5,9)\\)  的后验。 （b）使用具有充分统计量 \\(N_1=11,,N_0=13\\)  的二项拟然来更新 \\({\\rm Beta}(5,2)\\)  以生成一个 \\({\\rm Beta}(16,15)\\)  的后验。\n 当在先验和后验具有相同的形式时，我们说，这个先验是相关拟然的共轭先验。共轭先验被广泛使用，因为它们简化了计算，并且易于解释， 正如上所示。\n在伯努利的情况下，共轭先验是一个 \\(\\beta\\)  分布，就是我们在第2.4.5节中将会遇到的:\n\\[ {\\rm Beta}(\\theta | a,b) \\propto \\theta^{a-1} (1-\\theta)^{b-1} \\tag{3.15} \\]  这个先验的参数被称为超参数。我们可以设置它们以编码我们先验信念。例如，为了编码我们的信念: \\(\\theta\\)  均值为0.7，标准差为0.2，我们可以设置 \\(a=2.957\\)  和 \\(b=1.275\\)  （练习3.15）。或编码我们的信念: \\(\\theta\\)  的均值为0.15，并且有一定概率落在区间 \\((0.05,0.30)\\)  上，那么我们可以找到 \\(a=4.5\\)  和 \\(a=25.5\\)  （练习3.16）。\n如果我们对 \\(\\theta\\)  一无所知, 除了知道其落在 \\([0,1]\\)  中。 我们可以使用均匀先验，这是一种无信息先验之（详见5.4.2节）。均匀分布可以用的 \\(\\beta\\)  分布表示, 只要取 \\(a=b=1\\)  。\n3.3.3 后验 如果我们通过 \\(\\beta\\)  先验乘上拟然, 可得到如下的后验(依照方程3.14)：\n\\[ p(\\theta | \\mathcal{D}) \\propto {\\rm Bin}(N_1 | \\theta,N_0+N_1) {\\rm Beta}(\\theta | a,b) \\propto {\\rm Beta}(\\theta | N_1+a,N_0+b) \\tag{3.16} \\]  特别是，后验是通过将先前的超参数加上经验计数获得的。因此，超参数称为 伪计数(pseudo counts)。先验的强度，也称为先验的有效样本大小(effective sample size) ，是伪计数的总和,即 \\(a+b\\)  ; 这起着类似于数据集大小的作用, \\(N_1+N_0=N\\)  。\n图3.6（a）给出了一个示例，其中我们使用有尖峰的似然函数来更新弱的 \\({\\rm Beta}(2,2)\\)  ，这是对与大样本量而言的; 我们可看到后验与拟然基本一样： 因为数据已经压倒了先验。图3.6（b）给出了一个示例，其中我们也使用尖峰似然函数来更新强的 \\({\\rm Beta}(5,2)\\)  ; 现在我们看到后验是先验和拟然之间的“妥协”。\n请注意，顺序更新后验等效于一次性批量更新。为了看清这一点，假设我们有两个数据集 \\(\\mathcal{D}_a\\)  和 \\(\\mathcal{D}_b\\)  , 其充分统计量分别是 \\(N_1^a,N_0^a\\)  和 \\(N_1^b,N_0^b\\)  。设 \\(N_1=N_1^a+N_1^b\\)  和 \\(N_0=N_0^a+N_0^b\\)  是组合数据集的充分统计。在批量模式中，我们有:\n\\[ p(\\theta | \\mathcal{D}_a,\\mathcal{D}_b) \\propto {\\rm Bin}(N_1 | \\theta,N_0+N_1) {\\rm Beta}(\\theta | a,b) \\propto {\\rm Beta}(\\theta | N_1+a,N_0+b) \\tag{3.17} \\]  在顺序模式下，我们有:\n\\[ \\begin{aligned} p(\\theta | \\mathcal{D}_a,\\mathcal{D}_b) \u0026 \\propto p(\\mathcal{D}_b | \\theta) \\ p(\\theta | \\mathcal{D}_a) \\\\ \\quad \u0026 \\propto {\\rm Bin}(N_1^b | \\theta,N_0^b+N_1^b) {\\rm Beta}(\\theta | N_1^a+a,N_0^a+b) \\\\ \u0026\\propto {\\rm Beta}(\\theta | N_1^a+N_1^b+a,N_0^a+N_0^b+b) \\end{aligned} \\tag{3.18-20} \\]  这使得贝叶斯推理特别适合在线学习，我们将在后面看到。\n3.3.3.1 后验均值和众数(mode) 根据公式2.62，MAP估计可由下式给出:\n\\[ \\hat{\\theta}_{\\rm MAP} = \\dfrac{a+N_1-1}{a+b+N-2} \\tag{3.21} \\]  如果我们使用均匀先验，那么MAP估计简化成MLE， 这正好是\u0026quot;正面\u0026quot;的经验值:\n\\[ \\hat{\\theta}_{\\rm MLE} = \\dfrac{N_1}{N} \\tag{3.22} \\]  这复合直觉，但它也可以通过应用基础微积分来最大化式3.11中的似然函数推导出来 （练习3.1）。\n相比之下，后验均值由下式给出:\n\\[ \\bar{\\theta} = \\dfrac{a+N_1}{a+b+N} \\tag{3.23} \\]  这种众数(等于MAP)和均值之间的差异将在以后着重证明。\n我们现在将展示后验均值是先验均值和MLE的凸组合，它捕捉了后验是我们之前所认为的和数据告诉我们的这两种情况折衷的概念。\n令 \\(\\alpha_0=a+b\\)  表示先验的等效样本尺寸，通过它控制强度，进而先验均值可写成 \\(m_1=a/\\alpha_0\\)  。然后，后验均值写成:\n\\[ \\mathbb{E}[\\theta|\\mathcal{D}]=\\dfrac{\\alpha_0 m_1 + N_1}{N+\\alpha_0}=\\dfrac{\\alpha_0}{N+\\alpha_0}m_1+\\dfrac{N}{N+\\alpha_0} \\dfrac{N_1}{N}=\\lambda \\ m_1+(1-\\lambda) \\ \\hat{\\theta}_{\\rm MLE} \\tag{3.24} \\]  其中 \\(\\lambda = \\frac{\\alpha_0}{N+\\alpha_0}\\)  是先验和后验等效样本尺寸的比率。因此越弱的先验具有越小的 \\(\\lambda\\)  ，进而后验均值越接近MLE。类似可见后验众数是先验众数和MLE的凸组合，并且它也会收敛到MLE。\n3.3.3.2 后验方差 均值和众数是点估计，但我们知道能够多大程度信任它, 也是是有用的。后验的方差是衡量这点的一种方法。 Beta后验的方差由下式给出:\n\\[ {\\rm Var}[\\theta | \\mathcal{D}]=\\dfrac{(a+N_1)(b+N_0)}{(a+N_1+b+N_0)^2(a+N_1+b+N_0+1)^2} \\tag{3.25} \\]  如果 \\(N\\gg a,b\\)  , 我们可以将这个\u0026quot;吓人\u0026quot;的表达式简化成:\n\\[ {\\rm Var}[\\theta | \\mathcal{D}] \\approx \\dfrac{N_1 N_0}{N N N} = \\dfrac{\\hat{\\theta} (1-\\hat{\\theta})}{N} \\tag{3.26} \\]  其中 \\(\\hat{\\theta}\\)  就是MLE。因此我们估计中的\u0026quot;误差条\u0026quot;（即后验标准差）由下式给出:\n\\[ \\sigma=\\sqrt{{\\rm Var}[\\theta | \\mathcal{D}]} \\approx \\sqrt{\\dfrac{\\hat{\\theta} (1-\\hat{\\theta})}{N}} \\tag{3.27} \\]  我们看到，不确定性随着比率 \\(1/\\sqrt{N}\\)  降低而降低 。但是请注意，当 \\(\\hat{\\theta}=0.5\\)  时, 不确定性（方差）最大, 而当 \\(\\hat{\\theta}\\)  接近0或1时最小。这意味着它更容易确保硬币偏置比，以确保它是公平。\n3.3.4 后验预测分布 到目前为止，我们一直关注未知参数的推断。现在让我们把注意力转向预测未来的可观测数据。\n考虑在单个未来试验中, 给定 \\({\\rm Beta}(a,b)\\)  后验, 那么\u0026quot;正面\u0026quot;预测的概率是:\n\\[ \\begin{aligned} p(\\tilde{x} = 1 | \\mathcal{D}) \u0026 = \\int_0^1 {p(x = 1 | \\theta) p(\\theta | \\mathcal{D}) d \\theta} \\\\ \\quad \u0026 =\\int_0^1 {\\theta \\ {\\rm Beta}(\\theta | a,b) d \\theta} = \\mathbb{E}[\\theta | \\mathcal{D}] = \\dfrac{a}{a+b} \\end{aligned} \\tag{3.28-29} \\]  由此可见, 正例后验预测分布可用后验参数均值等效插入, 进而完整的后验预测分布可写成: \\(p(\\tilde{x} | \\mathcal{D})={\\rm Ber}(\\tilde{x} | \\mathbb{E}[\\theta | \\mathcal{D}])\\)  。\n3.3.4.1 过拟合和黑天鹅悖论 我们考虑用MLE近似插入, 即 \\(p(\\tilde{x} | \\mathcal{D})={\\rm Ber}(\\tilde{x} | \\hat{\\theta}_{\\rm MLE})\\)  。 不幸的是，当样本量很小时，这种近似可能表现很差。例如，假设我们已经看到 \\(N=3\\)  个连续\u0026quot;反面\u0026quot;。MLE是 \\(\\hat{\\theta}=0/3=0\\)  ，因为要尽可能用到所有观察到的数据。但是，使用这个估计，我们预测\u0026quot;正面\u0026quot;是不可能的。这被称为 零计数问题 或 稀疏数据问题，并且在从少量数据估计计数时经常发生。有人可能会认为，在“大数据”时代，这种担忧是无关紧要的，但请注意，一旦我们根据某些标准对数据进行区分 - 例如 _特定人员_从事_特定活动_的次数 - 样本量可以变的非常小。例如，当试图执行个性化推荐网页时, 会出现该问题。因此贝叶斯方法仍然有用，即使在大数据体系中也是如此（Jordan 2011）。\n零计数问题类似于哲学中所谓黑天鹅悖论的问题。这是基于古老的西方观念，即所有天鹅都是白色的。在这种情况下，黑天鹅是一种不可能存在的隐喻。 （黑天鹅是17世纪欧洲探险家在澳大利亚发现的。）“黑天鹅悖论”这个词首先由著名的科学哲学家卡尔波普尔创造; 该术语也被用作最近一本畅销书（Taleb 2007）的标题。这个悖论被用来描述归纳问题，这是如何从过去的特定观察中得出关于未来的一般结论的问题。\n现在让我们推导出一个简单的贝叶斯解决方案。我们将使用均匀先验，因此 \\(a = b = 1\\)  。在这种情况下，插入后验均值, 得到拉普拉斯的继承规则:\n\\[ p(\\tilde{x} = 1 | \\mathcal{D}) = \\dfrac{N_1 + 1}{N_1+N_0 + 2} \\tag{3.30} \\]  这种将经验计数加1，归一化, 然后插入的常见做法，被称为 加1平滑(add-one smoothing)。 （注意，在MAP参数中插入是不会有这种平滑效果，由于众数形如 \\(\\hat{\\theta} = \\dfrac{a+N_1-1}{a+b+N-2}\\)  , 如果 \\(a = b = 1\\)  , 那么将变成MLE。）\n3.3.4.1 预测多个未来试验的结果 假设，我们现在感兴趣的是, 在 \\(M\\)  次未来试验中, 预测出现\u0026quot;正面\u0026quot;的次数 \\(x\\)  . 可由下式表示:\n\\[ \\begin{aligned} p(x | \\mathcal{D},M) \u0026 = \\int_0^1{{\\rm Bin}(x | \\theta,M){\\rm Beta}(\\theta | a, b) \\ d \\theta} \\\\ \\quad \u0026 =\\binom{M}{x} \\dfrac{1}{B(a, b)} \\int_0^1{ \\theta^x (1-\\theta)^{M-x} \\theta^{a-1} (1-\\theta)^{b-1} \\ d \\theta} \\end{aligned} \\tag{3.31-32} \\]  我们注意到 \\({\\rm Beta}(a+x, M-x+b)\\)  分布可以积分得到归一化常数。因此\n\\[ \\int_0^1{ \\theta^x (1-\\theta)^{M-x} \\theta^{a-1} (1-\\theta)^{b-1} \\ d \\theta}=B(a+x, M-x+b) \\tag{3.33} \\]  于是，我们找到了后验预测的分布, 这就是被称作(复合的) \\(\\beta\\)  **-二项分布**:\n\\[ {\\rm Bb}(x | a,b,M) \\overset{\\Delta}{=} \\binom{M}{x} \\dfrac{B(a+x, M-x+b)}{B(a, b)} \\tag{3.34} \\]  该分布具有以下的均值和方差\n\\[ \\mathbb{E}[x] = M \\dfrac{a}{a+b}, \\quad {\\rm Var}[x]=\\dfrac{M a b}{(a+b)^2} \\dfrac{a+b+M}{a+b+1} \\tag{3.35} \\]  如果 \\(M=1\\)  ，于是 \\(x \\in \\{0,1\\}\\)  ，我们看到，均值变成 \\(\\mathbb{E}[x | \\mathcal{D}] =p(x=1 | \\mathcal{D})= \\dfrac{a}{a+b}\\)  ，这与公式3.29是一致。\n该过程如图3.7（a）所示。我们从 \\({\\rm Beta}(2,2)\\)  先验开始，并绘制了在看到 \\(N_1=3\\)  个\u0026quot;正面\u0026quot;和 \\(N_0=17\\)  个\u0026quot;反面\u0026quot;的后验预测密度。图3.7（b）绘制了使用MAP的插入近似。我们看到贝叶斯预测具有更长的尾部，更广泛地扩展其概率质量，因此不太容易出现过拟合和黑天鹅类的悖论。\n返回本章目录\n"}),a.add({id:280,href:'/notes/tags/%E4%BC%97%E6%95%B0/',title:"众数",content:""}),a.add({id:281,href:'/notes/tags/%E5%88%86%E5%B8%83/',title:"分布",content:""}),a.add({id:282,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0040/',title:"3.2 贝叶斯概念学习",content:"返回本章目录\n考虑孩子如何学习理解单词的含义，例如“狗”。据推测，孩子的父母指出了这个概念的正面例子，说“看着可爱的小狗！”或“小心小狗”等等。然而，他们提供反面的例子是不太可能的，“看看那只非狗“?。当然，在积极的学习过程中可能会得到负面的例子 - 孩子说“看狗”，父母说“那是猫，亲爱的，不是狗” - 但心理学研究表明，人们可以仅从正面例子来学习概念（Xu和Tenenbaum 2007）。\n 图3.1 在这个数字游戏中, 8个人的平均经验预测分布。头两行：表示看到   \\(\\mathcal{D}=\\{16\\}\\)  和 \\(\\mathcal{D}=\\{20\\}\\)  之后 。这说明了以数字为中心扩散的相似性。第三行：看到 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  之后 。也看到基于规则的相似行为（2次幂）。底排：看到 \\(\\mathcal{D}=\\{16,23,19,20\\}\\)  之后 。这说明了聚焦的相似性（数字接近20）。\n 我们可以认为单词含义学习, 等同于概念学习, 也等同于二项分类。为了明白这点，定义 \\(f(\\boldsymbol{x})=1\\)  表示 \\(\\boldsymbol{x}\\)  是概念C的示例; 否则, \\(f(\\boldsymbol{x})=0\\)  。然后，目标就是学习定义在集合C上的指标函数 \\(f\\)  。通过允许不确定的 \\(f\\)  或等效的C的元素，我们可以模拟模糊集理论，但使用标准概率演算。请注意，标准二项分类器技术同时需要正例和负例。相比之下，我们将设计一种方法，仅从正例中学习。\n出于教学目的，我们将考虑一个非常简单的概念学习案例，称为 数字游戏，基于Josh Tenenbaum博士论文的一部分（Tenenbaum 1999）。游戏如下进行: 我选择了一些简单的算术概念 C，例如“素数”或“1到10之间的数字”。然后我给你一系列随机选择的正例 \\(\\mathcal{D}=\\{\\boldsymbol{x}_1,\\dots,\\boldsymbol{x}_N\\},\\boldsymbol{x}_i \\in C\\)  ，并问你一个新的测试例 \\(\\tilde{\\boldsymbol{x}}\\)  是否属于C，即我要求你对 \\(\\tilde{\\boldsymbol{x}}\\)  进行分类。\n假设，为简单起见，所有数字都是1到100之间的整数。现在如果我告诉你“16”是概念的一个正例。你认为还有哪些其他那些数字是正例？ 17？ 6？ 32？ 99？只用一个案例很难说清楚，所以你的预测会很模糊。据推测，在某种意义上与16相似的数字更有可能。但是以什么方式相似？ 17是类似的，因为它是“靠近”，6是相似的，因为它有一个共同的数字，32是相似的，因为它也是偶数和2的幂，但99似乎不相似。因此，一些数字比其他数字更可能。我们可以将其表示为概率分布 \\(p(\\tilde{\\boldsymbol{x}}|\\mathcal{D})\\)  : 对任何数据 \\(\\tilde{\\boldsymbol{x}} \\in \\{1,\\dots,100\\}\\)  , 在给定数据集 \\(\\mathcal{D}\\)  条件下, \\(\\tilde{\\boldsymbol{x}} \\in C\\)  的概率 。称之为 后验预测分布。 图3.1（顶排）显示了从实验室实验获得的人的预测分布。我们看到人们在各种相似性下预测与16相似的数字。\n现在假设我告诉你，8,2和64 也是 正面的例子。现在你可能会猜到隐藏的概念是“2次幂”。这是一个案例归纳的。鉴于这一假设，预测分布是非常具体的，并将其大部分落在2次幂数上，如图3.1（第三行）所示。相反，如果我告诉你的数据是 \\(\\mathcal{D}=\\{16,23,19,20\\}\\)  ， 你将得到不同的泛化梯度( you will get a different kind of generalization gradient )，如图3.1（底部）。\n我们如何解释这种行为并在机器中模拟它？经典方法, 归纳起来说, 假设我们有一个概念的假设空间(hypothesis space) \\(\\mathcal{H}\\)  , 比如: 奇数，偶数，1到100之间的所有数，2次幂，所有以 \\(j\\)  结尾的数( \\(0 \\le j \\le 9\\)  ), 等等. 和数据 \\(\\mathcal{D}\\)  一致的 \\(\\mathcal{H}\\)  子集被称作版本空间(version space)。正如我们看到例子那样，版本空间越小，我们对这个概念越肯定（Mitchell 1997）。\n然而，版本空间并不是全部。看到 \\(\\mathcal{D}=\\{16\\}\\)  后 ，有许多一致的规则; 如何将它们结合起来预测 \\(\\tilde{\\boldsymbol{x}} \\in C\\)  ？此外，看到 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  后，你为什么选择“2次幂”规则，而不是说，“所有的偶数”，或“2次幂-{32}”，这两者都与证据一致？ 为此, 我们现在将提供贝叶斯解释。\n3.2.1 拟然(Likelihood) 我们必须解释, 在看到 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  之后, 为什么选择 \\(h_{two}\\overset{\\Delta}{=}\\)  \u0026quot;2次幂\u0026quot; ，而不是说 \\(h_{even}\\overset{\\Delta}{=}\\)  \u0026quot;偶数\u0026quot;. 考虑到两种假设都与证据相一致。关键的直觉是我们想要避免可疑的巧合。如果真正的概念是偶数，为什么我们只看到碰巧是2次幂数字？\n为了形式化这一点，让我们假设从一个概念的外延随机均匀地采样获得示例 。 （概念外延只是属于它的数字集合，例如， \\(h_{even}\\)  的外延是 \\(\\{2,4,6,\\dots,98,100\\}\\)  ; “以9结尾的数”的外延是 \\(\\{9,19,\\dots,99\\}\\)  . Tenenbaum称其为强抽样假设。 给定这个假设，从 \\(h\\)  中独立地采样出 \\(\\mathcal{D}\\)  的概率:\n\\[ p(\\mathcal{D} | h)=\\left[ \\dfrac {1} {{\\rm size}(h)} \\right]^N=\\left[ \\dfrac {1} {\\left| h \\right|} \\right]^N, \\quad N=\\left| \\mathcal{D} \\right| \\tag{3.2} \\]  这个关键的等式体现了Tenenbaum所说的尺寸原理，这意味着该模型倾向于与数据一致的最简单（最小）假设。这通常被称为 奥卡姆剃刀 。\n看看它是如何工作的，令让 \\(\\mathcal{D}=\\{ 16 \\}\\)  , 那么 \\(p(\\mathcal{D} | h_{two})={1 \\over 6}\\)  。因为 \\(h_{two}\\)  只有6个的小于100的2的幂, 但是 \\(p(\\mathcal{D} | h_{even})={1 \\over 50}\\)  ，因为有50个偶数。所以 \\(h= h_{two}\\)  的拟然高过 \\(h= h_{even}\\)  。 对于4个例子的 \\(\\mathcal{D}\\)  ， \\(h_{two}\\)  的拟然是 \\(\\left( 1 \\over 6 \\right)^4=7.7 \\times 10^{-4}\\)  ，而 \\(h_{even}\\)  的拟然是 \\(\\left( 1 \\over 50 \\right)^4=1.6 \\times 10^{-7}\\)  。这里似然比 几乎是 \\(5000:1\\)  ，有利于 \\(h_{two}\\)  。这个数据支持了我们先前的直觉，即,如果 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  是由 \\(h_{even}\\)  生成. 那么很可能是可疑的巧合.\n3.2.2 先验(Prior) 假设 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  。 给定此数据，概念 \\(h^{'}=\\)  \u0026quot;排除32的2次幂\u0026quot;比 \\(h=\\)  \u0026quot;2次幂\u0026quot;更可能，因为 \\(h^{'}\\)  不需要解释这组例子中缺少32的巧合。\n 图3.2 \\(\\mathcal{D}=\\{16\\}\\)  的 先验, 拟然和后验。\n 但是，假设 \\(h^{'}=\\)  \u0026quot;2次幂-{32}\u0026ldquo;比 \\(h=\\)  \u0026quot;2次幂\u0026quot;似乎“概念上很不自然”。我们可以通过为这种不自然概念指定低的先验概率来捕捉这种直觉。当然，您的先验可能与我的不同。这种贝叶斯推理的主观方面引起了很多争议，因为它意味着，例如，儿童和数学教授将会得到不同的答案。事实上，他们可能不仅有不同的先验，而且还有不同的假设空间。然而，我们可以通过将儿童和数学教授的假设空间定义为相同来确定，然后将孩子的先验权重设置为某些“高级”概念为零。因此，先验空间和假设空间之间没有明显的区别。\n虽然先验的主观性是有争议的，但它实际上非常有用。如果你被告知这些数字来自某些算术规则，那么给定1200,1500,900和1400，你可能会认为400可能，但1183不太可能。但如果你被告知数字是健康胆固醇水平的例子，你可能会认为400不太可能，1183可能。因此，我们看到先验是可以使背景知识对问题产生影响的机制。没有这个，快速学习（即从小样本尺寸）是不可能的。\n那么，我们应该使用什么先验呢？为了便于说明，让我们使用一个简单的先验，它将均匀概率放在30个简单的算术概念上，例如“偶数”，“奇数”，“素数”，“以9结尾的数字”，等等。为了事情更有趣，我们将故意使概念变得更加古怪进而更像先验。我们包括两个“不自然”概念，即“2次幂+{37}”和“2次幂-{32}”，但给它们较低的先验权重。有关此先验的图，请参见图3.2（a）。我们稍后会考虑稍微复杂一点。\n3.2.3 后验(Posterior) 后验是拟然乘上先验再归一化。我们有\n\\[ p(h | \\mathcal{D}) = \\dfrac {p(\\mathcal{D} | h) p(h)} {\\sum_{h^{'} \\in \\mathcal{H}} {p(\\mathcal{D} | h^{'}) p(h^{'})}}= \\dfrac {p(h) \\mathbb{I}(\\mathcal{D} \\in h)/\\left| h \\right|^N } {\\sum_{h^{'} \\in \\mathcal{H}} {p(h^{'}) \\mathbb{I}(\\mathcal{D} \\in h')/\\left| h^{'} \\right|^N}} \\tag{3.3} \\]  其中 \\(\\mathbb{I}(\\mathcal{D} \\in h)=1\\)  当且仅当所有数据都在假设 \\(h\\)  的外延中。图3.2描绘了在看到 \\(\\mathcal{D}=\\{16\\}\\)  后的先验，拟然可能性和后验 。我们看到后验是先验和拟然的结合。在大多数概念的情况下，先验是均匀的，因此后验与拟然成比例。然而，“2次幂+{37}”和“2次幂-{32}”的“不自然的”概念具有低的后验支撑，尽管由于低先验而具有高拟然。相反，由于低拟然，奇数的概念具有较低的后验支持，尽管具有较高的先验。\n 图3.3 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  的 先验, 拟然和后验。\n 图3.3绘制了 看到 \\(\\mathcal{D} = \\{ 16,8,2,64 \\}\\)  后的先验 ,拟然和后验 。现在，在2次幂概念的拟然更加突出，所以这支配了后验。本质上，学习者有一个惊喜的时刻，并且证实了这个新概念。 （这里我们看到非自然概念需要较低的先验，否则我们将拟合数据, 以凸显“2次幂-{32}”。）\n一般来说，当我们有足够的数据时，后验 \\(p(h | \\mathcal{D})\\)  变得在单个概念上显著，称之为MAP估计(最大后验估计)，即,\n\\[ p(h | \\mathcal{D}) \\to \\delta_{\\hat{h}^{\\rm MAP}} \\left(h\\right) \\tag{3.4} \\]  其中 \\(\\hat{h}^{\\rm MAP} = \\underset{h}{\\rm argmax} \\ p(h | \\mathcal{D})\\)  是后验模式，并且 \\(\\delta\\)  是 狄拉克量度, 定义为:\n\\[ \\delta_x(A) = \\begin{cases} 1 \u0026 x \\in A \\\\ 0 \u0026 x \\notin A\\end{cases} \\tag{3.5} \\]  请注意，MAP估计可以被写为:\n\\[ \\hat{h}^{\\rm MAP}= \\underset{h}{\\rm argmax} \\ p(\\mathcal{D} | h) p(h) = \\underset{h}{\\rm argmax} \\ [ {\\rm log} \\ p(\\mathcal{D} | h) + {\\rm log} \\ p(h)] \\tag{3.6} \\]  由于似然项指数依赖 \\(N\\)  ， 并且先验保持不变，随着我们获得越来越多的数据，MAP估计收敛到最大似然估计(MLE):\n\\[ \\hat{h}^{\\rm mle} \\overset{\\Delta}{=} \\underset{h}{\\rm argmax} \\ p(\\mathcal{D} | h) = \\underset{h}{\\rm argmax} \\ {\\rm log} \\ p(\\mathcal{D} | h) \\tag{3.7} \\]  换句话说，如果我们有足够的数据，我们会看到的数据淹没先验( data overwhelms the prior)。在这种情况下, MAP估计收敛于MLE。\n如果这个真的假设在假设空间中，那么MAP/ML估计将收敛于该假设。因此我们说贝叶斯推断（及 ML估计）是一致估计（详见6.4.1节）。我们也说这个假设空间是极限可识别的(identiﬁable in the limit)，这意味着我们可以从极其有限的数据中恢复真相。如果我们的假设类不足以代表“真理”（通常就是这种情况），我们将趋于尽可能接近真理的假设。然而，将这种“亲近”概念的形式化已超出本章的范围。\n3.2.4 后验预测分布  图3.4 看到一个正例 \\(\\mathcal{D}=\\{16\\}\\)  后的后验假设及其相应的预测分布。图中的点表示与此假设一致的数字。右边的图 \\(p(h | \\mathcal{D})\\)  是假设 \\(h\\)  的权重。通过所有点的加权求和，我们得到 \\(p(\\tilde{\\boldsymbol{x}} \\in C | \\mathcal{D})\\)  （ 顶部的图）。\n 后验是我们关于世界的内在信念状态(belief state) 。测试我们的信念是否合理的方法是使用它们来预测客观可观察的数量（这是科学方法的基础）。具体来说，在这种意义下, 后验预测分布 可由下式给出.\n\\[ p(\\tilde{\\boldsymbol{x}} \\in C | \\mathcal{D}) = \\sum_h {p(y=1 | \\tilde{\\boldsymbol{x}},h) p(h | \\mathcal{D})} \\tag{3.8} \\]  这就是对所有假设的预测的进行加权平均, 被称为 贝叶斯模型平均 （Hoeting等，1999）, 如图3.4所示。 图中底部的点显示了每个假设的预测; 右边的垂直曲线显示了与每个假设相关的权重。如果我们将每一行乘以它的权重并加起来，我们得到图中顶部的分布。\n当我们有一个小的 和/或 模糊的数据集时，后验 \\(p(h | \\mathcal{D})\\)  是模糊的，这导致宽的预测分布。然而，一旦我们“解决了问题”，后验就变成了以MAP估计为中心的delta函数。在这种情况下，预测分布变成:\n\\[ p(\\tilde{\\boldsymbol{x}} \\in C | \\mathcal{D}) = \\sum_h {p(\\tilde{\\boldsymbol{x}} |h) \\delta_{\\hat{h}}(h)} \\tag{3.9} \\]  被称为 预测概率密度的插入式近似(plug-in approximation) ,并且由于其简单性而被广泛使用。然而，总的来说，这不足以代表我们的不确定性，而且我们的预测不会像使用BMA那样“平稳”。我们将在本书后面看到更多这方面的例子。\n尽管MAP学习很简单，但它无法解释从基于相似性的推理（具有不确定的后验）到基于规则的推理（具有某些后验）的逐渐转变。例如，假设我们观察到 \\(\\mathcal{D}=\\{16\\}\\)  。如果我们使用上面的简单先验，则最小一致假设是“4的所有幂”，因此只有4和16得到非零概率的预测。这当然是过拟合的一个例子。给定 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  ，MAP 假设是“2次幂”。因此，当我们看到更多数据时，插入式预测分布变得更宽（或保持不变）：它开始狭窄的，但由于看到更多数据而被迫扩大。相比之下，在贝叶斯方法中，如果我们学的更多, 那么开始宽泛然后缩小，这更直观。特别是，给定 \\(\\mathcal{D}=\\{16\\}\\)  ，有许多具有不可忽视的后验支撑的假设，因此预测分布是宽泛的。然而，当我们看到 \\(\\mathcal{D}=\\{16,8,2,64\\}\\)  ， 后验集中在一个假设上，因此，预测分布变得更窄。因此，插入方法和贝叶斯方法的预测在小样本环境中是完全不同的，尽管我们看到更多数据时, 它们都收敛到的相同的答案。\n3.2.5 一个更加复杂的先验  图3.5 使用完整假设空间模型的预测分布。与图3.1比较。贝叶斯模型的预测仅绘出针对人类数据是可用的那些值 \\(\\tilde{\\boldsymbol{x}}\\)  ; 这就是为什么顶部图的线比图3.4更稀疏的原因。\n 为人类行为建模，Tenenbaum使用了一个稍微复杂的先验，通过分析人们如何衡量数字之间相似性的一些实验数据得出结论, 更详细信息，请参阅（Tenenbaum 1999，p208）。结果是一组类似于上面提到的算术概念，加上所有 n和m之间的区间( \\(1 \\le n,m \\le 100\\)  )。 （注意，这些假设不是相互排斥）。因此这个先验是两个先验的混合物，一个前面提及的算术规则，另一个以上的区间:\n\\[ p(h)=\\pi_0 \\ p_{\\rm rules} (h) +(1-\\pi_0) \\ p_{\\rm interval} (h) \\tag{3.10} \\]  模型中仅有的自由参数是相对权重 \\(\\pi_0\\)  ，在现有的这两个先验部分中。这个值对结果并不十分敏感，只要 \\(\\pi_0  0.5\\)  ，反映的一个事实是人们更有可能想到规则所定义的概念。这个使用更大的假设空间的模型的预测分布, 如图3.5所示。它与人类预测分布惊人地相似，如图3.1所示，尽管它不适用于人类数据（以假设空间的选择为模）。\n返回本章目录\n"}),a.add({id:283,href:'/notes/tags/%E6%A6%82%E5%BF%B5%E5%AD%A6%E4%B9%A0/',title:"概念学习",content:""}),a.add({id:284,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/0039/',title:"3.1 引言",content:"返回本章目录\n在第2.2.3.2中，我们讨论了如何对特征矢量   \\(\\boldsymbol{x}\\)  进行分类: 应用贝叶斯法则得到形如下式的生成式分类器:\n\\[ p(y=c | \\boldsymbol{x},\\boldsymbol{\\theta}) \\propto p(\\boldsymbol{x} | y=c ,\\boldsymbol{\\theta}) p(y=c |\\boldsymbol{\\theta}) \\tag{3.1} \\]  使用此模型的关键是指定一个合适的类条件密度 \\(p(\\boldsymbol{x} | y=c ,\\boldsymbol{\\theta})\\)  ，它定义了在每一类中我们期望的数据类型。在本章中，我们关注离散情况下的数据。我们还讨论在此模型中如何推断未知参数 \\(\\boldsymbol{\\theta}\\)  。\n返回本章目录\n"}),a.add({id:285,href:'/notes/tags/%E7%89%B9%E5%BE%81%E7%9F%A2%E9%87%8F/',title:"特征矢量",content:""}),a.add({id:286,href:'/notes/docs/mlapp/03generative_models_for_discrete_data/',title:"第三章 基于离散数据的生成式模型",content:"第三章 基于离散数据的生成式模型 本节中的目录：\n  3.1 引言\n  3.2 贝叶斯概念学习\n  3.3 贝塔-二项模型\n  3.4 狄利克雷-多项模型\n  3.5 朴素贝叶斯分类器\n  Exercises\n  "}),a.add({id:287,href:'/notes/docs/mlapp/02probability/0038/',title:"Exercises",content:"返回本章目录\n"}),a.add({id:288,href:'/notes/docs/mlapp/02probability/0035/',title:"2.6 Transformations of random variables",content:"返回本章目录\n"}),a.add({id:289,href:'/notes/docs/mlapp/02probability/0036/',title:"2.7 Monte Carlo approximation",content:"返回本章目录\n"}),a.add({id:290,href:'/notes/docs/mlapp/02probability/0037/',title:"2.8 Information theory",content:"返回本章目录\n"}),a.add({id:291,href:'/notes/docs/mlapp/02probability/0034/',title:"2.5 联合概率分布",content:"返回本章目录\n到目前为止，我们一直专注于建模单变量概率分布。 在本节中，我们开始讨论在多个相关随机变量上建立联合概率分布的更具挑战性的问题; 这将是本书的核心主题。\n联合概率分布形如   \\(p(x_1,\\dots,x_D),D1\\)  ，并且模拟变量之间的（随机）关系。 如果所有变量都是离散的，我们可以将联合分布表示为一个大的多维数组，每个维度有一个变量。 但是，定义这种模型所需的参数数量是 \\(O(K^D)\\)  ，其中K是每个变量的状态数。\n我们可以通过条件独立性假设使用更少的参数来定义高维联合分布，正如我们在第10章中解释的那样。在连续分布的情况下，另一种方法是将pdf的形式限制为某些函数形式，其中一些我们将在下面进行研究。\n2.5.1 协方差和相关性 两个随机变量X和Y之间的协方差衡量了X和Y的（线性）相关度。 协方差定义为\n\\[ {\\rm cov}[X,Y]\\overset{\\Delta}{=}\\mathbb{E}[(X-\\mathbb{E}[X])(Y-\\mathbb{E}[Y])]=\\mathbb{E}[XY]-\\mathbb{E}[X]\\mathbb{E}[Y] \\tag{2.65} \\]  如果 \\(\\boldsymbol{x}\\)  是d维随机向量，则其协方差矩阵被定义为如下的对称正定矩阵：\n\\[ \\begin{aligned} {\\rm cov}[\\boldsymbol{x}] \\overset{\\Delta}{=} \u0026 \\mathbb{E}\\left[(\\boldsymbol{x}-\\mathbb{E}[\\boldsymbol{x}])(\\boldsymbol{x}-\\mathbb{E}[\\boldsymbol{x}])^T\\right] \\\\ \\quad = \u0026 \\left(\\begin{matrix}{\\rm var}[X_1] \u0026 {\\rm cov}[X_1,Y_2] \u0026 \\dots \u0026 {\\rm cov}[X_1,Y_d]\\\\ {\\rm cov}[X_2,Y_1] \u0026 {\\rm var}[X_2] \u0026 \\dots \u0026 {\\rm cov}[X_2,Y_d]\\\\ \\vdots \u0026 \\vdots \u0026 \\dots \u0026 \\vdots\\\\ {\\rm cov}[X_d,Y_1] \u0026 {\\rm cov}[X_d,Y_2] \u0026 \\dots \u0026 {\\rm var}[X_d]\\\\ \\end{matrix}\\right) \\end{aligned} \\tag{2.66-67} \\]  协方差可以在0和 \\(\\infty\\)  之间。 有时使用标准化度量(有上限)更方便。 X和Y之间的（Pearson）相关系数定义为\n\\[ {\\rm corr}[X,Y]\\overset{\\Delta}{=}\\dfrac{{\\rm cov}[X,Y]}{\\sqrt{{\\rm var}[X]{\\rm var}[Y]}} \\tag{2.68} \\]  一个相关系数矩阵形如\n\\[ R =\\left(\\begin{matrix}1 \u0026 {\\rm corr}[X_1,Y_2] \u0026 \\dots \u0026 {\\rm corr}[X_1,Y_d]\\\\ {\\rm corr}[X_2,Y_1] \u0026 1 \u0026 \\dots \u0026 {\\rm corr}[X_2,Y_d]\\\\ \\vdots \u0026 \\vdots \u0026 \\dots \u0026 \\vdots\\\\ {\\rm corr}[X_d,Y_1] \u0026 {\\rm corr}[X_d,Y_2] \u0026 \\dots \u0026 1\\\\ \\end{matrix}\\right) \\tag{2.69} \\]  可以证明（练习4.3） \\(-1 \\le {\\rm corr}[X,Y] \\le 1\\)  。在相关系数矩阵中，对角线上的项都是1，而其他条目在-1和1之间。\n也可以证明 \\({\\rm corr} [X,Y] = 1\\)  ，当且仅当，X和Y之间存在线性关系，即 \\(Y = a X + b, \\exists a,b\\)  ，（参见练习4.4）。 直观地，可以预期相关系数与回归线的斜率相关，即表达式 \\(Y=a X+b\\)  中的系数 \\(a\\)  。 然而，正如我们后面所在证明的公式7.99那样，回归系数实际上就是由 \\(a={\\rm cov} [X,Y] / {\\rm var} [X]\\)  给出的。 考虑相关系数的更好方法是线性度：见图2.12。\n 图2.12 几组(x,y)点，每组都反映了x和y的相关系数。 注意，相关反映了线性关系的噪声和方向（顶行），而不是反映了该关系的斜率（中间），也无法反映非线性关系的许多方面（底部）。 注意：中心的数字的斜率为0，但在这种情况下，相关系数是不确定的，因为Y的方差为零。 源自: http://en.wikipedia.org/wiki/File:Correlation_examples.png\n 如果X和Y是独立的，意味着 \\(p(X,Y)=p(X)p(Y)\\)  （见2.2.4节），于是 \\({\\rm cov} [X,Y] = 0\\)  ，进而 \\({\\rm corr} [X,,Y] = 0\\)  ，因此它们是不相关的。 然而，反过来是不成立的：不相关并不意味着独立。 例如，设 \\(X \\sim U(-1,1)\\)  和 \\(Y = X^2\\)  。 显然Y依赖于X（事实上，Y由X唯一确定），但是可以证明（练习4.1） \\({\\rm corr} [X,Y] = 0\\)  。 图2.12展示了这一事实的一些引人注目的例子。 这显示了几个数据集，其中X和Y之间存在明显的依赖关系，但相关系数为0。更一般的随机变量之间的依赖性度量是互信息(mutual information)，将在2.8.3节中讨论。 如果变量确实是独立的，那么它只能是零。\n2.5.2 多元高斯分布 多元高斯或多元正态（MVN）是连续变量使用最广泛的联合概率密度函数。 我们将在第4章详细讨论MVN; 这里我们只给出一些定义和图表。\nD维MVN的pdf由定义如下：\n\\[ \\mathcal{N}(\\boldsymbol{x}|\\boldsymbol{\\mu},\\boldsymbol{\\Sigma})\\overset{\\Delta}{=} \\dfrac{1}{(2\\pi)^{D/2}|\\boldsymbol{\\Sigma}|^{1/2}}\\exp\\left[-\\dfrac{1}{2}(\\boldsymbol{x}-\\boldsymbol{\\mu})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right] \\tag{2.70} \\]  其中， \\(\\boldsymbol{\\mu}= \\mathbb{E} [\\boldsymbol{x}] \\in \\mathbb{R}^D\\)  是均值向量，并且 \\(\\boldsymbol{\\Sigma}= {\\rm cov} [\\boldsymbol{x}]\\)  是D×D协方差矩阵。 有时我们会使用精度矩阵或浓度矩阵， 这只是逆协方差矩阵， \\(\\boldsymbol{\\Lambda}=\\boldsymbol{\\Sigma}^{-1}\\)  。 归一化常数 \\((2\\pi)^{-D/2}|\\boldsymbol{\\Lambda}|^{1/2}\\)  只确保pdf积分为1（参见练习4.5）。\n图2.13绘制了三种不同协方差矩阵的2维MVN密度。 完整的协方差矩阵具有 \\(D(D+1)/ 2\\)  个参数（由于 \\(\\boldsymbol{\\Sigma}\\)  是对称的，所以除以2）。 对角协方差矩阵则有D个参数（非对角线项为0）。 球面或各向同性协方差 \\(\\boldsymbol{\\Sigma}=\\sigma^2\\boldsymbol{I}_D\\)  只有一个自由参数。\n 图2.13 我们展示2维高斯的水平集。 （a）完全协方差矩阵具有椭圆等高线。 （b）对角协方差矩阵是轴对齐的椭圆。 （c）球形协方差矩阵具有圆形形状。 （d）绘制c中球形高斯的表面。 由_gaussPlot2Ddemo_生成的图。\n 2.5.3 多元学生t分布 比MVN的一个更稳健的替代方案是多变量学生t分布，其pdf由下式给出\n\\[ \\begin{aligned} \\mathcal{T}(\\boldsymbol{x}|\\boldsymbol{\\mu},\\boldsymbol{\\Sigma},v) = \u0026 \\dfrac{\\Gamma(v/2+D/2)}{\\Gamma(v/2)}\\dfrac{|\\boldsymbol{\\Sigma}|^{-1/2}}{v^{D/2}\\pi^{D/2}}\\left[1+\\dfrac{1}{v}(\\boldsymbol{x}-\\boldsymbol{\\mu})^T\\boldsymbol{\\Sigma}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right]^{-\\frac{v+D}{2}} \\\\ \\quad = \u0026 \\dfrac{\\Gamma(v/2+D/2)}{\\Gamma(v/2)}|\\pi \\boldsymbol{V}|^{-1/2}\\left[1+(\\boldsymbol{x}-\\boldsymbol{\\mu})^T\\boldsymbol{V}^{-1}(\\boldsymbol{x}-\\boldsymbol{\\mu})\\right]^{-\\frac{v+D}{2}} \\end{aligned} \\tag{2.71-72} \\]  其中， \\(\\boldsymbol{\\Sigma}\\)  称为缩放矩阵（因为它不完全是协方差矩阵）， \\(\\boldsymbol{V}=ν \\boldsymbol{\\Sigma}\\)  。 比高斯有更胖的尾巴。 ν越小，尾巴越胖。 当 \\(ν \\to \\infty\\)  时，分布趋于高斯分布。 这个分布有如下属性\n\\[ {\\rm mean}= \\boldsymbol{\\mu}, {\\rm mode}=\\boldsymbol{\\mu}, {\\rm Cov}=\\dfrac{v}{v-2}\\boldsymbol{\\Sigma} \\tag{2.73} \\]  2.5.4 狄利克雷分布 贝塔分布的多元推广是Dirichlet分布，它支持如下定义的概率单纯形(probability simplex)\n\\[ S_K=\\{\\boldsymbol{x}:0 \\le x_k \\le 1, \\sum_{k=1}^K{x_k}=1\\} \\tag{2.74} \\]  其pdf定义如下:\n\\[ {\\rm Dir}(\\boldsymbol{x}|\\boldsymbol{\\alpha})\\overset{\\Delta}{=}\\dfrac{1}{B(\\boldsymbol{\\alpha})}\\prod_{i=1}^K{x_k^{\\alpha_k-1}\\mathbb{I}(\\boldsymbol{x} \\in S_k)} \\tag{2.75} \\]  其中， \\(B(\\alpha_1,\\dots,\\alpha_K)\\)  是贝塔函数对K变量的自然推广：\n\\[ B(\\boldsymbol{\\alpha})\\overset{\\Delta}{=}\\dfrac{\\prod_{k=1}^K{\\Gamma(\\alpha_k)}}{\\Gamma(\\alpha_0)} \\tag{2.76} \\]  其中， \\(\\alpha_0 \\overset{\\Delta}{=}\\sum_{k=1}^K{\\alpha_k}\\)  。\n图2.14显示了K=3时狄利克雷分布的一些图，以及图2.15一些已采样的概率矢量。 我们看到 \\(\\alpha_0 =\\sum_{k=1}^K{\\alpha_k}\\)  控制分布的强度（它是如何达到峰值），以及 \\(\\alpha_k\\)  控制峰值出现在哪里。 例如， \\({\\rm Dir}(1,1,1)\\)  是均匀分布， \\({\\rm Dir}(2,2,2)\\)  是以(1/3,1/3,1/3)为中心的宽分布，和 \\({\\rm Dir}(20,20,20)\\)  以(1/3,1/3,1/3)为中心的窄分布 。 如果 \\(\\alpha_k，我们将单形角的拐角处得到“尖峰”。\n作为参考，此分布具有下述属性\n\\[ \\mathbb{E}[x_k]=\\dfrac{\\alpha_k}{\\alpha_0},{\\rm mode}[x_k]=\\dfrac{\\alpha_k-1}{\\alpha_0-1}, {\\rm var}[x_k]=\\dfrac{\\alpha_k(\\alpha_0-\\alpha_k)}{\\alpha_0^2(\\alpha_0+1)} \\tag{2.77} \\]  其中， \\(\\alpha_0 = \\sum_k{\\alpha_k}\\)  。 通常我们使用形如 \\(\\alpha_k=\\alpha/K\\)  的对称狄利克雷先验。 在这种情况下，均值变为1/K，方差变为 \\({\\rm var}[x_k] = \\frac{K-1}{K^2(\\alpha+1)}\\)  。 因此，增加 \\(\\alpha\\)  会增加分布的精度（减小方差）。\n 图2.14 （a）狄利克雷分布(K=3)定义了单纯形上的分布，可以由三角形表面表示。 该表面上的点满足 \\(0 \\le \\theta_k \\le 1\\)  和 \\(\\sum_{k =1}^3{\\theta_k}=1\\)  （b）当 \\(\\boldsymbol{\\alpha} = (2,2,2)\\)  时，狄利克雷密度的图。 （c） \\(\\boldsymbol{\\alpha} = (20,2,2)\\)  。 图由Jonathan Huang通过_visDirichletGui_生成。 （d） \\(\\boldsymbol{\\alpha} = (0.1,0.1,0.1)\\)  。 （边缘上的梳状结构是绘图伪像。）由_dirichlet3dPlot_生成的图。\n  图2.15 Samples from a 5-dimensional symmetric Dirichlet distribution for different parameter values.(a) α = (0.1,\u0026hellip;, 0.1). This results in very sparse distributions, with many 0s. (b) α = (1,\u0026hellip;, 1). This results in more uniform (and dense) distributions. Figure generated by dirichletHistogramDemo.\n 返回本章目录\n"}),a.add({id:292,href:'/notes/tags/%E5%8D%8F%E6%96%B9%E5%B7%AE/',title:"协方差",content:""}),a.add({id:293,href:'/notes/tags/%E7%9B%B8%E5%85%B3%E6%80%A7/',title:"相关性",content:""}),a.add({id:294,href:'/notes/docs/mlapp/02probability/0033/',title:"2.4 一些常见的连续分布",content:"返回本章目录\n在本节中，我们展现了一些常用的单变量（一维）连续概率分布。\n2.4.1 高斯（正态）分布 统计学和机器学习中使用最广泛的分布是高斯分布或正态分布。 它的pdf是\n  \\[ \\mathcal{N}(x|\\mu,\\sigma^2) \\overset{\\Delta}{=} \\dfrac{1}{\\sqrt{2 \\pi \\sigma^2}} e^{-\\frac{1}{2\\sigma^2}(x-\\mu)^2} \\tag{2.43} \\]  这里 \\(\\mu = \\mathbb{E} [X]\\)  是均值（和众数）， \\(\\sigma^2= {\\rm var} [X]\\)  是方差。 \\(\\sqrt{2 \\pi \\sigma^2}\\)  是确保密度积分为1的归一化常数（见练习2.11）。\n我们用 \\(X \\sim \\mathcal{N}(\\mu,\\sigma^2)\\)  来表示 \\(p(X=x)=\\mathcal{N}(x |\\mu,\\sigma^2)\\)  。 如果 \\(X \\sim \\mathcal{N}(0,1)\\)  ，则说 \\(X\\)  服从标准正态分布。 有关此pdf的绘制参见图2.3（b）; 有时被称为钟形曲线。\n我们经常谈的高斯精度，指的是逆方差： \\(\\lambda = 1 /\\sigma^2\\)  。 高精度意味着以 \\(\\mu\\)  为中心的窄分布（低方差）。\n请注意，由于这是一个pdf，可以有 \\(p(x) 1\\)  。为了看到这一点，考虑计算其中心 \\(x=\\mu\\)  的密度。 我们有 \\(N(\\mu|\\mu,\\sigma^2)=(\\sigma \\sqrt{2 \\pi})^{-1} e^0\\)  ，所以如果 \\(\\sigma，我们有 \\(p(x)1\\)  。\n高斯的累积分布函数或cdf定义为\n\\[ \\Phi(x;\\mu,\\sigma^2) \\overset{\\Delta}{=} \\int_{-\\infty}^x{\\mathcal{N}(z|\\mu,\\sigma^2)dz} \\tag{2.44} \\]  当 \\(\\mu = 0,\\sigma^2= 1\\)  时，cdf绘制见图2.3（a）。该积分没有封闭形式表达式，但内置于大多数软件包中。 特别是，我们可以根据误差函数（erf）计算它：\n\\[ \\Phi(x;\\mu,\\sigma^2) = \\dfrac{1}{2}[1+{\\rm erf}(z/\\sqrt{z})] \\tag{2.45} \\]  其中 \\(z = (x-\\mu)/\\sigma\\)  及\n\\[ {\\rm erf}(x)\\overset{\\Delta}{=}\\dfrac{2}{\\sqrt{\\pi}}\\int_0^x{e^{-t^2}dt} \\tag{2.46} \\]  高斯分布是统计学中使用最广泛的分布。 有几个原因。 首先，它有两个易于解释的参数，它们捕获分布的一些最基本的属性，即它的均值和方差。 其次，中心极限定理（第2.6.3节）告诉我们，独立随机变量的总和近似高斯分布，使其成为建模残差或“噪声”的良好选择。 第三，高斯分布假设具有最小数量的假设（具有最大熵），受限于具有指定的均值和方差，如第9.2.6节所示; 这使它在许多情况下成为一个很好的默认选择。 最后，它有一个简单的数学形式，这导致易于实现，但通常是高效的方法(我们将看到)。 参见（Jaynes 2003，第7章）有关高斯如此广泛使用的更多讨论。\n2.4.2 退化pdf 在 \\(\\sigma^2 \\to 0\\)  的极限中，高斯变为以 \\(\\mu\\)  为中心的无限高且无限薄的“尖峰”：\n\\[ \\lim_{\\sigma^2 \\to 0} \\mathcal{N}(x|\\mu,\\sigma^2) = \\delta(x-\\mu) \\tag{2.47} \\]  其中δ称为狄拉克函数，定义为\n\\[ \\delta(x)=\\left\\{ \\begin{aligned} \\infty \\quad \u0026 if \\quad x=0 \\\\ 0 \\quad \u0026 if \\quad x \\ne 0 \\\\ \\end{aligned} \\right. \\tag{2.48} \\]  满足\n\\[ \\int_{-\\infty}^{+\\infty} {\\delta(x)dx}=1 \\tag{2.49} \\]  delta函数的一个有用性质是筛选属性(sifting property)，它从求和或积分中选择一个单独项：\n\\[ \\int_{-\\infty}^{+\\infty} {f(x)\\delta(x-\\mu)dx}=f(\\mu) \\tag{2.50} \\]  因为被积函数只在 \\(x=\\mu\\)  处非零。\n高斯分布的一个问题是它对异常值敏感，因为对数概率仅随距离中心的距离而平方衰减。 更稳健的分布是学生t分布，其pdf如下：\n\\[ \\mathcal{T}(x|\\mu,\\sigma^2,\\upsilon) \\propto \\left[1+\\dfrac{1}{\\upsilon}\\left(\\dfrac{x-\\mu}{\\sigma}\\right)^2\\right]^{-(\\frac{\\upsilon+1}{2})} \\tag{2.51} \\]  其中 \\(\\mu\\)  是均值， \\(\\sigma^2 0\\)  是比例参数， \\(\\upsilon 0\\)  称为自由度。 参见图2.7。 供以后参考，我们注意到该分布具有以下属性：\n\\[ {\\rm mean}=\\mu, {\\rm mode}=\\mu, {\\rm var}=\\dfrac{\\upsilon \\sigma^2}{(\\upsilon-2)} \\tag{2.52} \\]  仅在 \\(\\upsilon  2\\)  时方差才有定义。仅在 \\(\\upsilon 1\\)  时均值才有定义。\n 图2.7 （a）对于 \\(\\mathcal{N}(0,1)\\)  ， \\(\\mathcal{T}(0,1,1)\\)  和 \\({\\rm Lap}(0,1/\\sqrt{2})\\)  的pdf。 对于高斯和拉普拉斯，其均值都为0并且其方差都为1。 当 \\(\\upsilon= 1\\)  时，学生的均值和方差是不确定的。（b）这些pdf的对数。 请注意，对于任何参数值，学生分布都不是对数凹的，不像拉普拉斯分布，它总是对数凹（和对数凸\u0026hellip;）然而，两者都是单峰的。 由_studentLaplacePdfPlot_生成的图。\n 为了说明学生分布的稳健性，请考虑图2.8。 在左侧，我们显示高斯和学生都适合某些数据，没有异常值。 在右边，我们添加了一些异常值。 我们看到高斯受到很大影响，而学生分布几乎没有变化。 这是因为学生有更重的尾巴，至少对于小的 \\(\\upsilon\\)  （见图2.7）。\n 图2.8 异常值对拟合高斯，学生和拉普拉斯分布的影响的例证。 （a）没有异常值（高斯和学生曲线相互叠加）。 （b）有异常值。 我们看到高斯更多地受到异常值的影响而不是学生和拉普拉斯分布。 基于（Bishop 2006a）的图2.16。 由_robustDemo_生成的图。\n 如果 \\(\\upsilon= 1\\)  ，则该分布称为柯西或洛伦兹分布。 这是值得注意的是，具有如此重的尾部使得定义均值的积分不会收敛。\n为了确保有限方差，我们要求 \\(\\upsilon 2\\)  。通常使用 \\(\\upsilon= 4\\)  ，这样就能在一系列问题中表现出良好的性能（Lange等，1989）。 对于 \\(\\upsilon \\gg 5\\)  ，学生分布快速接近高斯分布并失去其稳健性(鲁棒性)。\n2.4.3 拉普拉斯分布 具有重尾的另一种分布是拉普拉斯分布 ，也称为双侧指数分布。 有以下pdf：\n\\[ {\\rm Lap}(x|\\mu,b) \\overset{\\Delta}{=}\\dfrac{1}{2b} \\exp\\left(-\\dfrac{|x-\\mu|}{b}\\right) \\tag{2.53} \\]  这里 \\(\\mu\\)  是位置参数， \\(b 0\\)  是比例参数。 有关绘图参见图2.7。 此分布具有以下性质：\n\\[ {\\rm mean}=\\mu, {\\rm mode}=\\mu, {\\rm var}=2b^2 \\tag{2.54} \\]  它对异常值的稳健性如图2.8所示。 它还比高斯将更多的概率密度设置为0。 这个性质是在模型中增强稀疏的有用方法，我们将在第13.3节中看到。\n2.4.4 伽玛分布 伽玛分布是对正实值随机变量 \\(x0\\)  的灵活分布。它是根据两个参数定义的，称为形状 \\(a 0\\)  且比率 \\(b 0\\)  ：\n\\[ {\\rm Ga}(T|{\\rm shap}=a,{\\rm rate}=b)\\overset{\\Delta}{=}\\dfrac{b^2}{\\Gamma(a)}T^{a-1}e^{-Tb} \\tag{2.55} \\]  其中 \\(\\Gamma(a)\\)  是伽马函数：\n\\[ \\Gamma(x) \\overset{\\Delta}{=} \\int_0^\\infty {u^{x-1}e^{-u}du} \\tag{2.56} \\]  参见图2.9。 供以后参考，我们注意到该分布具有以下属性：\n\\[ {\\rm mean}=\\dfrac{a}{b},{\\rm mode}=\\dfrac{a-1}{b},{\\rm var}=\\dfrac{a}{b^2} \\tag{2.57} \\]   图2.9 （a）一些 \\({\\rm Ga}(a,b = 1)\\)  分布。 如果 \\(a \\le 1\\)  ，则众数为0，否则为 \\( 0\\)  。当我们增加速率b时，可以减小水平尺度，从而向左和向上挤压一切。 由_gammaPlotDemo_生成的图。 （b）一些降雨数据的经验pdf，叠加了拟合的Gamma分布。 由_gammaRainfallDemo_生成的图。\n 有几种分布只是Gamma的特殊情况，我们将在下面讨论。\n 指数分布 这由 \\({\\rm Expon}(x | \\lambda) \\overset{\\Delta}{=} {\\rm Ga}(x | 1, \\lambda)\\)  定义，其中 \\(\\lambda\\)  是速率参数。 该分布描述了泊松过程中事件之间的时间，即事件以恒定平均速率 \\(\\lambda\\)  连续且独立地发生的过程。 Erlang分布 与伽马分布相同，其中 \\(a\\)  是整数。 固定 \\(a = 2\\)  是常见的，产生单参数Erlang分布， \\({\\rm Erlang}(x |\\lambda) = {\\rm Ga}(x | 2, \\lambda)\\)  ，其中 \\(\\lambda\\)  是速率参数。 卡方分布 由 \\(\\chi^2(x |\\upsilon) \\overset{\\Delta}{=} {\\rm Ga}(x |\\frac{\\upsilon}{2},\\frac{1}{2})\\)  定义。 这是平方高斯随机变量之和的分布。 更确切地说，如果 \\(Z_i \\sim \\mathcal{N}(0,1)\\)  ，并且 \\(S =\\sum_{i= 1}^\\upsilon{Z_i^2}\\)  ，那么 \\(S \\sim \\chi_\\upsilon^2\\)  。  另一个有用的结果如下：如果 \\(X \\sim {\\rm Ga}(a,b)\\)  ，则可以证明（练习2.10） \\(\\frac{1}{X} \\sim {\\rm IG}(a,b)\\)  ，其中 \\({\\rm IG}\\)  是由下式定义的反伽马分布：\n\\[ {\\rm IG}(x|{\\rm shape}=a, {\\rm scale}=b)\\overset{\\Delta}{=}\\dfrac{b^2}{\\Gamma(a)}x^{-(a+1)}e^{-b/x} \\tag{2.58} \\]  分布具有这些性质\n\\[ {\\rm mean}=\\dfrac{b}{a-1}, {\\rm mode}=\\dfrac{b}{a+1},{\\rm var}=\\dfrac{b^2}{(a-1)^2(a-2)} \\tag{2.59} \\]  均值只在 \\(a 1\\)  时存在。方差仅在 \\(a 2\\)  时存在。\n稍后我们将看到这些分布的应用。\n2.4.5 贝塔分布 贝塔分布支持区间[0,1]，并定义如下：\n\\[ {\\rm Beta}(x|a,b)=\\dfrac{1}{B(a,b)}x^{a-1}(1-x)^{b-1} \\tag{2.60} \\]  其中 \\(B(a,b)\\)  是贝塔函数，\n\\[ B(a,b)\\overset{\\Delta}{=}\\dfrac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)} \\tag{2.61} \\]  有关一些贝塔分布，参见图2.10。 我们要求 \\(a,b 0\\)  以确保分布是可积的（即，确保 \\(B(a,b)\\)  存在）。 如果 \\(a = b = 1\\)  ，我们得到均匀分布。 如果a和b都小于1，我们得到双峰分布，其中“尖峰”为0和1; 如果a和b都大于1，则得到单峰分布。 为了以后的参考，我们注意到该分布具有以下属性（练习2.16）：\n\\[ {\\rm mean}=\\dfrac{a}{a+b},{\\rm mode}=\\dfrac{a-1}{a+b-2},{\\rm var}=\\dfrac{a b}{(a+b)^2(a+b+1)} \\tag{2.62} \\]   图2.10 一些贝塔分布。 由_betaPlotDemo_生成的图。\n 2.4.6 帕累托分布 帕累托分布用于模拟表现出长尾(重尾)量的分布。 例如，已经观察到英语中最频繁的单词（“the”）出现的频率大约是第二个最频繁的单词（“of”）的两倍，其发生频率是第四个最频繁的单词的两倍，等等。 如果我们绘制单词的频率与他们的等级，我们将得到一个幂律; 这被称为齐夫定律(Zipf’s law)。 财富有类似的偏差分布，特别是在美国这样的富豪中 。\n帕累托的pdf定义如下：\n\\[ {\\rm Pareto}(x|k,m)=k m^k x^{-(k+1)}\\mathbb{I}(x \\ge m) \\tag{2.63} \\]  这个密度断言 \\(x\\)  必须大于某个常数 \\(m\\)  ，但不能太大，其中 \\(k\\)  控制的是“太多”。 当 \\(k \\to \\infty\\)  时，分布接近 \\(\\delta(x-m)\\)  。 参见图2.11（a）。 如果我们在对数-对数标度上绘制分布，它形成一条直线，形如 \\(\\log p(x)=a \\log x +c\\)  , 其中a和c是常数。 有关说明参见图2.11（b）（这称为幂律）。 此分布具有以下属性\n\\[ {\\rm mean}=\\dfrac{k m}{k-1}\\quad if \\quad k1, {\\rm mode}=m, {\\rm var}=\\dfrac{m^2 k}{(k-1)^2(k-2)} \\quad if \\quad k2 \\tag{2.64} \\]   图2.11 （a）帕累托分布 \\({\\rm Pareto}(x | m,k)（,m = 1\\)  。（b）对数-对数刻度上的pdf。 由_paretoPlot_生成的图。\n 返回本章目录\n"}),a.add({id:295,href:'/notes/docs/mlapp/02probability/0032/',title:"2.3 一些常见的离散分布",content:"返回本章目录\n在本节中，我们将回顾在离散状态空间(包括有限状态和可数无限状态)上定义的一些常用参数分布。\n2.3.1 二项和伯努利分布 假设我们投掷硬币n次。 设   \\(X \\in \\{0,\\dots,n\\}\\)  为出现头部的次数。 如果出现头的概率是 \\(\\theta\\)  ，那么我们说 \\(X\\)  具有二项分布，写为 \\(X \\sim {\\rm Bin}(n,\\theta)\\)  。 pmf由下式给出\n\\[ {\\rm Bin}(k | n, \\theta) \\overset{\\Delta}{=} \\binom{n}{k} \\theta^k (1-\\theta)^{n-k} \\tag{2.28} \\]  其中\n\\[ \\binom{n}{k} \\overset{\\Delta}{=}\\dfrac{n!}{(n-k)!k!} \\tag{2.29} \\]  是从n中选择k项的方法数（这被称为二项式系数，读着为“n选k”）。 有关二项分布的一些示例，请参见图2.4。 此分布具有以下均值和方差：\n\\[ {\\rm mean}=\\theta, {\\rm var}=n \\theta(1-\\theta) \\tag{2.30} \\]  现在假设我们只扔了一次硬币。 设 \\(X \\in \\{0,1\\}\\)  为二值随机变量，“成功”或“头”的概率为 \\(\\theta\\)  。 我们说 \\(X\\)  具有伯努利分布。 写为 \\(X \\sim {\\rm Ber}(\\theta)\\)  ，其pmf定义为\n\\[ {\\rm Ber}(x |\\theta) \\overset{\\Delta}{=} \\theta^{\\mathbb{I}(x=1)} (1-\\theta)^{\\mathbb{I}(x=0)} \\tag{2.31} \\]  换句话说\n\\[ {\\rm Ber}(x |\\theta) \\overset{\\Delta}{=} \\left\\{ \\begin{aligned} \\theta \\quad \u0026 {\\rm if} \\quad x=1 \\\\ 1-\\theta \\quad \u0026 {\\rm if} \\quad x=0 \\\\ \\end{aligned} \\right. \\tag{2.32} \\]  这显然只是二项分布的特殊情况( \\(n = 1\\)  )。\n 图2.4 二项分布的插图， \\(n = 10\\)  和 \\(\\theta \\in \\{0.25, 0.9\\}\\)  。 由_binomDistPlot_生成的图。\n 2.3.2多项和广义伯努利分布 二项分布可用于模拟硬币投掷的结果。 为了模拟抛掷具有K面的骰子的结果，我们可以使用多项分布。 这定义如下：令 \\(\\boldsymbol{x} =(x_1,\\dots,x_K)\\)  是随机向量，其中 \\(x_j\\)  是骰子的第 \\(j\\)  面出现的次数。 然后 \\(\\boldsymbol{x}\\)  有以下pmf：\n\\[ {\\rm Mu}(\\boldsymbol{x}|n, \\boldsymbol{\\theta}) \\overset{\\Delta}{=} \\binom{n}{x_1,\\dots,x_K}\\prod_{j=1}^K{\\theta_j^{x_j}} \\tag{2.33} \\]  其中 \\(\\theta_j\\)  是 \\(j\\)  面出现的概率，并且\n\\[ \\binom{n}{x_1,\\dots,x_K} \\overset{\\Delta}{=}\\dfrac{n}{x_1!x_2!\\dots x_K!} \\tag{2.34} \\]  是多项式系数（将大小为 \\(n = \\sum_{k = 1}^K{x_k}\\)  的集合切分成大小依次为 \\(x_1\\)  到 \\(x_K\\)  的 \\(K\\)  个子集的方法数）。\n现在假设n = 1.这就像滚动一个K侧骰子一样，因此 \\(\\boldsymbol{x}\\)  将是0-1向量（位向量），只能有一个位置为1(其它位置为0)。 具体来说，如果骰子显示为面 \\(k\\)  ，则第 \\(k\\)  位为1(其它位置为0)。 在这种情况下，我们可以将 \\(x\\)  视为具有K个状态（值）的标量分类随机变量，向量 \\(\\boldsymbol{x}\\)  是标量 \\(x\\)  的虚拟编码(dummy encoding)，即 \\(\\boldsymbol{x} = [\\mathbb{I}(x=1),\\dots,\\mathbb{I}(x=K)]\\)  。 例如，如果K = 3，我们将状态1，2和3编码为 \\((1,0,0)\\)  ， \\((0,1,0)\\)  和 \\((0,0,1)\\)  。 这也称为单热编码(one-hot encoding,)，因为我们想象 \\(K\\)  个位置中只有一个是“热”或“开”的。 在这种情况下，pmf变为\n\\[ {\\rm Mu}(\\boldsymbol{x}|1, \\boldsymbol{\\theta}) \\overset{\\Delta}{=} \\prod_{j=1}^K{\\theta_j^{\\mathbb{I}(x_j=1)}} \\tag{2.35} \\]  有关示例参见图2.1（b-c）。 这种非常常见的特殊情况称为分类(categorical)或离散分布。 （Gustavo Lacerda建议我们将其称为广义伯努利分布(multinoulli distribution)，类比二项式/伯努利式的区别，我们将在本书中采用这一术语。）我们将使用以下符号表示此分布：\n\\[ {\\rm Cat}(x|\\boldsymbol{\\theta}) \\overset{\\Delta}{=} {\\rm Mu}(\\boldsymbol{x}|1, \\boldsymbol{\\theta}) \\tag{2.36} \\]  换句话说，如果 \\(x \\sim {\\rm Cat}(\\boldsymbol{\\theta})\\)  ，则 \\(p(x = j | \\boldsymbol{\\theta})=\\theta_j\\)  。 有关摘要，请参阅表2.1。\n   分布 \\(n\\)   \\(k\\)   \\(x\\)       多项分布 - - \\(\\boldsymbol{x} \\in \\{0,1,\\dots,n\\}^K, \\sum_{k=1}^K{x_k}=n\\)     广义伯努利分布 1 - \\(\\boldsymbol{x} \\in \\{0,1\\}^K, \\sum_{k=1}^K{x_k}=1\\)  (1-of-K 编码)   二项分布 - 1 \\(x \\in \\{0,1,\\dots,n\\}\\)     伯努利分布 1 1 \\(x \\in \\{0,1\\}\\)       表2.1 多项分布及相关分布的摘要\n 2.3.2.1 应用：DNA序列基序 多项模型的一个有趣的应用出现在生物序列分析中。 假设我们有一组（对齐的）DNA序列，如图2.5（a）所示，其中有10行（序列）和15列（沿着基因组的位置）。 我们看到几个位置通过进化而保存（例如，因为它们是基因编码区的一部分），因为相应的列倾向于“纯”。 例如，第7列都是G'。\n一种可视化汇总数据的方法是使用序列标识(sequence logo)：见图2.5（b）。 我们将字母A，C，G和T绘制成与其经验概率成比例的字体大小，并在顶部绘制最可能的字母。 位置 \\(t\\)  的经验概率分布 \\(\\hat{\\theta}_t\\)  是通过对计数向量进行归一化得到的（见公式3.48）：\n\\[ \\begin{aligned} \\boldsymbol{N}_t = \u0026 \\left(\\sum_{i=1}^N{\\mathbb{I}(X_{it}=1)},\\sum_{i=1}^N{\\mathbb{I}(X_{it}=2)},\\sum_{i=1}^N{\\mathbb{I}(X_{it}=3)}, \\sum_{i=1}^N{\\mathbb{I}(X_{it}=4)}\\right) \\\\ \\hat{\\boldsymbol{\\theta}}_t = \u0026 \\boldsymbol{N}_t/N \\end{aligned} \\tag{2.37-38} \\]  这种分布被称为基序(motif)。 我们还可以计算每个位置最可能的字母; 这被称为共有序列(consensus sequence)。\n 图2.5 （a）一些对齐的DNA序列。 （b）相应的序列标识。 由_seqlogoDemo_生成的图。\n 2.3.3 泊松分布 我们说 \\(X \\in \\{0,1,2,\\dots\\}\\)  具有参数 \\(\\lambda 0\\)  的泊松分布，写成 \\(X \\sim {\\rm Poi}(\\lambda)\\)  ，如果它的pmf是\n\\[ {\\rm Poi}(x|\\lambda) \\overset{\\Delta}{=}e^{-\\lambda}\\dfrac{\\lambda^x}{x!} \\tag{2.39} \\]  第一项只是标准化常数，需要确保分布总和为1。\n泊松分布通常用作放射性衰变和交通事故等罕见事件计数的模型。 见图2.6。\n 图2.6 λ∈{1,10}的一些泊松分布图。 为清晰起见，我们已将x轴截断为25，但分布的支持超过了所有非负整数。 由_poissonPlotDemo_生成的图。\n 2.3.4 经验分布 给定一组数据， \\(\\mathcal{D} = \\{x_1,\\dots,x_N\\}\\)  ，我们定义经验分布，也称为经验度量，如下：\n\\[ p_{\\rm emp}(A)\\overset{\\Delta}{=}\\dfrac{1}{N}\\sum_{i=1}^N{\\delta_{x_i}(A)} \\tag{2.40} \\]  其中 \\(\\delta_{x}(A)\\)  是狄拉克度量，定义如下\n\\[ \\delta_x(A)=\\left\\{ \\begin{aligned} 0 \\quad \u0026 if \\quad x \\notin A \\\\ 1 \\quad \u0026 if \\quad x \\in A \\\\ \\end{aligned} \\right. \\tag{2.41} \\]  通常，我们可以为每个样本关联上一个“权重”：\n\\[ p(x) = \\sum_{i=1}^N{w_i \\delta_{x_i}(x)} \\tag{2.42} \\]  其中我们要求 \\(0 \\le w_i \\le 1\\)  和 \\(\\sum_{i = 1}^N{w_i} = 1\\)  .我们可以将其视为直方图，在数据点 \\(x_i\\)  处具有“尖峰”，其中 \\(w_i\\)  确定尖峰 \\(i\\)  的高度。 此分布将0概率分配给不在数据集中的任何点。\n返回本章目录\n"}),a.add({id:296,href:'/notes/tags/%E4%BC%AF%E5%8A%AA%E5%88%A9/',title:"伯努利",content:""}),a.add({id:297,href:'/notes/docs/mlapp/02probability/0031/',title:"2.2 概率论的简要回顾",content:"返回本章目录\n本节是对概率论基础知识的简要回顾，仅仅是对可能“荒疏”的读者的复习。 已经熟悉这些基础知识的读者可以安全地跳过本节。\n2.2.1 离散随机变量 表达式   \\(p(A)\\)  表示事件A为真的概率。 例如，A可能是逻辑表达“明天会下雨”。 我们要求 \\(0 \\le p(A) \\le 1\\)  ，其中 \\(p(A)= 0\\)  表示事件肯定不会发生，而 \\(p(A)= 1\\)  表示事件肯定会发生。 我们写 \\(p(\\bar{A})\\)  来表示事件不是A的概率; 这被定义为 \\(p(\\bar{A})= 1-p(A)\\)  。 我们经常写 \\(A = 1\\)  表示事件A为真， \\(A = 0\\)  表示事件A为假。\n我们可以通过定义一个离散的随机变量 \\(X\\)  来扩展二元事件的概念，它可以从有限或可数无限集 \\(\\mathcal{X}\\)  中获取任何值。 我们将事件 \\(X = x\\)  的概率表示为 \\(p(X = x)\\)  ，或简写为 \\(p(x)\\)  。 这里 \\(p()\\)  被称为概率质量函数(probability mass function)或pmf。 它满足 \\(0 \\le p(x) \\le 1\\)  和 \\(\\sum_{x \\in \\mathcal{X}}{p(x)}= 1\\)  的性质。 图2.1显示了在有限状态空间 \\(\\mathcal{X} = \\{1,2,3,4,5\\}\\)  上定义的两个pmf。 在左边我们有一个均匀分布 \\(p(x)= 1/5\\)  ，在右边我们有一个退化分布(degenerate distribution) \\(p(x)=\\mathbb{I}(x = 1)\\)  ，其中 \\(\\mathbb{I}()\\)  是二元指示函数。 该分布表示X始终等于值1的事实，换句话说，它是常数。\n 图2.1 （A）{1,2,3,4}上的均匀分布， \\(p(x = k)= 1/4\\)  。 （b）如果x = 1，则退化分布 \\(p(x)= 1\\)  ，如果 \\(x \\in \\{2,3,4\\}\\)  ，则 \\(p(x)= 0\\)  。 由_discreteProbDistFig_生成的图\n 2.2.2 基本规则 在本节中，我们将回顾概率的基本规则。\n2.2.2.1 两个事件并的概率 给定两个事件A和B，我们将A或B的概率定义如下：\n\\[ \\begin{aligned} p(A \\lor B)=\u0026 p(A)+p(B)-p(A \\land B) \\\\ \\quad = \u0026 P(A)+p(B) \\quad 如果A和B是互斥的 \\\\ \\end{aligned} \\tag{2.1-2} \\]  2.2.2.2 联合概率 我们将事件A和B的联合概率定义如下：\n\\[ P(A,B)=P(A \\ \\text{and} \\ B)=p(A|B)p(B) \\tag{2.3} \\]  这有时被称为乘法规则。 给定对两个事件的联合分布 \\(p(A，B)\\)  ，那么可将边际分布定义如下：\n\\[ p(A)=\\sum_b{p(A,B)}=\\sum_b{p(A|B=b)p(B=b)} \\tag{2.4} \\]  其中, 我们对B的所有可能状态进行了求和。可类似地定义 \\(p(B)\\)  。 有时被称为求和规则或全概率规则(rule of total probability)。\n可以多次应用乘法规则就产生了概率链式规则：\n\\[ p(X_{1:D})=p(X_1)p(X_2|X_1)p(X_3|X_2,X_1)p(X_4|X_3,X_2,X_1) \\dots p(X_D|X_{1:D-1}) \\tag{2.5} \\]  我们在这里引入类似Matlab的符号 \\(1:D\\)  来表示集合 \\(\\{1,2,\\dots,D\\}\\)  。\n2.2.2.3 条件概率 在事件B为真的情况下，我们定义事件A的条件概率，如下所示：\n\\[ p(A|B)=\\dfrac{p(A,B)}{p(B)} \\quad if p(B)0 \\tag{2.6} \\]  2.2.3 贝叶斯规则 将条件概率的定义与乘积和求和规则相结合，得到贝叶斯规则，也称为贝叶斯定理:\n\\[ p(X=x|Y=y)=\\dfrac{p(X=x,Y=y)}{p(Y=y)}=\\dfrac{p(X=x)p(Y=y|X=x)}{\\sum_{x'}{p(X=x')p(Y=y|X=x')}}\\tag{2.7} \\]  2.2.3.1 例：医学诊断 作为如何使用此规则的示例，请考虑以下医学诊断问题。 假设你是一个40多岁的女性，你决定进行乳房癌的医学测试，称为乳房X光检查。 如果检测结果为阳性，您患癌症的概率是多少？ 这显然取决于测试的可靠性。 假设您被告知测试的灵敏度为80％，这意味着，如果您患有癌症，则测试为阳的概率为0.8。 换一种说法\n\\[ p(x=1|y=1)=0.8 \\tag{2.8} \\]  其中 \\(x = 1\\)  是乳房X线检查为阳性的事件， \\(y = 1\\)  是乳腺癌的事件。 许多人认为他们80％的可能患有癌症。 但这是假的！ 它忽略了患乳腺癌的先验概率，幸运的是它很低：\n\\[ p(y=1)=0.004 \\tag{2.9} \\]  忽略这个先验被称为基本比率谬误(base rate fallacy)。 我们还需要考虑到测试可能是假阳或误报的事实。 不幸的是，这种假阳是很可能的（使用目前的筛选技术）：\n\\[ p(x=1|y=0)=0.1 \\tag{2.10} \\]  使用贝叶斯规则组合上述三式，我们可以如下计算正确的答案：\n\\[ \\begin{aligned} p(y=1|x=1)=\u0026\\dfrac{p(x=1|y=1)p(y=1)}{p(x=1|y=1)p(y=1)+p(x=1|y=0)p(y=0)} \\\\ \\quad = \u0026\\dfrac{0.8 \\times 0.004}{0.8 \\times 0.004+0.1 \\times 0.996}=0.031 \\\\ \\end{aligned} \\tag{2.11-12} \\]  其中 \\(p(y=0)= 1 -p(y=1)= 0.996\\)  。 换句话说，如果你测试为阳性，你实际患乳腺癌的几率只有3％！\n2.2.3.2 示例：生成式分类器 我们可以推广医学诊断的例子来对任意类型的特征向量 \\(\\boldsymbol{x}\\)  进行如下分类：\n\\[ p(y=c|\\boldsymbol{x},\\boldsymbol{\\theta})=\\dfrac{p(y=c|\\boldsymbol{\\theta})p(\\boldsymbol{x}|y=c,\\boldsymbol{\\theta})}{\\sum_{c'}p(y=c'|\\boldsymbol{\\theta})p(\\boldsymbol{x}|y=c',\\boldsymbol{\\theta})} \\tag{2.13} \\]  这被称为生成式分类器(generative classifier)，因为它指定了如何使用类条件密度 \\(p(\\boldsymbol{x}|y=c)\\)  和类先验 \\(p(y=c)\\)  来生成数据。 我们将在第3章和第4章中详细讨论这些模型。另一种方法是直接拟合类后验 \\(p(y=c|\\boldsymbol{x})\\)  ; 这被称为判别式分类器。 我们将在8.6节讨论这两种方法的优缺点。\n2.2.4 独立性和条件独立性 我们说 \\(X\\)  和 \\(Y\\)  是无条件独立的或边缘独立的(记作为 \\(X \\bot Y\\)  )，如果我们可以将它们的联合分布表示为两个边缘分布的乘积（见图2.2），即\n\\[ X \\bot Y \\Leftrightarrow p(X,Y)=p(X)p(Y) \\tag{2.14} \\]   图2.2 计算 \\(p(X,Y)= p(X)p(Y)\\)  ，其中 \\(X \\bot Y\\)  。 这里X和Y是离散随机变量; X有6种可能的状态（值），Y有5种可能的状态。 对两个这样的变量的一般联合分布将需要（6×5） - 1 = 29个参数来定义它（我们减去1，因为有一个求和到1的约束）。 通过假设（无条件）独立性，我们只需要（6-1）+（5-1）= 9个参数来定义 \\(p(X,Y)\\)  。\n 一般来说，如果一组变量的联合分布可以写成边缘分布的乘积，我们说这组变量是相互独立的。\n不幸的是，无条件独立很少见，因为大多数变量都会影响大多数其他变量。 然而，通常这种影响是通过其他变量调节的，而不是直接的。 因此，我们说 \\(X\\)  和 \\(Y\\)  对给定 \\(Z\\)  是条件独立的（CI）, 当且仅当 , 如果条件联合可以写成条件边际的乘积：\n\\[ X \\bot Y | Z \\Leftrightarrow p(X,Y|Z)=p(X|Z)p(Y|Z) \\tag{2.15} \\]  当我们在第10章讨论图模型时，我们将看到我们可以将这个假设写成图 \\(X -Z -Y\\)  ，它捕获了 \\(X\\)  和 \\(Y\\)  之间的所有依赖关系都是通过Z调解的直觉。例如，已经知道今天是否下雨（事件Z）的条件下，它明天下雨（事件X）的概率与今天地面是否潮湿（事件Y）无关。 直觉上，这是因为Z“导致”X和Y，所以如果我们知道Z，我们不需要知道Y以便预测X，反之亦然。 我们将在第10章中扩展这个概念。\nCI的另一个性质是：\n定理2.2.1. \\(X \\bot Y | Z\\)  ，当且仅当，存在函数 \\(g\\)  和 \\(h\\)  ，满足\n\\[ p(x,y|z)=g(x,z)h(y,z),\\quad p(z)0 \\quad \\forall x,y,z \\tag{2.16} \\]  有关证明，请参阅习题2.8。\nCI假设允许我们从小块构建大型概率模型。 我们将在本书中看到许多这方面的例子。 特别是，在第3.5节中，我们讨论了朴素贝叶斯分类器，在第17.2节中，我们讨论了马尔可夫模型，在第10章中我们讨论了图模型; 所有这些模型都大量利用CI属性。\n2.2.5 连续随机变量 到目前为止，我们只考虑了不确定离散量。 我们现在将展示（以下（Jaynes 2003，p107））如何将概率扩展到不确定连续量。\n假设 \\(X\\)  是一个不确定的连续数量。 \\(X\\)  位于任何区间 \\(a \\le X \\le b\\)  的概率可以如下计算。 定义事件 \\(A =(X \\le a)\\)  ， \\(B =(X \\le b)\\)  和 \\(W =(a 。我们有 \\(B =A \\vee W\\)  ，并且因为 \\(A\\)  和 \\(W\\)  是互斥的，所以求和规则给出\n\\[ p(B)=p(A)+p(W) \\tag{2.17} \\]  进而\n\\[ p(W)=p(B)-p(A) \\tag{2.18} \\]  定义函数 \\(F(q) \\overset{\\Delta}{=} p(X \\le q)\\)  。 这称为累积分布函数或 \\(X\\)  的cdf。这显然是单调递增函数。 有关示例，请参见图2.3（a）。 使用这种表示法我们有\n\\[ p(a \\lt X \\le b)=F(b)-F(a) \\tag{2.19} \\]  现在定义 \\(f(x)=\\frac{d}{dx} F(x)\\)  （我们假设这个导数存在）; 这称为概率密度函数或pdf。 有关示例，请参见图2.3（b）。 给定pdf，我们可以计算连续变量在有限区间内的概率，如下所示：\n\\[ P(a \\lt X \\le b)=\\int_a^b{f(x)dx} \\tag{2.20} \\]  在很小的区间，我们可以写\n\\[ P(x \\le X \\le x+dx)\\approx p(x)dx \\tag{2.21} \\]  我们要求 \\(p(x) \\ge 0\\)  ，但对于任何给定的 \\(x\\)  ， \\(p(x) 1\\)  都是可能的，只要密度可积分到1.例如，考虑均匀分布 \\({\\rm Unif}(a,b)\\)  ：\n\\[ {\\rm Unif}(a,b)=\\dfrac{1}{a+b}\\mathbb{I}(a \\le x \\le b) \\tag{2.22} \\]  如果我们设 \\(a = 0\\)  且 \\(b = \\frac{1}{2}\\)  ，则对于任何 \\(x \\in [0,\\frac{1}{2}]\\)  ，我们有 \\(p(x)= 2\\)  。\n 图2.3 （a）标准正态 \\(\\mathcal{N}(0,1)\\)  的cdf图。 （b）相应的pdf。 阴影区域各自包含概率质量的α/ 2。 因此，非阴影区域包含概率质量的1 - α。 如果分布是高斯 \\(\\mathcal{N}(0,1)\\)  ，则最左边的截止点是 \\(\\Phi^{-1}(\\alpha/2)\\)  ，其中 \\(\\Phi\\)  是高斯的cdf。 通过对称性，最右边的截止点是 \\(\\Phi^{-1}(1-\\alpha/2)=-\\Phi^{-1}(\\alpha/2)\\)  。 如果α= 0.05，则中心间隔为95％，左截止值为-1.96，右边为1.96。 由_quantileDemo_生成的图。\n 2.2.6 分位数 由于cdf \\(F\\)  是单调递增函数，因此它具有逆函数; 让我们用 \\(F ^{-1}\\)  来表示这一点。 如果 \\(F\\)  是 \\(X\\)  的cdf，则 \\(F^{-1}(\\alpha)\\)  是 \\(x_\\alpha\\)  的值，满足 \\(P(X \\le x_\\alpha)=\\alpha\\)  ; 那么成称 \\(x_\\alpha\\)  为 \\(F\\)  的 \\(\\alpha\\)  分位数。值 \\(F^{-1}(0.5)\\)  则是分布的中位数，左边是概率质量的一半，右边是另一半。 值 \\(F^{-1}(0.25)\\)  和 \\(F^{-1}(0.75)\\)  分别是下四分位数和上四分位数。\n我们还可以使用逆cdf来计算尾区概率。 例如，如果 \\(\\Phi\\)  是高斯分布 \\(\\mathcal{N}(0,1)\\)  的cdf，则 \\(\\Phi^{-1}(\\alpha/ 2)\\)  左侧的点包含α/ 2的概率质量，如图2.3（b）所示。 通过对称性， \\(\\Phi^{-1}(1-\\alpha/2)\\)  右侧的点也包含质量的α/ 2。 因此，中心区间 \\((\\Phi^{-1}(\\alpha/2),\\Phi^{-1}(1-\\alpha/2))\\)  包含质量的1-α。 如果我们设置α= 0.05，则中心95％区间被范围覆盖\n\\[ (\\Phi^{-1}(0.025),\\Phi^{-1}(0.975))=(-1.96,1.96) \\tag{2.23} \\]  如果分布为 \\(\\mathcal{N}(\\mu,\\sigma^2)\\)  ，则95％区间变为（μ-1.96σ，μ+1.96σ）。 有时这种近似可写成μ±2σ。\n2.2.7 均值和方差 分布最熟悉的属性是其均值或期望值，用 \\(\\mu\\)  表示。 对于离散随机变量，它被定义为 \\(\\mathbb{E} [X] \\overset{\\Delta}{=} \\sum_{x \\in \\mathcal{X}}{x p(x)}\\)  ，对于连续随机变量，它被定义为 \\(\\mathbb{E} [X] \\overset{\\Delta}{=} \\int_{\\mathcal{X}}{x p(x) dx}\\)  。 如果这个积分不是有限的，则均值没有定义（我们稍后会看到一些这样的例子）。\n方差是分布“扩散”的度量，用 \\(\\sigma^2\\)  表示。 这定义如下：\n\\[ \\begin{aligned} {\\rm var}[X] \\overset{\\Delta}{=} \u0026 \\mathbb{E}\\left[(X-\\mu)^2\\right]=\\int{(x-\\mu)^2p(x)dx} \\\\ \\quad = \u0026 \\int{x^2p(x)dx}+ \\mu^2 \\int{p(x)dx} - 2 \\mu \\int{ x p(x)dx}=\\mathbb{E}[X^2]-\\mu^2 \\\\ \\end{aligned} \\tag{2.24-25} \\]  从中我们得出有用的结果\n\\[ \\mathbb{E}[X^2]=\\sigma^2+\\mu^2 \\tag{2.26} \\]  标准偏差(简称标准差)定义为\n\\[ {\\rm std}[X] \\overset{\\Delta}{=}\\sqrt{{\\rm var}(X)} \\tag{2.27} \\]  这很有用，因为它与 \\(X\\)  本身具有相同的单位。\n返回本章目录\n"}),a.add({id:298,href:'/notes/tags/%E5%88%86%E4%BD%8D%E6%95%B0/',title:"分位数",content:""}),a.add({id:299,href:'/notes/tags/%E7%8B%AC%E7%AB%8B%E6%80%A7/',title:"独立性",content:""}),a.add({id:300,href:'/notes/tags/%E8%81%94%E5%90%88%E6%A6%82%E7%8E%87/',title:"联合概率",content:""}),a.add({id:301,href:'/notes/tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/',title:"随机变量",content:""}),a.add({id:302,href:'/notes/docs/mlapp/02probability/0030/',title:"2.1 导论",content:"返回本章目录\n 概率论只不过是把常识归纳为计算问题。 - 皮埃尔·拉普拉斯，1812年\n 在前一章中，我们看到了概率如何在机器学习中发挥有用的作用。 在本章中，我们将更详细地讨论概率论。 我们没有足够的空间来详细说明 - 为此，你最好查阅一些关于这个主题的优秀教科书，例如（Jaynes 2003; Bertsekas和Tsitsiklis 2008; Wasserman 2004）。 但我们将简要回顾一下您在后面章节中需要的许多关键想法。\n在我们开始使用更多技术材料之前，让我们暂停并问：概率是什么？ 我们都熟悉“硬币落地出现头部概率为0.5”这一短语。 但是，这是什么意思？ 实际上至少有两种不同的概率解释。 一种被称为频率派解释。 在这种观点中，概率表示长时间事件出现的频率。 例如，上面的陈述意味着，如果我们多次翻转硬币，我们预计它大约一半的时间出现正面。\n另一种解释称为贝叶斯概率解释。 在这种观点中，概率用于量化我们对某事物的不确定性; 因此，它与信息基本相关，而不是重复试验（Jaynes，2003）。 在贝叶斯观点中，上述陈述意味着我们相信硬币在下一次投掷时同样可能在落地出现头部或尾部。\n贝叶斯解释的一个重要优点是它可以用来模拟我们对没有长期频率的事件的不确定性。例如，我们可能想要计算极地冰盖在2020年之前融化的概率。此事件将发生零次或一次，但不能重复发生。然而，我们应该能够量化我们对这一事件的不确定性;根据我们认为这个事件的可能性，我们（希望！）采取适当的行动（参见第5.7节讨论不确定性下的最优决策）。为了提供更多面向机器学习的示例，我们可能已收到特定的电子邮件消息，并希望计算它是垃圾邮件的概率。或者我们可能在我们的雷达屏幕上观察到“昙花一现”，并且想要计算相应目标位置（无论是鸟类，飞机还是导弹）的概率分布。在所有这些情况下，重复试验的想法没有意义，但贝叶斯解释是有效的，而且确实非常自然。因此，我们将在本书中采用贝叶斯解释。幸运的是，无论采用何种解释，概率论的基本规则都是相同的。\n返回本章目录\n"}),a.add({id:303,href:'/notes/tags/%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7/',title:"不确定性",content:""}),a.add({id:304,href:'/notes/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/',title:"概率论",content:""}),a.add({id:305,href:'/notes/docs/mlapp/02probability/',title:"第二章 概率",content:"第二章 概率 本节中的目录：\n  2.1 导论\n  2.2 概率论的简要回顾\n  2.3 一些常见的离散分布\n  2.4 一些常见的连续分布\n  2.5 联合概率分布\n  2.6 Transformations of random variables\n  2.7 Monte Carlo approximation\n  2.8 Information theory\n  Exercises\n  "}),a.add({id:306,href:'/notes/docs/mlapp/01introduction/0029/',title:"Exercises",content:"返回本章目录\n"}),a.add({id:307,href:'/notes/docs/mlapp/01introduction/0028/',title:"1.4 机器学习的一些基本概念",content:"返回本章目录\n在本节中，我们将介绍机器学习中的一些关键思想。 我们将在本书后面对这些概念进行扩展，但我们将在此简要介绍它们，以便给引起大家兴趣。\n1.4.1 参数与非参数模型 在本书中，我们将重点关注形如   \\(p(y | \\boldsymbol{x})\\)  或 \\(p(x)\\)  的概率模型，这取决于我们是否分别对有监督或无监督学习感兴趣。 有许多方法可以定义这样的模型，但最重要的区别是：模型是否具有固定数量的参数，或者参数的数量是否随着训练数据量的增加而增加？ 前者称为参数模型，后者称为非参数模型。 参数模型具有通常更快使用的优点，但缺点是对数据分布的性质做出更强的假设。 非参数模型更灵活，但对于大型数据集而言通常在计算上难以处理。 我们将在下面的部分中给出两种模型的示例。 尽管我们的许多讨论也适用于无监督学习，但我们只关注监督学习的简单性。\n1.4.2 简单的非参数分类器：K-最近邻  图1.14 （a）2维 \\(K = 3\\)  的K-最近邻分类器的图示. 测试点的 \\(\\boldsymbol{x}_1\\)  的3最近邻有标签1,1和0，因此我们预测 \\(p(y = 1 | \\boldsymbol{x}_1,\\mathcal{D},K = 3)= 2/3\\)  。 测试点 \\(\\boldsymbol{x}_2\\)  的3最近邻具有标记0,0和0，因此我们预测 \\(p(y = 1 | \\boldsymbol{x}_3,\\mathcal{D},K = 3)= 0/3\\)  。 （b）由1-NN引起的Voronoi曲面细分的图示。 基于（Duda等人，2001）的图4.13。 由_knnVoronoi_生成的图。\n  图1.15 （a）2d中合成的3类训练数据。 （b）K = 10的KNN的第1类的概率。（c）第2类的概率。（d）类别标签的MAP估计。 由_knnClassifyDemo_生成的图。\n 非参数分类器的简单示例是K最近邻（KNN）分类器。 这只是“查看”训练集中最接近测试输入x的K点，计算每个类中有多少成员，并将经验分数作为估计返回，如图1.14所示。 更正式的，\n\\[ p(y=c|\\boldsymbol{x},\\mathcal{D},K) = \\dfrac{1}{K} \\sum_{i \\in N_K(\\boldsymbol{x},\\mathcal{D})}{\\mathbb{I}(y_i=c)} \\tag{1.2} \\]  其中 \\(N_K(\\boldsymbol{x},\\mathcal{D})\\)  是 \\(\\mathcal{D}\\)  中最接近 \\(\\boldsymbol{x}\\)  的K个点（的索引）， 并且 \\(\\mathbb{I}(e)\\)  是指标函数，其定义如下：\n\\[ \\mathbb{I}(e)=\\begin{cases} 1 \u0026 \\text{if e is true} \\\\ 0 \u0026 \\text{if e is false}\\end{cases} \\tag{1.3} \\]  该方法是基于记忆的学习或基于实例的学习的示例。 它可以从第14.7.3节中解释的概率框架推导出来。 最常用的距离度量是欧几里德距离（限制这个技术对实值数据的适用性），当然还可以使用其他度量。\n图1.15给出了一个实际操作方法的例子，其中输入是二维的，我们有三个类， \\(K = 10\\)  .（我们在后面讨论 \\(K\\)  的效果。）面板（a）绘制训练数据。 图（b）绘制 \\(p(y = 1 | \\boldsymbol{x},\\mathcal{D})\\)  ，其中 \\(\\boldsymbol{x}\\)  在点网格上计算。 图（c）绘制 \\(p(y = 2 | \\boldsymbol{x},\\mathcal{D})\\)  。 我们不需要绘制 \\(p(y = 3 | \\boldsymbol{x},\\mathcal{D})\\)  ，因为概率总和为1。 图（d）绘制MAP估计 \\(\\hat{y}(\\boldsymbol{x})=\\underset{c}{\\rm argmax} p(y = c | \\boldsymbol{x},\\mathcal{D})\\)  。\n \\(K = 1\\)  的KNN分类器诱导点的Voronoi曲面细分（见图1.14（b））。 这是空间的划分，其将区域 \\(V(\\boldsymbol{x}_i)\\)  与每个点 \\(\\boldsymbol{x}_i\\)  相关联，使得 \\(V(\\boldsymbol{x}_i)\\)  中的所有点都更接近 \\(\\boldsymbol{x}_i\\)  而不是任何其他点。 在每个单元格内，预测标签是相应训练点的标签。\n1.4.3 维度的诅咒 KNN分类器很简单，并且可以很好地工作，只要它具有良好的距离度量并且具有足够的标记训练数据。 实际上，可以证明，如果 \\(N \\to \\infty\\)  ，则KNN分类器可以在最佳可能性能的2倍之内（Cover and Hart 1967）。\n然而，KNN分类器的主要问题是它们在高维输入时不能很好地工作。 高维设置中的糟糕表现是由于维度的诅咒。\n为了解释这个诅咒，我们举了一些例子（Hastie et al.2009，p22）。 考虑将KNN分类器应用于在D维单元立方体中均匀分布的输入数据。 假设我们估计测试点 \\(\\boldsymbol{x}\\)  周围的类标签密度（通过“增长”围绕 \\(\\boldsymbol{x}\\)  的超立方体来直到数据占比达到 \\(f\\)  ）。 此立方体的预期边长将为 \\(e_D(f)= f^{ 1 / D}\\)  . 如果 \\(D = 10\\)  ，并且我们希望估计值是基于 \\(f=10\\%\\)  数据的，我们得到 \\(e_{10}(0.1)= 0.8\\)  ，因此我们需要沿 \\(\\boldsymbol{x}\\)  的每个维度扩展80％的立方体。 即使我们只使用1％的数据，我们发现 \\(e_{10}(0.01)= 0.63\\)  ：见图1.16。 由于沿着每个维度的整个数据范围仅为1，因此我们看到该方法不再是本地的，尽管名称为“最近邻居”。 查看距离较远的邻居的问题在于，它们可能不是关于给定点处输入 - 输出函数行为的良好预测器。\n 图1.16 维度诅咒的插图。 （a）我们在较大的单位立方体内嵌入一个小方块s。 （b）我们绘制一个立方体的边长，它是覆盖单位立方体的给定体积所需的尺寸的数量。 基于图2.6（Hastie等人，2009）。 由_curseDimensionality_生成的图。\n 1.4.4 用于分类和回归的参数模型 打破维度诅咒的主要方法是对数据分布的性质做出一些假设（监督问题的 \\(p(y | \\boldsymbol{x})\\)  或无监督问题的 \\(p(\\boldsymbol{x})\\)  ）。 这些假设称为归纳偏向(inductive bias)，通常以参数模型的形式体现，参数模型是具有固定数量参数的统计模型。 下面我们简要介绍两个广泛使用的例子; 我们将在本书后面更深入地重新讨论这些和其他模型。\n1.4.5 线性回归 最广泛使用的回归模型之一称为线性回归。 这断言响应是输入的线性函数。 这可以写成如下：\n\\[ y(\\boldsymbol{x})=\\boldsymbol{w}^T \\boldsymbol{x} + \\epsilon=\\sum_{j=1}^D {w_i x_i} + \\epsilon \\tag{1.4} \\]  其中 \\(\\boldsymbol{w}^T \\boldsymbol{x}\\)  代表输入向量 \\(\\boldsymbol{x}\\)  和模型权重向量 \\(\\boldsymbol{w}\\)  之间的内部或标量积，并且 \\(\\epsilon\\)  是我们的线性预测和真实响应之间的残差。\n我们经常假设 \\(\\epsilon\\)  具有高斯或正态分布。 我们用 \\(\\epsilon \\sim \\mathcal{N}(\\mu, \\sigma^2)\\)  表示之，其中 \\(\\mu\\)  是均值， \\(\\sigma^2\\)  是方差（详见第2章）。 当我们绘制这个分布时，我们得到了如图1.17（a）所示众所周知的钟形曲线。\n为了使线性回归和高斯之间的联系更加明确，我们可以用以下形式重写模型：\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{\\theta})=\\mathcal{N}(\\mu(\\boldsymbol{x}), \\sigma^2(\\boldsymbol{x})) \\tag{1.5} \\]  这清楚地表明该模型是条件概率密度。 在最简单的情况下，我们假设 \\(\\mu\\)  是 \\(\\boldsymbol{x}\\)  的线性函数，因此 \\(\\mu= \\boldsymbol{w}^T \\boldsymbol{x}\\)  ，并且噪声是固定的， \\(\\sigma^2(\\boldsymbol{x})=\\sigma^2\\)  。 在这种情况下， \\(\\boldsymbol{\\theta}=(\\boldsymbol{w}，\\sigma^2)\\)  是模型的参数。\n例如，假设输入是1维的。 预期响应可表示如下：\n\\[ \\mu(\\boldsymbol{x}) = w_0+w_1 x= \\boldsymbol{w}^T \\boldsymbol{x} \\tag{1.6} \\]  其中 \\(w_0\\)  是截距或偏置项， \\(w_1\\)  是斜率，我们定义了向量 \\(\\boldsymbol{x} =(1,x)\\)  。 （将一个常数1项加到输入向量上是一个常见的符号技巧，它允许我们将截距项与模型中的其他项组合。）如果 \\(w_1\\)  为正，则意味着我们期望输出随着输入的增加而增加。 这在图1.17（b）中的1d中说明; 图1.7（a）显示了一个更常规的平均响应与 \\(x\\)  的关系图。\n 图1.17 （a）均值为0方差为1的高斯pdf，.由_gaussPlotDemo_生成的图。 （b）条件密度模型的可视化 \\(p(y|x,\\boldsymbol{\\theta})=\\mathcal{N}(y | w_0+w_1 x, \\sigma^2)\\)  。 当我们离开回归线时，密度以指数方式快速下降。 由_linregWedgeDemo2_生成的图。\n 通过用输入的一些非线性函数 \\(\\boldsymbol{\\phi}(\\boldsymbol{x})\\)  代替 \\(\\boldsymbol{x}\\)  ，可以用线性回归以模拟非线性关系。 也就是说，我们使用\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{\\theta})=\\mathcal{N}(\\boldsymbol{w}^T \\boldsymbol{\\phi}(\\boldsymbol{x}), \\sigma^2) \\tag{1.7} \\]  这被称为基函数扩展。 例如，图1.18说明了对于 \\(d = 14\\)  和 \\(d = 20\\)  ， \\(\\boldsymbol{\\phi}(\\boldsymbol{x})= [1,x,x^2,\\dots,x^d ]\\)  的情况; 这被称为多项式回归。 我们将在本书的后面部分考虑其他类型的基函数。 事实上，许多流行的机器学习方法 - 例如支持向量机，神经网络，分类和回归树等 - 可以被视为从数据中估计基函数的不同方式，正如我们在第14章和第16章中讨论的那样。\n 图1.18 度数为14和20的多项式最小二乘拟合到21个数据点。 由_linregPolyVsDegree_生成的图。\n 1.4.6 逻辑斯蒂回归  图1.19 （a）sigmoid或logistic函数。 我们有 \\({\\rm sigm}(-\\infty)= 0\\)  ， \\({\\rm sigm}(0)= 0.5\\)  ， \\({\\rm sigm}(\\infty)= 1\\)  。 由_sigmoidPlot_生成的图。 （b）SAT分数的逻辑斯蒂回归。 实心黑点是数据。 开放的红色圆圈是预测的概率。 绿色叉表示两个学生具有相同的SAT分数525（因此相同的输入表示 \\(x\\)  ）但具有不同的训练标签（一个学生通过， \\(y = 1\\)  ，另一个失败， \\(y = 0\\)  ）。 因此，仅使用SAT功能就无法完全分离这些数据。 由_logregSATdemo_生成的图。\n 我们可以通过进行两次更改将线性回归推广到（二元）分类设置。 首先，我们用伯努利分布替换 \\(y\\)  的高斯分布，这更适合于响应是二元的情况，y∈{0,1}。 也就是说，我们使用\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{w})= {\\rm Ber}(y | \\mu(\\boldsymbol{x})) \\tag{1.8} \\]  其中 \\(\\mu (\\boldsymbol{x})= \\mathbb{E} [y | \\boldsymbol{x} ] = p(y = 1 | \\boldsymbol{x})\\)  。 其次，我们像以前一样计算输入的线性组合，但是我们定义一个满足 \\(0 \\le \\mu (\\boldsymbol{x} ) \\le 1\\)  的函数\n\\[ \\mu(\\boldsymbol{x}) = {\\rm sigm}(\\boldsymbol{w}^T \\boldsymbol{x}) \\tag{1.9} \\]  其中 \\({\\rm sigm} (\\eta)\\)  被称作sigmoid函数，也称为logistic或logit函数。 这被定义为\n\\[ {\\rm sigm}(\\eta) \\overset{\\Delta}{=} \\dfrac{1}{1+\\exp(-\\eta)}=\\dfrac{e^\\eta}{1+e^\\eta} \\tag{1.10} \\]  术语“sigmoid”意味着S形：见图1.19（a）。 它也被称为压缩函数，因为它将整个实数域映射到 \\([0,1]\\)  ，这对于将输出解释为概率是必要的。\n\\[ p(y|\\boldsymbol{x},\\boldsymbol{w})= {\\rm Ber}(y | {\\rm sigm}(\\boldsymbol{w}^T \\boldsymbol{x})) \\tag{1.11} \\]  这被称为逻辑斯蒂回归，因为它与线性回归相似（尽管它是一种分类形式，而不是回归！）。\n逻辑斯蒂回归的一个简单例子如图1.19（b）所示，我们用下式绘制之\n\\[ p(y_i=1|x_i,\\boldsymbol{w})={\\rm sigm}(w_0+w_1 x_i) \\tag{1.12} \\]  其中 \\(x_i\\)  是学生 \\(i\\)  的SAT分数，和 \\(y_i\\)  表示是否通过了课程。 实心黑点显示训练数据，红色圆圈显示 \\(p(y=1|\\boldsymbol{x}_i,\\hat{\\boldsymbol{w}})\\)  ，其中 \\(\\hat{\\boldsymbol{w}}\\)  是从训练数据估计的参数（我们将讨论如何在8.3.4节中计算这些估计值）。\n如果我们将输出概率阈值设置为0.5，我们就可以引出决策规则的形式\n\\[ \\hat{y}(x)=1 \\Leftrightarrow p(y=1|\\boldsymbol{x})0.5 \\tag{1.13} \\]  通过查看图1.19（b），我们看到对于 \\(x \\approx 545= x^*\\)  ， \\({\\rm sigm}(w_0+w_1 x)= 0.5\\)  。 我们可以想象在 \\(x = x^*\\)  处绘制一条垂直线; 这被称为决策边界。 该行左侧的所有内容都归类为0，该行右侧的所有内容都归类为1。\n我们注意到，即使在训练集上，该决策规则也具有非零错误率。 这是因为数据不是线性可分的，即我们没有直线可以将0与1分开。 我们可以使用基函数展开创建具有非线性决策边界的模型，就像我们使用非线性回归一样。 我们将在本书后面看到许多这方面的例子。\n1.4.7 过拟合  图1.20 在图1.15（a）中数据的KNN预测表面。 （a）K = 1。 （b）K = 5。 由_knnClassifyDemo_生成的图。\n 当我们拟合高度灵活的模型时，我们需要注意不要过拟合数据，也就是说，我们应该避免尝试对输入中的每个微小变化进行建模，因为这比真实信号更可能是噪声。 这在图1.18（b）中说明，其中我们看到使用高次多项式导致非常“摇摆”的曲线。 真正的函数不太可能具有如此极端的振荡。 因此，使用这样的模型可能导致无法对未来输出进行很好的预测。\n作为另一个例子，考虑KNN分类器。 K的值会对此模型的行为产生很大影响。 当K = 1时，该方法在训练集上没有错误（因为我们只返回原始训练点的标签），但是得到的预测表面非常“摇摆”（见图1.20（a））。 因此，该方法可能无法很好地预测未来的数据。 在图1.20（b）中，我们看到使用K = 5可以得到更平滑的预测表面，因为我们在较大的邻域上求平均值。 随着K增加，预测变得更平滑，直到在K = N的极限中，我们最终预测整个数据集的多数标签。 下面我们讨论如何选择K的“正确”值。\n1.4.8 模型选择 当我们有各种不同复杂度的模型时（例如，具有不同度多项式的线性或逻辑斯蒂回归模型，或具有不同K值的KNN分类器），我们应该如何选择正确的模型？ 一种自然的方法是计算每种方法的训练集的误分率。 这定义如下：\n\\[ {\\rm err}(f,\\mathcal{D})=\\dfrac{1}{N}\\sum_{i=1}^N {\\mathbb{I}(f(\\boldsymbol{x}_i) \\ne y_i)} \\tag{1.14} \\]  其中 \\(f(\\boldsymbol{x})\\)  是我们的分类器。 在图1.21（a）中，我们绘制了KNN分类器（蓝色虚线）的误差率与K的关系曲线。 我们看到增加K会_增加_训练集的错误率，因为过度平滑。 如上所述，通过使用K = 1，我们可以在训练集上获得最小的误差，因为该模型只是记忆数据。\n但是，我们关心的是泛化误差，它是对未来数据进行平均时误分类率的预期值（详见6.3节）。 这可以通过计算大型独立测试集上的错误分类率来近似，而不是在模型训练期间使用。 我们将图1.21（a）中的测试误差与K绘制成实心红色（上部曲线）。 现在我们看到一个U形曲线：对于复杂模型（小K），方法过度拟合，对于简单模型（大K），该方法欠拟合。 因此，选择K的一种明显方法是在测试集上选择具有最小误差的值（在此示例中，10到100之间的任何值都应该没问题）。\n不幸的是，在训练模型时，我们无法访问测试集（假设），因此我们无法使用测试集来选择正确复杂度的模型。 但是，我们可以通过分区来创建测试集 训练集合为两个：一部分用于训练模型，第二部分称为验证集，用于选择模型复杂性。 然后，我们将所有模型拟合到训练集上，并在验证集上评估它们的性能，并选择最佳。 一旦我们选择了最好的，我们可以将其重新调整为所有可用数据。 如果我们有一个单独的测试集，我们可以评估它的性能，以便估计我们方法的准确性。 （我们将在第6.5.3节中更详细地讨论这个问题。）\n我们经常使用大约80％的数据用于训练集，20％用于验证集。 但是，如果训练案例的数量很少，这种技术会遇到问题，因为该模型没有足够的数据来训练，我们将没有足够的数据来对未来的性能进行可靠的估计。\n 图1.21 （a）K-最近邻分类器中的误分类率与K的关系. 靠左边K更小，模型很复杂，因此我们过拟合。 靠右边，K很大，模型很简单，我们欠适合。 虚线蓝线：训练集（大小200）。 红色实线：测试集（大小500）。 （b）5折交叉验证的示意图。 由_knnClassifyDemo_生成的图。\n 一个简单但流行的解决方案是使用交叉验证（CV）。 这个想法很简单：我们将训练数据分成 \\(K\\)  个折叠; 然后，对于每个折叠 \\(k\\in {1,\\dots,K}\\)  ，我们训练所有的折叠但是第k折叠排除在外，并且用来测试第k折叠，如此循环，如图1.21所示（b）。 然后，我们计算在所有折叠上平均误差，并将其用作测试误差的代理。 （注意，每个点只预测一次，虽然它将用于训练 \\(K -1\\)  次。）通常使用 \\(K = 5\\)  ; 这被称为5折CV。 如果我们取 \\(K = N\\)  ，那么我们得到一个名为留1交叉验证(leave-one out cross validation)或LOOCV的方法，因为在折叠 \\(i\\)  中，我们训练除 \\(i\\)  之外的所有数据情况，然后在 \\(i\\)  上进行测试。 练习1.3要求您计算测试误差与K的5折CV估计值，并将其与图1.21（a）中的经验测试误差进行比较。\n为KNN分类器选择K是一个更普遍的问题（称为模型选择）的特例，我们必须在具有不同灵活性的模型之间进行选择。 交叉验证被广泛用于解决此类问题，尽管我们将在本书后面讨论其他方法。\n1.4.9 无免费午餐定理  所有的模型都是错误的，但有些模型是有用的。 - George Box（Box and Draper 1987，p424）.\n 许多机器学习都涉及定制不同的模型，不同算法, 以适合它们的。 我们可以使用交叉验证等方法根据经验为我们的特定问题选择最佳方法。 然而，没有普遍最好的模型 - 这有时被称为无免费午餐定理（Wolpert 1996）。 这样做的原因是，在一个域中运行良好的一组假设可能在另一个域中运行不佳。\n由于没有免费午餐定理，我们需要开发许多不同类型的模型，以涵盖现实世界中出现的各种各样的数据。 对于每个模型，我们可以使用许多不同的算法来训练模型，从而进行不同的速度 - 精度 - 复杂度权衡。 我们将在后续章节中研究这种数据，模型和算法的组合。\n返回本章目录\n"}),a.add({id:308,href:'/notes/tags/%E5%88%86%E7%B1%BB/',title:"分类",content:""}),a.add({id:309,href:'/notes/tags/%E5%8F%82%E6%95%B0%E6%A8%A1%E5%9E%8B/',title:"参数模型",content:""}),a.add({id:310,href:'/notes/tags/%E5%9B%9E%E5%BD%92/',title:"回归",content:""}),a.add({id:311,href:'/notes/tags/%E6%9C%80%E8%BF%91%E9%82%BB/',title:"最近邻",content:""}),a.add({id:312,href:'/notes/tags/%E7%BB%B4%E5%BA%A6%E8%AF%85%E5%92%92/',title:"维度诅咒",content:""}),a.add({id:313,href:'/notes/tags/%E8%BF%87%E6%8B%9F%E5%90%88/',title:"过拟合",content:""}),a.add({id:314,href:'/notes/docs/mlapp/01introduction/0027/',title:"1.3 无监督学习",content:"返回本章目录\n我们现在考虑无监督学习，我们只给出输出数据，没有任何输入。目标是在数据中发现“有趣的结构”;这有时被称为知识发现。与监督学习不同，我们没有被告知每个输入所期望输出是什么。相反，我们将我们的任务形式化为密度估计中的一种，也就是说，我们想要构建形如   \\(p(\\boldsymbol{x}_i | \\boldsymbol{\\theta})\\)  的模型。与有监督情形有两点不同。首先，我们写了 \\(p(\\boldsymbol{x}_i | \\boldsymbol{\\theta})\\)  而不是 \\(p(y_i | \\boldsymbol{x}_i,\\boldsymbol{\\theta})\\)  ;也就是说，监督学习是条件密度估计，而无监督学习是无条件密度估计。其次， \\(\\boldsymbol{x}_i\\)  是特征向量，因此我们需要创建多变量概率模型。相比之下，在监督学习中， \\(y_i\\)  通常只是我们试图预测的单个变量。这意味着对于大多数监督学习问题，我们可以使用单变量概率模型（参数依赖的输入），这显着简化了问题。 （我们将在第19章讨论多输出分类，我们将在其中看到它还涉及多变量概率模型。）\n无监督学习可以说是人类和动物学习的典型。 它也比监督学习更广泛适用，因为它不需要人类专家来手动标记数据。 标记数据不仅价格昂贵 ，而且它包含的信息相对较少，当然不足以可靠地估计复杂模型的参数。 多伦多大学着名ML教授Geoff Hinton说：\n 当我们学会看时，没有人告诉我们正确答案是什么 - 我们只是看看。 每隔一段时间，你的母亲就会说“那只狗”，但那信息很少。 如果您获得一些信息 - 即使每秒一位 - 那么你会很幸运。 大脑的视觉系统有 \\(10^{14}\\)  个神经连接。 而你只能活 \\(10^9\\)  秒。 所以每秒学习一位是没用的。 你需要更多像每秒 \\(10^5\\)  位。 而且只有一个地方可以获得那么多信息：来自输入本身。 - Geoffrey Hinton，1996年（引自（Gorder 2006））。\n 下面我们描述一些无监督学习的典型例子。\n1.3.1 发现聚类 作为无监督学习的典型示例，考虑将数据聚集到各组的聚类问题。 例如，图1.8（a）绘制了一些2d数据，表示一组210人的身高和体重。 似乎可能存在各种集群或子集，尽管尚不清楚有多少集群或子集。 设 \\(K\\)  表示簇的数量。 我们的第一个目标是估计聚类数量的分布， \\(p(K | \\mathcal{D})\\)  ; 这告诉我们数据中是否有子群体。 为简单起见，我们经常通过其众数来近似这个分布 \\(p(K | \\mathcal{D}), K^{*} =\\underset{K}{\\rm argmax} p(K | \\mathcal{D})\\)  。 在监督的情况下，我们被告知有两个类别（男性和女性），但在无监督的情况下，我们可以自由选择我们喜欢的多个或几个集簇。 挑选“正确”复杂度的模型称为模型选择，并将在下面详细讨论。\n我们的第二个目标是估计每个点所属的簇。 令 \\(z_i\\in {1,\\dots,K}\\)  表示分配了数据点 \\(i\\)  的簇。 （ \\(z_i\\)  是隐藏或潜在变量的一个例子，因为在训练集中从未观察到它。）我们可以通过计算 \\(z_i^{*} =\\underset{k}{\\rm argmax} p(z_i = k | \\boldsymbol{x}_i，\\mathcal{D})\\)  来推断每个数据点属于哪个簇。 如图1.8（b）所示，我们使用不同的颜色来指示分配，假设 \\(K = 2\\)  。\n 如图1.8 (a) 一些人的身高和体重。 （b）使用K = 2簇的可能聚类。 由_kmeansHeightWeight_生成的图。\n 在本书中，我们关注基于模型聚类，这意味着我们将拟合一个概率模型到数据，而不是运行一些特设的算法。 基于模型的方法的优点是可以客观地比较不同类型的模型（就它们分配给数据的可能性而言），我们可以将它们组合成更大的系统，等等。这里有一些聚类的实际应用。\n 在天文学中，AutoClass系统（Cheeseman et al.1988）基于聚类天体物理测量发现了一种新型恒星。 在电子商务中，通常基于用户的购买或网上冲浪行为将用户聚类成组，然后向每个组发送定制的目标广告（参见例如（Berkhin 2006））。 在生物学中，通常将流式细胞术数据聚类成组，以发现不同的细胞亚群（参见例如（Lo等人，2009））。  1.3.2 发现潜在因素 在处理高维数据时，通过将数据投影到较低维度子空间(以捕获数据“本质”)来降低纬度，这通常是有用的。 这称为降维。 一个简单的例子如图1.9所示，我们将一些3d数据投影到2d平面。 2d近似是非常好的，因为大多数点靠近该子空间。 减少到1d将涉及将点投射到图1.9（a）中的红线上; 这将是一个相当差的近似值。 （我们将在第12章中使这一概念更加精确。）\n这种技术背后的动机是尽管数据可能看起来很维数高，但可能只有少量的可变度，对应于潜在因素。 例如，在对人脸图像的外观进行建模时，可能只有少数潜在因素描述了大部分的可变性，例如照明，姿势，身份等，如图1.10所示。\n 图1.9 (a) 嵌入3d中的2d线性子空间上的一组点。 红色实线是第一个主要成分方向。 黑色虚线是第二个次要成分方向。 (b) 数据的2D表示。 由_pcaDemo3d_生成的图。\n  图1.10 a）来自Olivetti人脸数据库的25个随机选择的64×64像素图像。 （b）均值和前三个主成分基矢量（特征脸）。 由_pcaImageDemo_生成的图。\n 当用作其他统计模型的输入时，这种低维表示通常会产生更好的预测准确度，因为它们关注对象的“本质”，过滤掉不必要的特征。 而且，低维表示对于实现快速最近邻搜索是有用的，并且二维投影对于可视化高维数据非常有用。\n降维的最常用方法称为主成分分析或PCA。 这可以被认为是（多输出）线性回归的无监督版本，其中我们观察到高维响应 \\(\\boldsymbol{y}\\)  ，而不是低维“原因” \\(\\boldsymbol{z}\\)  。 因此模型原本形式为 \\(\\boldsymbol{z} \\to \\boldsymbol{y}\\)  ; 在这里，我们必须“反转箭头”，并从观察到的高维 \\(\\boldsymbol{y}\\)  推断出潜在的低维 \\(\\boldsymbol{z}\\)  。 详细信息请参见第12.1节。\n降维，特别是PCA，已经应用于许多不同领域。 包括以下一些例子：\n 在生物学中，通常使用PCA来解释基因微阵列数据，以解释这样的事实，即每个测量通常是许多基因的结果，这些基因通过它们属于不同生物途径的事实而与它们的行为相关。 在自然语言处理中，通常使用称为潜在语义分析的PCA变体来进行文档检索（参见第27.2.2节）。 在信号处理（例如，声学或神经信号）中，通常使用ICA（其是PCA的变体）将信号分离到它们的不同源中（参见第12.6节）。 在计算机图形学中，通常将运动捕捉数据投影到低维空间，并使用它来创建动画。 有关解决此类问题的一种方法，请参见第15.5节。  1.3.3 发现图结构 有时我们测量一组相关变量，我们想要发现哪些与其他变量最相关。 这可以用图 \\(G\\)  表示，其中节点代表变量，边代表变量之间的直接相关性（当我们讨论图形模型时，我们将在第10章中做到这一点）。 然后我们可以从数据中学习这个图结构，即我们计算 \\(\\hat{G} = {\\rm argmax} p(G | \\mathcal{D})\\)  。\n与一般的无监督学习一样，学习稀疏图有两个主要应用：发现新知识，并获得更好的联合概率密度估计。 我们现在给出一些例子。\n 学习稀疏图形模型的大部分动机来自系统生物学界。 例如，假设我们测量细胞中某些蛋白质的磷酸化状态（Sachs等人，2005）。 图1.11给出了从该数据中学习的图结构示例（使用第26.7.2节中讨论的方法）。 另一个例子是史密斯等人（2006）表明，人们可以从时间序列的脑电图数据中恢复某种鸟类神经“接线图”。 恢复的结构与这部分鸟脑的已知功能连接性非常匹配。 在某些情况下，我们对解释图形结构不感兴趣，我们只想用它来建模相关性并进行预测。 其中一个例子是金融投资组合管理，其中大量不同股票之间协方差的准确模型很重要。 Carvalho和West（2007）表明，通过学习稀疏图，然后使用它作为交易策略的基础，有可能比没有利用稀疏图的方法表现更好（即赚更多的钱）。 另一个例子是预测高速公路上的交通拥堵。 Horvitz等人（2005）描述了一个名为JamBayes的部署系统，用于预测西雅图地区的交通流量; 使用图形模型进行预测，其结构是从数据中学习的。   图1.11 使用图形lasso（第26.7.2节）学习的稀疏无向高斯图形模型应用于一些流式细胞仪数据（来自（Sachs等人2005）），其测量11种蛋白质的磷酸化状态。 由ggmLassoDemo生成的图。\n 1.3.4 矩阵完成 有时我们会丢失数据，即值未知的变量。 例如，我们可能进行了调查，有些人可能没有回答某些问题。 或者我们可能有各种传感器，其中一些传感器失效。 相应的设计矩阵将在其中具有“洞”; 这些缺失的条目通常由NaN表示，其代表“不是数字”。 插补的目的是推断缺失条目的合理值。 这有时称为矩阵完成(matrix completion)。 下面我们举一些示例应用程序。\n1.3.4.1 图像修复 一个类似插补任务的有趣例子被称为图像修复。 目标是在具有真实纹理的图像中“填充”孔（例如，由于划痕或遮挡）。 如图1.12所示，我们对图像进行去噪处理，并对隐藏在遮挡后面的像素进行处理。 这可以通过在给定一组干净图像的情况下构建像素的联合概率模型，然后在给定已知变量（像素）的情况下推断未知变量（像素）来解决。 这有点像市场篮子分析，除了数据是实值和空间结构，因此我们使用的概率模型的种类是完全不同的。 有关可能的选择，请参见第19.6.2.7节和第13.8.4节。\n 图1.12 （a）带有遮挡物的嘈杂图像。 （b）基于成对MRF模型的基础像素强度的估计。 资料来源：（Felzenszwalb和Huttenlocher，2006年）的图8。 与Pedro Felzenszwalb的使用许可一起使用。\n 1.3.4.2 协同过滤 类似插补任务的另一个有趣示例称为协同过滤(Collaborative filtering)。 这方面的一个常见例子是根据他们和其他人如何评价已经看过的电影来预测人们想要观看的电影。 关键的想法是预测不是基于电影或用户的特征（尽管可能是），而仅仅基于评级矩阵。 更确切地说，我们有一个矩阵 \\(\\boldsymbol{X}\\)  ，其中 \\(\\boldsymbol{X}(m,u)\\)  是电影 \\(m\\)  的用户 \\(u\\)  的评级（比如1到5之间的整数，其中1表示不喜欢，5表示）。 请注意， \\(\\boldsymbol{X}\\)  中的大多数条目都将丢失或未知，因为大多数用户不会评分大多数电影。 因此，我们只观察 \\(\\boldsymbol{X}\\)  矩阵的一小部分，我们想要预测不同的子集。 特别是，对于任何给定的用户 \\(u\\)  ，我们可能想要预测他/她最有可能想要观看哪些未评级的电影。\n 图1.13 电影评级数据的示例。 训练数据为红色，测试数据用？表示，空单元格未知。\n 为了鼓励这方面的研究，DVD租赁公司Netflix在2006年推出了一项奖金，奖金为100万美元（见http://netflixprize.com/）。 特别是，他们提供了一个大的评级矩阵，范围为1到5级，用于约50万用户创作的约18,000部电影。 完整矩阵将具有 \\(9 \\times 10^9\\)  个条目，但是仅观察到大约1％的条目，因此矩阵非常稀疏。 其中一部分用于培训，其余部分用于测试，如图1.13所示。 竞争的目标是比Netflix现有系统更准确地预测。 2009年9月21日，该奖项授予了一个名为“BellKor’s Pragmatic Chaos”的研究团队。 第27.6.2节讨论了他们的一些方法。 有关团队及其方法的更多详细信息，请访问 http://www.netflixprize.com/community/viewtopic.php?id=1537 。\n1.3.4.3 市场篮子分析 在商业数据挖掘中，人们对称为市场购物篮分析的任务很感兴趣。 数据由（通常非常大但稀疏的）二进制矩阵组成，其中每列表示项目或产品，每行代表一个事务。 如果在第 \\(i\\)  次交易中购买了商品 \\(j\\)  ，我们设置 \\(x_{ij} = 1\\)  。 许多物品是一起购买的（例如，面包和黄油），因此比特之间会有相关性。 给定新的部分观察的位向量，表示消费者已经购买的项目的子集，目标是预测哪些其他位可能打开，表示消费者可能购买的其他项目。 （与协同过滤不同，我们经常假设培训数据中没有丢失的数据，因为我们知道每个客户过去的购物行为。）\n除了建模购买模式之外，此任务还出现在其他领域。 例如，类似的技术可用于模拟复杂软件系统中的文件之间的依赖性。 在这种情况下，任务是在给定已经改变的文件子集的情况下预测哪些其他文件需要更新以确保一致性（参见例如（Hu等人，2010））。\n通常使用频繁项集挖掘(frequent itemset mining)来解决这样的任务，其创建关联规则（参见例如（Hastie等人，2009，第14.2节）以获得细节）。 或者，我们可以采用概率方法，并将联合密度模型 \\(p(x_1,\\dots,x_D)\\)  拟合到位向量，参见例如（Hu等人，2010）。 这些模型通常具有比关联规则更好的预测准确性，尽管它们可能不太可解释。 这是数据挖掘和机器学习之间典型的差异：在数据挖掘中，更多地强调可解释模型，而在机器学习中，更强调精确模型。\n返回本章目录\n"}),a.add({id:315,href:'/notes/tags/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/',title:"无监督学习",content:""}),a.add({id:316,href:'/notes/tags/%E8%81%9A%E7%B1%BB/',title:"聚类",content:""}),a.add({id:317,href:'/notes/tags/%E9%99%8D%E7%BB%B4/',title:"降维 ",content:""}),a.add({id:318,href:'/notes/docs/mlapp/01introduction/0026/',title:"1.2 监督学习",content:"返回本章目录\n我们通过讨论监督学习来开始我们对机器学习的研究，监督学习是在实践中最广泛使用的ML的形式。\n1.2.1 分类 在本节中，我们讨论分类。这里的目标是学习从输入   \\(x\\)  到输出 \\(y\\)  的映射，其中 \\(y\\in {1,\\dots,C}\\)  ， \\(C\\)  是类的数量。 如果 \\(C = 2\\)  ，则称为二项分类（在这种情况下，我们通常假设 \\(y\\in {0,1}\\)  ）; 如果 \\(C  2\\)  ，则称为多类分类。 如果类标签不是互斥的（例如，有人可能被分类为高和强），我们称之为多标签分类，但这最好被视为预测多个相关二项类标签（所谓的多输出模型）。当我们使用术语“分类”时，我们将表示具有单个输出的多类分类，除非我们另有说明。\n形式化问题的一种方法是函数逼近。对于某个未知函数 \\(f\\)  ，我们假设 \\(y = f(x)\\)  ，并且学习的目标是在给定标记训练集的情况下估计函数 \\(f\\)  ，然后使用 \\(\\hat{y} =\\hat{f} (x)\\)  进行预测。（我们使用帽子符号^来表示估计值。）我们的主要目标是对新输入进行预测，这意味着我们之前从未见过的输入（这称为泛化），因为预测训练集的响应很容易（我们可以查看答案）。\n1.2.1.1 示例 作为分类的简单玩具示例，请考虑图1.1（a）中所示的问题。我们有两类对象，分别对应标签0和1。输入是已着色的形状。 这些已由 \\(D\\)  个特征或属性描述，这些特征或属性存储在 \\(N \\times D\\)  设计矩阵 \\(\\boldsymbol{X}\\)  中，如图1.1（b）所示。输入的特征 \\(\\boldsymbol{x}\\)  可以是离散的，连续的或两者的组合。除了输入之外，我们还有一个训练标签向量 \\(\\boldsymbol{y}\\)  。\n 图1.1 左：一些标记有色形状的训练示例，以及3个未标记的测试用例。右：将训练数据表示为 \\(N \\times D\\)  设计矩阵。 行 \\(i\\)  表示特征向量 \\(x_i\\)  。 最后一列是标签， \\(y_i \\in {0,1}\\)  。 基于Leslie Kaelbling的一个人物。\n 在图1.1中，测试用例是蓝色新月形，黄色圆形和蓝色箭头。 以前都没有见过这些。因此，我们需要在训练集之外进行泛化。一个合理的猜测是蓝色新月应该是 \\(y = 1\\)  ，因为所有蓝色形状在训练集中都标记为1。黄色圆圈更难以分类，因为一些黄色的东西被标记为 \\(y = 1\\)  并且一些被标记为 \\(y = 0\\)  ，并且一些圆圈被标记为 \\(y = 1\\)  并且一些 \\(y = 0\\)  。因此，在黄色圆圈的情况下，不清楚正确的标签应该是什么。 同样，蓝色箭头的正确标签也不清楚。\n1.2.1.2 概率预测的必要性 为了处理模糊情况，例如上面的黄色圆圈，希望返回合理的概率。 假设读者已经熟悉概率的基本概念。如果没有，请在必要时查阅第2章进行复习。\n在给定输入向量 \\(\\boldsymbol{x}\\)  和训练集 \\(\\mathcal{D}\\)  的情况下，我们将可能标签上的概率分布表示成 \\(p(y | \\boldsymbol{x}, \\mathcal{D})\\)  。通常，这是长度为 \\(C\\)  的向量。（如果只有两个类，则返回单个数 \\(p(y = 1 | \\boldsymbol{x},\\mathcal{D})\\)  就足够了，因为 \\(p(y = 1 | \\boldsymbol{x},\\mathcal{D})+ p(y = 0 | \\boldsymbol{x},\\mathcal{D})=1\\)  .）在我们的符号中，我们通过将\u0026quot;测试输入 \\(\\boldsymbol{x}\\)  和训练集 \\(\\mathcal{D}\\)  \u0026quot;放在条件栏\u0026quot;|\u0026ldquo;的右侧明确表示概率是以 \\(\\boldsymbol{x},\\mathcal{D}\\)  为条件的。 我们也会隐含我们用来进行预测的模型形式的条件。当在不同模型之间进行选择时，我们将通过写 \\(p(y | \\boldsymbol{x},\\mathcal{D}, M)\\)  来明确这个假设，其中 \\(M\\)  表示模型。但是，如果模型从上下文中清楚，我们将删除 \\(M\\)  以简化。\n给定概率输出，我们总能计算我们的“最佳猜测”作为“真实标签”\n\\[ \\hat{y}=\\hat{y}(\\boldsymbol{x})=\\underset{c=1:C}{\\rm argmax} \\ p(y=c | \\boldsymbol{x},\\mathcal{D}) \\tag{1.1} \\]  这对应于最可能的类标签，称为分布 \\(p(y | \\boldsymbol{x},\\mathcal{D})\\)  的众数(mode); 它也被称为MAP估计（MAP代表最大后验）。 使用最可能的标签具有直观意义，但我们将在5.7节中为此过程提供更正式的理由。\n现在考虑一个例如黄色圆圈的情况，其中 \\(p(y | \\boldsymbol{x},\\mathcal{D})\\)  远离1.0。在这种情况下，我们对自己的回答并不十分自信，所以最好说“我不知道”，而不是回答我们不相信的答案。这在医学和金融等领域尤为重要，我们可能会厌恶风险，正如我们在5.7节中解释的那样。评估风险很重要的另一个应用是播放电视游戏节目，例如Jeopardy。在这个游戏中，参赛者必须解决各种单词拼图并回答各种琐事问题，但如果他们回答错误，他们会赔钱。2011年，IBM公布了一款名为Watson的计算机系统，该系统击败了顶级人类Jeopardy冠军。Watson使用了各种有趣的技术（Ferrucci et al.2010），但对我们目前来说最相关的技术是它包含一个模块来估计它对答案的信心程度。如果有足够的信心，系统只选择“buzz in”做为的答案。 同样，Google有一个称为SmartASS（广告选择系统）的系统，可根据您的搜索历史记录以及其他用户和广告特定功能预测您点击广告的概率（Metz 2010）。此概率称为点击率或CTR，可用于最大化预期利润。我们将在本书后面讨论SmartASS等系统背后的一些基本原理。\n1.2.1.3 实际应用 分类可能是最广泛使用的机器学习形式，并且已被用于解决许多有趣且通常困难的现实问题。我们已经提到了一些重要的应用。我们在下面给出更多例子。\n文档分类和垃圾邮件过滤\n 图1.2 20个新闻组数据的大小为16242 x 100的子集。 为清晰起见，我们只显示1000行。每行是一个文档（表示为一个包字位向量），每列是一个单词。红线分隔了4个类，它们是（按降序排列）comp，rec，sci，talk（这些是USENET组的标题）。我们可以看到有一些词的子集，其表示该类存在或不存在。 数据可从http://cs.nyu.edu/~roweis/data.html获得。 由_newsgroupsVisualize_生成的图。\n 在文档分类中，目标是将文档（例如网页或电子邮件消息）分类为 \\(C\\)  个类别之一，即计算 \\(p(y = c | \\boldsymbol{x},\\mathcal{D})\\)  ，其中 \\(x\\)  是文本的一些表示。一个特例是垃圾邮件过滤，其中类别是垃圾邮件 \\(y = 1\\)  或 正常邮件 \\(y = 0\\)  。\n大多数分类器假设输入向量 \\(\\boldsymbol{x}\\)  具有固定大小。以特征向量格式表示可变长度文档的常用方法是使用词袋表示。这在3.4.4.1节中有详细解释，但基本思想是定义 \\(x_{ij} = 1\\)  当且仅当 单词 \\(j\\)  出现在文档 \\(i\\)  中。 如果我们将此转换应用于数据集中的每个文档，我们将获得二进制文档×单词 共生矩阵：有关示例，请参见图1.2。 本质上，文档分类问题已经减少到一个寻找位模式细微变化的问题。例如，我们可能会注意到大多数垃圾邮件很可能包含“买”，“便宜”，“伟哥”等字样。在练习8.1和练习8.2中，您将获得将各种分类技术应用于垃圾邮件过滤问题的实践经验。\n鲜花分类\n 图1.3 三种类型的鸢尾花：setosa，versicolor和virginica。 资料来源：http：//www.statlab.uni-heidelberg.de/data/iris/。 使用Dennis Kramb和SIGNA的许可。\n  图1.4 将鸢尾花数据可视化为成对散点图。 对角线绘制了4个特征的边缘直方图。 非对角线的图包含所有可能的特征对的散点图。 红圈= setosa，绿钻= versicolor，蓝星= virginica。 由_fisheririsDemo_生成的图。\n 图1.3给出了另一个分类示例，由统计学家Ronald Fisher提供。目的是学会区分三种不同种类的鸢尾花，称为Setosa，versicolor和virginica。幸运的是，植物学家已经提取了4个有用的特征或特征，不是直接处理图像，而是萼片的长度和宽度，以及花瓣的长度和宽度。（这种特征提取是一项重要但困难的任务。大多数机器学习方法都使用某些人选择的特性。稍后我们将讨论一些可以从数据中学习好特征的方法。） 如果我们制作鸢尾花数据的散点图，如图1.4所示，我们看到通过检查它们的花瓣长度或宽度是否低于某个阈值，很容易区分Setosa（红色圆圈）和其他两个类别。然而，区分versicolor和virginica稍微难一些; 任何决定都需要至少基于两个特征。 （在应用机器学习方法之前，执行探索性数据分析（例如绘制数据）总是一个好主意。）\n图像分类和手写识别\n现在考虑直接对图像进行分类的难题，即人类尚未对数据进行预处理。 我们可能想要将图像整体分类，例如，它是室内还是室外场景？ 它是水平还是垂直的照片？ 它是否包含一只狗？ 这称为图像分类。\n在特殊情况下，图像由孤立的手写字母和数字组成，例如，在信件上的邮政编码或邮政编码中，我们可以使用分类来执行手写识别。 该领域使用的标准数据集称为MNIST，代表“美国国家标准技术研究所修订数据集”。 （使用术语“修订”是因为图像已经过预处理以确保数字大部分位于图像的中心。）此数据集包含60,000个训练图像和10,000个数字0到9的测试图像，由不同的人编写。 图像尺寸为28×28，灰度值范围为0：255。有关示例图像，请参见图1.5（a）。\n 图1.5 （a）前9个测试MNIST灰度图像。 （b）与（a）相同，但将特征随机排列了。 两种版本的数据的分类性能相同（假设训练数据以相同的方式排列了）。 由_shuffledDigitsDemo_生成的图。\n  图1.6 面部检测的示例。 （a）输入图像（墨菲家族，2010年8月5日拍摄的照片）。 使用Sherwood Studios的Bernard Diedrich的同意。 （b）分类器的输出，其在不同姿势下检测到5个面部。 这是使用http://demo.pittpatt.com/ 上的在线演示制作的。 分类器在1000个手动标记的面部和非面部图像上进行训练，然后应用于测试图像中的一组密集的重叠斑块。 仅返回包含面部概率足够高的一小块。 与Pittpatt.com的实体许可一起使用\n 许多通用分类方法忽略输入要素中的任何结构，例如空间布局。 因此，他们也可以轻松处理如图1.5（b）所示的数据，这是相同的数据，除了我们将所有特征随机排序了。 （您将在练习1.1中对此进行验证。）这种灵活性既是一种祝福（因为方法是通用的），也是一种诅咒（因为这些方法忽略了明显有用的信息来源）。 我们将在本书后面讨论在输入特性中利用结构的方法。\n人脸检测和识别\n一个更难的问题是在图像中找到对象; 这称为对象检测或对象本地化。 一个重要的特殊情况是人脸检测。 解决该问题的一种方法是将图像划分为在不同位置，比例和方向上的许多小重叠片，并且基于它是否包含面部纹理来对每个这样的片进行分类。 这被称为滑动窗口检测器。 然后系统返回面部概率足够高的那些位置。 有关示例，请参见图1.6。 这种面部检测系统内置于大多数现代数码相机中; 检测到的面部的位置用于确定自动对焦的中心。 另一个应用程序会自动模糊Google的StreetView系统中的面孔。\n找到面部后，可以继续进行面部识别，这意味着估计人的身份（见图1.10（a））。 在这种情况下，类标签的数量可能非常大。 此外，应该使用的特征可能与面部检测问题不同：对于识别，诸如发型之类的面部之间的细微差别对于确定身份可能是重要的，但是对于检测，重要的是对这些细节不变， 并只关注面部和非面部之间的差异。 有关视觉对象检测的更多信息，请参阅例如（Szeliski 2010）。\n1.2.2 回归 回归就像分类一样，除了响应变量是连续的。 图1.7显示了一个简单的例子：我们有一个实值输入 \\(x_i\\in \\mathbb{R}\\)  和一个实值响应 \\(y_i\\in \\mathbb{R}\\)  。我们考虑将两个模型拟合到数据中：直线和二次函数。 （在后面, 我们将解释如何拟合这些模型。）可能会出现这个基本问题的各种扩展，例如具有高维输入，异常值，非平滑响应等。我们将在本书后面讨论处理此类问题的方法。\n 图1.7 （a）对一些1维数据的线性回归。 （b）对相同的数据进行多项式回归（2度）。 由_linregPolyVsDegree_生成的图。\n 以下是实际回归问题的一些示例。\n 根据当前市场情况和其他可能的附带信息预测明天的股市价格。 预测在YouTube上观看特定视频的观看者的年龄。 预测机器人手臂末端执行器在3维空间中位置，给出控制信号（扭矩）并且发送到各种电机。 预测体内前列腺特异性抗原（PSA）的量, 作为许多不同临床测量的功能。 使用天气数据，时间，门传感器等，预测建筑物内任何位置的温度。  返回本章目录\n"}),a.add({id:319,href:'/notes/docs/mlapp/01introduction/0025/',title:"1.1 机器学习：什么和为什么？",content:"返回本章目录\n 我们淹没在信息中，渴望知识。 — John Naisbitt。\n 我们正在进入大数据时代。 例如，有大约1万亿个网页; YouTube一个小时的视频上传，每天相当于10年的内容;1000多人的基因组，每个人的长度为3.8×109个碱基对，已被各种实验室测序; 沃尔玛每小时处理超过1M笔交易，数据库包含超过2.5千兆字节（2.5×1015）的信息（Cukier 2010）; 等等。\n这种大量数据需要自动化的数据分析方法，这就是机器学习所提供的。特别是，我们定义机器学习为一组能够自动探测数据中潜在模式的方法，并且用这种模式来预测未来的数据，或在不确定性因素下执行其他类型的决策（例如规划如何收集更多数据！）。\n本书采用的观点是，解决此类问题的最佳方法是使用概率论工具。 概率论可以应用于任何涉及不确定性的问题。 在机器学习中，不确定性有多种形式： 根据过去的一些数据，对未来的最佳预测是什么？什么是解释一些数据的最佳模型？下一步该进行什么样的度量？ 等等。 机器学习的概率方法与统计学领域密切相关，但在重点和术语方面略有不同。\n我们将描述适用于各种数据和任务的各种概率模型。 我们还将描述用于学习和使用此类模型的各种算法。我们的目标不是开发一种特殊技术的烹饪书，而是通过概率建模和推理来全面认识这一领域。虽然我们会关注计算效率，但是在其他书籍中更好地描述了如何将这些方法扩展到真正大规模数据集的细节，例如（Rajaraman和Ullman 2011; Bekkerman等人2011）。\n然而，应该注意的是，即使拥有一个庞大的数据集，实际有效数据点也可能很小。事实上，许多领域的数据都表现出称为长尾的特点，这意味着一些事物（例如，单词）非常常见，但大多数事情都非常罕见（详见第2.4.6节）。例如，每天有20％的Google搜索从未见过。这意味着我们在本书中讨论关于从相对较小的样本尺寸进行推广的核心统计问题，即使在大数据时代也仍然非常相关。\n1.1.1 机器学习的类型 机器学习通常分为两大类。第一种方法是预测性的或监督学习方法，目标是在给定一组有标记的输入-输出对   \\(\\mathcal{D} ={(x_i，y_i)}_{i=1}^N\\)  的情况下学习从输入 \\(x\\)  到输出 \\(y\\)  的映射。 这里 \\(\\mathcal{D}\\)  被称为训练集， \\(N\\)  是训练样本的数量。\n在最简单的设置中，每个训练输入 \\(x_i\\)  是 \\(D\\)  维向量，例如表示人的身高和体重。这些被称为特征，属性或协变量。 然而，一般而言， \\(x_i\\)  可以是复杂的结构化对象，例如图像，句子，电子邮件消息，时间序列，分子形状，图形等。\n类似地，输出或响应变量的形式原则上可以是任何形式，但是大多数方法假设 \\(y_i\\)  是来自某个有限集的分类或名称变量， \\(y_i \\in {1,\\dots,C}\\)  （例如男性或女性） 或者 \\(y_i\\)  是一个实值标量（如收入水平）。当 \\(y_i\\)  是分类时，问题被称为分类或模式识别，并且当 \\(y_i\\)  是实值时，该问题被称为回归。另一种变体，称为序数回归(译者注: 也叫排名学习)，发生在标签空间 \\(\\mathcal{Y}\\)  具有某种自然顺序的地方，例如等级A-F。\n第二种主要的机器学习类型是描述性的或无监督学习方法。 这里我们只给出输入， \\(\\mathcal{D} = \\{ x_i \\}_{i = 1}^N\\)  ，目标是在数据中找到“有趣的模式”。这有时被称为知识发现。这是一个定义不太明确的问题，因为我们没有被告知要查找哪种模式，并且没有明显的误差度量标准可供使用（与监督学习不同，我们可以将我们对给定 \\(x\\)  的 \\(y\\)  的预测进行比较 观察值）。\n还有第三种类型的机器学习，称为强化学习，它在某种程度上不太常用。这对于学习如何在给予偶尔的奖励或惩罚信号时的动作或行为很有用。 （例如，考虑一个婴儿如何学会走路。） 不幸的是，RL超出了本书的范围，尽管我们在第5.7节讨论决策理论，这是RL的基础。参见（Kaelbling等人1996; Sutton和Barto 1998; Russell和Norvig 2010; Szepesvari 2010; Wiering和van Otterlo 2012）以获得关于RL的更多信息。\n返回本章目录\n"}),a.add({id:320,href:'/notes/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/',title:"强化学习",content:""}),a.add({id:321,href:'/notes/docs/mlapp/01introduction/',title:"第一章 导论",content:"第一章 导论 本节中的目录：\n  1.1 机器学习：什么和为什么？\n  1.2 监督学习\n  1.3 无监督学习\n  1.4 机器学习的一些基本概念\n  Exercises\n  "}),a.add({id:322,href:'/notes/docs/mlapp/',title:"《机器学习：概率视角》",content:"《机器学习：概率视角》 原文: Machine Learning A Probabilistic Perspective, Kevin P. Murphy, MIT, 2012\n译者: 混沌(joistwang@sina.com)\n随书代码\n 第一章 导论 第二章 概率 第三章 基于离散数据的生成式模型 第四章 高斯模型    第五章 贝叶斯统计 第六章 频率派统计 第七章 线性回归   "}),a.add({id:323,href:'/notes/docs/apm/',title:"主动投资组合管理",content:"主动投资组合管理 电子书 主动投资组合管理：创造高收益并控制风险的量化投资方法（原书第2版）-[美]理查德·C·格林诺德 等-李腾 等(译)-机械工业出版社-2014\nActive Portfolio Management：A Quantitative Approach for Providing Superior Returns and Controlling Risk, 2ed, Grinold ＆ Kahn, MacGraw-Hill, 2000\nhttps://github.com/chaoskey/notes/tree/master/apm/pdf\n目录  第一章 绪论 第二章 一致预期收益率：资本资产定价模型 第三章 风险 第四章 超常收益率、业绩基准和附加值    第五章 残差风险和残差收益率：信息率 第六章 主动管理基本定律 第七章 预期收益率和套利定价理论 第八章 估值理论   "}),a.add({id:324,href:'/notes/categories/%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84/',title:"量化投资",content:""}),a.add({id:325,href:'/notes/tags/%E4%B8%AD%E6%80%A7/',title:"中性",content:""}),a.add({id:326,href:'/notes/tags/%E4%BC%B0%E5%80%BC/',title:"估值",content:""}),a.add({id:327,href:'/notes/tags/%E5%A4%B4%E5%AF%B8/',title:"头寸",content:""}),a.add({id:328,href:'/notes/tags/%E5%A5%97%E5%88%A9/',title:"套利",content:""}),a.add({id:329,href:'/notes/tags/%E6%8A%95%E8%B5%84/',title:"投资",content:""}),a.add({id:330,href:'/notes/docs/apm/0024/',title:"第八章 估值理论",content:'离散随机模型 考虑   \\(N+1\\)  个资产，经历 \\(T\\)  个时间单位的，关于价格的离散随机过程：\n    前续 当前 后续     时刻 \\(t-1\\)   \\(t\\)   \\(t+1\\)     状态 \\(\\phi(s,t)\\)   \\(s=\\phi(z,t+1)\\)   \\(z\\)      时刻 \\(t\\)  的每个状态 \\(s\\)  代表：在时刻 \\(t\\)  的历史价格路径。如果给定时刻 \\(t\\)  的状态 \\(s\\)  ，那么 \\(s\\)  有确定的前续状态记为 \\(\\phi(s,t)\\)  ，而 \\(s\\)  的后续状态是不确定的，将 \\(s\\)  所有可能的后续状态集记为 \\(\\Omega(s,t)\\)  ；并且将时刻 \\(t\\)  的所有状态集记为 \\(\\Phi(t)\\)  。\n假设我们知道时刻 \\(t\\)  状态 \\(s\\)  的发生概率为 \\(\\pi(s,t)0\\)  。\n资产价格由 \\(\\boldsymbol{p}(s,t)=(p_0(s,t),\\dots,p_N(s,t))^T\\)  表示，即在时刻 \\(t\\)  状态 \\(s\\)  下的价格向量。特别地， \\(t=0\\)  时刻仅有一种状态，不妨记 \\(\\boldsymbol{p}(s,0)=\\boldsymbol{p}(0)\\)  。第0个资产是无风险资产：\n\\[ p_0(z,t+1)=\\left[1+i_F(s,t) \\right]\\ p_0(s,t) , \\quad \\forall z\\in \\Omega(s,t) \\]  引入与前几章头寸权重类似的概念－投资策略 \\(\\boldsymbol{w}(s,t)=(w_0(s,t),\\dots,w_N(s,t))^T\\)  ，表示资产的持仓数。进而可定义投资组合在时刻 \\(t\\)  状态 \\(s\\)  下的价值：\n\\[ W(s,t)=\\boldsymbol{w}^T(s,t)\\ \\boldsymbol{p}(s,t) \\]  强制投资策略满足自融资约束（组合价值在头寸调整前与调整后是一致的）：\n\\[ W(s,t)=\\boldsymbol{w}^T(s,t)\\ \\boldsymbol{p}(s,t)=\\boldsymbol{w}^T(\\phi(s,t),t-1)\\ \\boldsymbol{p}(s,t), \\quad \\forall t\\ge1, \\forall s\\in \\Phi(t) \\]  套利机会 我们称套利机会存在，如果存在满足如下性质的投资策略：\n１）所需初始资金非正，即 \\(W(0)\\le0\\)  ：\n２）绝对不会亏钱，即 \\(W(s,T)\\ge 0, \\quad \\forall s\\in \\Phi(T)\\)  ；\n３）至少在一种可能结果中赚钱，即 \\(\\sum\\limits_{s\\in \\Phi(T)}{W(s,T)}0\\)  。\n估值公式：资产定价第一基本定律 如果不存在套利机会，那么存在一个正值的估值乘子 \\(v(s,t)0\\)  ，满足：\n\\[ \\frac{\\boldsymbol{p}(0)}{p_0(0)}=\\sum_{s\\in \\Phi(t)}{\\pi(s,t) v(s,t) \\frac{\\boldsymbol{p}(s,t)}{p_0(s,t)}} \\]  证明有待细看（尚未完全看懂）。\n风险调整期望（风险中性期望） 第一基本定律的证明过程中构造出一个新的概率 \\(\\pi(s,t)\\)  ，称作风险中性概率或鞅概率，进而构造出价值乘子 \\(v(s,t)\\)  ：\n\\[ v(s,t)=\\frac{\\pi^*(s,t)}{\\pi(s,t)} \\]  注意到第一基本定律具有数学期望的形式，进而可改写成：\n\\[ \\boldsymbol{p}(0) = p_0(0)\\ \\mathrm{E}\\left\\{v(t) \\frac{\\boldsymbol{p}(t)}{p_0(t)}\\right\\} = p_0(0)\\ \\mathrm{E}^*\\left\\{\\frac{\\boldsymbol{p}(t)}{p_0(t)}\\right\\}, \\quad \\forall t\\ge 1 \\]  其中， \\(\\mathrm{E}\\)  是真实概率分布的数学期望，我称之为真实期望，而 \\(\\mathrm{E}^*\\)  则是风险中性概率分布的数学期望，在本书中被称作风险调整期望，我认为称作风险中性期望似乎更好。而前面的价值乘子 \\(v(s,t)\\)  ，就是一个Radon-Nikodyn导致。\n所有现代的估值理论，包括期权定价理论、CAPM和APT都使用了上述形式的估值公式。\n确定现金流的估值 资产定价第一基本定律，本质上一个递推公式： \\(t=0\\)  时刻的正确定价依赖于 \\(t0\\)  时刻的正确定价。特别地，对于一个确定的现金流，递推的结果就是：任何 \\(t\\)  时刻的估值完全由相对 \\(t\\)  时刻的未来剩余现金流确定。也就是对现金流的每个偿付套用估值公式然后求和，而特定 \\(t\\)  时刻的确定现金偿付就是对应的定价，记作 \\(\\mathrm{cf}(t)\\)  ，于是有：\n\\[ p=p(0)=\\sum_{t=1}^T{\\mathrm{E}^*\\{\\frac{p(t)}{(1+i_F)^t}\\}}=\\sum_{t=1}^T{\\frac{\\mathrm{cf}(t)}{(1+i_F)^t}} \\]  注意：对应确定的现金流，任何时刻都只有一种状态，无论是真实概率还是风险中性概率都是1。\n关于风险中性期望的计算 需要假定市场无套利，才能利用资产定价第一基本定律进行估值定价。\n如果要对某个资产进行定价，首先需要知道风险中性概率分布，进而才能进行风险中性期望的计算。\n如果有当前（ \\(t=0\\)  时刻）的市场价格 \\(\\boldsymbol{p}\\)  （根据假设，必定已经合理定价）和未来（ \\(t0\\)  时刻）的可能状态 \\(s\\in \\Phi(t)\\)  对应的价格 \\(\\boldsymbol{p}(s,t)\\)  ，根据定价公式可以确定风险中性概率分布 \\(\\pi^*(s,t)\\)  ：\n\\[ \\boldsymbol{p}=p_0\\mathrm{E}^*\\left\\{\\frac{\\boldsymbol{p}(t)}{p_0(t)}\\right\\}=p_0\\sum_{s\\in \\Phi(t)}{\\pi^*(s,t) \\frac{\\boldsymbol{p}(s,t)}{p_0(s,t)}} \\]  如果考虑离散状态 \\(s=1,\\dots,S\\)  ，上述关系可改写矩阵方程形式：\n\\[ \\begin{aligned} \u0026\\dfrac{\\boldsymbol{p}}{p_0}=\\boldsymbol{D}\\ \\boldsymbol{\\pi}^* \\\\ 其中，\u0026\\boldsymbol{D}=(D_{i,s})_{(N+1)\\times S} \\quad t时刻，第i资产第s状态"标准化价格" \\\\ \u0026 \\boldsymbol{\\pi}^*=(\\pi_1^*,\\dots,\\pi_S^*) \\quad 第s状态发生的概率 \\end{aligned} \\]  矩阵方程的第0资产(无风险资产)对应的分量方程恰满足概率归一条件：\n\\[ 1=\\sum_{s=1}^S{\\pi_s^*} \\]  对于 \\(S\\)  个状态，只需要 \\(S-1\\)  个风险资产就可以确定风险中性概率分布。\n我们发现，无需知道真实概率分布（也无法知道），只要不存在套利机会，并且知道一部分基础资产的市场价格，那么就可唯一确定风险中性概率分布。\n'}),a.add({id:331,href:'/notes/tags/%E5%AE%9A%E4%BB%B7/',title:"定价",content:""}),a.add({id:332,href:'/notes/docs/apm/0023/',title:"第七章 预期收益率和套利定价理论",content:" 套利定价理论(APT)是资本资产定价模型(CAPM)在预测预期收益率上的一个有趣而强力的替代选择。\n尽管CAPM抓住了最重要的角色－－市场，但是忽略了其它因素对预期收益率的影响，必然在某些时期会出现系统性缺陷。\nAPT是生成预期收益率的模型。\nAPT的应用是艺术，而非科学。\nAPT关注因子和预期收益率之间的关系。\nAPT的灵活性导致它不适合作为一致预期收益率的模型。\nAPT是主动投资经理的一个信息来源。\n 套利定价理论 和第３章的风险结构化模型类似，APT首先给超额收益率设定了一个因子模型：\n  \\[ \\boldsymbol{r} = \\boldsymbol{X} \\boldsymbol{b} + \\boldsymbol{u} \\]  式中：\n\\[ \\begin{aligned} \\boldsymbol{r} \u0026= (r_1,\\dots,r_N)^T \\quad r_i(t)资产i的\\mathbf{超额收益率} \\\\ \\boldsymbol{X} \u0026= (X_{i,j})_{N \\times K} \\quad X_{i,j}(t)资产i对因子k的\\mathbf{暴露度}(\\mathbf{因子载荷}) \\\\ \\boldsymbol{b} \u0026= (b_1,\\dots,b_K)^T \\quad b_j(t)因子j的\\mathbf{因子收益率} \\\\ \\boldsymbol{u} \u0026= (u_1,\\dots,u_N)^T \\quad u_i(t)资产i的\\mathbf{特异收益率} \\end{aligned} \\]  第３章关注的风险，这里我们关注预期收益率。\n然后假设：\n１） \\(f_C0\\)  ，因此组合Q存在且 \\(f_Q0\\)  ；\n２）特异收益率 \\(\\boldsymbol{u}\\)  和因子收益率 \\(\\boldsymbol{b}\\)  互不相关；\n３）因子暴露度矩阵 \\(\\boldsymbol{X}\\)  在考察期初就完全确定地获知。\n基于这些假设，超额收益率协方差可写成：\n\\[ \\boldsymbol{V} = \\boldsymbol{X} \\boldsymbol{F} \\boldsymbol{X}^T + \\Delta \\]  式中：\n\\[ \\begin{aligned} \\boldsymbol{V} \u0026= (V_{i,j})_{N \\times N} \\quad V_{i,j}资产i和资产j的超额收益率协方差 \\\\ \\boldsymbol{F} \u0026= (F_{i,j})_{K \\times K} \\quad F_{i,k}因子i和因子j的因子收益率协方差 \\\\ \\boldsymbol{\\Delta} \u0026= (\\Delta_{i,j})_{N \\times N} \\quad \\Delta_{i,i}资产i特异收益率方差，通常假设是对角阵(不是必要) \\end{aligned} \\]  我们用 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  来表示因子模型。\nAPT是关于预期超额收益率的，其表述为：预期超额收益率可用一组因子的暴露度来表达。换而言之，因子模型 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  解释了预期超额收益率向量 \\(\\boldsymbol{f}=\\mathrm{E}\\{\\boldsymbol{r}\\}\\)  ，如果存在因子预测向量 \\(\\boldsymbol{m}\\)  ，使得：\n\\[ \\boldsymbol{f}=\\boldsymbol{X}\\ \\boldsymbol{m} \\]  APT的推导 在第２章我们知道，预期超额收益率可用组合Q表达：\n\\[ \\boldsymbol{f}=f_Q\\frac{\\boldsymbol{V} \\boldsymbol{h}_Q}{\\sigma_Q^2} \\]  进而，预期超额收益率可改写成：\n\\[ \\begin{aligned} \\boldsymbol{f}\u0026=\\kappa_Q \\left(\\boldsymbol{X}\\boldsymbol{F}\\boldsymbol{X}^T+\\boldsymbol{\\Delta} \\right)\\boldsymbol{h}_Q \\\\ 其中，\\kappa_Q\u0026=\\dfrac{f_Q}{\\sigma_Q^2} \\end{aligned} \\]  令 \\(\\boldsymbol{m}^*=\\kappa_Q \\boldsymbol{F}\\boldsymbol{X}^T\\boldsymbol{h}_Q\\)  ，则有：\n\\[ \\boldsymbol{f}=\\boldsymbol{X}\\ \\boldsymbol{m}^*+\\kappa_Q \\boldsymbol{\\Delta}\\ \\boldsymbol{h}_Q \\]  这个表示已经很接近APT，但还不是我们要的 \\(\\boldsymbol{m}\\)  。\n为了推导出APT，我们还需要作一个更强的假设。首先定义：一个组合P被称作相对因子模型 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  充分分散，如果组合P在所有具有相同因子暴露度的组合中风险最低，即如下优化问题的最优解：\n\\[ \\begin{aligned} \\underset{\\boldsymbol{h}=\\boldsymbol{h}_P}{\\min} \\quad \\boldsymbol{h}^T V \\boldsymbol{h} \\\\ s.t. \\quad \\boldsymbol{X}^T \\boldsymbol{h} = \\boldsymbol{x}_P \\end{aligned} \\]  我们需要的更强假设是：组合Q相对因子模型 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  充分分散。\n事实上，因子模型 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  能够解释预期超额收益率，当且仅当，组合Q相对因子模型 \\((\\boldsymbol{X},\\boldsymbol{F},\\boldsymbol{\\Delta})\\)  充分分散。\n【充分性】用拉格朗日乘子法求解充分分散的最优化问题，将其一阶条件整理后就是：\n\\[ \\boldsymbol{V}\\ \\boldsymbol{h}_Q=\\boldsymbol{X}\\ \\boldsymbol{\\pi} \\]  其中， \\(\\boldsymbol{\\pi}\\)  是拉格朗日乘子向量。带入到组合Q表示的预期超额收益率就得到我们要的因子预测向量 \\(\\boldsymbol{m}=\\kappa_Q \\boldsymbol{\\pi}\\)  。\n【必要性】基本思路就是反证法，推导出一个错误：“存在比组合Q具有更高夏普率的组合”。\n应用 １）结构化模型１：给定暴露度，估计因子收益率；\n２）结构化模型２：给定因子收益率，估计暴露度；\n３）结构化模型３：结构化模型１和２的结合；\n４）统计模型１：主成份分析；\n５）统计模型２：最大拟然因子分析；\n６）统计模型３：统计模型２的对偶。\n"}),a.add({id:333,href:'/notes/tags/%E4%B8%BB%E5%8A%A8%E7%AE%A1%E7%90%86/',title:"主动管理",content:""}),a.add({id:334,href:'/notes/tags/%E4%BF%A1%E6%81%AF%E7%8E%87/',title:"信息率",content:""}),a.add({id:335,href:'/notes/tags/%E6%AE%8B%E5%B7%AE/',title:"残差",content:""}),a.add({id:336,href:'/notes/docs/apm/0022/',title:"第六章 主动管理基本定律",content:"基本定律 主动管理基本定律是信息率的一种近似表达。\n这条定律基于投资策略的两条基本属性：\n１）投资策略的广度（   \\(\\mathrm{BR}\\)  ）：策略每年对超常收益率作出的独立预测的数目。\n２）投资经理的信息系数（ \\(\\mathrm{IC}\\)  ）：每个预测与实现结果之间的相关系数，表征投资经理的能力。简化假设：所有预测的 \\(\\mathrm{IC}\\)  都是相同的。\n主动管理基本定律：\n\\[ \\mathrm{IR} = \\mathrm{IC} \\ \\sqrt{\\mathrm{BR}} \\]  此定律的近似条件：忽略我的预测在降低风险方面的作用， \\(\\mathrm{IC}\\)  越小，主动管理基本定律的正确性越高。\n根据基本定律以及第５章的最优残差风险水平与信息率之间的关系，最优残差风险可重新表述成：\n\\[ \\omega^*=\\frac{\\mathrm{IC} \\ \\sqrt{\\mathrm{BR}}}{2 \\lambda_R} \\]  这意味着：能力越高可以采用更激进的策略（因为成功概率更大）；广度越高也可以适当增加激进水平（因为有更多机会去分散风险）。\n投资经理所能创造的最大附加值也可表述为：\n\\[ \\mathrm{VA}^* = \\frac{\\mathrm{IC}^2 \\ \\mathrm{BR}}{4 \\lambda_R} \\]  主动管理基本定律说明的真谛：需要在增加投资测的广度 \\(\\mathrm{BR}\\)  （覆盖更多的股票或缩短预测时间）和提高能力 \\(\\mathrm{IC}\\)  之间进行权衡。战略上，这种权衡很快速简单；但具体精确估计广度 \\(\\mathrm{BR}\\)  是困难的，因为广度定义要求各个预测之间是独立的。\n基本定律的应用 赌场老板 轮盘赌：１８个红格，１８个黑格，１个绿格，赌徒只能压黑或压红。\n从赌场视角看：１）如果赌徒压错则赌场赢；２）赌徒下注后，赌场作为对手方下同等注；３）赌场赢，额外获得赌徒所下的注（100%收益率）；如果赌场输，将所下注赔给赌徒（-100%收益率）。\n赌场单局赢率 \\(\\dfrac{19}{37}\\)  ，单局盈利能力 \\(\\mathrm{IC}=\\dfrac{1}{37}\\)  。\n进而可算出：赌场单局预期收益率 \\(f=\\mathrm{E}\\{r\\}=2.7027\\%\\)  ；赌场单局收益率标准差 \\(\\sigma=\\sqrt{\\mathrm{E}\\{(r-f)^2\\}}=99.9634\\%\\)  。\n假设赌场每年的赌局数为 \\(\\mathrm{BR}=1000000\\)  。赌场年预期收益率依然是 \\(f\\)  ，但年收益率标准差为 \\(\\dfrac{\\sigma}{\\sqrt{\\mathrm{BR}}}\\)  。进而可算出年信息率为：\n\\[ \\mathrm{IR}=\\dfrac{f}{\\sigma_{年}}=\\sqrt{\\mathrm{BR}} \\ \\dfrac{f}{\\sigma}=27.037 \\]  而通过基本定律算出的结果：\n\\[ \\mathrm{IR} = \\mathrm{IC} \\ \\sqrt{\\mathrm{BR}}=27.027 \\]  赌场老板秒杀一切投资经理。\n残差收益率的半年预测 考虑每次预测的股票数 \\(N=200\\)  ，那么 \\(\\mathrm{BR}=2 N\\)  ，并假设：\n１）不同股票残差收益率相互独立；\n２）股票预期残差收益率为零；\n３）每只股票半年残差收益率的标准差都为 \\(\\sigma=17.32\\%\\)  。\n根据这三个假设，不妨将每只股票的残差收益率分解为M个独立变量之和：\n\\[ \\theta_i=\\sum_{j=1}^M{\\theta_{i,j}} \\]  其中， \\(\\theta_{i,j}\\)  以相等概率取值 \\(1\\%\\)  和 \\(-1\\%\\)  ，于是每个独立变量都具有零均值和 \\(1\\%\\)  标准差。\n每支股票的残差收益率 \\(\\theta_i\\)  的标准差为： \\(\\sigma=\\sqrt{M}/100\\)  ，意味着独立变量数应该是 \\(M=(100 \\ \\sigma)^2=300\\)  。\n进而可算出残差收益率与每个独立变量的相关系数(即，信息系数)为 \\(\\mathrm{IC}=\\dfrac{\\mathrm{Cov}\\{\\theta_i,\\theta_{i,j}\\}}{\\mathrm{Var}\\{\\theta_i\\}\\mathrm{Var}\\{\\theta_{ij}\\}}=\\dfrac{0.01}{\\sigma}=0.0577\\)  。\n根据基本定律可以算出信息率 \\(\\mathrm{IR}=\\mathrm{IC} \\ \\sqrt{2 N}=1.154\\)  。\n实现这个信息率的一种策略方案：假设业绩基准组合是这200只股票的等权组合，每半年的预测结果：100只股票预期残差收益率为 \\(1\\%\\)  ,另100只股票预期收益率 \\(-1\\%\\)  。那么等权买入正预期的股票，卖出负预期的股票。这种方案下，每半年，预期主动收益率为 \\(0.5\\ (1\\%)+(-0.5)\\ (-1\\%)=1\\%\\)  ，主动标准差为 \\(\\dfrac{\\sigma}{\\sqrt{N}}=1.2247\\%\\)  ，进而算出信息率 \\(\\mathrm{IR}=\\dfrac{1\\%}{1.2247\\%}=0.8165\\)  ，转换成年化信息率 \\(\\sqrt{2}\\ 0.8165=1.1547\\)  。略高于基本定律的计算值。\n市场方向的季度预测 用变量 \\(x(t)=\\pm1\\)  表示市场方向， \\(y(t)=\\pm1\\)  则表示预测值， \\(x\\)  和 \\(y\\)  都具有零均值和单位标准差。如果考虑市场的N次预测（ \\(t=1,\\dots,N\\)  ），那么信息系数 \\(\\mathrm{IC}\\)  的计算公式为：\n\\[ \\mathrm{IC}=\\mathrm{Cov}\\{x,y\\}=\\mathrm{E}\\{x y\\}=\\frac{1}{N} \\sum_t^N{x(t) y(t)} \\]  如果 \\(N\\)  次预测中， \\(N_1\\)  次正确( \\(x=y\\)  )， \\(N-N_1\\)  次错误( \\(x=-y\\)  )，那么信息率 \\(\\mathrm{IC}\\)  为：\n\\[ \\mathrm{IC}=\\frac{1}{N} (N_1-(N-N_1) )=2 \\ \\frac{N_1}{N}-1 \\]  前面曾看到0.0577的信息系数可产生高于1.0的信息率，而这里可看到为了达到0.0577的信息率，我们只需要在 \\(52.885\\%\\)  的时间里正确地预测出市场方向（这个要求不高）。\n信息率的平方可加性 信息率的平方可加性将在基本定律的推导中附带证明，和基本定律一样，也是近似成立的。\n书中分别给出了四种情况：１）不同广度；２）不同信息系数；３）国际化投资组合；４）不同投资经理。\n假设 基本定律告诉我们：要想获得最高附加值，就要做的频繁（高广度 \\(\\mathrm{BR}\\)  ）并且做的出色（高能力 \\(\\mathrm{IC}\\)  ）。和其它理论一样，主动管理基本定律也是基于一些不太实际的假设。\n假设１（完美胜任假设）：投资经理能够精确衡量自己的能力（计算信息的价值）并以最优的方式利用这种能力。\n假设２：各个预测之间应该是独立的。\n预测之间（信息源之间）的相关性会降低你的整体能力。如果用表示两个相同能力 \\(\\mathrm{IC}\\)  信息源之间的相关系数 \\(\\gamma\\)  ，那么合并信息源的能力 \\(\\mathrm{IC}_{合并}\\)  将是：\n\\[ \\mathrm{IC}_{合并}＝\\mathrm{IC} \\ \\sqrt{ \\frac{2}{1+\\gamma}} \\]  如果两个信息源不相关，那么 \\(\\mathrm{IC}_{合并}^2＝2 \\ \\mathrm{IC}^2\\)  。\n假设３： \\(\\mathrm{BR}\\)  个主动赌注中的每一个都具有相同的能力。\n信息模型 以业绩基准为基础的超额收益率分解：\n\\[ \\begin{aligned} \u0026 \\boldsymbol{r}=\\boldsymbol{\\beta} \\ r_B + \\boldsymbol{\\theta} \\\\ \\quad \\\\ 其中， \u0026 \\boldsymbol{\\beta}=(\\beta_1,\\dots,\\beta_N)^T \\quad 资产相对业绩基准B的贝塔列向量 \\\\ \u0026 \\boldsymbol{\\theta}=(\\theta_1,\\dots,\\theta_N)^T \\quad 残差收益率列向量 \\\\ \u0026 r_B \\quad 业绩基准的超额收益率 \\end{aligned} \\]  进而一步对残差收益率 \\(\\boldsymbol{\\theta}\\)  进行建模：\n\\[ \\begin{aligned} \u0026 \\boldsymbol{\\theta}=\\boldsymbol{A} \\boldsymbol{x} \\\\ \\quad \\\\ 其中， \u0026 \\boldsymbol{x}=(x_1,\\dots,x_N)^T \\quad \\mathrm{E}\\{\\boldsymbol{x}\\}=\\boldsymbol{0}_{N \\times 1},\\mathrm{Var}\\{\\boldsymbol{x}\\}=\\boldsymbol{I}_{N \\times N} \\\\ \u0026 \\boldsymbol{A}=(A_{i,j})_{N \\times N} \\quad \\boldsymbol{r}的残差协方差矩阵的平方根矩阵 \\\\ \u0026 \\mathrm{Var}\\{\\boldsymbol{\\theta}\\}=\\boldsymbol{A}\\boldsymbol{A}^T \\end{aligned} \\]  关于矩阵 \\(\\boldsymbol{A}\\)  ，有：\n１） \\(\\boldsymbol{V}=\\sigma_B^2 \\ \\boldsymbol{\\beta} \\ \\boldsymbol{\\beta}^T+\\boldsymbol{A} \\boldsymbol{A}^T\\)  ；\n２） \\(\\boldsymbol{A}^T \\boldsymbol{h}_B=0\\)  ，所以矩阵 \\(\\boldsymbol{A}\\)  的秩为 \\(N-1\\)  ；\n３）当残差收益率之间互不相关时， \\(\\boldsymbol{A}\\)  恰好是以残差风险为对角线元素的对角矩阵。\n在更一般的情况下， \\(\\boldsymbol{A}\\)  是从一组不相关的基础变量到相互关联的残差收益率变量的线性变换矩阵。\n假如我们的信息以信号列向量 \\(\\boldsymbol{z}=(z_1,\\dots,z_{\\mathrm{BR}})^T\\)  的形式到达。不失一般性，假设信号 \\(\\boldsymbol{z}\\)  服从零均值、１标准差的联合正态分布，于是可将写成：\n\\[ \\begin{aligned} \u0026 \\boldsymbol{z}=\\boldsymbol{E} \\ \\boldsymbol{y} \\\\ \\quad \\\\ 其中， \u0026 \\boldsymbol{y}=(y_1,\\dots,y_{\\mathrm{BR}})^T \\quad \\mathrm{E}\\{\\boldsymbol{y}\\}=\\boldsymbol{0}_{\\mathrm{BR} \\times 1},\\mathrm{Var}\\{\\boldsymbol{y}\\}=\\boldsymbol{I}_{\\mathrm{BR} \\times \\mathrm{BR}} \\\\ \u0026 \\boldsymbol{E}=(E_{i,j})_{\\mathrm{BR} \\times \\mathrm{BR}} \\quad \\boldsymbol{z}的协方差矩阵的平方根矩阵且可逆 \\\\ \u0026 \\mathrm{Var}\\{\\boldsymbol{z}\\}=\\boldsymbol{E}\\boldsymbol{E}^T \\end{aligned} \\]  记\n\\[ \\begin{aligned} \\boldsymbol{Q}\u0026=\\mathrm{Cov}\\{\\boldsymbol{\\theta},\\boldsymbol{z}\\}=(\\mathrm{Cov}\\{\\theta_i,z_j\\})_{N \\times \\mathrm{BR}} \\\\ \\boldsymbol{P}\u0026=\\mathrm{Corr}\\{\\boldsymbol{x},\\boldsymbol{y}\\}=(\\mathrm{Corr}\\{x_i,y_j\\})_{N \\times \\mathrm{BR}}=\\left(\\dfrac{\\mathrm{Cov}\\{x_i,y_j\\}}{\\mathrm{Std}\\{x_i\\} \\mathrm{Std}\\{y_j\\}}\\right)_{N \\times \\mathrm{BR}} \\\\ \u0026=(\\mathrm{Cov}\\{x_i,y_j\\})_{N \\times \\mathrm{BR}}=\\mathrm{Cov}\\{\\boldsymbol{x},\\boldsymbol{y}\\} \\end{aligned} \\]  于是有 \\(\\boldsymbol{Q}=\\boldsymbol{A} \\boldsymbol{P} \\boldsymbol{E}^T\\)  。\n已知 \\(\\boldsymbol{z}\\)  信号的情况下，残差收益率 \\(\\boldsymbol{\\theta}\\)  的条件均值列向量和条件协方差矩阵：\n\\[ \\begin{aligned} \\mathrm{E}\\{\\boldsymbol{\\theta} | \\boldsymbol{z}\\}= \\boldsymbol{A} \\boldsymbol{P} \\boldsymbol{E}^{-1} \\boldsymbol{z} \\overset{\\Delta}{=} \\boldsymbol{\\alpha}(\\boldsymbol{z})\\\\ \\mathrm{Var}\\{\\boldsymbol{\\theta} | \\boldsymbol{z}\\}=\\boldsymbol{A}(\\boldsymbol{I}-\\boldsymbol{P}\\boldsymbol{P}^T)\\boldsymbol{A}^T\\overset{\\Delta}{=}\\boldsymbol{G} \\end{aligned} \\]  【提示】1） \\(\\boldsymbol{\\theta} = \\boldsymbol{A} \\boldsymbol{x} \\sim \\boldsymbol{A} \\boldsymbol{P} \\boldsymbol{y}=\\boldsymbol{A} \\boldsymbol{P} \\boldsymbol{E}^{-1} \\boldsymbol{z}\\)  ;2） \\(\\mathrm{E}\\{\\boldsymbol{A}\\boldsymbol{x}|\\boldsymbol{z}\\}=\\boldsymbol{A} \\mathrm{E}\\{\\boldsymbol{x}|\\boldsymbol{z}\\}\\)  ;3） \\(\\mathrm{Var}\\{\\boldsymbol{\\theta} | \\boldsymbol{z}\\}=\\mathrm{E}\\{(\\boldsymbol{\\theta}-\\mathrm{E}\\{\\boldsymbol{\\theta}|\\boldsymbol{z}\\})(\\boldsymbol{\\theta}-\\mathrm{E}\\{\\boldsymbol{\\theta}|\\boldsymbol{z}\\})^T\\}\\)  .\n注意：\n１） \\(\\boldsymbol{\\alpha}(\\boldsymbol{z})\\)  的无条件期望值为零；\n２） \\(\\boldsymbol{\\alpha}(\\boldsymbol{z})\\)  的无条件方差为 \\(\\mathrm{Var}\\{\\boldsymbol{\\alpha}(\\boldsymbol{z})\\}=\\boldsymbol{A}\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{A}^T\\)  ；\n３）残差收益率的条件协方差矩阵 \\(\\mathrm{Var}\\{\\boldsymbol{\\theta} | \\boldsymbol{z}\\}\\)  不依赖于 \\(\\boldsymbol{z}\\)  。\n目标 我们的目标是：给定信号 \\(\\boldsymbol{z}\\)  的前提下，最大化附加值（忽略业绩基准择时），即求解如下优化问题（最优残差头寸 \\(\\boldsymbol{h}^*\\)  ）：\n\\[ \\begin{aligned} \\mathrm{VA}(\\boldsymbol{z}) =\u0026 \\underset{\\boldsymbol{h}=\\boldsymbol{h}^*}{\\max} \\left\\{\\boldsymbol{h}^T \\boldsymbol{\\alpha}(\\boldsymbol{z})-\\lambda \\boldsymbol{h}^T \\boldsymbol{G} \\boldsymbol{h} \\right\\} \\\\ s.t. \u0026 \\boldsymbol{\\beta}^T h =0 \\end{aligned} \\]  最优主动头寸 通过拉格朗日乘子法，容易求出最优残差头寸 \\(\\boldsymbol{h}^*\\)  ：\n\\[ \\begin{aligned} \\boldsymbol{h}^* \u0026= \\dfrac{1}{2\\lambda} \\left( \\boldsymbol{G}^{-1} \\boldsymbol{\\alpha}(\\boldsymbol{z})-\\phi \\ \\boldsymbol{G}^{-1} \\boldsymbol{\\beta} \\right) \\\\ \\phi \u0026= \\dfrac{\\boldsymbol{\\beta}^T \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z})}{\\boldsymbol{\\beta}^T \\boldsymbol{G}^{-1}\\boldsymbol{\\beta}} \\end{aligned} \\]  信息率的严格计算 最优组合的阿尔法：\n\\[ \\boldsymbol{h}^{*T}(\\boldsymbol{z})\\ \\boldsymbol{\\alpha}(\\boldsymbol{z}) = \\frac{1}{2\\lambda}\\left(\\boldsymbol{\\alpha}^T(\\boldsymbol{z}) \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z})-\\frac{\\left( \\boldsymbol{\\beta}^T \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z}) \\right)^2}{\\boldsymbol{\\beta}^T\\boldsymbol{G}^{-1}\\boldsymbol{\\beta}} \\right) \\]  最优组合的残差方差：\n\\[ \\boldsymbol{h}^{*T}(\\boldsymbol{z})\\ \\boldsymbol{G}\\ \\boldsymbol{h}^{*}(\\boldsymbol{z}) = \\frac{1}{4 \\lambda^2}\\left(\\boldsymbol{\\alpha}^T(\\boldsymbol{z}) \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z})-\\frac{\\left( \\boldsymbol{\\beta}^T \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z}) \\right)^2}{\\boldsymbol{\\beta}^T\\boldsymbol{G}^{-1}\\boldsymbol{\\beta}} \\right) \\]  于是信息率的平方：\n\\[ \\begin{aligned} \u0026\\mathrm{IR}^2(\\boldsymbol{z}) \u0026=\u0026 \\boldsymbol{\\alpha}^T(\\boldsymbol{z}) \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z})-\\dfrac{\\left( \\boldsymbol{\\beta}^T \\boldsymbol{G}^{-1}\\boldsymbol{\\alpha}(\\boldsymbol{z}) \\right)^2}{\\boldsymbol{\\beta}^T\\boldsymbol{G}^{-1}\\boldsymbol{\\beta}} \\\\ \u0026 \u0026=\u0026 \\boldsymbol{y}^T \\boldsymbol{P}^T \\boldsymbol{D} \\boldsymbol{P} \\boldsymbol{y} - \\dfrac{\\boldsymbol{\\beta}^T \\left(\\boldsymbol{A}^{-1}\\right)^T \\boldsymbol{D} \\boldsymbol{P}\\ \\boldsymbol{y}\\ \\boldsymbol{y}^T \\boldsymbol{P}^T \\boldsymbol{D} \\boldsymbol{A}^{-1}\\boldsymbol{\\beta}}{\\boldsymbol{\\beta}^T \\left(\\boldsymbol{A}^{-1}\\right)^T \\boldsymbol{D} \\boldsymbol{A}^{-1}\\boldsymbol{\\beta}} \\\\ 其中，\u0026 \\quad \\quad \\boldsymbol{D} \u0026=\u0026 \\left(\\boldsymbol{I} - \\boldsymbol{P} \\boldsymbol{P}^T \\right)^{-1} \\\\ \u0026 \\quad \\quad \\boldsymbol{y} \u0026=\u0026 \\boldsymbol{E}^{-1} \\boldsymbol{z} , \\quad 相互独立的标准随机变量列向量 \\end{aligned} \\]  有了 \\(\\boldsymbol{z}\\)  已知条件的信息率，进而可求出信息率平方的无条件期望值：\n\\[ \\mathrm{IR}^2 = \\mathrm{E}\\{\\mathrm{IR}^2(\\boldsymbol{z})\\} = \\mathrm{Tr}\\{\\boldsymbol{P}^T \\boldsymbol{D} \\boldsymbol{P}\\} - \\dfrac{\\boldsymbol{\\beta}^T \\left(\\boldsymbol{A}^{-1}\\right)^T \\boldsymbol{D} \\boldsymbol{D} \\boldsymbol{A}^{-1}\\boldsymbol{\\beta}}{\\boldsymbol{\\beta}^T \\left(\\boldsymbol{A}^{-1}\\right)^T \\boldsymbol{D} \\boldsymbol{A}^{-1}\\boldsymbol{\\beta}} + 1 \\]  信息率的近似计算 首先将 \\(\\boldsymbol{D}\\)  展开：\n\\[ \\boldsymbol{D}=\\left(\\boldsymbol{I}-\\boldsymbol{P}\\boldsymbol{P}^T \\right)^{-1}=\\boldsymbol{I}+\\left(\\boldsymbol{P}\\boldsymbol{P}^T\\right)+\\left(\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\right)+\\left(\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\right)+\\dots \\]  进而有：\n\\[ \\begin{aligned} \\boldsymbol{P}^T \\boldsymbol{D} \\boldsymbol{P} \u0026= \\left(\\boldsymbol{P}^T \\boldsymbol{P}\\right) + \\left(\\boldsymbol{P}^T \\boldsymbol{P} \\boldsymbol{P}^T \\boldsymbol{P}\\right) + \\dots \\\\ \\boldsymbol{D} \\boldsymbol{D} \u0026=\\boldsymbol{I}+2 \\left(\\boldsymbol{P}\\boldsymbol{P}^T\\right)+3 \\left(\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\right)+4 \\left(\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\boldsymbol{P}\\boldsymbol{P}^T\\right)+\\dots \\end{aligned} \\]  投资中遇到的相关系数通常非常接近零（最乐观也不超过 \\(0.1\\)  ），所以：\n\\[ \\begin{aligned} \\boldsymbol{P}^T \\boldsymbol{D} \\boldsymbol{P} \\approx \\boldsymbol{P}^T \\boldsymbol{P} \\\\ \\boldsymbol{D} \\boldsymbol{D} \\approx \\boldsymbol{D} \\end{aligned} \\]  这种近似意味着：忽略已知信息 \\(z\\)  对方差的降低。进而有信息率的近似计算：\n\\[ \\mathrm{IR}^2 \\approx \\mathrm{Tr}\\{\\boldsymbol{P}^T \\boldsymbol{P}\\}=\\sum_{i,j}{\\rho_{i,j}^2} \\]  记 \\(\\xi_j^2=\\sum_i^N{\\rho_{i,j}^2}\\)  ，于是有(同时展示了基本定律的可加性)：\n\\[ \\mathrm{IR}^2=\\sum_j^{\\mathrm{BR}}{\\xi_j^2} \\]  根据假设，所有信号都具有相同的价值，即：\n\\[ \\xi_j^2=\\rho^2=\\mathrm{IC}^2 \\]  最后就得到主动管理基本定律：\n\\[ \\mathrm{IR}^2=\\mathrm{BR}\\ \\mathrm{IC}^2 \\]  其它 １）主动管理基本定律并非大数定律的投资学版本\n证明过程表明，基本定律近似成立源自独立信息源和驱动残差收益率的独立变量之间相关系数很小；而大数定律近似成立，则源于大样本数。\n类似的部分：更高的广度可充分分散残差风险；而大样本量可充分分散样本误差。\n２）根据模拟阿尔法信号产生的最优组合和后验信息率与基本定律给出的预测值在统计上无法区分。\n３）基本定律鼓励基金经理采用兼收并蓄的投资风格。\n"}),a.add({id:337,href:'/notes/tags/%E5%81%8F%E5%A5%BD/',title:"偏好",content:""}),a.add({id:338,href:'/notes/docs/apm/0021/',title:"第五章 残差风险和残差收益率：信息率",content:"阿尔法 向未来看（先验），阿尔法是对残差收益率的预测；向过去看（后验），阿尔法是实现的残差收益率的均值。\n阿尔法和贝塔都源自线性回归模型（见第2章笔记：超额收益率分解）。\n本章专注阿尔法的预测；第１２章将评估阿尔法预测的质量；第１７章考虑实现的阿尔法。\n向未来看时，阿尔法是对残差收益率的预测：\n  \\[ \\boldsymbol{\\alpha} = \\mathrm{E} \\boldsymbol{\\theta} \\]  组合P的阿尔法（即组合P对阿尔法的暴露度）：\n\\[ \\alpha_P = \\boldsymbol{\\alpha}^T \\boldsymbol{h}_P \\]  业绩基准组合的阿尔法必然等于零，这也就要求阿尔法向量必须满足这个约束： \\(\\alpha_B=0\\)  。\n无风险组合F（可用现金代称）的阿尔法也必然等于零，这意味着任何由业绩基准和现金构成的投资组合的阿尔法也必然等于零。\n阿尔法特征组合A 阿尔法向量的特征组合A将尽可能有效地发掘阿尔法向量中的信息。我们在第２章已经掌握了阿尔法向量及其特征组合Ａ的相关结论：\n\\[ \\begin{aligned} \\boldsymbol{h}_A = \\dfrac{\\boldsymbol{V}^{-1} \\boldsymbol{\\alpha}}{\\boldsymbol{\\alpha}^T \\boldsymbol{V}^{-1} \\boldsymbol{\\alpha}} \u0026 组合Ａ的头寸 \\\\ \\boldsymbol{\\alpha}^T h_A = \\alpha_A = 1 \u0026 组合Ａ具有单位阿尔法暴露度\\\\ \\sigma_A^2 = \\boldsymbol{h}_A^T \\boldsymbol{V} \\boldsymbol{h}_A = \\dfrac{1}{\\boldsymbol{\\alpha}^T \\boldsymbol{V}^{-1} \\boldsymbol{\\alpha}} \u0026 组合Ａ的方差 \\\\ \\boldsymbol{\\alpha} = \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_A}{\\sigma_A^2} \u0026 用组合Ａ对应的阿尔法向量 \\end{aligned} \\]  信息率 组合P的信息率 \\(\\mathrm{IR}_P\\)  ：\n\\[ \\mathrm{IR}_P = \\left\\{ \\begin{aligned} \\frac{\\alpha_P}{\\omega_P} , \\quad \u0026 \\omega_P  0 \\\\ 0, \\quad \u0026 \\omega_P = 0 \\end{aligned} \\right. \\]  (最大)信息率 \\(\\mathrm{IR}\\)  ：\n\\[ \\mathrm{IR} = \\underset{P}{\\max} \\ \\mathrm{IR}_P \\]  我们注意到，信息率和夏普率的概念很相似。前者关注残差收益率，而后者关注组合的预期超额收益率。\n与求最大夏普率的套路类似：有一组解(非唯一解)，特别地，这里求单位阿尔法值( \\(\\alpha_P=1\\)  )的最小残差风险的组合解，必然对应最大信息率。而最小残差风险对应最小风险（需要后续证明），所以组合A恰好具有最高信息率。\n组合Ａ的性质：\n１）组合Ａ的贝塔值为0（即，组合Ａ具有零贝塔暴露度）。因此组合Ａ通常同时具有多空头寸。\n【提示】因为业绩基准收益率和残差收益不相关，进而 \\(0=\\sigma_{AB} = \\beta_A \\sigma_B^2 = \\alpha_B \\sigma_A^2\\)  。\n２）组合Ａ具有最高的信息率： \\(\\mathrm{IR}= \\mathrm{IR}_A = \\sqrt{\\boldsymbol{\\alpha}^T \\boldsymbol{V}^{-1} \\boldsymbol{\\alpha}}\\ge \\mathrm{IR}_P, \\forall P\\)  。\n【提示】和\u0026quot;组合q具有最高夏普率\u0026quot;的论证本质一样。\n３）组合Ａ的总风险和残差风险都等于信息率的倒数： \\(\\sigma_A = \\omega_A = \\dfrac{1}{\\mathrm{IR}}\\)  。\n４）形如 \\(\\boldsymbol{h}_P = \\beta_P \\boldsymbol{h}_B + \\alpha_P \\boldsymbol{h}_A, \\quad \\alpha_P0\\)  的组合P都具有最高信息率。\n【提示】也和\u0026quot;组合q具有最高夏普率\u0026quot;的论证本质一样。\n５）组合Ｑ也可表示成： \\(\\boldsymbol{h}_Q = \\beta_Q \\boldsymbol{h}_B + \\alpha_Q \\boldsymbol{h}_A,\\quad \\beta_Q= \\dfrac{f_B \\sigma_Q^2}{f_Q \\sigma_B^2},\\quad \\alpha_Q=\\dfrac{\\sigma_Q^2}{f_Q \\omega_A^2}\\)  。因此组合Q和组合A的信息率相同。\n【提示】仅用第２章技术附录中的一系列关系易证。\n６）组合A在风险资产中的总持仓权重为： \\(e_A=\\dfrac{\\alpha_C \\omega_A^2}{\\sigma_C^2}\\)  。\n【提示】 \\(\\sigma_{CA}=e_A \\sigma_C^2=\\alpha_C \\sigma_A^2=\\alpha_C \\omega_A^2\\)  ７）任意组合P的信息率： \\(\\mathrm{IR}_P=\\mathrm{IR}_Q \\mathrm{Corr}\\{\\theta_P,\\theta_Q\\}\\)  。\n【提示】组合A具有零贝塔值；组合A和组合Q的残差收益率完全相关。\n８）最高信息率和最高夏普率的关系： \\(\\mathrm{IR}=\\dfrac{\\alpha_Q}{\\omega_Q}=\\mathrm{SR} \\dfrac{\\omega_Q}{\\sigma_Q}\\)  。\n【提示】用到：性质5；组合Q既是最高夏普率组合 \\(\\mathrm{SR}=\\dfrac{f_Q}{\\sigma_Q}\\)  ，组合Q也是最高信息率组合 \\(\\mathrm{IR}=\\dfrac{\\alpha_Q}{\\omega_Q}\\)  ；组合A也是最高信息率组合 \\(\\mathrm{IR}=\\dfrac{1}{\\omega_A}\\)  ； \\(\\omega_Q=\\alpha_Q \\omega_A\\)  。\n９）阿尔法可表示为： \\(\\boldsymbol{\\alpha}=\\mathrm{IR} \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_A}{\\omega_A}=\\mathrm{IR} \\ \\boldsymbol{M\\!C\\!R\\!R}_Q\\)  。此性质将资产的阿尔法值与该资产的残差风险边际贡献直接关联起来，关联系数正是信息率。\n【提示】用到：相关定义；特征组合A及其对应属性 \\(\\boldsymbol{\\alpha}\\)  的关系。\n１０）业绩基准的夏普率与最高夏普率和最高信息率之间的关系： \\(\\mathrm{SR}_B^2 = \\mathrm{SR}^2-\\mathrm{IR}^2\\)  。\n【提示】先推导出 \\(\\mathrm{SR}^2=\\boldsymbol{f}^T \\boldsymbol{V}^{-1}\\boldsymbol{f}\\)  ，然后带入 \\(\\boldsymbol{f}=\\boldsymbol{\\alpha}+\\boldsymbol{\\beta} \\ f_B\\)  。\n先验信息率：对机会的衡量 上一节关于信息率的定义是先验的。\n如果向未来看，组合信息率就是每承担一个单位年化残差风险所能获得的预期年化残差收益率（假设信息被有效利用）。而最大信息率则是投资经理能够获得的年化残差收益率与残差风险的比率。\n和夏普率的性质类似：相同的信息率，可能具有不同的残差收益率和残差风险，尽管其比值相等。所以：信息率不依赖于投资经理的激进程度。（实践中，这个论断最终由于投资约束的限制而不再成立。）\n信息率依赖时间尺度。为了避免混乱，统一使用1年作为时间尺度。根据预期收益率和风险的时间尺度换算容易推导出信息率时间尺度换算：\n\\[ \\mathrm{IR}_{年度} = \\sqrt{12} \\ \\mathrm{IR}_{月度} = \\sqrt{\\frac{1}{\\Delta t}} \\ \\mathrm{IR}_{\\Delta t} \\]  后验信息率：对业绩的衡量 后验证信息率，是（年化）实现残差收益率对（年化）实现残差风险的比值。在后验情况中，考虑的是某段历史时期的上实现的信息率。\n实现的信息可能（经常）是负值。\n第１７章关于“后验信息率”更多讨论的剧透：后验信息率和回归分析中的阿尔法的 \\(t\\)  统计量有关。如果回归分析所用数据的长度为Y年，那么：\n\\[ \\mathrm{IR} \\approx \\frac{t统计量}{\\sqrt{Y}} \\]  残差前沿：投资经理的机会集 信息率为主动投资经理定义了一条“预算约束”，其直观图像就是残差前沿：\n\\[ \\alpha_P = \\mathrm{IR} \\ \\omega_P \\]  残差前沿描述了主动投资经理的机会集。先验信息率决定了主动投资经理的残差前沿。残差前沿是通过原点和组合Ｑ的一条直线，业绩基准组合和无风险资产都落在原点上。\n偏好曲线：主动投资经理的目标函数 如果忽略了业绩基准择时，那么主动管理目标的是最大化残差收益率附加值：\n\\[ \\mathrm{IR}[P] = \\alpha_P - \\lambda_R \\omega_P^2 \\]  有时附加值也被称作：确定性等价收益率。\n最优投资组合的残差风险水平 信息率描述了主动投资经理可选机会集，主动投资经理需要在机会集中挑选附加值最大的那个投资组合：\n\\[ \\begin{aligned} \u0026 \\underset{P}{\\max} \\ \\{\\alpha_P - \\lambda_R \\omega_P^2\\} \\\\ s.t. \u0026 \\alpha_P = \\mathrm{IR}\\ \\omega_P \\end{aligned} \\]  解得最优残差风险水平：\n\\[ \\omega^*=\\dfrac{\\mathrm{IR}}{2 \\lambda_R} \\]  直观理解：最优投资组合 \\(P^*\\)  落在残差前沿和偏好曲线的切点处。\n最大附加值：风险调整残差收益率 前面得到最优残差风险，进而算出在可选机会集中最大的附加值：\n\\[ \\mathrm{VA}^* = \\mathrm{VA}[\\omega^*] = \\frac{\\mathrm{IR}^2}{4 \\lambda_R} = \\frac{\\omega^* \\mathrm{IR}}{2} \\]  因此，投资经理的信息率决定了他创造附加值的潜力。\n信息率是主动管理的关键。\n最优投资组合 用组合头寸重新表示附加值优化问题：\n\\[ \\mathrm{VA} = \\underset{\\boldsymbol{h}_P}{\\max} \\ \\{ \\boldsymbol{\\alpha}^T \\boldsymbol{h}_P - \\lambda_R \\boldsymbol{h}_P^T \\boldsymbol{V\\!R} \\ \\boldsymbol{h}_P \\} \\]  此优化问题的的最优解：\n\\[ \\begin{aligned} \\boldsymbol{h}_P \u0026= \\dfrac{1}{2 \\lambda_R} \\boldsymbol{V\\!R}^{-1} \\alpha = \\dfrac{1}{2 \\lambda_R} (\\boldsymbol{V}-\\sigma_B^2 \\boldsymbol{\\beta} \\ \\boldsymbol{\\beta}^T)^{-1} \\alpha \\\\ \u0026= \\beta_P \\boldsymbol{h}_B + \\dfrac{\\mathrm{IR}^2}{2 \\lambda_R} \\boldsymbol{h}_A \\quad (此为最优头寸的变形分解) \\end{aligned} \\]  由此可见，组合A是寻找最优残差头寸的关键。\n【特别说明】我们发现最优解的分解式中，如果将 \\(\\beta_P\\)  理解成任意常数，都不影响最优附加值。这是因为一旦任意选定 \\(\\beta_P=\\boldsymbol{\\beta}^T \\boldsymbol{h}_P\\)  ，而最优解 \\(\\boldsymbol{h}_P\\)  是确定的，进而可以反过来选择某个业绩基准组合 \\(\\boldsymbol{h}_B\\)  （非唯一选择）。其中的关键是：最优解 \\(\\boldsymbol{h}_P\\)  是确定。这意味着，最优附加值也是确定的，而不受 \\(\\beta_P\\)  选择的影响， \\(\\beta_P\\)  的不同选择，影响的仅仅是业绩基准组合的选择。但是一旦确定了业绩基准组合B， 组合A就为附加值提供完全的贡献，而业绩基准组合B对附加值就毫无贡献。\n单位贝塔值有效前沿 第２章附录中提及的有效前沿，全称是全额投资有效前沿。类似地，给定预期收益率的，具有单位贝塔值的最小风险组合，被称作单位贝塔有效前沿。\n基于单位贝塔的约束，推导出单位贝塔有效前沿的收益率/方差方程，要比第２章推导全额投资有效前沿的收益率/方差方程容易的多。因为我们很容易列出如下关系：\n\\[ \\begin{aligned} \\sigma_P^2 = \\sigma_B^2 + \\omega_P^2 \\\\ f_P = f_B + \\alpha_P \\\\ \\omega_P^2 = \\dfrac{\\alpha_P^2}{\\mathrm{IR}^2} \\end{aligned} \\]  其中，业绩基准组合B就是单位贝塔值组合中风险最小的组合，必然落在单位贝塔有效前沿曲线上。第３个等式，如果你认真解这个单位贝塔有效前沿的优化化问题，会发现单位贝塔有效前沿上的任何组合P都可写成业绩基准组合B和组合A的线性表示，进而说明单位贝塔有效前沿上的所有组合都具有最高信息率。\n根据上述三个关系，立刻可写出单位贝塔有效前沿的收益率/方差方程：\n\\[ \\sigma_P^2 = \\sigma_B^2 + \\frac{1}{\\mathrm{IR}^2} (f_P-f_B)^2 \\]  主动头寸组合Y：无主动现金并无主动贝塔  组合C的残差组合CR：  \\[ \\boldsymbol{h}_{\\mathrm{CR}}=\\boldsymbol{h}_C-\\beta_C \\boldsymbol{h}_B \\]   主动头寸组合Y：  \\[ \\boldsymbol{h}_Y=\\frac{\\boldsymbol{h}_A}{\\omega_A}-\\frac{\\mathrm{IR}_C}{\\mathrm{IR}} \\frac{\\boldsymbol{h}_{\\mathrm{CR}}}{\\omega_C} \\]   组合Y的性质： 组合Y的贝塔值等于0，即 \\(\\beta_Y=0\\)  ； 组合Y的总方差和残差方差： \\(\\sigma_Y^2=\\omega_Y^2=1-\\left (\\dfrac{\\mathrm{IR}_C}{\\mathrm{IR}} \\right )^2\\)  ； 组合Y的阿尔法值为： \\(\\alpha_Y = \\mathrm{IR} \\left[ 1-\\left (\\dfrac{\\mathrm{IR}_C}{\\mathrm{IR}} \\right )^2 \\right]\\)  ； 组合Y的现金头寸为零，即 \\(e_Y=0\\)  ； 组合Y的信息率为： \\(\\mathrm{IR}_Y= \\mathrm{IR} \\sqrt{ 1-\\left (\\dfrac{\\mathrm{IR}_C}{\\mathrm{IR}} \\right )^2 }=\\mathrm{IR} \\sqrt{ 1- Corr^2\\{\\theta_Q,\\theta_C\\}}\\)  。  最优无主动贝塔且无主动现金组合 考虑在无主动现金和无主动贝塔的约束下的一个组合优化问题：\n\\[ \\begin{aligned} \u0026\\underset{\\boldsymbol{h}_P}{\\max} \\ \\{ \\alpha^T \\boldsymbol{h}_P - \\lambda_R \\boldsymbol{h}_P^T \\ \\boldsymbol{V\\!R} \\ \\boldsymbol{h}_P\\} \\\\ s.t. \u0026 \\boldsymbol{\\beta}^T \\boldsymbol{h}_P = 1 \\quad (无主动贝塔)\\\\ \u0026 \\boldsymbol{e}^T \\boldsymbol{h}_P = e_B \\quad (无主动现金) \\end{aligned} \\]  根据第１个约束条件，及其推论 \\(\\boldsymbol{h}_P=\\boldsymbol{h}_B+\\boldsymbol{h}_{\\mathrm{PR}}\\)  ，上述优化问题可重写成：\n\\[ \\begin{aligned} \u0026\\underset{\\boldsymbol{h}_{\\mathrm{PR}}}{\\max} \\ \\{ \\alpha^T \\boldsymbol{h}_{\\mathrm{PR}} - \\lambda_R \\boldsymbol{h}_{\\mathrm{PR}}^T \\ \\boldsymbol{V} \\ \\boldsymbol{h}_{\\mathrm{PR}}\\} \\\\ s.t. \u0026 \\boldsymbol{\\beta}^T \\boldsymbol{h}_{\\mathrm{PR}} = 0, \\quad \\boldsymbol{e}^T \\boldsymbol{h}_{\\mathrm{PR}} = 0 \\end{aligned} \\]  利用拉格朗日乘子法，并结合组合A、组合B和组合C的定义，以及之间的关系，可求得最优解：\n\\[ \\begin{aligned} \\boldsymbol{h}_{\\mathrm{PR}} = \\dfrac{\\mathrm{IR}^2}{2 \\lambda_R} \\boldsymbol{h}_A + \\phi \\ \\boldsymbol{h}_B + \\pi \\ \\boldsymbol{h}_C \\\\ \\pi = \\dfrac{- \\alpha_C}{2 \\ \\lambda_R \\ \\omega_C^2} \\\\ \\phi = - \\pi \\ \\beta_C \\end{aligned} \\]  回代并整理得：\n\\[ \\begin{aligned} \\boldsymbol{h}_{\\mathrm{PR}} \u0026= \\dfrac{\\mathrm{IR}}{2 \\lambda_R} (\\dfrac{\\boldsymbol{h}_A}{\\omega_A}-\\dfrac{\\mathrm{IR}_C}{\\mathrm{IR}}\\dfrac{\\boldsymbol{h}_C-\\beta_C \\boldsymbol{h}_B}{\\omega_C}) \\\\ \u0026\\overset{\\Delta}{=} \\dfrac{\\mathrm{IR}}{2 \\lambda_R} (\\dfrac{\\boldsymbol{h}_A}{\\omega_A}-\\dfrac{\\mathrm{IR}_C}{\\mathrm{IR}}\\dfrac{\\boldsymbol{h}_{\\mathrm{CR}}}{\\omega_C}) \\\\ \u0026\\overset{\\Delta}{=} \\dfrac{\\mathrm{IR}}{2 \\lambda_R} \\boldsymbol{h}_Y \\end{aligned} \\]  由此可见，组合Y与寻找最优无主动贝塔且无主动现金的组合密切相关。\n"}),a.add({id:339,href:'/notes/tags/%E8%B4%9D%E5%A1%94/',title:"贝塔",content:""}),a.add({id:340,href:'/notes/tags/%E9%98%BF%E5%B0%94%E6%B3%95/',title:"阿尔法",content:""}),a.add({id:341,href:'/notes/tags/capm/',title:"capm",content:""}),a.add({id:342,href:'/notes/tags/%E4%B8%9A%E7%BB%A9%E5%9F%BA%E5%87%86/',title:"业绩基准",content:""}),a.add({id:343,href:'/notes/tags/%E6%94%B6%E7%9B%8A/',title:"收益",content:""}),a.add({id:344,href:'/notes/docs/apm/0020/',title:"第四章 超常收益率、业绩基准和附加值",content:"CAPM提供一致预期收益率，多因子模型可以帮助控制风险。本章讨论如何进行预期收益率的预测，并概述如何将预测转化成投资组合。\n业绩基准 业绩基准组合的别称：标杆、规范组合。业绩基准组合是投资管理机构化的产物。\n弃用市场组合，转而使用业绩基准组合。 在新的分析框架下，贝塔、残差风险都是相对某个业绩基准组合而言。\n主动头寸是组合头寸与业绩基准头寸之差：\n  \\[ \\boldsymbol{h}_{P\\!B} = \\boldsymbol{h}_P - \\boldsymbol{h}_B \\]  主动方差则是主动头寸收益率的方差：\n\\[ \\psi_P^2 = \\boldsymbol{h}_{P\\!B}^T \\boldsymbol{V} \\ \\boldsymbol{h}_{P\\!B} = \\sigma_P^2 + \\sigma_B^2 - 2 \\sigma_{P,B} \\]  如果我们使用相对业绩基准的贝塔和相对业绩基准的残差收益率，即：\n\\[ \\boldsymbol{r}_P = \\boldsymbol{\\beta} \\ r_B + \\boldsymbol{\\theta}_P \\]  那么主动方差可以改写成：\n\\[ \\psi_P^2 = \\beta_{P\\!B}^2 \\sigma_B^2 + \\omega_P^2 \\]  其中， \\(\\beta_{P\\!B}\\)  是主动贝塔（即 \\(\\beta_P-1\\)  ）， \\(\\omega_P\\)  是残差风险。\n选择业绩基准将有助于把预期收益率分解成不同的组成部分。\n预期收益率的组成 预期收益率的预测值可分解为四个部分：无风险部分（时间溢价）、业绩基准部分（风险溢价）、基准择时部分（超常业绩基准收益率）、阿尔法部分（预期残差收益率）。设 \\(\\boldsymbol{R}=(R_1,\\dots,R_N)^T\\)  代表资产的总收益率向量，那么：\n\\[ \\mathrm{E} \\boldsymbol{R} = \\boldsymbol{i}_F + \\boldsymbol{\\beta} \\ \\mu_B + \\boldsymbol{\\beta} \\ \\mathrm{\\Delta}f_B + \\boldsymbol{\\alpha} \\]   时间溢价 \\(\\boldsymbol{i}_F\\)  投资者放弃其它投资一年所获得的回报。可以事先确定时间溢价。 风险溢价 \\(\\boldsymbol{\\beta} \\ \\mu_B\\)  其中 \\(\\mu_B\\)  是业绩基准的预期超额收益率，估计的方法之一：用极长期（７０年以上）平均值。 超常业绩基准收益率 \\(\\boldsymbol{\\beta} \\ \\mathrm{\\Delta}f_B\\)  其中 \\(\\mathrm{\\Delta}f_B\\)  衡量了业绩基准在临近的未来时期上的预期超额收益率与长期预期超额收益率之差。 阿尔法 \\(\\boldsymbol{\\alpha}\\)  预期残差收益率 \\(\\boldsymbol{\\alpha}=\\mathrm{E} \\boldsymbol{\\theta}\\)    上述四个部分的几种常用组合：\n 一致预期超额收益率 \\(\\boldsymbol{\\beta} \\ \\mu_B\\)   预期超额收益率 \\(\\boldsymbol{f}=\\boldsymbol{\\beta} \\ \\mu_B + \\boldsymbol{\\beta} \\ \\mathrm{\\Delta}f_B + \\boldsymbol{\\alpha}\\)   预期超常收益率 \\(\\boldsymbol{\\beta} \\ \\mathrm{\\Delta}f_B + \\boldsymbol{\\alpha}\\)  主动管理的关键。第一项衡量了基准择时收益，第二项衡量了选股收益。  管理总风险和总收益率  预期超额收益率的一致预测：  \\[ \\boldsymbol{\\mu} = \\boldsymbol{\\beta} \\ \\mu_B \\]  此时，具有最高夏普率的全额投资组合就是业绩基准B。\n 预测超额收益率的主动管理预测：  \\[ \\boldsymbol{f} = \\boldsymbol{\\beta} \\ f_B + \\boldsymbol{\\alpha} \\]  此时，具有最高夏普率的全额投资组合就是组合Q（就是第２章技术附录中的组合Ｑ）。业绩基准Ｂ不在有效前沿上，存在战胜组合Ｂ的机会，那就是组合Q。 \\(\\boldsymbol{f}\\)  偏离一致预测的程度由 \\(f_B\\)  偏离一致预测 \\(\\mu_B\\)  的程度和 \\(\\alpha\\)  偏离0的程度决定。\n 总收益率/总风险权衡  这种权衡就是使用传统的均值/方差目标函数来指导组合挑选，这种权衡标准称为预期效用，表示为 \\(U[P]\\)  ，定义为：\n\\[ U[P] = f_P - \\lambda_T \\sigma_P^2 \\]  其中，等号右边第一项是预期超额收益率，第二项是风险惩罚项，参数 \\(\\lambda_T\\)  衡量了对总风险的厌恶程度。这里的总风险包括系统性风险（源自业绩基准）和残差风险（源自资产选择）。\n剩下的任务就是求解一个优化问题：\n\\[ \\underset{P}{\\max} \\ U[P] \\]  再求解这个优化问题前，还需要确定 \\(\\lambda_T\\)  。不妨合理假设在如下两种情况下的优化问题具有相同的参数 \\(\\lambda_T\\)  ：\n１）允许组合中持有现金，那么有效前沿将由无风险组合F到组合Q的直线段构成，即：\n\\[ \\begin{aligned} f_P = \\beta_P f_B \\\\ \\sigma_P^2 = \\beta_P^2 \\sigma_B^2 \\end{aligned} \\]  于是优化问题变成：\n\\[ \\underset{\\beta_P}{\\max} \\ \\{ \\beta_P \\ f_B - \\lambda_T \\beta_P^2 \\sigma_B^2 \\} \\]   \\(\\beta_P\\)  最优解是：\n\\[ \\beta_P=\\dfrac{f_B}{2 \\lambda_T \\sigma_B^2} \\]  ２）并且，没有额外信息（ \\(\\boldsymbol{f}=\\boldsymbol{\\mu},\\ \\ \\beta_P=1\\)  ），进而获得 \\(\\lambda_T\\)  的一个合理表达式：\n\\[ \\lambda_T=\\frac{\\mu_B}{2 \\sigma_B^2} \\]  进而 \\(\\beta_P\\)  最优解可改写成：\n\\[ \\beta_P=1+ \\frac{\\mathrm{\\Delta}f_B}{\\mu_B} \\]  其中 \\(\\mathrm{\\Delta}f_B=f_B-\\mu_B\\)  被称作超常业绩基准收益率的预测。\n一旦确定了参数 \\(\\lambda_T\\)  ，就可回过头求解目标优化问题：\n\\[ \\begin{aligned} \u0026 \\underset{P}{\\max} \\ U[P] \\\\ \u0026 = \\underset{\\boldsymbol{h}_P}{\\max} \\ \\{ \\boldsymbol{f}^T \\boldsymbol{h}_P - \\lambda_T \\boldsymbol{h}_P^T \\boldsymbol{V} \\boldsymbol{h}_P \\} \\end{aligned} \\]  头寸 \\(\\boldsymbol{h}_P\\)  最优解是：\n\\[ \\begin{aligned} \\boldsymbol{h}_P \u0026= \\dfrac{1}{2 \\lambda_T} \\boldsymbol{V}^{-1} \\boldsymbol{f} \\\\ \u0026= \\dfrac{1}{2 \\lambda_T \\sigma_q^2} \\boldsymbol{h}_q = \\dfrac{e_q}{2 \\lambda_T \\sigma_q^2} \\boldsymbol{h}_Q \\\\ \u0026= \\dfrac{f_Q}{2 \\lambda_T \\sigma_Q^2} \\boldsymbol{h}_Q \\end{aligned} \\]  如果将超额收益率分解成系统部分和残差部分，那么头寸 \\(\\boldsymbol{h}_P\\)  最优解可改写成：\n\\[ \\begin{aligned} \\boldsymbol{h}_P \u0026= \\dfrac{f_B}{2 \\lambda_T} \\boldsymbol{V}^{-1} \\boldsymbol{\\beta} + \\dfrac{1}{2 \\lambda_T} \\boldsymbol{V}^{-1} \\boldsymbol{\\alpha} \\\\ \u0026= \\dfrac{f_B}{2 \\lambda_T \\sigma_B^2} \\boldsymbol{h}_B + \\dfrac{1}{2 \\lambda_T \\sigma_A^2} \\boldsymbol{h}_A \\\\ \u0026= \\beta_P \\boldsymbol{h}_B + \\dfrac{1}{2 \\lambda_T \\sigma_A^2} \\boldsymbol{h}_A \\overset{\\Delta}{=} \\beta_P \\boldsymbol{h}_B + \\dfrac{\\mathrm{IR}}{2 \\lambda_T} \\boldsymbol{h}_A \\end{aligned} \\]  其中 \\(\\mathrm{IR}\\)  ，是第５章将要讨论的信息率：预期残差收益率与残差风险的比值（形式上类似“夏普率”的概念）。\n在总风险/总收益率分析框架下，较低水平的信息也会导致很高水平的残差风险。\n效用函数的分解  组合持仓权重 \\(\\boldsymbol{h}_P\\)  的分解：  \\[ \\boldsymbol{h}_P = \\beta_P \\boldsymbol{h}_B + \\boldsymbol{h}_{\\mathrm{PR}} \\]  其中， \\(\\boldsymbol{h}_{\\mathrm{PR}}\\)  被称作残差头寸。\n 超额收益率预测 \\(f\\)  的分解：  \\[ \\begin{aligned} f_P \u0026= \\beta_P f_B + \\alpha_P \\\\ \u0026= f_B + \\beta_{\\mathrm{PB}} f_B + \\alpha_P \\\\ \u0026= f_B + \\beta_{\\mathrm{PB}} \\mu_B + \\beta_{\\mathrm{PB}} \\mathrm{\\Delta} f_B + \\alpha_P \\end{aligned} \\]  其中：\n  \\(f_B\\)  ，预期业绩基准超额收益率；  \\(\\beta_{\\mathrm{PB}} \\mu_B\\)  ，主动贝塔 \\(\\times\\)  一致预期产生的收益率；  \\(\\beta_{\\mathrm{PB}} \\mathrm{\\Delta} f_B\\)  ，主动贝塔 \\(\\times\\)  超常预测产生的收益率；  \\(\\alpha_P\\)  ，股票阿尔法，即选股产生的收益率。 组合方差 \\(\\sigma_P^2\\)  的分解：  \\[ \\begin{aligned} \\sigma_P^2 \u0026= \\beta_P^2 \\sigma_B^2 + \\omega_P^2 \\\\ \u0026= (1+\\beta_{\\mathrm{PB}})^2 \\sigma_B^2 + \\omega_P^2 \\\\ \u0026= \\sigma_B^2 + 2 \\beta_{\\mathrm{PB}} \\sigma_B^2 + \\beta_{\\mathrm{PB}}^2 \\sigma_B^2 + \\omega_P^2 \\end{aligned} \\]  其中：\n  \\(\\sigma_B^2\\)  ，业绩基准方差；  \\(2 \\beta_{\\mathrm{PB}} \\sigma_B^2\\)  ，主动贝塔产生的协方差；  \\(\\beta_{\\mathrm{PB}}^2 \\sigma_B^2\\)  ，主动贝塔产生的方差；  \\(\\omega_P^2\\)  ，选股产生的方差。 效用函数一般形式的分解(第二个等号右边第３和４项分别 \\(\\lambda_{\\mathrm{BT}},\\lambda_R\\)  用分别代替 \\(\\lambda_T\\)  )：  \\[ \\begin{aligned} U[P] \u0026= f_P - \\lambda_T \\sigma_P^2 \\\\ \u0026= (f_B - \\lambda_T \\sigma_B^2) + \\beta_{\\mathrm{PB}} (\\mu_B - 2 \\lambda_T \\sigma_B^2) + (\\beta_{\\mathrm{PB}} \\mathrm{\\Delta} f_B - \\lambda_{\\mathrm{BT}} \\beta_{\\mathrm{PB}}^2 \\sigma_B^2) + (\\alpha_P - \\lambda_R \\omega_P^2) \\end{aligned} \\]  其中：\n  \\(f_B - \\lambda_T \\sigma_B^2\\)  ，业绩基准部分，纯粹的预测，与投资行为无关（不影响最优组合）；  \\(\\beta_{\\mathrm{PB}} (\\mu_B - 2 \\lambda_T \\sigma_B^2 )\\)  ，交叉项，与投资行为相关，但没有预测；  \\(\\beta_{\\mathrm{PB}} \\mathrm{\\Delta} f_B - \\lambda_{\\mathrm{BT}} \\beta_{\\mathrm{PB}}^2 \\sigma_B^2\\)  ，业绩基准择时，既包含预测，也与投资行为相关；  \\(\\alpha_P - \\lambda_R \\omega_P^2\\)  ，选股，，既包含预测，也与投资行为相关。  容易证明，无论 \\(\\beta_{\\mathrm{PB}}\\)  如何选择，第二项都为0。于是效用函数可精确该写成：\n\\[ U[P] = (f_B - \\lambda_T \\sigma_B^2) +(\\beta_{\\mathrm{PB}} \\mathrm{\\Delta} f_B - \\lambda_{\\mathrm{BT}} \\beta_{\\mathrm{PB}}^2 \\sigma_B^2) + (\\alpha_P - \\lambda_R \\omega_P^2) \\]  聚焦于附加值 再次观察目标效用函数的分解式：将风险和收益率拆分成三个部分：\n 内蕴部分， \\(f_B-\\lambda_T \\sigma_B\\)  。这部分不在投资经理的掌控范围内。 \\(\\lambda_T\\)  是对总风险厌恶系数。 择时部分， \\(\\beta_{\\mathrm{PB}} \\mathrm{\\Delta}f_B-\\lambda_{\\mathrm{BT}} \\beta_{\\mathrm{PB}^2} \\sigma_B^2\\)  。它由投资经理主动贝塔决定。 \\(\\lambda_{\\mathrm{BT}}\\)  是对业绩基准择时风险恶系数。 残差部分， \\(\\alpha_P - \\lambda_R \\omega_P^2\\)  。它有投资经理的残差头寸产生。 \\(\\lambda_R\\)  是对残差风险恶系数。  其中内蕴部分如果确定了业绩基准组合和对总风险厌恶系数，那么是一个常数。所以后面两部分之和才与衡量了投资经理增加价值的能力有关，称之为附加值：\n\\[ \\mathrm{V\\!A} = (\\beta_{\\mathrm{PB}} \\mathrm{\\Delta}f_B-\\lambda_{\\mathrm{BT}} \\beta_{\\mathrm{PB}^2} \\sigma_B^2) + (\\alpha_P - \\lambda_R \\omega_P^2) \\]  附加值是一种风险调整预期收益率，忽略了业绩基准对风险和预期收益率的贡献。\n业绩基准择时 业绩基准择时是指逐个时期选择合适的贝塔。\n主动贝塔的最优水平（以 \\(\\mathrm{VA}\\)  第一部分最大为目标）：\n\\[ \\beta_{\\mathrm{PB}} = \\frac{\\mathrm{\\Delta}f_B}{2 \\lambda_{\\mathrm{BT}} \\sigma_B^2} \\]  非常高的业绩基准择时风险厌恶系数，或不进行业绩基准择时，都使得主动贝塔为0。\n\u0026ldquo;主动管理基本定律\u0026quot;告诉我们：通过业绩基准择时产生显著附加值的机会较少。\n主动收益率与残差收益率 主动收益率和风险：\n\\[ \\begin{aligned} r_{\\mathrm{PB}} = r_P - r_B = \\theta_P + \\beta_{\\mathrm{PB}} r_B \\\\ \\psi_P = \\mathrm{std}\\{r_{\\mathrm{PB}}\\} = \\sqrt{\\omega_P^2 + \\beta_{\\mathrm{PB}}^2 \\sigma_B^2 } \\end{aligned} \\]  特别地，如果不进行业绩基准择时，则有 \\(\\beta_P=1,\\ \\beta_{\\mathrm{PB}}=\\beta_P-1=0\\)  ，进而主动收益率和风险就等于残差收益率和风险。\n"}),a.add({id:345,href:'/notes/tags/%E5%A4%9A%E5%9B%A0%E5%AD%90/',title:"多因子",content:""}),a.add({id:346,href:'/notes/tags/%E6%A0%87%E5%87%86%E5%B7%AE/',title:"标准差",content:""}),a.add({id:347,href:'/notes/docs/apm/0019/',title:"第三章 风险",content:"标准差 书中介绍了风险的各种定义及其优劣，最终还是选择标准差作为本书的风险定义。\n尽管标准差具有某些不足，只要我的假设中依赖或近似依赖正态分布，那么推荐标准差这个风险度量定义。因为它能满足我们普适，对称，灵活和可精确预测的要求。若无特殊要求，我们讨论的风险总是指收益率的年化标准差（以百分之一为单位）。\n投资组合   \\(r_P=\\sum_i{w_i r_i}\\)  的标准差：\n\\[ \\begin{aligned} \\sigma_P \u0026 =\\sqrt{\\sum_{i,j}{\\rho_{i,j}(w_i \\sigma_i)(w_j \\sigma_j)}} \\\\ \u0026 \\le \\sqrt{(\\sum_i{w_i \\sigma_i})^2} \\\\ \u0026 = \\sum_i{w_i \\sigma_i} \\end{aligned} \\]  这意味着：整体风险小于部分风险之和－－这是投资组合分散化的关键。\n特例1，考虑等权重股票组合( \\(w_i=\\frac{1}{N}\\)  )，股票之间互不相关( \\(\\rho_{i,j}=\\delta_{i,j}\\)  )，每只股票的风险都是 \\(\\sigma_i=\\sigma\\)  ，那么：\n\\[ \\begin{aligned} \\sigma_P \u0026 = \\sqrt{\\sum_{i,j}{\\delta_{i,j}(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)}} = \\sqrt{\\sum_{i}{(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)}} \\\\ \u0026 = \\sqrt{N(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)} \\\\ \u0026 = \\dfrac{\\sigma}{\\sqrt{N}} \\end{aligned} \\]  从这个结果也能看出分散化的威力。\n特例2，考虑等权重股票组合( \\(w_i=\\frac{1}{N}\\)  )，任意两个不同股票的相关系数相同( \\(\\rho_{i,j}=\\rho, i \\ne j\\)  )，每只股票的风险都是 \\(\\sigma_i=\\sigma\\)  ，那么：\n\\[ \\begin{aligned} \\sigma_P \u0026 = \\sqrt{\\sum_{i,j}{\\rho_{i,j}(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)}} = \\sqrt{\\sum_{i}{(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)} + \\sum_{i \\ne j}{\\rho(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)}} \\\\ \u0026 = \\sqrt{N(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma) +(N^2-N) \\rho(\\frac{1}{N} \\sigma)(\\frac{1}{N} \\sigma)} \\\\ \u0026 = \\sigma \\sqrt{ \\frac{1 + \\rho (N-1)}{N}} \\quad \\overset{N \\rightarrow \\infty}{\\longrightarrow} \\quad \\sigma \\sqrt{\\rho} \\end{aligned} \\]  利用这个公式可以反算出，股票之间的平均相关系数。\n风险既不能沿横截面也不能沿时间相加。然而，如果任何不重叠的两个时间段上的收益率不相关（自相关性等于0），那么方差可以沿时间相加。 这意味着方差随预测期的长度而增加，风险则随预期长度的平方根增加。于是，年化风险和月度风险有如下关系：\n\\[ \\sigma_{年度} =\\sqrt{12} \\sigma_{月度}=\\sqrt{\\frac{1}{\\Delta t}} \\ \\sigma_{\\Delta t}, \\quad \\Delta t以年为单位 \\]  主动收益率就是投资组合超额收益率 \\(r_P\\)  与业绩基准超额收益率 \\(r_B\\)  的差，记作 \\(r_{PB}\\)  。相应的主动风险为主动收益率的标准差，记作 \\(\\psi_P\\)  。有时也称主动风险为跟踪误差。\n很多投资者认为：资产的主动风险与其市值成比例**【不妨作为一个经验定律】**。\n残差风险就是收益率中与系统收益率正交的那部分的风险。组合P关于组合B的残差风险用表示 \\(\\omega_P\\)  ：\n\\[ \\begin{aligned} \\omega_P \u0026 = \\sqrt{\\sigma_P^2-\\beta_P^2 \\sigma_B^2} \\\\ \\beta_P \u0026 = \\dfrac{\\mathrm{Cov}\\{r_P,r_B\\}}{\\mathrm{Var}\\{r_B\\}} \\end{aligned} \\]  基本的风险模型 为了确定投资组合的风险，必须知道组合中任意两个资产超额收益率协方差组成的协方差矩阵。风险模型的目标就是要精确并高效地预测这个协方差矩阵。\n 单因子模型  单因子风险模型将收益率分解成：\n\\[ r_i = \\beta_i r_M + \\theta_i \\]  并且假设残差收益率 \\(\\theta_i\\)  是互不相关的，因此有：\n\\[ \\begin{aligned} \\mathrm{Cov}\\{r_i,r_j\\} = \\beta_i \\beta_j \\sigma_M \\\\ \\sigma_i^2 = \\beta_i^2 \\sigma_M^2 + \\omega_i^2 \\end{aligned} \\]  当然这个假设肯定是不对的，至少市场上所有股票的残差收益率的市值加权平均值应该精确等于0：\n\\[ \\boldsymbol{\\theta}^T \\boldsymbol{h}_M = \\sum_i{h_{M,i} \\theta_i}=0 \\]  尽管单因子模型的假设有瑕疵，但依旧很有吸引力，因为它分离的市场风险和残差风险，并将股票之间的残差协方差保守估计为0。\n 等相关系数模型  根据等相关系数这个简单假设可以直接写出协方差表达式：\n\\[ \\mathrm{Cov}\\{r_i,r_j\\} = \\sigma_i \\sigma_j \\rho \\]   历史样本模型  用这个模型估计既不稳健也不合理。在该模型下，要用 \\(T\\)  个时期的样本来估计一个 \\(N\\times N\\)  协方差矩阵，并且要求 \\(T \\gt N\\)  。这个模型存在的问题：\n 只能考虑较短时间尺度上的收益率； 历史风险不能快速反应公司不断变化的基本面； 有选择偏差； 样本偏差将导致协方差估计上的某些整体偏差。  结构化风险模型－－多因子风险模型  基本想法  股票的收益率可以被一组共同因子和一个仅与该股票的特异因子解释。通过识别出重要因子，可以降低问题的规模。\n 对收益率进行简单的线性分解  \\[ \\boldsymbol{r}(t) = \\boldsymbol{X}(t) \\boldsymbol{b}(t) + \\boldsymbol{u}(t) \\]  式中：\n\\[ \\begin{aligned} \\boldsymbol{r} = (r_1,\\dots,r_N)^T \\quad r_i(t)表示资产i从时刻t \\rightarrow t+1的\\mathbf{超额收益率} \\\\ \\boldsymbol{X} = (X_{i,j})_{N \\times K} \\quad X_{i,j}(t)表示时刻t资产i对因子k的\\mathbf{暴露度}(\\mathbf{因子载荷}) \\\\ d \\boldsymbol{b} = (b_1,\\dots,b_K)^T \\quad b_j(t)表示因子j从时刻t \\rightarrow t+1的\\mathbf{因子收益率} \\\\ \\boldsymbol{u} = (u_1,\\dots,u_N)^T \\quad u_i(t)表示资产i从时刻t \\rightarrow t+1的\\mathbf{特异收益率} \\end{aligned} \\]   假设特异收益率和因子收益率不相关，不同股票的特异收益率也不相关，于是整个市场的风险结构可表示为：  \\[ \\boldsymbol{V} = \\boldsymbol{X} \\boldsymbol{F} \\boldsymbol{X}^T + \\Delta \\]  式中：\n\\[ \\begin{aligned} \\boldsymbol{V} = (V_{i,j})_{N \\times N} \\quad V_{i,j}表示资产i和资产j的超额收益率协方差 \\\\ \\boldsymbol{F} = (F_{i,j})_{K \\times K} \\quad F_{i,k}表示因子i和因子j的因子收益率协方差 \\\\ \\boldsymbol{\\Delta} = (\\Delta_{i,j})_{N \\times N} \\quad \\Delta_{i,i}表示资产i特异收益率方差，\\Delta_{i,j}=0,i\\ne j \\end{aligned} \\]  挑选因子 建立多因子模型的艺术在于挑选何时的一组因子，所有的因子必须是先验因子（即因子暴露必须在考察期初确定）。\n 宏观因子  比如：债券贝塔（债券市场收益率），通胀异动，油价变动，汇率变动，工业产量变动等。\n宏观因子解释能力强，但有三个严重缺陷：\n 有严重的估计误差； 估计的结果仅仅是历史行为，不能反应现在的情况； 数据源自政府采集，不能从市场中观察到，并且质量不佳。 横截面比较因子  一般由分为两类：基本面类和市场类。\n基本面类包括各种比率例如分红率，盈利率以及分析师对未来每股盈利的预测。市场类包括过去某段时间的上的波动率，收益率，期权的隐含波动率，换手率等等。\n注意，市场类因子也有宏观因子类似的缺陷，尽管如此，根据经验，这些横截面比较因子还是非常有效的。\n 统计因子  \u0026ldquo;统计绞肉机\u0026rdquo;\n 因子选用的原则   有区分能力； 直观； 有意义。  我们通过研究来挑选合适的因子，合格过程依赖于统计技术和投资直觉。统计技术帮助我们选出具有区分能力和解释力的因子；投资直觉帮助我们选出具有直观含义的因子。因子必须具有统计显著性和投资显著性中至少一种。\n我们选用的因子主要包括两类：行业因子和风险指数。其中，风险指数衡量行业之外的维度上不同股票群之间的行为差异。\n行业因子 行业分类应该满足以下几个原则：\n 每个行业都应该包括合理数目的公司； 每个行业在全市场中都应该占用合理的市值比例； 行业划分应该符合市场共识及投资者心理习惯。  美国股市行业划分书中有列表；中国股市行业列表见我的聚宽投资研究中的“行业因子”。\n行业暴露通常是0/1变量。市场组合对全部行业因子的暴露度之和为1。由于大型公司可能在多个行业运作，所以有时需要对行业因子进行扩展。\n风险指数 股市中可识别的风险指数可归为以下几个类别：\n 波动率　历史上具有较高的波动率，我们也预期其未来也具有较高波动率； 动能　近期表现； 规模　市值； 流动性　交易量； 价值　基本面：市盈率、分红率、市现率、市净率、市销率，等等； 盈利波动率　盈利的波动性； 财务杠杆　债务股本比率、对利率风险的暴露度。  每个风险指数都包含若干度量变量，称之为描述变量。同一风险指数下的描述变量之间通常的高度相关，但又有所不同，各自代表该风险指数的某个方面。股票对风险指数的暴露度是股票对构成该风险指数的若干描述变量的暴露度的加权平均值，其中，我们选择使风险指数解释力和预测力达到最高的权重。\n暴露度的标准化：\n\\[ x_{标准化}=\\frac{x_{原始} - \\bar{x}_{原始}}{\\mathrm{Std}[x_{原始}]} \\]  经过标准化，每个风险指数的暴露度都具有零均值和单位标准差。标准化过程还应该加入离群值的处理。\n风险模型的应用 假设结构化风险模型中的因子协方差矩阵 \\(\\boldsymbol{V}\\)  和特异协方差矩阵 \\(\\boldsymbol{\\Delta}\\)  是已知的。\n 现在：当前组合风险分析  分析当前组合风险时，不但可以衡量组合总体风险水平，而且可以将组合风险分解到各个来源，进而使我们可以检查该来源是否也是主动收益率的来源。\n分解风险的方式：\n 将收益率分解成市场部分和残差部分； 考察组合相对某个业绩基准的风险，即分解出主动风险； 将组合按多因子模型分解成模型风险和特异风险。  风险模型还允许我们对风险进行边际分析：在头寸的边际变动下，各资产对组合分散化的效力。\n风险分析的重要性：被动投资经理通过风险分析试图最小化跟踪误差（主动风险）；而主动投资经理则通过风险分析了解承担了多少主动风险，知道为什么以及如何改变主动风险，并且可将承担的风险划分为固有风险、意向的和意外的风险。\n 未来  风险模型有助于我们设计未来的投资组合。第１４章“组合构建”中将详细讨论这个作用。\n 过去  风险模型有助于我们评价投资组合过去的表现。第１７章“业绩分析”中将详细讨论这个主题。\n风险模型效果如何 前面，我们已经选择了标准差作为风险的定义；选择了结构化风险模型以精确并高效地预测协方差矩阵。下面就要给出一些实证依据。\n 比较预测标准差的两种方法：基于投资组合 V.S. 基于历史表现  前者方法是：先建立结构化风险模型，得到协方差矩阵的预测值，然后带入投资组合头寸，计算出组合风险的预测值。\n研究结果显示：基于前者的预测由于基于后者的预测。\n 研究不同风险度量的可预测性：标准差　V.S.　备选度量  备选度量必须完全基于历史数据。\n研究结果显示：根据历史数据进行预测的情况下，我们只能预测标准差。\n风险模型的估计 首先给定行业因子和风险因子的暴露度 \\(\\boldsymbol{X}\\)  ，收集资产超额收益率数据 \\(\\boldsymbol{r}\\)  ，可以通过多元回归估计因子收益率 \\(\\boldsymbol{b}\\)  ，目标是选择使特异收益率的平方和（可能是加权的）最小的因子收益率。数学形式表达式：\n\\[ \\underset{\\boldsymbol{b}}{\\min} \\quad \\| \\boldsymbol{r} - \\boldsymbol{X} \\boldsymbol{b} \\| \\]  为了有效地估计因子的收益率，我们选择合适加权权重，采用广义最小二乘法（GLS）。我们试图每个资产收益率样本选择与其特异方差的倒数成正比的权重（实践中，我们可用市值平方根代替特异方差的倒数来对每个观测值进行加权）。这意味着，特异协方差矩阵的逆矩阵 \\(\\boldsymbol{\\Delta}^{-1}\\)  就是用于_GLS_的加权权重矩阵。这是一个对角矩阵，对角向量就是这样加权权重向量。\n进而写出的 \\(\\|*\\|\\)  的表达式：\n\\[ \\| \\boldsymbol{u} \\| = \\sqrt{\\sum_i{\\frac{1}{\\delta_i} u_i^2}}=\\sqrt{\\boldsymbol{u}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{u}} \\]  于是目标问题的数学表达式可以改写成：\n\\[ \\underset{\\boldsymbol{b}}{\\min} \\quad (\\boldsymbol{r} - \\boldsymbol{X} \\boldsymbol{b})^T \\boldsymbol{\\Delta}^{-1} (\\boldsymbol{r} - \\boldsymbol{X} \\boldsymbol{b}) \\]  因子组合 因子收益率估计值的数学表达式（前述极值问题的数学解）为：\n\\[ \\boldsymbol{b} = (\\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{r} \\overset{\\Delta}{=} \\boldsymbol{C}_{K \\times N} \\boldsymbol{r} \\]  就具体因子而言，因子收益率就是资产超额收益的加权和：因子 \\(k​\\)  的收益率 \\(b_k​\\)  可以看作一个投资组合的收益率，其权重为 \\((C_{k,1},\\dots,C_{k,N})​\\)  。因此，上述组合被称作因子 \\(k​\\)  的因子组合。\n因子组合是先验可知的。因子组合具有如下特性（因子组合的另一种定义）：对相应因子具有单位暴露度，而对其他因子零暴露度，并且符合这两个约束条件的最小风险组合。\n注意区分：特征组合和因子组合这两个概念。\n关于因子组合有两种不同解释：有时被解释为因子模拟组合，表示它模拟了一些潜在基础因子的行为。本书解释成：捕获通过因子暴露定义出的各种特异效应的投资组合。\n因子协方差矩阵 一旦估计出每段时期的因子收益率，就可以进一步估计因子的协方差矩阵。因子协方差矩阵是建立有效的风险模型的关键，应该根据投资者的时间尺度选择对未来因子协方差矩阵的最佳预测。\n\\[ \\boldsymbol{F} = \\mathbf{E}[(\\boldsymbol{b}-\\mathbf{E}{\\boldsymbol{b}})(\\boldsymbol{b}-\\mathbf{E}{\\boldsymbol{b}})^T] \\]  具体技巧阅读原书及参考文献。\n特异风险 多因子模型不能对股票的特异收益率提供任何深刻见解，但对特异方差，情况不一样。可以对特异收益率的方差 \\(u_i^2\\)  建模（假设特异收益率的均值为0）：\n\\[ \\begin{aligned} u_i^2(t) \u0026= S(t)[1+v_i(t)] \\\\ s.t. \u0026 (\\dfrac{1}{N})\\sum_{i=1}^N{u_i^2(t)}=S(t) \\\\ \u0026 (\\dfrac{1}{N})\\sum_{i=1}^N{v_i(t)}=0 \\end{aligned} \\]   \\(S(t)\\)  衡量了股票空间上特异方差的平均水平，而 \\(v_i\\)  则捕捉了特异方差在横截面上的起伏。\n为了预测特异风险，需要 \\(S(t)\\)  对建立时间序列模型，并 \\(v_i(t)\\)  对建立多因子模型。的模型通常包含风险指数因子，以及衡量近期特异收益率平方的因子。然后通过剔除离群值的混合回归来估计模型系数。最后就可以预测出特异收益率方差：\n\\[ \\boldsymbol{\\Delta} = \\left[ \\begin{matrix} u_1^2 \u0026 \u0026 \u0026 \\\\ \u0026 u_2^2 \u0026 \u0026\\Huge0 \\\\ \\Huge0\u0026 \u0026 \\ddots \u0026\\\\ \u0026 \u0026 \u0026 u_N^2 \\end{matrix} \\right] \\]  风险分析 考虑一个权重为 \\(\\boldsymbol{h}_P\\)  的投资组合P, 其因子暴露度和方差分别为：\n\\[ \\begin{aligned} \\boldsymbol{x}_P \u0026= \\boldsymbol{X}^T \\boldsymbol{h}_P \\\\ \\sigma_P^2\u0026=\\boldsymbol{x}_P^T \\boldsymbol{F} \\boldsymbol{x}_P + \\boldsymbol{h}_P^T \\boldsymbol{\\Delta} \\boldsymbol{h}_P = \\boldsymbol{h}_P^T \\boldsymbol{V} \\boldsymbol{h}_P \\end{aligned} \\]  进而可以写出主动风险（跟踪误差）的表达式：\n\\[ \\begin{aligned} \\psi_P^2 \u0026= \\boldsymbol{h}_{P\\!B}^T \\boldsymbol{V} \\boldsymbol{h}_{P\\!B} \\\\ s.t. \u0026 \\boldsymbol{h}_{P\\!B} = \\boldsymbol{h}_P - \\boldsymbol{h}_B \\\\ \u0026 \\boldsymbol{h}_B 是业绩基准的持仓权重 \\end{aligned} \\]  注意到，可以将投资组合Ｐ的总风险及主动风险各自分解成共同因子部分和特异部分，能够这样作的原因是假设因子风险和特异风险是不相关的。\n将风险分解成市场部分和残差部分要困难些。首先，资产关于业绩基准B的贝塔列向量：\n\\[ \\begin{aligned} \\boldsymbol{\\beta} \u0026= \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_B}{\\sigma_B^2} = \\dfrac{X \\boldsymbol{F} \\boldsymbol{x}_B + \\boldsymbol{\\Delta} \\boldsymbol{h}_B}{\\sigma_B^2} \\\\ \u0026 \\overset{\\Delta}{=} \\boldsymbol{X} \\boldsymbol{b} + \\boldsymbol{d} \\\\ s.t. \u0026\\boldsymbol{b} = \\dfrac{\\boldsymbol{F} \\boldsymbol{x}_B}{\\sigma_B^2} , \\boldsymbol{d} = \\dfrac{\\boldsymbol{\\Delta} \\boldsymbol{h}_B}{\\sigma_B^2} \\end{aligned} \\]  因此，每个资产的贝塔都包括因子部分的贡献和特异部分的贡献。基准权重为0的资产，对应的贝塔特异部分的贡献为零，大部分情况行业因子的贡献主导了资产的贝塔值。\n投资组合Ｐ的贝塔：\n\\[ \\beta_P = \\boldsymbol{h}_P^T \\boldsymbol{\\beta} = \\boldsymbol{x}_P^T \\boldsymbol{b} + \\boldsymbol{h}_P^T \\boldsymbol{d} \\]  一旦获得组合的贝塔，很自然就可将组合收益率/组合风险分解成系统性部分和残差部分：\n\\[ \\begin{aligned} r_P = \\beta_P r_B + \\theta_P \\\\ \\sigma_P^2 = \\beta_P^2 \\sigma_B^2 + \\omega_P^2 \\end{aligned} \\]  另方面，有了资产贝塔向量，那么资产收益率向量，及其协方差矩阵也可以分解成系统部分和残差部分：\n\\[ \\begin{aligned} \\boldsymbol{r} = \\boldsymbol{\\beta} \\ r_B + \\boldsymbol{\\theta} \\\\ \\boldsymbol{V} = \\sigma_B^2 \\ \\boldsymbol{\\beta} \\ \\boldsymbol{\\beta}^T + \\boldsymbol{V\\!R} \\end{aligned} \\]  风险归因 无论是将市场风险和残差风险分离，还是将共同因子风险和特异风险分离，分离的两部分都是互不相关的。但当不同风险来源具有相关性时，为了讨论这种情况，需要引入风险边际贡献概念。\n资产的风险边际贡献  资产的总风险边际贡献：  \\[ \\boldsymbol{M\\!C\\!T\\!R}=\\frac{\\partial \\sigma_P}{\\partial \\boldsymbol{h}_P^T} = \\frac{\\boldsymbol{V} \\boldsymbol{h}_P}{\\sigma_P} \\]  在一阶近似下有：\n\\[ \\mathrm{\\Delta} \\sigma_P \\approx \\boldsymbol{M\\!C\\!T\\!R}^T \\mathrm{\\Delta} \\boldsymbol{h}_P \\]   资产的残差风险边际贡献：  \\[ \\begin{aligned} \\boldsymbol{M\\!C\\!R\\!R} = \\dfrac{\\partial \\omega_P}{\\partial \\boldsymbol{h}_P^T} = \\dfrac{\\boldsymbol{V\\!R} \\ \\boldsymbol{h}_P}{\\omega_P} = \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_{P\\!R}}{\\omega_P} \\\\ 式中 \\ \\boldsymbol{h}_{P\\!R} = \\boldsymbol{h}_P - \\beta_P \\ \\boldsymbol{h}_B \\ 是组合P的\\mathbf{残差头寸} \\end{aligned} \\]   资产的主动风险边际贡献：  \\[ \\boldsymbol{M\\!C\\!A\\!R} = \\frac{\\partial \\psi_P}{\\partial \\boldsymbol{h}_{P\\!B}^T} = \\frac{\\boldsymbol{V} \\boldsymbol{h}_{P\\!B}}{\\psi_P} \\]  进而，主动风险边际贡献可分成市场部分和残差部分：\n\\[ \\begin{aligned} \\boldsymbol{M\\!C\\!A\\!R} = k_1 \\boldsymbol{\\beta} + k_2 \\boldsymbol{M\\!C\\!R\\!R} \\\\ 式中 \\ k_1 = \\dfrac{\\beta_{P\\!B} \\ \\sigma_B^2 }{\\psi_P} \\quad k_2 = \\dfrac{\\omega_P}{\\psi_P} \\end{aligned} \\]  可以看出 \\(0\\le k_2 \\le 1\\)  ，并且当 \\(\\beta_{P\\!A}=0\\)  时有 \\(k_1=0\\)  和 \\(k_2=1\\)  。\n因子的风险边际贡献 所谓因子的风险边际贡献，是指每个因子对应的因子组合对风险的边际贡献。以主动风险为例：\n\\[ \\begin{aligned} \\mathrm{\\Delta} \\boldsymbol{h}_{P\\!B} \u0026= ( (\\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1})^T \\ \\boldsymbol{\\delta} \\\\ \\mathrm{\\Delta} \\psi_P \u0026= \\mathrm{\\Delta} \\boldsymbol{h}_{P\\!B}^T \\boldsymbol{M\\!C\\!A\\!R} \\\\ \u0026= \\boldsymbol{\\delta}^T (\\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{M\\!C\\!A\\!R} \\\\ \\Longrightarrow \\\\ \\dfrac{\\mathrm{\\Delta} \\psi_P}{\\boldsymbol{\\delta}^T} \u0026= (\\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{X})^{-1} \\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_{P\\!B}}{\\psi_P} \\\\ \u0026= \\dfrac{\\boldsymbol{F} \\ \\boldsymbol{x}_{P\\!B}}{\\psi_P} + \\dfrac{(\\boldsymbol{X}^T \\boldsymbol{\\Delta}^{-1} \\boldsymbol{X})^{-1} \\boldsymbol{x}_{P\\!B}}{\\psi_P} \\\\ \u0026 \\approx \\dfrac{\\boldsymbol{F} \\ \\boldsymbol{x}_{P\\!B}}{\\psi_P} \\end{aligned} \\]  说明：\n  \\(\\dfrac{\\Delta \\psi_P}{\\boldsymbol{\\delta}^T}\\)  就是因子的主动风险边际贡献； 因子的主动风险边际贡献分解式的第一项反映了由因子暴露度改变导致的因子风险变化；第二项则反映了使用因子来改变因子暴露度所产生的特异风险的变化； 因子组合定义本身就意味着其特异风险应该相对较小，实证测试也发现第二项远小于第一项，于是就有上述的近似表达式。  板块的风险边际贡献 不幸的是，板块风险边际贡献问题的答案不是很清晰，需要额外研究。\n资产的风险贡献  边际贡献：和数学上的导数或偏导数概念有关；\n贡献/相对贡献：和数学上的微分或全微分概念有关。\n 我们可以用风险的边际贡献来定义风险的分解（依然以主动风险的分解为例）：\n\\[ \\begin{aligned} \\mathrm{d} \\psi_P \u0026= \\mathrm{d} \\boldsymbol{h}_{PB}^T \\ \\boldsymbol{M\\!C\\!A\\!R} = \\sum_i{\\mathrm{d} h_{PB,i} \\ M\\!C\\!A\\!R_i} \\\\ \\psi_P \u0026= \\boldsymbol{h}_{PB}^T \\ \\boldsymbol{M\\!C\\!A\\!R} \\end{aligned} \\]  为了引入相对风险边际贡献的概念，不妨将上式改写成（注意是精确相等而非近似）：\n\\[ \\begin{aligned} \\mathrm{\\Delta} \\psi_P \u0026= \\sum_i{\\mathrm{\\Delta} h_{PB,i} \\ M\\!C\\!A\\!R_i} \\\\ \u0026= \\sum_i{\\dfrac{\\mathrm{\\Delta} h_{PB,i}}{h_{PB,i}} \\ h_{PB,i} \\ M\\!C\\!A\\!R_i} \\\\ \u0026 \\overset{\\Delta}{=} \\sum_i{\\dfrac{\\mathrm{\\Delta} h_{PB,i}}{h_{PB,i}} R\\!M\\!C\\!A\\!R_i} \\end{aligned} \\]  其中， \\(\\boldsymbol{R\\!M\\!C\\!A\\!R}\\)  就是主动风险的相对风险边际贡献，注意，这里的相对风险边际贡献甚至就是直接贡献。\n因子的风险贡献 利用因子风险模型，我们有：\n\\[ \\psi_P^2 = \\boldsymbol{x}_{P\\!B}^T F \\ \\boldsymbol{x}_{P\\!B} + \\boldsymbol{h}_{P\\!B}^T \\boldsymbol{\\Delta} \\ \\boldsymbol{h}_{P\\!B} \\]  进而有：\n\\[ \\begin{aligned} \\mathrm{d} \\psi_P \u0026= \\mathrm{d} \\boldsymbol{x}_{P\\!B}^T \\dfrac{F \\ \\boldsymbol{x}_{P\\!B}}{\\psi_P} + \\mathrm{d} \\boldsymbol{h}_{P\\!B}^T \\dfrac{\\boldsymbol{\\Delta} \\ \\boldsymbol{h}_{P\\!B}}{\\psi_P} \\\\ \u0026= \\mathrm{d} \\boldsymbol{x}_{P\\!B}^T \\ \\boldsymbol{F\\!M\\!C\\!A\\!R} + \\mathrm{d} \\boldsymbol{h}_{P\\!B}^T \\dfrac{\\partial \\psi_P}{\\partial \\boldsymbol{h}_{P\\!B}^T} \\\\ \\psi_P \u0026= \\boldsymbol{x}_{P\\!B}^T \\boldsymbol{F\\!M\\!C\\!A\\!R} + \\dfrac{\\boldsymbol{h}_{P\\!B}^T \\boldsymbol{\\Delta} \\ \\boldsymbol{h}_{P\\!B}}{\\psi_P} \\end{aligned} \\]  说明：\n  \\(\\boldsymbol{F\\!M\\!C\\!A\\!R}\\)  就是因子对主动风险的边际贡献;  \\(\\boldsymbol{x}_{P\\!B}^T \\boldsymbol{F\\!M\\!C\\!A\\!R}\\)  就是因子来源对主动风险的相对边际贡献，在这里甚至就是直接贡献；  \\(\\dfrac{\\boldsymbol{h}_{P\\!B}^T \\boldsymbol{\\Delta} \\ \\boldsymbol{h}_{P\\!B}}{\\psi_P}\\)  就是特异来源对主动风险的相对边际贡献，在这里甚至就是直接贡献。  相关性和市场波动率 单因子模型可解释一个实证现象：资产之间的相关性通常随着市场的波动率增加而增加。\n\\[ \\rho_{i,j} = \\frac{\\beta_i \\ \\beta_j \\ \\sigma_M^2}{\\sqrt{(\\beta_i^2 \\ \\sigma_M^2 + \\omega_i^2)(\\beta_j^2 \\ \\sigma_M^2 + \\omega_j^2)}} \\] "}),a.add({id:348,href:'/notes/tags/%E4%B8%80%E8%87%B4%E9%A2%84%E6%9C%9F/',title:"一致预期",content:""}),a.add({id:349,href:'/notes/tags/%E5%B8%82%E5%9C%BA%E7%BB%84%E5%90%88/',title:"市场组合",content:""}),a.add({id:350,href:'/notes/tags/%E6%8A%95%E8%B5%84%E7%BB%84%E5%90%88/',title:"投资组合",content:""}),a.add({id:351,href:'/notes/docs/apm/0018/',title:"第二章 一致预期收益率：资本资产定价模型",content:"几个概念  收益率   \\(R_P\\)    某个资产P在某个期间的收益率。\n 超额收益率  超额是相对无风险资产而言的，于是资产的超额收益率 \\(r_P\\)  就是资产收益率 \\(R_P\\)  与同期无风险资产收益率 \\(R_f\\)  的差额：\n\\[ r_P = R_P - R_F \\]   预期超额收益率　预期对应与“数学期望”的概念，预期超额收益率是对未来超额收益率的的估计：  \\[ f_P = \\mathrm{E}\\{ r_P \\} \\]   资产与投资组合  资产与投资组合本质上可以看作同一个概念：任意一个投资组合都可以看成是某种资产（比如持有某种基金），任何一个资产也都可以看成一个投资组合（比如，持有一只股票，可以看这只股票的头寸非零，其它股票头寸为零的投资组合）。当然，故名思义，投资组合也可以看成投资一堆资产的组合，每种资产分配特定的头寸权重，于是任意投资组合（简称组合）都可以用头寸权重列向量表示：\n\\[ \\boldsymbol{h}=(h_1,\\dots,h_N)^T \\]  于是组合P可表示成 \\(\\boldsymbol{h}_P\\)  。类似地，也有一堆资产的超额收益率列向量和预期超额收益率列向量：\n\\[ \\begin{aligned} \\boldsymbol{r} = (r_1,\\dots,r_N)^T \\\\ \\boldsymbol{f} = (f_1,\\dots,f_N)^T \\end{aligned} \\]  于是组合P的超额收益率 \\(r_P\\)  及预期超额收益率 \\(f_P\\)  可分别表示为：\n\\[ \\begin{aligned} r_P = \\boldsymbol{r}^T \\boldsymbol{h}_P \\\\ f_P = \\boldsymbol{f}^T \\boldsymbol{h}_P \\end{aligned} \\]  另外，将风险资产的超额收益率之间的协方差矩阵(假设非奇异的)记作：\n\\[ \\boldsymbol{V} = \\mathrm{E}\\{(\\boldsymbol{r} - \\mathrm{E}\\boldsymbol{r} )(\\boldsymbol{r} - \\mathrm{E}\\boldsymbol{r} )^T\\} = (\\mathrm{Cov}\\{r_i,r_j\\})_{N \\times N} \\overset{\\Delta}{=} (V_{i j})_{N \\times N} \\]   市场组合M  很自然，市场中所有资产按其市值作为权重，必然构成一个最大的组合，这就是市场组合。对应的超额收益率和预期超额收益率分别是 \\(r_M\\)  和 \\(f_M\\)  。\n 组合的属性值或暴露度  前面已经涉及了资产的两种属性：超额收益率和预期超额收益率，以及组合的超额收益率和预期超额收益率。前者表示所有资产的属性列向量，后者是组合的属性值。\n一般地，如果我们将资产的属性记作 \\(\\boldsymbol{a}\\)  （列向量），那么组合P的属性值 \\(a_P\\)  可定义成：\n\\[ a_P = \\boldsymbol{a}^T \\boldsymbol{h}_P \\]  在书中，组合P（关于属性 \\(\\boldsymbol{a}\\)  ）的属性值 \\(a_P\\)  ，又被称作组合P对属性 \\(\\boldsymbol{a}\\)  的暴露度。\n具有明显经济含义时，我们往往使用属性值的说法（比如，组合的超额收益率）；没有明显经济含义时，往往使用暴露度的说法。\n 年化  当某属性随着预测期长度按某幂次增长时，都可引入年化概念。比如：预期收益率，随预测期长度线性增长；风险(标准差)，随预测期长度的平方根增长，对应的年化与月度的变换分别是：\n\\[ \\begin{aligned} f_{年化} = 12 \\ f_{月度} = \\dfrac{1}{\\Delta t} \\ f_{\\Delta t} \\\\ \\sigma_{年化} = \\sqrt{12} \\ \\sigma_{月度} = \\sqrt{\\dfrac{1}{\\Delta t}} \\ \\sigma_{\\Delta t} \\end{aligned} \\]  其中， \\(\\Delta t\\)  是以年为单位的预测期长度。\n为了方便对不同预测期的同一属性进行比较，标准的做法是：统一以年化属性作为比较标准。以后，凡是可以年化的属性，在列出年化转换公式后，如果不作声明，都是指年化属性。\n超额收益率分解 为了对超额收益率进行分解，线性分解是我们最容易想到的，而市场组合M提供了一个理想的分解基准，于是自然会想到源自线性回归分析的贝塔概念。\n组合P的贝塔值（是一个相对概念，默认是对市场组合M而言），可定义成：\n\\[ \\beta_P = \\frac{\\mathrm{Cov}\\{r_P,r_M\\}}{\\mathrm{Var}\\{r_M\\}} \\]  容易验证：市场组合M的贝塔值是1，无风险资产的贝塔值是0。\n贝塔是一个先验概念（向未来看，假设当前已知），贝塔的概念源自线性回归分析，比如组合P在时期 \\(t=1,\\dots,T\\)  上的超额收益率 \\(r_P(t)\\)  对同期市场超额收益率 \\(r_M(t)\\)  的回归：\n\\[ r_P(t) =\\alpha_P+ \\beta_P r_M(t) + \\epsilon_P(t) \\]  其中，回归分析得到的对 \\(\\beta_P\\)  和 \\(\\alpha_P\\)  的估计值被称作实现的或历史的贝塔值和阿尔法值，而 \\(\\epsilon_P(t)\\)  则是零均值随机项。历史贝塔则是一个后验证概念（向历史看）。\n一旦知道组合P的贝塔值，那么可将组合P的超额收益率分解成市场部分和残差部分：\n\\[ r_P = \\beta_P r_M + \\theta_P \\]  其中，假设残差收益率 \\(\\theta_P=\\alpha_P + \\epsilon_P\\)  与市场收益率 \\(r_M\\)  是不相关的。\n进而，也可将组合P的预期超额收益率分解为：\n\\[ f_P = \\beta_P f_M + \\alpha_P \\]  其中，预期残差收益率恰好是组合P的阿尔法值 \\(\\alpha_P=\\mathrm{E}\\{ \\theta_P \\}\\)  。\n组合P的方差也可分解成：\n\\[ \\sigma_P^2 = \\beta_P^2 \\sigma_M^2 + \\omega_P^2 \\]  其中， \\(\\omega_P^2\\)  是组合P的残差方差，即 \\(\\omega_P^2 = \\mathrm{Var}\\{\\theta_P\\}\\)  。\nCAPM 一般而言，市场组合M的预期残差收益率严格为0。 因为 \\(\\alpha_M=f_M-\\beta_M f_M＝f_M- f_M=0\\)  。\n但CAPM更理想化地认为，任何股票或组合的的预期残差收益率都为0（即， \\(\\alpha_P=\\mathrm{E}\\{ \\theta_P \\} = 0\\)  ）。进而任意组合P的预期超额收益率正比于组合P的贝塔值：\n\\[ \\mu_P = \\beta_P \\mu_M \\]  其中， \\(\\mu_P=\\mathrm{E}\\{r_P\\}\\)  是组合P的预期超额收益率， \\(\\mu_M=\\mathrm{E}\\{r_M\\}\\)  是市场组合M的预期超额收益率。（用 \\(\\mu\\)  替代 \\(f\\)  表示CAPM观点下的预期超额收益率）\n在CAPM下，持有异于市场组合的投资组合的投资者在玩一个零和游戏。此类投资者承担了额外的风险却没有获得额外的预期收益。这个逻辑导致被动投资，即买入并持有市场组合。\nCAPM的合理性依赖你认可不存在“更傻的傻瓜”。即使你不认可，CAPM也提供了一个可以参考的合理基准。\nCAPM和有效市场理论虽然不一样，但却是一致的。前者强调如果不存在“更傻的傻瓜”，那么没有人能够战胜市场。而有效市场理论，则为不存在“更傻的傻瓜”提供了某种理由，比如强有效市场理论，认为市场价格包含了一切相关信息。\nCAPM是关于预期的(先验的)。无论是先验还是后验证。无风险资产和市场组合连接而成直线被称作证券市场线。先验情况下，是在“贝塔-预期收益率”图中的直线，并且所有组合精确落在市场线上；后验情况下，是在“贝塔-收益率”图中的直线。一般而言，实现的组合很可能不落在市场线上，这些组合和市场线的垂直偏差，就是实现的残差收益率。\n一致预期收益率 所谓一致，即无一例外的意思，这里特指大家都在CAPM模型下，算出的结果。一致预期收益率就是CAPM预期收益率。后面将证明：CAPM产生的预期收益率恰好使得市场组合是均值/方差最优的。所以，市场组合可被称为一致组合。\n一致预期收益率的价值在于它为我们设立了一个比较基准。\n主动管理决策就是由我们的预测与一致预期收益率之间的差异来驱动的。\nCAPM为一致预期收益率提供了一个有效来源，但不是预测预期收益率的唯一方法；另一种提供预期收益率的替代方法是APT，但是不能作为一致收益率的来源。\n技术性假设 在单一投资期内不进行组合的再平衡操作，并且假设：\n 存在一个无风险资产； 所有一阶和二阶矩均存在； 不存在零风险的全额投资组合； 最小方差全额投资组合C的预期超额收益率严格正值。  其中最后一个假设可能会被放松。\n属性及其特征组合  示意：     任意属性 特征组合P     \\(\\boldsymbol{a}=(a_1,\\dots,a_n)^T\\)   \\(\\boldsymbol{h}_P=(h_{P,1},\\dots,h_{P,n})^T\\)       定义：  非零属性 \\(\\boldsymbol{a}\\)  的特征组合 \\(\\boldsymbol{h}_a\\)  ：对 \\(\\boldsymbol{a}\\)  具有单位暴露度的最小风险组合。\n 数学表述：  \\[ \\begin{aligned} \\underset{\\boldsymbol{h}}{\\min} \u0026 \\boldsymbol{h}^T \\boldsymbol{V} \\boldsymbol{h} \\\\ \\quad s.t. \u0026 \\boldsymbol{a}^T \\boldsymbol{h} = 1 \\end{aligned} \\]   用拉格朗日乘子法可求得特征组合解（意味着非零属性对应一个唯一特征组合）：  \\[ \\boldsymbol{h}_a = \\dfrac {\\boldsymbol{V}^{-1} \\boldsymbol{a}} {\\boldsymbol{a}^T \\boldsymbol{V}^{-1} \\boldsymbol{a}} \\]   该特征组合的方差：  \\[ \\sigma_a^2 = \\boldsymbol{h}_a^T \\boldsymbol{V} \\boldsymbol{h}_a = \\dfrac {1} {\\boldsymbol{a}^T \\boldsymbol{V}^{-1} \\boldsymbol{a}} \\]   由上述两式变形可得：  \\[ \\boldsymbol{a} = \\dfrac {\\boldsymbol{V} \\boldsymbol{h}_a} {\\sigma_a^2} \\]  这表明属性 \\(\\boldsymbol{a}\\)  也是相对其特征组合 \\(\\boldsymbol{h}_a\\)  的贝塔：\n\\[ \\begin{aligned} \\beta_i \u0026= \\dfrac{\\mathrm{Cov}\\{r_i,r_a\\}}{\\sigma_a^2} = \\dfrac{\\mathrm{Cov}\\{r_i,\\sum_j{r_j h_{a,j}}\\}}{\\sigma_a^2} \\\\ \u0026= \\dfrac{\\sum_j{\\mathrm{Cov}\\{r_i,r_j \\} h_{a,j}}}{\\sigma_a^2} = \\dfrac{\\sum_j{V_{i,j} h_{a,j}}}{\\sigma_a^2} \\\\ \u0026 \\Longrightarrow \\boldsymbol{\\beta}_{相对组合\\boldsymbol{h}_a} = \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_a}{\\sigma_a^2}=\\boldsymbol{a} \\end{aligned} \\]  第一个等式是根据贝塔的扩展定义（默认是相对市场组合M，这里扩展成相对任意指定组合）。\n 考虑属性及其特征组合对 \\((\\boldsymbol{a},\\boldsymbol{h}_a)\\)  和 \\((\\boldsymbol{d},\\boldsymbol{h}_d)\\)  ，以及交叉暴露度 \\(a_d\\)  和 \\(d_a\\)  。　那么这两个特征组合的协方差为：  \\[ \\sigma_{a,d} =\\boldsymbol{h}_a^T \\boldsymbol{V} \\boldsymbol{h}_d = a_d \\sigma_a^2 = d_a \\sigma_d^2 \\]   属性 \\(\\kappa \\boldsymbol{a}(\\kappa0)\\)  的特征组合是 \\(\\boldsymbol{h}_a / \\kappa\\)  （通过除于 \\(\\kappa\\)  ，确保对属性的单位暴露度）。 从属性到其特征组合，保线性但不保线性系数。一般地，如果 \\(\\boldsymbol{a}=\\sum \\kappa \\ \\boldsymbol{d}\\)  （ \\(\\kappa,\\boldsymbol{d}\\)  都忽略了求和下标，请自行脑补），那么：  \\[ \\begin{aligned} \u0026\\boldsymbol{h}_a = \\sum \\dfrac {\\kappa \\ \\sigma_a^2} {\\sigma_d^2} \\boldsymbol{h}_d \\\\ \\mathrm{where} \\quad \u0026 \\dfrac {1} {\\sigma_a^2} = \\sum \\dfrac {\\kappa \\ a_d} {\\sigma_d^2} \\end{aligned} \\]  全1向量及其特征组合C  示意：     全1向量 组合C     \\(\\boldsymbol{e}=(1,\\dots,1)^T\\)   \\(h_C\\)       这是第一个特殊的特征组合。属性及其特征组合的一般结论，必然适用于这个特征组合上。如非强调，不再重复列出相关结论。 组合C特点：  １）组合P对 \\(\\boldsymbol{e}\\)  的暴露度 \\(e_P=\\boldsymbol{e}^T \\boldsymbol{h}_P=\\sum_i{h_{P,i}}\\)  就是组合P权重之和，进而单位暴露度就是全额投资，所以组合C就是最小风险全额投资组合；\n２）任何资产对组合C的贝塔恒为1；\n３）对全额投资组合P而言， \\(\\sigma_{P,C} = \\sigma_C^2\\)  。\n贝塔及业绩基准组合B  示意：     贝塔 组合B     \\(\\boldsymbol{\\beta}\\)   \\(h_B\\)       说明：  这里的贝塔是特指，相对某个有特定含义的组合（业绩基准组合）的贝塔。而前面称“属性 \\(\\boldsymbol{a}\\)  也是相对其特征组合 \\(\\boldsymbol{h}_a\\)  的贝塔”，其中的贝塔相对的组合是没有特定含义的，是任意选定的一个组合。以后，我们提及贝塔这个概念时，除非人为指定，根据上下文，默认有可能是相对市场组合M，也可能是相对业绩基准组合B。\n 组合B特点：  业绩基准就是贝塔值等于1的最小风险组合， \\(\\beta_B=1\\)  。\n预期超额收益率及其特征组合q  示意：     预期超额收益率 组合q     \\(\\boldsymbol{f}\\)   \\(h_q\\)       夏普率  对任何风险组合 \\(P(\\sigma_P0)\\)  ,夏普率 \\(\\mathrm{SR}_P\\)  定义：\n\\[ \\mathrm{SR}_P = \\frac {f_P} {\\sigma_P} \\]   组合q特点：  １） 组合q就是最大夏普率组合： \\(\\mathrm{SR}_q = \\underset{P}{\\max}\\{ \\mathrm{SR}_P \\} = \\sqrt{\\boldsymbol{f}^T \\boldsymbol{V}^{-1} \\boldsymbol{f}}\\)  ；\n２）组合q的预期超额收益率为1；\n３）组合q对应的预期超额收益率可表示成： \\(\\boldsymbol{f} = (\\dfrac {\\boldsymbol{V} \\boldsymbol{h}_q} {\\sigma_q}) \\mathrm{SR}_q\\)  ；\n４）任何组合P和组合q的夏普率有关系： \\(\\mathrm{SR}_P=\\rho_{P,q} \\mathrm{SR}_q,\\quad\\rho_{P,q}=\\dfrac {\\sigma_{P,q}} {\\sigma_P \\sigma_q}\\)  ；\n５）组合q投资于风险资产的权重，即组合q对属性 \\(\\boldsymbol{e}\\)  的暴露度： \\(e_q=\\dfrac {f_C \\sigma_q^2} {\\sigma_C^2}\\)  。\n阿尔法及其特征组合A  示意：     阿尔法 组合A     \\(\\boldsymbol{\\alpha}=\\boldsymbol{f}-\\boldsymbol{\\beta} f_B\\)   \\(h_A\\)       组合A特点：  \\[ \\begin{aligned} \\alpha_B=0, \\beta_A=0, \\sigma_{A,B}=0 \\alpha_q = 1 - f_B \\beta_q \\\\ \\boldsymbol{h}_A=\\dfrac {\\sigma_A^2} {\\sigma_q^2} \\boldsymbol{h}_q - \\dfrac {f_B \\sigma_A^2} {\\sigma_B^2} \\boldsymbol{h}_B \\quad \\dfrac 1 {\\sigma_A^2}=\\dfrac {\\alpha_q} {\\sigma_q^2} \\end{aligned} \\]  组合Q  示意：     Q属性 组合Q     \\(e_q \\boldsymbol{f}\\)   \\(\\boldsymbol{h}_Q\\)  （当 \\(f_C0\\)  ）    假设 \\(f_C0\\)  ，即：组合C的预期超额收益率大于0。这条假设导致的关键信息：组合Q的头寸是组合q头寸的正整数倍，进而这两个组合的夏普率相同，并且各自与其它任意组合的相关系数都对应相等。\n 组合q是净多头，即 \\(e_q0\\)  。 令组合Q是属性 \\(e_q f\\)  对应的特征组合,则：  \\[ \\begin{aligned} e_Q=1\\\\ \\boldsymbol{h}_Q=\\dfrac {\\boldsymbol{h}_q} {e_q} \\\\ \\mathrm{SR}_Q=\\mathrm{SR}_q \\\\ \\mathrm{SR}_P=\\rho_{P,Q} \\mathrm{SR}_Q, \\forall P \\end{aligned} \\]   用组合Ｑ表达预期超额收益率  \\[ \\begin{aligned} \u0026\\dfrac{f_C}{\\sigma_C^2}=\\dfrac{f_Q}{\\sigma_Q^2}\\\\ \u0026\\boldsymbol{f} = f_Q \\dfrac{\\boldsymbol{V} \\boldsymbol{h}_Q}{\\sigma_Q^2} = f_Q \\boldsymbol{\\beta}_{相对组合Q} \\end{aligned} \\]  这是一个很重要的结论：资产预期超额收益率列向量与资产关于组合Q的贝塔值列向量成比例。\n 组合Ｑ的贝塔值（注意区分 \\(\\boldsymbol{\\beta}_{相对组合Q}\\)  和 \\(\\beta_Q\\)  ，前者是相对组合Q的贝塔列向量，后者是组合Q对贝塔的暴露度(值)）  \\[ \\beta_Q=\\dfrac{f_B \\sigma_Q^2}{f_Q \\sigma_B^2} \\]   如果业绩基准组合是全额投资，即 \\(e_B=1\\)  ，那么：  \\[ \\beta_Q=\\dfrac{\\beta_C f_B}{f_C} \\]  部分特征组合的列表    属性 特征组合     \\(\\boldsymbol{f}\\)   \\(h_q\\)     \\(e_q \\boldsymbol{f}\\)   \\(h_Q\\)  （当 \\(f_C0\\)  ）   \\(\\boldsymbol{\\beta}\\)   \\(h_B\\)     \\(\\boldsymbol{e}\\)   \\(h_C\\)     \\(\\boldsymbol{\\alpha}=\\boldsymbol{f}-\\boldsymbol{\\beta} f_B\\)   \\(h_A\\)      有效前沿  定义：  一个组合被称为**(全额投资)有效的**，如果它在所有具有相同预期收益率的全额投资组合中具有最小的风险。\n 数学表示：  \\[ \\begin{aligned} \\underset{\\boldsymbol{h}=\\boldsymbol{h}_P}{\\min} \u0026 \\frac{1}{2} \\boldsymbol{h}^T \\boldsymbol{V} \\boldsymbol{h} \\\\ \\quad s.t. \u0026 \\boldsymbol{e}^T \\boldsymbol{h} = 1 \\\\ \\quad \u0026 \\boldsymbol{f}^T \\boldsymbol{h} = f_P \\end{aligned} \\]   求解概要  第一步：列出拉格朗日乘子方程：\n\\[ \\begin{aligned} \\boldsymbol{h} = \\lambda_1 \\boldsymbol{V}^{-1} \\boldsymbol{e} + \\lambda_2 \\boldsymbol{V}^{-1} \\boldsymbol{f} \\\\ \\quad \\\\ \\quad \\lambda_1 \\boldsymbol{e}^T \\boldsymbol{V}^{-1} \\boldsymbol{e} + \\lambda_2 \\boldsymbol{e}^T \\boldsymbol{V}^{-1} \\boldsymbol{e} = 1 \\\\ \\quad \\lambda_1 \\boldsymbol{f}^T \\boldsymbol{V}^{-1} \\boldsymbol{e} + \\lambda_2 \\boldsymbol{f}^T \\boldsymbol{V}^{-1} \\boldsymbol{f} = f_P \\end{aligned} \\]  第二步：尽可能用组合Ｃ和组合Ｑ来表示方程的各个部分：\n\\[ \\begin{aligned} \\boldsymbol{V}^{-1} \\boldsymbol{e} = \\dfrac{1}{\\sigma_C^2} \\boldsymbol{h}_C \\boldsymbol{V}^{-1} \\boldsymbol{f} = \\dfrac{f_Q}{\\sigma_Q^2} \\boldsymbol{h}_Q \\\\ \\boldsymbol{e}^T \\boldsymbol{V}^{-1} \\boldsymbol{e} = \\dfrac{1}{\\sigma_C^2} \\boldsymbol{f}^T \\boldsymbol{V}^{-1} \\boldsymbol{f} = \\dfrac{f_Q^2}{\\sigma_Q^2} \\\\ \\boldsymbol{e}^T \\boldsymbol{V}^{-1} \\boldsymbol{f} = \\boldsymbol{f}^T \\boldsymbol{V}^{-1} \\boldsymbol{e} = \\dfrac{f_Q}{\\sigma_Q^2} = \\dfrac{f_C}{\\sigma_C^2} \\end{aligned} \\]  第三步：重写拉格朗日乘子方程：\n\\[ \\begin{aligned} \\boldsymbol{h}_P = \\dfrac{\\lambda_1}{\\sigma_C^2} \\boldsymbol{h}_C + \\dfrac{f_Q \\lambda_2}{\\sigma_Q^2} \\boldsymbol{h}_Q \\\\ \\quad \\\\ \\quad \\dfrac{1}{\\sigma_C^2} \\lambda_1 + \\dfrac{f_Q}{\\sigma_Q^2} \\lambda_2 = 1 \\\\ \\quad \\dfrac{f_C}{\\sigma_C^2} \\lambda_1 + \\dfrac{f_Q^2}{\\sigma_Q^2} \\lambda_2 = f_P \\end{aligned} \\]  第四步：求解结果：\n\\[ \\begin{aligned} \\quad \\lambda_1 = \\sigma_C^2 \\dfrac{f_Q-f_P}{f_Q-f_C} \\\\ \\quad \\lambda_2 = \\dfrac{\\sigma_Q^2}{f_Q} \\dfrac{f_P-f_C}{f_Q-f_C} \\\\ \\quad \\\\ \\boldsymbol{h}_P = \\dfrac{f_Q-f_P}{f_Q-f_C} \\boldsymbol{h}_C + \\dfrac{f_P-f_C}{f_Q-f_C} \\boldsymbol{h}_Q \\end{aligned} \\]   有效组合的内蕴属性：  \\[ \\boldsymbol{a}_P = \\dfrac{1}{\\sigma_P^2 (f_Q-f_C)} (\\sigma_C^2(f_Q-f_P) \\boldsymbol{e} + \\sigma_Q^2 (f_P-f_C) e_q \\boldsymbol{f}) \\]   有效组合的方差（有效组合Ｐ作为变量）：  \\[ \\begin{aligned} \\sigma_P^2 = \\sigma_C^2 + \\kappa (f_P - f_C)^2 \\\\ \\quad \\kappa = \\dfrac{\\sigma_Q^2-\\sigma_C^2}{(f_Q - f_C)^2} \\end{aligned} \\]  资本资产定价模型 如果\n１）所有投资者都具有均值/方差偏好;\n２）所有资产都纳入分析；\n３）所有投资者都知道预期超额收益率\n４）所有投资者都对资产的方差和协方差具有一致的观点；\n５）没有交易成本和税负。\n那么组合Ｑ等于组合Ｍ（市场组合），并且\n\\[ \\boldsymbol{f} = \\boldsymbol{\\mu} = \\boldsymbol{\\beta} \\boldsymbol{\\mu}_M \\]  【提示】首先根据前面的结论“资产预期超额收益率列向量与资产关于组合Q的贝塔值列向量成比例”，在这个结论以及前提假设下，每位投资都会选择组合Q和无风险资产F的某种比例组成的投资组合。 而所有投资者的组合按投资市值加权平均就是市场组合M，其中无风险资产的汇总必然等于0（所有借出＝所有借入），并且所有投资组合的汇总必然是全额投资组合。 所以市场组合M就是组合Q，相对组合Q的贝塔就是贝塔（默认相对市场组合M的）。\n市场组合M 注意：本小节涉及的贝塔是相对市场组合M而言；不要求CAPM成立。\n１）市场组合M必然是全额投资组合，即 \\(e_M=1\\)  。\n２）市场贝塔(列向量)可表示成： \\(\\boldsymbol{\\beta}=\\dfrac{\\boldsymbol{V} \\boldsymbol{h}_M}{\\sigma_M^2}\\)  ，并且市场组合M是市场贝塔 \\(\\boldsymbol{\\beta}\\)  的特征组合；\n３）组合C的贝塔值： \\(\\beta_C=\\dfrac{\\sigma_C^2}{\\sigma_M^2}\\)  。\n【提示】 \\(\\beta_C \\sigma_M^2=e_M \\sigma_C^2=\\sigma_C^2\\)  由于组合C是最小方差组合，所以 \\(\\beta_C \\le 1\\)  ，并且 \\(\\beta_C=1\\)  当且仅当市场组合M恰好为最小方差组合。\n"}),a.add({id:352,href:'/notes/docs/apm/0017/',title:"第一章 绪论",content:"投资的艺术正在演变成投资的科学。\n有效市场理论任务无法战胜市场；而量化主动管理则试图战胜市场。\n尽管量化主动管理试图战胜市场，但承认这的确不容易。\n量化主动管理是现代投资组合理论的穷亲戚：有现代投资组合理论的威力和结构，却没有合法的名分。\n学界总是讨论总风险和总收益率；而投资者更关注主动风险和主动收益率。 实际上，主动风险/主动收益率更一般，只要将业绩基准取为现金（无风险资产），就可以回到学院派分析框架。\n由于采用了相对视角，我们会关注收益率的一部分－－残差收益率，就是资产收益率中与业绩基准收益率不相关的部分。\n信息率(IR)就是残差收益率的年化预期值与其年化波动率之比。信息率越高，主动管理的空间就越大。信息率衡量了主动管理的机会集。\n在主动管理中，更高的残差收益率，更低的残差风险是必然的偏好。主动管理中，采用均值/方差体现这点：用残差收益率减去一个残差风险的二次惩罚项（即残差方差的线性惩罚项）。称之为风险调整预期收益率或附加值。每个附加值对应一条无差异曲线，而每条无差异曲线都包含一个具有零残差风险的特殊组合，其残差收益率被称为“确定性等价”残差收益率。\n同时考虑偏好（无差异曲线）与机会集，就产生了投资选择。 在主动管理中，获得最高的附加值正比与信息率的平方。\n主动管理基本定律（   \\(IR = IC \\times \\sqrt{BR}\\)  ）告诉我们信息率（IR）的两个来源：一）预测每只资产残差收益率的能力（信息系数，IC）；二）每年我们能够应用前述预测能力的次数（广度，BR）。\n收益、风险、基准、偏好和信息率是组成主动组合管理的五个基本单元。但主动管理实践还需要：与一致预期不同的预期收益率预测。\n主动管理即预测。没有预测，基金经理将采用被动投资－－持有业绩基准组合。本书中，预测是指将资产收益率的原始预测信号转换为精炼预测的过程。基本想法就是预测基本定律：阿尔法 = 波动率 \\(\\times\\)  IC \\(\\times\\)  标准分值。它是将一个标准化分值（0均值,1标准差）转换成一个对残差收益率的预测值的基本方程。\n整个主动管理流程：从信息到预测再到执行，需要持续、一致的监控和业绩表现的不断反馈。\n"}),a.add({id:353,href:'/notes/images/',title:"Images\\",content:""}),a.add({id:354,href:'/notes/posts/images/',title:"Posts\\Images\\",content:""})})()